<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统八股2 | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统八股2  ✅线程上下文切换（Thread Context Switch）  一、什么是上下文切换（Context Switch）？ 上下文：指一个程序（进程或线程）在某一时刻运行所需的状态数据，包括：  程序计数器（PC） 寄存器（Register） 堆栈指针（Stack Pointer） 内核数据结构（如 PCB、TCB） 页表指针（进程独有）  上下文切换">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统八股2">
<meta property="og:url" content="http://totorocatcat.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A12/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="操作系统八股2  ✅线程上下文切换（Thread Context Switch）  一、什么是上下文切换（Context Switch）？ 上下文：指一个程序（进程或线程）在某一时刻运行所需的状态数据，包括：  程序计数器（PC） 寄存器（Register） 堆栈指针（Stack Pointer） 内核数据结构（如 PCB、TCB） 页表指针（进程独有）  上下文切换">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%B8%AD%E5%9B%BD%E9%A3%8E%E5%85%83%E7%B4%A0-%E4%BA%91%E9%9B%BE%E8%83%8C%E6%99%AF.png">
<meta property="article:published_time" content="2025-05-08T16:23:58.000Z">
<meta property="article:modified_time" content="2025-05-08T16:26:02.992Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="提高">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%B8%AD%E5%9B%BD%E9%A3%8E%E5%85%83%E7%B4%A0-%E4%BA%91%E9%9B%BE%E8%83%8C%E6%99%AF.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/b5ca6e582a7a45e6fde46e616eeb68e.png"><link rel="canonical" href="http://totorocatcat.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A12/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":765,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统八股2',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-05-09 00:26:02'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%BE%A0%E5%AE%A2-%E6%AD%A6%E4%BE%A0%E5%9C%BA%E6%99%AF-%E6%B8%B8%E6%88%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">864</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%B8%AD%E5%9B%BD%E9%A3%8E%E5%85%83%E7%B4%A0-%E4%BA%91%E9%9B%BE%E8%83%8C%E6%99%AF.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统八股2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-08T16:23:58.000Z" title="发表于 2025-05-09 00:23:58">2025-05-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-08T16:26:02.992Z" title="更新于 2025-05-09 00:26:02">2025-05-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统八股2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A12/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A12/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统八股2">操作系统八股2</h1>
<hr>
<h1 id="线程上下文切换thread-context-switch">✅线程上下文切换（Thread
Context Switch）</h1>
<hr>
<h2 id="一什么是上下文切换context-switch">一、什么是上下文切换（Context
Switch）？</h2>
<p><strong>上下文</strong>：指一个程序（进程或线程）在某一时刻运行所需的状态数据，包括：</p>
<ul>
<li>程序计数器（PC）</li>
<li>寄存器（Register）</li>
<li>堆栈指针（Stack Pointer）</li>
<li>内核数据结构（如 PCB、TCB）</li>
<li>页表指针（进程独有）</li>
</ul>
<p><strong>上下文切换</strong>：是指操作系统暂停当前运行的线程或进程，并保存其状态，然后恢复另一个线程或进程的状态，使
CPU 能继续执行新的任务。</p>
<hr>
<h2 id="二线程上下文切换的两种情况">二、线程上下文切换的两种情况</h2>
<h3 id="不同进程的线程之间切换线程属于不同进程">1️⃣
不同进程的线程之间切换（线程属于不同进程）</h3>
<p>这种切换实质上是<strong>进程上下文切换</strong>，涉及：</p>
<table>
<colgroup>
<col style="width: 29%">
<col style="width: 70%">
</colgroup>
<thead>
<tr>
<th>切换项</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>页表（Page Table）</td>
<td>不同进程使用不同虚拟内存空间</td>
</tr>
<tr>
<td>CPU 寄存器</td>
<td>保存和恢复原线程/进程的计算状态</td>
</tr>
<tr>
<td>内核栈、用户栈</td>
<td>每个进程都有自己的栈，需切换</td>
</tr>
<tr>
<td>内存缓存（TLB 缓存）</td>
<td>地址空间变了，会导致 TLB 失效（称为 TLB flush）</td>
</tr>
<tr>
<td>其他内核结构（PCB）</td>
<td>保存进程状态、优先级、调度信息等</td>
</tr>
</tbody>
</table>
<p>✅ <strong>开销大</strong>，因为涉及虚拟内存切换、TLB 清空、I/O
管理等。</p>
<hr>
<h3 id="同一进程内的线程切换线程属于同一进程">2️⃣
同一进程内的线程切换（线程属于同一进程）</h3>
<p>线程属于同一进程，它们共享：</p>
<ul>
<li>虚拟地址空间（代码段、数据段、堆等）</li>
<li>文件描述符、I/O 资源</li>
<li>页表（Page Table）</li>
</ul>
<p>切换时只需更换线程自己的内容：</p>
<table>
<thead>
<tr>
<th>切换项</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>寄存器</td>
<td>每个线程有独立寄存器状态</td>
</tr>
<tr>
<td>程序计数器（PC）</td>
<td>指向线程执行的位置</td>
</tr>
<tr>
<td>栈指针（SP）</td>
<td>每个线程有独立的用户栈、内核栈</td>
</tr>
<tr>
<td>TCB（线程控制块）</td>
<td>保存线程状态、调度信息等</td>
</tr>
</tbody>
</table>
<p>✅ <strong>开销小</strong>，无需切换虚拟内存、页表或刷新 TLB。</p>
<hr>
<h2 id="三总结对比线程-vs-进程-上下文切换">三、总结对比：线程 vs 进程
上下文切换</h2>
<table>
<thead>
<tr>
<th>比较项</th>
<th>线程上下文切换（同进程）</th>
<th>进程上下文切换（或跨进程线程）</th>
</tr>
</thead>
<tbody>
<tr>
<td>虚拟内存</td>
<td>不变</td>
<td>需要切换页表</td>
</tr>
<tr>
<td>页表切换</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>TLB 刷新</td>
<td>无</td>
<td>有</td>
</tr>
<tr>
<td>共享资源</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>切换开销</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>性能影响</td>
<td>较小</td>
<td>较大</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="四线程切换的时机由内核线程调度器决定">四、线程切换的时机（由内核线程调度器决定）</h2>
<ul>
<li>时间片到期（抢占式调度）</li>
<li>主动让出 CPU（如调用
<code>yield()</code>、<code>sleep()</code>）</li>
<li>等待 I/O 或资源阻塞（如锁、信号量）</li>
<li>高优先级线程抢占低优先级线程</li>
</ul>
<hr>
<h2 id="五面试答题模板简洁表达">五、面试答题模板（简洁表达）</h2>
<p><strong>线程上下文切换的开销取决于线程是否属于同一进程：</strong></p>
<ul>
<li>若线程属于<strong>不同进程</strong>，那么线程切换就等同于<strong>进程切换</strong>，涉及页表、虚拟内存、TLB
缓存的切换，<strong>开销大</strong>。</li>
<li>若线程属于<strong>同一进程</strong>，因为共享虚拟内存空间，只需要切换寄存器、程序计数器、堆栈等私有部分，<strong>开销小</strong>。</li>
<li>因此，一般来说，线程上下文切换的<strong>开销远小于进程切换</strong>。</li>
</ul>
<hr>
<h1 id="线程的三种实现方式">✅ 线程的三种实现方式</h1>
<hr>
<h2 id="一线程的本质">一、线程的本质</h2>
<p>线程（Thread）是<strong>程序执行的最小单位</strong>，多个线程可以共享一个进程的地址空间和资源。不同的操作系统对线程的支持方式不同，线程的实现方式影响线程调度、性能、阻塞行为等。</p>
<hr>
<h2 id="二线程的三种主要实现方式">二、线程的三种主要实现方式</h2>
<hr>
<h3 id="用户态线程user-level-thread-ult">1️⃣ 用户态线程（User-Level
Thread, ULT）</h3>
<h4 id="定义">✅ 定义：</h4>
<p>线程完全在用户空间由用户自己实现，操作系统<strong>内核感知不到</strong>线程的存在。</p>
<h4 id="特点">✅ 特点：</h4>
<table>
<colgroup>
<col style="width: 47%">
<col style="width: 52%">
</colgroup>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>线程切换无需陷入内核，<strong>切换开销小、速度快</strong></td>
<td>内核无法感知线程，一个线程阻塞，<strong>整个进程阻塞</strong></td>
</tr>
<tr>
<td>可移植性强，<strong>跨平台运行</strong></td>
<td>无法利用多核 CPU，线程只能在一个核上执行</td>
</tr>
<tr>
<td>用户可定制线程调度策略</td>
<td>系统无法进行真正并发</td>
</tr>
</tbody>
</table>
<h4 id="示例">✅ 示例：</h4>
<ul>
<li>Green Thread（Java 早期实现）</li>
<li>用户态线程库（如 GNU Pth）</li>
</ul>
<h4 id="调度方式">✅ 调度方式：</h4>
<p>用户自己维护线程队列和上下文，调用库函数完成调度。</p>
<hr>
<h3 id="内核态线程kernel-level-thread-klt">2️⃣ 内核态线程（Kernel-Level
Thread, KLT）</h3>
<h4 id="定义-1">✅ 定义：</h4>
<p>线程由操作系统内核直接支持和管理，<strong>每个线程都被内核感知并调度</strong>。</p>
<h4 id="特点-1">✅ 特点：</h4>
<table>
<colgroup>
<col style="width: 53%">
<col style="width: 46%">
</colgroup>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>一个线程阻塞不影响其他线程，<strong>线程独立性高</strong></td>
<td>上下文切换需要进入内核态，<strong>开销较大</strong></td>
</tr>
<tr>
<td>能充分利用多核 CPU 资源，<strong>实现真正并发</strong></td>
<td>线程的创建、销毁、调度都需要系统调用</td>
</tr>
<tr>
<td>内核调度更合理、安全性更强</td>
<td>用户无法自定义调度策略</td>
</tr>
</tbody>
</table>
<h4 id="示例-1">✅ 示例：</h4>
<ul>
<li>Linux (pthread)、Windows (CreateThread)</li>
<li>Solaris、FreeBSD 等操作系统</li>
</ul>
<h4 id="调度方式-1">✅ 调度方式：</h4>
<p>由操作系统内核进行调度，线程切换涉及上下文切换与内核态参与。</p>
<hr>
<h3 id="混合实现hybrid-thread-或-mn-模型">3️⃣ 混合实现（Hybrid Thread 或
M:N 模型）</h3>
<h4 id="定义-2">✅ 定义：</h4>
<p>结合用户态与内核态线程的优点，<strong>在用户空间管理多个用户态线程，对应少量内核态线程</strong>。</p>
<h4 id="模型结构">✅ 模型结构：</h4>
<ul>
<li>一个进程中有 <strong>M 个用户线程</strong>（由用户线程库管理）</li>
<li>映射到 <strong>N 个内核线程</strong>（由操作系统调度）</li>
</ul>
<p>→ 称为 M:N 模型（例如 M 个用户线程映射到 N 个内核线程）</p>
<h4 id="特点-2">✅ 特点：</h4>
<table>
<colgroup>
<col style="width: 55%">
<col style="width: 45%">
</colgroup>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>兼具用户线程的低开销、内核线程的阻塞处理能力</td>
<td>实现复杂，调度需要用户和内核协同管理</td>
</tr>
<tr>
<td>可实现线程绑定、并发执行、多核利用</td>
<td>同步、线程映射、阻塞模型较难设计</td>
</tr>
<tr>
<td>一些线程库支持协程（Coroutine）优化调度</td>
<td>Debug 和调试难度较大</td>
</tr>
</tbody>
</table>
<h4 id="示例-2">✅ 示例：</h4>
<ul>
<li>Solaris LWP（轻量级进程）</li>
<li>Windows Fiber + 内核线程</li>
<li>Linux 用户线程库与 pthread 配合使用</li>
</ul>
<hr>
<h2 id="三三种线程实现方式对比总结">三、三种线程实现方式对比总结</h2>
<table>
<colgroup>
<col style="width: 16%">
<col style="width: 30%">
<col style="width: 23%">
<col style="width: 29%">
</colgroup>
<thead>
<tr>
<th>比较项</th>
<th>用户态线程（ULT）</th>
<th>内核态线程（KLT）</th>
<th>混合线程（M:N）</th>
</tr>
</thead>
<tbody>
<tr>
<td>管理者</td>
<td>用户线程库</td>
<td>操作系统内核</td>
<td>用户线程库 + 内核调度</td>
</tr>
<tr>
<td>切换效率</td>
<td>高（不需陷入内核）</td>
<td>低（需内核参与）</td>
<td>较高，取决于实现方式</td>
</tr>
<tr>
<td>系统开销</td>
<td>小</td>
<td>大</td>
<td>中</td>
</tr>
<tr>
<td>阻塞影响</td>
<td>一个线程阻塞，全部挂起</td>
<td>不影响其他线程</td>
<td>不一定（看调度策略）</td>
</tr>
<tr>
<td>是否支持多核</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>简单</td>
<td>中</td>
<td>高</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="四面试答题模板简洁表达">四、面试答题模板（简洁表达）</h2>
<p>线程的实现方式有三种：</p>
<ol type="1">
<li><strong>用户态线程</strong>：由用户空间线程库管理，内核不感知线程，切换快但无法处理阻塞；</li>
<li><strong>内核态线程</strong>：由内核直接管理，支持多核并发，但切换开销大；</li>
<li><strong>混合线程</strong>：结合两者优势，在用户空间管理多个线程，由少量内核线程调度执行，兼顾效率与并发性。</li>
</ol>
<hr>
<h1 id="线程间同步thread-synchronization">✅ 线程间同步（Thread
Synchronization）</h1>
<hr>
<h2 id="一线程同步的目的">一、线程同步的目的</h2>
<p>线程同步解决的是<strong>多个线程并发访问共享资源</strong>时可能出现的数据不一致或冲突问题。</p>
<h3 id="目标">✨目标：</h3>
<p>不管线程之间如何交替执行，<strong>最终执行结果都应正确</strong>。</p>
<hr>
<h2 id="二临界区critical-section">二、临界区（Critical Section）</h2>
<h3 id="定义-3">✅ 定义：</h3>
<p>临界区是指一段<strong>访问共享资源的代码区域</strong>。如果多个线程同时进入临界区，就会导致竞态条件（race
condition），因此必须保证临界区的<strong>互斥访问</strong>。</p>
<h3 id="特性">✅ 特性：</h3>
<ul>
<li>一个线程进入临界区时，<strong>其他线程必须等待</strong>；</li>
<li>临界区可用于线程间，也适用于进程间同步。</li>
</ul>
<hr>
<h2 id="三线程同步的常见实现方式">三、线程同步的常见实现方式</h2>
<hr>
<h3 id="互斥锁mutex-lock">1️⃣ 互斥锁（Mutex Lock）</h3>
<h4 id="原理">✅ 原理：</h4>
<p>通过<strong>加锁与解锁</strong>控制共享资源的访问，确保同一时间只有一个线程执行临界区代码。</p>
<h4 id="关键操作">✅ 关键操作：</h4>
<ul>
<li><code>lock(mutex)</code>：尝试加锁；
<ul>
<li>如果锁空闲，线程加锁成功，进入临界区；</li>
<li>如果锁已被占用，线程等待。</li>
</ul></li>
<li><code>unlock(mutex)</code>：释放锁，唤醒等待线程。</li>
</ul>
<h4 id="类型">✅ 类型：</h4>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>自旋锁（忙等待锁）</td>
<td>尝试加锁失败时<strong>不停地循环检测锁</strong>是否释放，占用 CPU
资源，适合锁持有时间短的场景。</td>
</tr>
<tr>
<td>阻塞锁（无忙等待）</td>
<td>尝试加锁失败时，线程<strong>进入休眠/阻塞状态</strong>，释放
CPU，适合锁持有时间长的场景。</td>
</tr>
</tbody>
</table>
<h4 id="示例-3">✅ 示例：</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="信号量semaphore">2️⃣ 信号量（Semaphore）</h3>
<h4 id="定义-4">✅ 定义：</h4>
<p>一种通用的同步机制，用于控制访问特定数量的共享资源。</p>
<h4 id="信号量值sem">✅ 信号量值（sem）：</h4>
<ul>
<li>sem 为整数，表示资源数；</li>
<li>初始值可以设为资源总量；</li>
<li>常用于<strong>限制线程并发数</strong>，如连接池、线程池。</li>
</ul>
<h4 id="两个原子操作">✅ 两个原子操作：</h4>
<table>
<colgroup>
<col style="width: 25%">
<col style="width: 74%">
</colgroup>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>P()</code>（等待操作）</td>
<td>如果信号量值 &gt; 0，则减 1 并继续执行；否则线程阻塞</td>
</tr>
<tr>
<td><code>V()</code>（释放操作）</td>
<td>信号量值加 1，可能唤醒阻塞的线程</td>
</tr>
</tbody>
</table>
<h4 id="示例-4">✅ 示例：</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sem_wait(&amp;sem);   <span class="comment">// P 操作：尝试进入临界区</span></span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">sem_post(&amp;sem);   <span class="comment">// V 操作：离开临界区</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四互斥锁-vs-信号量对比">四、互斥锁 vs 信号量：对比</h2>
<table>
<colgroup>
<col style="width: 15%">
<col style="width: 43%">
<col style="width: 40%">
</colgroup>
<thead>
<tr>
<th>比较维度</th>
<th>互斥锁（Mutex）</th>
<th>信号量（Semaphore）</th>
</tr>
</thead>
<tbody>
<tr>
<td>本质</td>
<td>二值锁（0 或 1）</td>
<td>整数计数器</td>
</tr>
<tr>
<td>互斥性</td>
<td>是，专为互斥设计</td>
<td>也可用于互斥，但功能更通用</td>
</tr>
<tr>
<td>计数能力</td>
<td>无，只能控制单线程进入临界区</td>
<td>有，可控制多个线程并发进入</td>
</tr>
<tr>
<td>死锁可能性</td>
<td>有，使用不当会死锁</td>
<td>有，P/V 不匹配也会死锁</td>
</tr>
<tr>
<td>常见用途</td>
<td>保护临界区，线程间互斥</td>
<td>控制资源数量（连接池等）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="五线程同步进阶机制了解">五、线程同步进阶机制（了解）</h2>
<table>
<colgroup>
<col style="width: 36%">
<col style="width: 63%">
</colgroup>
<thead>
<tr>
<th>同步机制</th>
<th>简要说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>条件变量（Condition Variable）</td>
<td>用于线程<strong>等待特定条件</strong>，配合互斥锁使用</td>
</tr>
<tr>
<td>读写锁（Read-Write Lock）</td>
<td>多个线程可以同时读，但写操作必须独占</td>
</tr>
<tr>
<td>屏障（Barrier）</td>
<td>所有线程都到达屏障点后才能继续</td>
</tr>
<tr>
<td>原子操作（atomic）</td>
<td>由硬件或编译器保证操作的不可中断性，如
<code>atomic&lt;int&gt;</code></td>
</tr>
</tbody>
</table>
<hr>
<h2 id="六总结线程同步的选择建议">六、总结：线程同步的选择建议</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>建议使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>互斥访问一个资源</td>
<td>互斥锁</td>
</tr>
<tr>
<td>控制同时访问资源的数量</td>
<td>信号量</td>
</tr>
<tr>
<td>条件等待/唤醒线程</td>
<td>条件变量</td>
</tr>
<tr>
<td>多读少写场景</td>
<td>读写锁</td>
</tr>
<tr>
<td>精细控制共享数据更新</td>
<td>原子操作/自旋锁</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="死锁">✅死锁</h1>
<hr>
<h2 id="一什么是死锁deadlock">✅ 一、什么是死锁（Deadlock）？</h2>
<p><strong>定义</strong>：
在两个或多个<strong>并发进程或线程</strong>中，每个都持有某些资源，并<strong>等待其它线程释放它们当前占有的资源</strong>，所有线程因此<strong>相互等待、无法推进</strong>，就产生了<strong>死锁</strong>。</p>
<p><strong>通俗理解</strong>：
就像两个人在狭窄的走廊里面对面，都不肯先让一步，谁也不能动，僵持不下——这就是死锁。</p>
<hr>
<h2 id="二死锁产生的四个必要条件必须同时满足">✅
二、死锁产生的四个必要条件（必须同时满足）</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 27%">
<col style="width: 42%">
<col style="width: 29%">
</colgroup>
<thead>
<tr>
<th>条件名称</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. 互斥（Mutual Exclusion）</strong></td>
<td>某资源一次只能被一个线程占有，不能共享</td>
<td>打印机一次只能由一个人使用</td>
</tr>
<tr>
<td><strong>2. 占有且等待（Hold and Wait）</strong></td>
<td>一个进程占有部分资源，并等待其他资源</td>
<td>进程A占有资源1，等待资源2</td>
</tr>
<tr>
<td><strong>3. 不可剥夺（No Preemption）</strong></td>
<td>已分配的资源不能被强行剥夺，只能主动释放</td>
<td>系统不能强制拿走资源1</td>
</tr>
<tr>
<td><strong>4. 循环等待（Circular Wait）</strong></td>
<td>存在一个进程环，环中的每个进程等待下一个进程所占资源</td>
<td>A等B的资源，B等C的资源，C又等A的资源</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="三经典死锁场景举例">✅ 三、经典死锁场景举例</h2>
<p>假设有两个进程 <strong>P1、P2</strong> 和两个资源
<strong>R1、R2</strong>：</p>
<ul>
<li>P1 持有 R1，请求 R2</li>
<li>P2 持有 R2，请求 R1</li>
</ul>
<p>形成如下关系图：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">P1 —持有→ R1</span><br><span class="line">P1 —请求→ R2（被P2持有）</span><br><span class="line"></span><br><span class="line">P2 —持有→ R2</span><br><span class="line">P2 —请求→ R1（被P1持有）</span><br></pre></td></tr></table></figure>
<p>此时，满足四个条件：</p>
<ol type="1">
<li><strong>互斥</strong>：R1 和 R2 不能被同时占用</li>
<li><strong>占有且等待</strong>：P1 和 P2
都持有一个资源并请求另一个</li>
<li><strong>不可剥夺</strong>：资源不能强制拿走</li>
<li><strong>循环等待</strong>：P1 等 P2，P2 等 P1，形成环路</li>
</ol>
<p>因此产生<strong>死锁</strong>。</p>
<hr>
<h2 id="四总结">✅ 四、总结</h2>
<ul>
<li><strong>死锁=资源争夺+相互等待</strong></li>
<li><strong>只有当四个条件同时满足时，死锁才可能发生</strong></li>
<li>实际系统中通过<strong>破坏其中至少一个条件</strong>，就可以避免死锁（如：破坏循环等待）</li>
</ul>
<hr>
<h1 id="死锁的避免">死锁的避免</h1>
<hr>
<h2 id="一如何避免死锁deadlock-avoidance">✅ 一、如何避免死锁（Deadlock
Avoidance）</h2>
<p>死锁产生的四个必要条件如下：</p>
<ol type="1">
<li><strong>互斥（Mutual Exclusion）</strong></li>
<li><strong>占有并等待（Hold and Wait）</strong></li>
<li><strong>不可剥夺（No Preemption）</strong></li>
<li><strong>循环等待（Circular Wait）</strong></li>
</ol>
<p><strong>只要破坏其中一个条件，就可以避免死锁。</strong></p>
<hr>
<h3 id="消除互斥条件-通常不能破坏">🔹 1. 消除互斥条件
❌（<strong>通常不能破坏</strong>）</h3>
<ul>
<li><strong>说明</strong>：某些资源本身就不支持共享（如：打印机、锁等），因此互斥很难避免。</li>
<li><strong>结论</strong>：一般
<strong>不能通过破坏互斥条件避免死锁</strong>。</li>
</ul>
<hr>
<h3 id="消除占有并等待条件">🔹 2. 消除“占有并等待”条件 ✅</h3>
<ul>
<li><strong>做法</strong>：一个线程在申请资源时，<strong>必须一次性申请它需要的所有资源</strong>，不允许先拿一部分再等。</li>
<li><strong>缺点</strong>：可能会造成资源浪费（即使暂时不需要，也要先申请到）。</li>
</ul>
<hr>
<h3 id="消除不可剥夺条件">🔹 3. 消除“不可剥夺”条件 ✅</h3>
<ul>
<li><strong>做法</strong>：如果一个线程申请不到所需资源，就<strong>主动释放当前已占有的资源</strong>，稍后重新申请。</li>
<li><strong>实现方法</strong>：操作系统强制让占用者放弃资源（或提供 API
让其手动释放）。</li>
</ul>
<hr>
<h3 id="消除循环等待条件">🔹 4. 消除“循环等待”条件 ✅</h3>
<ul>
<li><strong>做法</strong>：对资源<strong>进行线性排序（编号）</strong>，进程<strong>必须按顺序申请资源</strong>（比如先申请资源编号小的）。</li>
<li><strong>效果</strong>：打破资源申请的“环”，从而避免了循环等待。</li>
</ul>
<hr>
<h3 id="总结死锁避免方法对照表">🔄 总结：死锁避免方法对照表</h3>
<table>
<thead>
<tr>
<th>条件</th>
<th>是否可破坏</th>
<th>避免策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>互斥</td>
<td>❌通常不能</td>
<td>资源本身不能共享</td>
</tr>
<tr>
<td>占有并等待</td>
<td>✅可以</td>
<td>一次申请所有资源</td>
</tr>
<tr>
<td>不可剥夺</td>
<td>✅可以</td>
<td>无法获得新资源就释放已有资源</td>
</tr>
<tr>
<td>循环等待</td>
<td>✅可以</td>
<td>给资源排序，按顺序申请</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="二活锁livelock与饥饿starvation">✅
二、活锁（Livelock）与饥饿（Starvation）</h2>
<h3 id="饥饿starvation">🔸 饥饿（Starvation）</h3>
<p><strong>定义</strong>：线程<strong>一直得不到资源</strong>，但系统中其他线程可能都在运行，导致它长期“被饿着”。</p>
<p><strong>原因</strong>：</p>
<ul>
<li>优先级不公平（高优先级线程一直抢资源）</li>
<li>调度策略不合理</li>
<li>被频繁抢占</li>
</ul>
<p><strong>特点</strong>：</p>
<ul>
<li>线程<strong>被动等待</strong>，长期得不到资源</li>
<li>没有资源分配的“公平性”</li>
</ul>
<hr>
<h3 id="活锁livelock">🔸 活锁（Livelock）</h3>
<p><strong>定义</strong>：线程虽然<strong>状态在不断变化（不断做出“让步”）</strong>，但始终无法向前推进。</p>
<p><strong>形象比喻</strong>：
两个人在窄桥上相遇，都想让对方先走，于是不断变换方向，但总是撞在一起，<strong>状态变了但谁也过不去</strong>。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>状态不断变（不是阻塞）</li>
<li>没有实质性进展</li>
<li>通常由<strong>过度退让或响应</strong>引起</li>
</ul>
<hr>
<h3 id="饥饿-vs-活锁-对比">🔄 饥饿 vs 活锁 对比</h3>
<table>
<thead>
<tr>
<th>项目</th>
<th>饥饿（Starvation）</th>
<th>活锁（Livelock）</th>
</tr>
</thead>
<tbody>
<tr>
<td>本质</td>
<td>一直得不到资源</td>
<td>一直尝试但无进展</td>
</tr>
<tr>
<td>状态变化</td>
<td>很少变化</td>
<td>状态不断变化</td>
</tr>
<tr>
<td>典型原因</td>
<td>资源调度不公平</td>
<td>反复退让导致</td>
</tr>
<tr>
<td>是否阻塞</td>
<td>是</td>
<td>否（活着但原地踏步）</td>
</tr>
<tr>
<td>可解决方式</td>
<td>引入公平策略</td>
<td>设置重试上限、随机退让</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="三总结">✅ 三、总结</h2>
<ul>
<li><strong>避免死锁</strong>的关键：破坏四个必要条件之一，尤其常用“请求顺序”、“一次性请求”策略。</li>
<li><strong>饥饿和活锁</strong>虽不是死锁，但也会导致程序“卡死”或长时间无响应。</li>
<li>实际编程中，应设计<strong>公平、有限重试</strong>的机制来应对这些问题。</li>
</ul>
<hr>
<h1 id="物理内存与虚拟内存">物理内存与虚拟内存</h1>
<hr>
<h2 id="一物理内存physical-memory">✅ 一、物理内存（Physical
Memory）</h2>
<h3 id="定义-5">📌 定义：</h3>
<ul>
<li>物理内存是计算机中<strong>真实存在的硬件内存（RAM）</strong>。</li>
<li>应用程序最终运行的指令和数据，必须被加载到物理内存中才能执行。</li>
</ul>
<h3 id="特点-3">📌 特点：</h3>
<ul>
<li>容量有限，如 8GB、16GB、64GB 等。</li>
<li>所有程序最终都依赖物理内存执行。</li>
<li>没有地址转换时，直接使用物理地址。</li>
</ul>
<hr>
<h2 id="二虚拟内存virtual-memory">✅ 二、虚拟内存（Virtual Memory）</h2>
<h3 id="定义-6">📌 定义：</h3>
<ul>
<li>虚拟内存是由<strong>操作系统和硬件（MMU）协同实现</strong>的一种内存管理机制。</li>
<li>为每个进程提供一个<strong>连续、隔离的虚拟地址空间</strong>，即使物理内存不足，也可以运行大型程序。</li>
</ul>
<h3 id="特点-4">📌 特点：</h3>
<ul>
<li>进程使用的是<strong>虚拟地址（逻辑地址）</strong>，不是物理地址。</li>
<li>每个进程都有自己的虚拟地址空间，相互隔离。</li>
<li>虚拟内存空间远大于实际物理内存，可通过磁盘空间扩展。</li>
</ul>
<hr>
<h2 id="三地址转换与页表机制">✅ 三、地址转换与页表机制</h2>
<table>
<colgroup>
<col style="width: 6%">
<col style="width: 93%">
</colgroup>
<thead>
<tr>
<th>步骤</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>1️⃣</td>
<td>CPU 发出虚拟地址（由程序指令使用）</td>
</tr>
<tr>
<td>2️⃣</td>
<td><strong>MMU（内存管理单元）</strong>
查找<strong>页表</strong>，将虚拟地址转换为物理地址</td>
</tr>
<tr>
<td>3️⃣</td>
<td>页表中保存虚拟页与物理页之间的映射关系</td>
</tr>
<tr>
<td>4️⃣</td>
<td>若所需页不在内存，触发<strong>缺页中断</strong>，操作系统将数据从磁盘加载到内存</td>
</tr>
<tr>
<td>5️⃣</td>
<td>数据成功加载后，程序继续运行</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="四虚拟内存的组成与结构">✅ 四、虚拟内存的组成与结构</h2>
<ul>
<li>虚拟内存空间被<strong>分成若干“页”（Page）</strong></li>
<li>物理内存空间被<strong>分成相同大小的“页框”（Frame）</strong></li>
<li>每个虚拟页可能被映射到某个页框中，也可能还在磁盘里（Swap 区）</li>
</ul>
<hr>
<h2 id="五虚拟内存的优势">✅ 五、虚拟内存的优势</h2>
<table>
<thead>
<tr>
<th>优势</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>✅ 隔离性</td>
<td>每个进程都在自己的空间运行，互不干扰，提升安全性</td>
</tr>
<tr>
<td>✅ 大空间</td>
<td>虚拟内存远大于物理内存，可运行大程序</td>
</tr>
<tr>
<td>✅ 简化编程</td>
<td>程序员无需关心物理内存地址，只需使用逻辑地址</td>
</tr>
<tr>
<td>✅ 支持内存换页</td>
<td>不活跃的页面可换出到磁盘，提高内存利用率</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="六物理内存-vs-虚拟内存-对比总结">✅ 六、物理内存 vs 虚拟内存
对比总结</h2>
<table>
<thead>
<tr>
<th>比较项</th>
<th>物理内存</th>
<th>虚拟内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否真实存在</td>
<td>是（RAM）</td>
<td>否（操作系统模拟）</td>
</tr>
<tr>
<td>地址类型</td>
<td>物理地址</td>
<td>虚拟地址（逻辑地址）</td>
</tr>
<tr>
<td>是否共享</td>
<td>所有程序共享</td>
<td>每个进程独享</td>
</tr>
<tr>
<td>大小限制</td>
<td>被硬件限制</td>
<td>理论上更大，可扩展到磁盘</td>
</tr>
<tr>
<td>访问机制</td>
<td>直接访问</td>
<td>需通过页表映射访问</td>
</tr>
<tr>
<td>核心功能</td>
<td>存储运行数据</td>
<td>提供隔离与扩展能力</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="七关键术语回顾">✅ 七、关键术语回顾</h2>
<table>
<thead>
<tr>
<th>术语</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>页（Page）</strong></td>
<td>虚拟内存划分的单位</td>
</tr>
<tr>
<td><strong>页框（Frame）</strong></td>
<td>物理内存划分的单位</td>
</tr>
<tr>
<td><strong>页表（Page Table）</strong></td>
<td>存储虚拟页到物理页框的映射关系</td>
</tr>
<tr>
<td><strong>缺页中断（Page Fault）</strong></td>
<td>所需页不在内存时，触发中断从磁盘加载</td>
</tr>
<tr>
<td><strong>交换空间（Swap）</strong></td>
<td>把不常用的页临时存放到磁盘的区域</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="内存分段">内存分段</h1>
<hr>
<h2 id="一什么是内存分段segmentation">✅
一、什么是内存分段（Segmentation）？</h2>
<h3 id="定义-7">📌 定义：</h3>
<p>内存分段是一种<strong>将程序从逻辑结构上划分成若干段</strong>的内存管理方式。每一段代表一类逻辑功能，如：</p>
<ul>
<li><strong>代码段（Code Segment）</strong>：存放程序指令</li>
<li><strong>数据段（Data Segment）</strong>：存放全局变量、静态变量</li>
<li><strong>栈段（Stack Segment）</strong>：存放函数调用栈帧</li>
<li><strong>堆段（Heap Segment）</strong>：存放动态分配的内存</li>
</ul>
<h3 id="核心思想">📌 核心思想：</h3>
<p>将程序划分为<strong>多个逻辑段</strong>，每个段<strong>独立管理</strong>，段与段之间<strong>物理位置不一定连续</strong>，但逻辑上是清晰的。</p>
<hr>
<h2 id="二虚拟地址结构逻辑地址">✅ 二、虚拟地址结构（逻辑地址）</h2>
<p>在分段系统中，一个虚拟地址由两部分组成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟地址 = &lt;段号 s, 段内偏移量 d&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>s</code>：段号，表示访问的是哪一个段</li>
<li><code>d</code>：段内偏移量，表示在该段内的偏移位置</li>
</ul>
<hr>
<h2 id="三段表segment-table">✅ 三、段表（Segment Table）</h2>
<p>系统为每个进程维护一个段表（Segment
Table），每个段有一个表项，包含：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>段基址 Base</strong></td>
<td>该段在物理内存中的起始地址</td>
</tr>
<tr>
<td><strong>段界限 Limit</strong></td>
<td>该段的长度（限制偏移量的最大值）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="四地址转换过程">✅ 四、地址转换过程</h2>
<p>当进程访问逻辑地址 <code>&lt;s, d&gt;</code> 时，系统做如下转换：</p>
<ol type="1">
<li><p>查找段表中段号 <code>s</code> 的基址和界限；</p></li>
<li><p>检查偏移量 <code>d</code> 是否越界（是否
<code>d &lt; Limit[s]</code>）；</p></li>
<li><p>如果不越界，则：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址 = Base[s] + d</span><br></pre></td></tr></table></figure></li>
<li><p>如果越界，则抛出段错误（Segment Fault）。</p></li>
</ol>
<hr>
<h2 id="五自定义示例分段地址映射">✅ 五、自定义示例：分段地址映射</h2>
<p>假设进程有以下段表（单位为字节）：</p>
<table>
<thead>
<tr>
<th>段号 (s)</th>
<th>段名</th>
<th>段基址（Base[s]）</th>
<th>段界限（Limit[s]）</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>代码段</td>
<td>1000</td>
<td>400</td>
</tr>
<tr>
<td>1</td>
<td>数据段</td>
<td>2000</td>
<td>300</td>
</tr>
<tr>
<td>2</td>
<td>栈段</td>
<td>3000</td>
<td>200</td>
</tr>
<tr>
<td>3</td>
<td>堆段</td>
<td>4000</td>
<td>500</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="示例问题-1">🔍 示例问题 1：</h3>
<blockquote>
<p>虚拟地址 =
<code>&lt;1, 120&gt;</code>（即访问<strong>数据段</strong>偏移量为
120）</p>
</blockquote>
<p><strong>解答过程：</strong></p>
<ol type="1">
<li><p>段号
<code>s = 1</code>，查表得：<code>Base[1] = 2000</code>，<code>Limit[1] = 300</code></p></li>
<li><p>偏移量 <code>d = 120</code>，满足
<code>d &lt; 300</code>，合法</p></li>
<li><p>转换物理地址：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Physical Address = 2000 + 120 = 2120</span><br></pre></td></tr></table></figure></li>
</ol>
<p>✅ 结果：物理地址为 <code>2120</code></p>
<hr>
<h3 id="示例问题-2">🔍 示例问题 2：</h3>
<blockquote>
<p>虚拟地址 =
<code>&lt;2, 250&gt;</code>（即访问<strong>栈段</strong>偏移量为
250）</p>
</blockquote>
<p><strong>解答过程：</strong></p>
<ol type="1">
<li>段号
<code>s = 2</code>，查表得：<code>Base[2] = 3000</code>，<code>Limit[2] = 200</code></li>
<li>偏移量 <code>d = 250</code>，超过界限 <code>200</code>，非法！</li>
</ol>
<p>❌ 结果：发生<strong>段越界错误（Segment Fault）</strong></p>
<hr>
<h2 id="六分段的优点与缺点">✅ 六、分段的优点与缺点</h2>
<h3 id="优点">✅ 优点：</h3>
<ul>
<li>更接近程序员对程序的逻辑结构划分</li>
<li>支持<strong>代码共享</strong>、<strong>数据保护</strong></li>
<li>每段可以有<strong>不同的访问权限</strong></li>
<li>支持<strong>非连续内存分配</strong>，减少内存浪费</li>
</ul>
<h3 id="缺点">❌ 缺点：</h3>
<ul>
<li>地址转换需要查段表，<strong>有一定开销</strong></li>
<li>每段管理需要<strong>段表、段寄存器</strong>，增加复杂性</li>
<li>如果段过多，段表会变大</li>
</ul>
<hr>
<h2 id="七分段与分页的比较">✅ 七、分段与分页的比较</h2>
<table>
<thead>
<tr>
<th>项目</th>
<th>分段</th>
<th>分页</th>
</tr>
</thead>
<tbody>
<tr>
<td>单位</td>
<td>逻辑段（大小不等）</td>
<td>固定大小页（如4KB）</td>
</tr>
<tr>
<td>地址结构</td>
<td>段号 + 偏移</td>
<td>页号 + 页内偏移</td>
</tr>
<tr>
<td>管理目标</td>
<td>程序的逻辑结构</td>
<td>内存空间的等分管理</td>
</tr>
<tr>
<td>外部碎片</td>
<td>有</td>
<td>无（但有内部碎片）</td>
</tr>
<tr>
<td>易于共享</td>
<td>支持段级共享</td>
<td>支持页级共享</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="内存分页">内存分页</h1>
<hr>
<h2 id="一什么是内存分页paging">✅ 一、什么是内存分页（Paging）？</h2>
<h3 id="定义-8">📌 定义：</h3>
<p>分页是一种<strong>将内存划分为固定大小的页（Page）*<em>的管理机制。分页的目标是将*</em>虚拟内存和物理内存都划分为固定大小的块</strong>，分别称为：</p>
<ul>
<li><strong>虚拟页（Virtual Page）</strong></li>
<li><strong>物理页框（Page Frame）</strong></li>
</ul>
<p>这种划分方式可以有效解决内存碎片问题，并使程序不再需要使用连续的物理地址空间。</p>
<hr>
<h2 id="二分页机制的核心思想">✅ 二、分页机制的核心思想</h2>
<ol type="1">
<li><strong>虚拟地址空间</strong>
被划分为若干个大小相等的<strong>页（page）</strong></li>
<li><strong>物理地址空间</strong> 被划分为同样大小的<strong>页框（page
frame）</strong></li>
<li>操作系统通过一个称为<strong>页表（Page
Table）</strong>的数据结构，记录每一个虚拟页和物理页框之间的映射关系。</li>
</ol>
<hr>
<h2 id="三地址结构与转换过程">✅ 三、地址结构与转换过程</h2>
<h3 id="虚拟地址结构">📌 虚拟地址结构：</h3>
<p>一个虚拟地址分为两部分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">虚拟地址 = &lt;页号 p, 页内偏移 d&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>p</code>：虚拟页号（Page Number）</li>
<li><code>d</code>：页内偏移（Page Offset），在该页内的具体位置</li>
</ul>
<hr>
<h3 id="地址转换流程">📌 地址转换流程：</h3>
<ol type="1">
<li><p><strong>查页表</strong>：用页号 <code>p</code>
找到页表中对应的<strong>物理页框号</strong></p></li>
<li><p><strong>检查有效性</strong>：判断该页是否已经加载到内存（如果没有，就发生缺页中断）</p></li>
<li><p><strong>计算物理地址</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址 = 物理页框起始地址 + 页内偏移量 d</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h2 id="四分页示例">✅ 四、分页示例</h2>
<h3 id="已知">已知：</h3>
<ul>
<li>每页大小：4KB（即 2¹² 字节）</li>
<li>虚拟地址：32 位
<ul>
<li>→ 高 20 位为页号（因为 2³² / 2¹² = 2²⁰ 页）</li>
<li>→ 低 12 位为页内偏移</li>
</ul></li>
</ul>
<hr>
<h3 id="示例问题">🧠 示例问题：</h3>
<blockquote>
<p>一个进程访问虚拟地址 <code>0x12345678</code>，页表中该虚拟页号
<code>0x12345</code> 被映射到物理页框号
<code>0xABC</code>。求物理地址。</p>
</blockquote>
<h3 id="解题步骤">✍️ 解题步骤：</h3>
<ol type="1">
<li><p><strong>提取页号和偏移</strong>：</p>
<ul>
<li><p>虚拟地址 = <code>0x12345678</code></p></li>
<li><p>二进制结构为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">页号 p  = 0x12345</span><br><span class="line">页内偏移 d = 0x678</span><br></pre></td></tr></table></figure></li>
</ul></li>
<li><p><strong>页框号</strong>：根据页表查得页号 <code>0x12345</code>
对应的物理页框是 <code>0xABC</code></p></li>
<li><p><strong>物理地址计算</strong>：</p>
<ul>
<li>每页大小为 4KB = <code>2^12 = 4096</code> 字节</li>
<li>页框基址 = <code>0xABC * 0x1000 = 0xABC000</code></li>
<li>物理地址 = <code>0xABC000 + 0x678 = 0xABC678</code></li>
</ul></li>
</ol>
<p>✅ 答案：物理地址为 <code>0xABC678</code></p>
<hr>
<h2 id="五分页系统的性能问题与优化">✅ 五、分页系统的性能问题与优化</h2>
<h3 id="访问内存需要两次内存访问">📌 访问内存需要两次内存访问：</h3>
<ol type="1">
<li>第一次：访问页表（找物理页框号）</li>
<li>第二次：访问物理内存（取数据）</li>
</ol>
<p>为了解决这个<strong>性能瓶颈</strong>，引入了：</p>
<hr>
<h3 id="tlbtranslation-lookaside-buffer">✅ TLB（Translation Lookaside
Buffer）</h3>
<ul>
<li><strong>TLB
是页表缓存</strong>，是一种小型、快速的<strong>联想存储器</strong></li>
<li><strong>作用</strong>：缓存页表中最近使用的页号和页框号映射</li>
<li>如果 TLB 命中，就不需要再访问内存查页表</li>
<li>如果 TLB 未命中，就要从内存访问页表，然后把新的映射加载到 TLB
中</li>
</ul>
<hr>
<h2 id="六分页的优缺点">✅ 六、分页的优缺点</h2>
<h3 id="优点-1">✅ 优点：</h3>
<ul>
<li>内存管理简单，页大小固定、便于分配</li>
<li>消除外部碎片（但会有内部碎片）</li>
<li>支持虚拟内存与进程隔离</li>
<li>易于实现按需分页与交换</li>
</ul>
<h3 id="缺点-1">❌ 缺点：</h3>
<ul>
<li>每次访问需要额外查页表，效率低（TLB 缓解）</li>
<li>页表可能很大，管理页表本身成为开销</li>
<li>存在内部碎片（最后一页可能浪费空间）</li>
</ul>
<hr>
<h2 id="七分页-vs-分段-对比">✅ 七、分页 vs 分段 对比</h2>
<table>
<thead>
<tr>
<th>特点</th>
<th>分段（Segmentation）</th>
<th>分页（Paging）</th>
</tr>
</thead>
<tbody>
<tr>
<td>划分方式</td>
<td>按逻辑功能（段）</td>
<td>按固定大小（页）</td>
</tr>
<tr>
<td>大小</td>
<td>不固定</td>
<td>固定（如 4KB）</td>
</tr>
<tr>
<td>地址结构</td>
<td>段号 + 段内偏移</td>
<td>页号 + 页内偏移</td>
</tr>
<tr>
<td>碎片类型</td>
<td>外部碎片多</td>
<td>无外部碎片，但有内部碎片</td>
</tr>
<tr>
<td>逻辑意义</td>
<td>有</td>
<td>无，只是划块</td>
</tr>
<tr>
<td>易共享性</td>
<td>段易共享</td>
<td>页易共享</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="多级页表">多级页表</h1>
<hr>
<h2 id="一什么是多级页表">✅ 一、什么是多级页表？</h2>
<p><strong>多级页表</strong>是一种 <strong>将页表本身也分页</strong>
的技术，目的是解决单级页表在大地址空间下的空间浪费问题。</p>
<hr>
<h2 id="二背景单级页表的问题">✅ 二、背景：单级页表的问题</h2>
<p>在一个 32 位系统中，虚拟地址空间为 4GB：</p>
<ul>
<li>页大小：4KB（即 2122^{12}）</li>
<li>页数：232212=220 = 2^{20} 个页</li>
<li>每个页表条目（PTE）占 4 字节</li>
<li>总页表大小：220×4=4MB2^{20} = 4</li>
</ul>
<p>⚠️ <strong>问题：</strong></p>
<ul>
<li>对于一个只用了几页的进程，也要分配整张 4MB 页表，造成严重浪费。</li>
</ul>
<hr>
<h2 id="三核心思想页表分页-分层管理">✅ 三、核心思想：页表分页 →
分层管理</h2>
<h3 id="多级页表的基本结构以两级页表为例">📌
多级页表的基本结构（以<strong>两级页表</strong>为例）：</h3>
<ol type="1">
<li><strong>第一级页表（页目录 Page Directory）</strong>
<ul>
<li>每项称为页目录项（PDE），存储第二级页表的物理地址</li>
</ul></li>
<li><strong>第二级页表（页表 Page Table）</strong>
<ul>
<li>每项称为页表项（PTE），存储实际页框的物理地址</li>
</ul></li>
</ol>
<h3 id="虚拟地址划分">📌 虚拟地址划分：</h3>
<p>以 32 位虚拟地址 &amp; 4KB 页大小为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虚拟地址结构（32 位）：</span><br><span class="line">[ 10位页目录号 | 10位页表号 | 12位页内偏移 ]</span><br></pre></td></tr></table></figure>
<ul>
<li>高 10 位（位 31~22）：页目录索引</li>
<li>中 10 位（位 21~12）：页表索引</li>
<li>低 12 位（位 11~0）：页内偏移</li>
</ul>
<hr>
<h2 id="四地址转换过程两级页表">✅ 四、地址转换过程（两级页表）</h2>
<p>假设我们要访问虚拟地址 <code>0x12345678</code>，页大小为 4KB：</p>
<h3 id="拆分地址">✍️ 1. 拆分地址：</h3>
<ul>
<li>二进制表示：<code>0001 0010 0011 0100 0101 0110 0111 1000</code></li>
<li>页目录索引（PDI）= 高 10 位 = <code>0001001000</code> =
<code>0x048</code></li>
<li>页表索引（PTI）= 中 10 位 = <code>1101000101</code> =
<code>0x345</code></li>
<li>页内偏移（OFFSET）= 低 12 位 = <code>011001111000</code> =
<code>0x678</code></li>
</ul>
<h3 id="查表转换">✍️ 2. 查表转换：</h3>
<ol type="1">
<li>使用 PDI (<code>0x48</code>)
查<strong>页目录表</strong>，找到对应的页表地址</li>
<li>用 PTI (<code>0x345</code>)
查该页表，得到对应页框的起始物理地址（比如 <code>0xABC000</code>）</li>
<li>最终物理地址 = 页框地址 <code>+</code> 页内偏移 <code>0x678</code> →
<code>0xABC000 + 0x678 = 0xABC678</code></li>
</ol>
<p>✅ 最终访问的是物理地址 <code>0xABC678</code></p>
<hr>
<h2 id="五优点与缺点">✅ 五、优点与缺点</h2>
<h3 id="优点-2">✅ 优点：</h3>
<ul>
<li><strong>节省内存</strong>：只有访问过的页目录/页表才会被分配内存</li>
<li><strong>支持稀疏地址空间</strong>：适合实际程序只用小部分地址空间的情况</li>
<li><strong>方便地址空间扩展</strong>：适应从 32 位扩展到 64 位架构</li>
</ul>
<h3 id="缺点-2">❌ 缺点：</h3>
<ul>
<li><strong>地址转换更复杂</strong>：从1次页表访问 → 变成 2
次或多次</li>
<li><strong>性能下降</strong>：多次内存访问（靠 TLB 缓解）</li>
</ul>
<hr>
<h2 id="六常见的多级页表结构">✅ 六、常见的多级页表结构</h2>
<table>
<colgroup>
<col style="width: 24%">
<col style="width: 12%">
<col style="width: 9%">
<col style="width: 53%">
</colgroup>
<thead>
<tr>
<th>架构</th>
<th>虚拟地址</th>
<th>页大小</th>
<th>分级结构</th>
</tr>
</thead>
<tbody>
<tr>
<td>x86 32 位</td>
<td>32 位</td>
<td>4KB</td>
<td>两级页表（页目录 + 页表）</td>
</tr>
<tr>
<td>x86_64（Linux）</td>
<td>48 位</td>
<td>4KB</td>
<td>四级页表（PGD → PUD → PMD → PTE）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="七补充linux-四级页表结构x86_64">✅ 七、补充：Linux
四级页表结构（x86_64）</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">虚拟地址结构（48 位）：</span><br><span class="line">[ 9位 PGD | 9位 PUD | 9位 PMD | 9位 PTE | 12位页内偏移 ]</span><br></pre></td></tr></table></figure>
<ul>
<li>每层表项数：29=5122^9 = 512</li>
<li>每层表大小：512 × 8B = 4KB（刚好一页）</li>
</ul>
<hr>
<h2 id="八总结">✅ 八、总结</h2>
<table>
<thead>
<tr>
<th>项目</th>
<th>单级页表</th>
<th>多级页表</th>
</tr>
</thead>
<tbody>
<tr>
<td>页表结构</td>
<td>扁平结构</td>
<td>分层结构</td>
</tr>
<tr>
<td>地址转换次数</td>
<td>1 次</td>
<td>多次（如 2~4 次）</td>
</tr>
<tr>
<td>内存使用</td>
<td>固定大页表</td>
<td>实际用多少分配多少</td>
</tr>
<tr>
<td>适合场景</td>
<td>小型系统</td>
<td>支持大虚拟空间</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="快表">快表</h1>
<hr>
<h2 id="什么是快表tlbtranslation-lookaside-buffer">✅
什么是快表（TLB：Translation Lookaside Buffer）</h2>
<h3 id="一定义">📌 一、定义</h3>
<p><strong>TLB（快表）</strong> 是一种位于 <strong>CPU
内部的高速缓存</strong>，用于缓存最近使用过的页表项，加快虚拟地址到物理地址的转换速度。</p>
<blockquote>
<p>✅ 全称：Translation Lookaside Buffer ✅
中文：地址变换旁路缓冲区，也称「快表」</p>
</blockquote>
<hr>
<h3 id="二背景知识">📌 二、背景知识</h3>
<ul>
<li>在分页机制中，<strong>虚拟地址需要通过页表转换为物理地址</strong></li>
<li>页表在内存中，<strong>访问页表本身就需要一次内存访问</strong></li>
<li>如果每次访问都要查页表，会导致
<strong>效率低（两次内存访问）</strong></li>
</ul>
<hr>
<h3 id="三tlb-的作用减少访问内存的次数">📌 三、TLB
的作用：<strong>减少访问内存的次数</strong></h3>
<table>
<colgroup>
<col style="width: 23%">
<col style="width: 76%">
</colgroup>
<thead>
<tr>
<th>情况</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>TLB 命中（Hit）</td>
<td>CPU 在 TLB
中找到了页表项，直接计算物理地址，<strong>只访问一次内存</strong></td>
</tr>
<tr>
<td>TLB 未命中（Miss）</td>
<td>去内存中查页表，找到页表项，<strong>再访问数据</strong>，通常需要两次访问</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="四局部性原理支撑">📌 四、局部性原理支撑</h3>
<blockquote>
<p><strong>程序访问局部区域的概率大</strong>，短时间内会频繁访问相同页面。</p>
</blockquote>
<ul>
<li>时间局部性：刚访问的数据很可能再次访问</li>
<li>空间局部性：访问了某个地址，可能访问其邻近地址</li>
</ul>
<p>TLB 只缓存<strong>最近访问的部分页表项</strong>（如 32~512
项），命中率高。</p>
<hr>
<h3 id="五tlb-工作示意图">📌 五、TLB 工作示意图</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CPU 虚拟地址 →</span><br><span class="line">       ┌────────────┐</span><br><span class="line">       │   TLB 查找 │ ←—— 近期常用页表项</span><br><span class="line">       └────────────┘</span><br><span class="line">            ↓命中？</span><br><span class="line">          是  ↓否</span><br><span class="line">       ┌───────┐</span><br><span class="line">       │ 查页表 │ ←—— 从内存中查页表</span><br><span class="line">       └───────┘</span><br><span class="line">            ↓</span><br><span class="line">       ┌────────────┐</span><br><span class="line">       │ 物理地址输出 │</span><br><span class="line">       └────────────┘</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="六补充概念">📌 六、补充概念</h3>
<ul>
<li>TLB 是 <strong>全相联缓存</strong>（每个项都能放任意页表映射）</li>
<li>TLB 是硬件级实现，由 CPU 自动维护</li>
<li>在<strong>TLB Miss</strong> 时，通常需要：
<ul>
<li>在页表中查找</li>
<li>更新 TLB 缓存项（淘汰旧的）</li>
</ul></li>
</ul>
<hr>
<h2 id="分页与分段的区别">✅分页与分段的区别</h2>
<table>
<colgroup>
<col style="width: 17%">
<col style="width: 35%">
<col style="width: 46%">
</colgroup>
<thead>
<tr>
<th>比较项</th>
<th>分页 Paging</th>
<th>分段 Segmentation</th>
</tr>
</thead>
<tbody>
<tr>
<td>单位类型</td>
<td><strong>物理单位</strong></td>
<td><strong>逻辑单位</strong></td>
</tr>
<tr>
<td>面向对象</td>
<td>面向系统（操作系统管理内存）</td>
<td>面向用户（程序按功能划分）</td>
</tr>
<tr>
<td>对用户是否可见</td>
<td>不可见（程序员无需知道页）</td>
<td>可见（程序员知道代码段、数据段等）</td>
</tr>
<tr>
<td>分割依据</td>
<td>固定大小划分（如每页4KB）</td>
<td>按程序逻辑模块划分（如代码段、堆段）</td>
</tr>
<tr>
<td>尺寸大小</td>
<td>固定大小（系统统一）</td>
<td>不固定（取决于段内容）</td>
</tr>
<tr>
<td>地址结构</td>
<td>虚拟地址 = 页号 + 页内偏移</td>
<td>虚拟地址 = 段号 + 段内偏移</td>
</tr>
<tr>
<td>地址转换机制</td>
<td>页表（Page Table）</td>
<td>段表（Segment Table）</td>
</tr>
<tr>
<td>地址空间</td>
<td>一维</td>
<td>二维</td>
</tr>
<tr>
<td>优点</td>
<td>简化内存管理，避免碎片</td>
<td>有利于信息共享、保护</td>
</tr>
<tr>
<td>缺点</td>
<td>存储保护和共享不方便</td>
<td>内存利用率低，外部碎片</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="补充分页-vs-分段">📌 补充：分页 vs 分段</h3>
<ul>
<li><strong>分页是为系统服务的</strong>：简化内存分配，提高内存利用</li>
<li><strong>分段是为用户服务的</strong>：便于程序结构组织、共享和保护</li>
</ul>
<hr>
<h2 id="总结速记">✅ 总结速记</h2>
<table>
<thead>
<tr>
<th>对比点</th>
<th>分页</th>
<th>分段</th>
</tr>
</thead>
<tbody>
<tr>
<td>单位</td>
<td>固定页</td>
<td>逻辑段</td>
</tr>
<tr>
<td>地址</td>
<td>页号 + 偏移</td>
<td>段号 + 偏移</td>
</tr>
<tr>
<td>维度</td>
<td>一维</td>
<td>二维</td>
</tr>
<tr>
<td>保护性</td>
<td>较弱</td>
<td>较强</td>
</tr>
<tr>
<td>用户可见</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="什么是交换空间swap-space">✅ 27、什么是交换空间（Swap
Space）</h2>
<h3 id="一定义-1">📌 一、定义</h3>
<p><strong>交换空间（Swap Space）</strong>
是磁盘上的一块区域，用作内存的“后备扩展”，当<strong>物理内存不足</strong>时，操作系统会将部分<strong>暂时不使用的页面</strong>从内存转移到交换空间，以释放内存。</p>
<hr>
<h3 id="二为什么需要-swap">📌 二、为什么需要 Swap？</h3>
<blockquote>
<p>原因：<strong>物理内存有限，而程序运行又需要更多内存</strong></p>
</blockquote>
<ul>
<li>当 RAM
不够用时，可以<strong>临时借助磁盘</strong>（Swap）避免程序崩溃。</li>
<li>利用了磁盘空间，扩大了<strong>虚拟内存的容量</strong>。</li>
</ul>
<hr>
<h3 id="三swap-的位置">📌 三、Swap 的位置</h3>
<p>通常是：</p>
<ul>
<li>一个磁盘<strong>分区</strong>（swap 分区），或</li>
<li>一个专用的<strong>swap 文件</strong>（如
<code>/swapfile</code>）</li>
</ul>
<hr>
<h3 id="四swap-的用途">📌 四、Swap 的用途</h3>
<table>
<colgroup>
<col style="width: 20%">
<col style="width: 79%">
</colgroup>
<thead>
<tr>
<th>用途</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1️⃣ 内存不足时</td>
<td>把不常用的页换到磁盘，腾出内存</td>
</tr>
<tr>
<td>2️⃣ 启动程序时</td>
<td>程序初始加载的内存页，有些之后不再访问，可交换出</td>
</tr>
<tr>
<td>3️⃣ 系统挂起/休眠</td>
<td>将整个内存内容写入 Swap，实现挂起恢复（如 Linux suspend）</td>
</tr>
</tbody>
</table>
<hr>
<h3 id="五工作机制简要">📌 五、工作机制简要</h3>
<ol type="1">
<li>程序运行需要内存</li>
<li>物理内存已满</li>
<li>操作系统选择一部分“冷数据页”</li>
<li>将其<strong>写入 swap 区</strong></li>
<li>释放 RAM，用于当前活跃程序</li>
</ol>
<hr>
<h3 id="六图示类比图书馆">📌 六、图示类比（图书馆）</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">物理内存 = 书架  </span><br><span class="line">交换空间 = 仓库</span><br><span class="line"></span><br><span class="line">书架满了（内存满）→ 把不常读的书放仓库（Swap）→ 腾出空间放新书</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="七优点-缺点">📌 七、优点 &amp; 缺点</h3>
<table>
<thead>
<tr>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>避免系统 OOM 崩溃</td>
<td>访问磁盘速度远慢于内存，性能下降</td>
</tr>
<tr>
<td>扩展虚拟内存</td>
<td>频繁交换会导致 <strong>thrashing（抖动）</strong></td>
</tr>
<tr>
<td>支持系统休眠</td>
<td>SSD 上频繁写入会影响寿命</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="什么是缺页中断page-fault">✅什么是缺页中断（Page Fault）</h2>
<h3 id="一定义-2">📌 一、定义</h3>
<p><strong>缺页中断</strong>是指程序访问某个页时，该页不在物理内存中，导致<strong>操作系统中断当前程序运行</strong>，将该页从磁盘中<strong>调入内存</strong>的过程。</p>
<hr>
<h3 id="二详细过程">📌 二、详细过程</h3>
<ol type="1">
<li>程序访问虚拟地址中的某页</li>
<li>页表查不到该页的物理页号（页不在内存）</li>
<li><strong>缺页中断触发</strong></li>
<li>操作系统调用页调度程序：
<ul>
<li>从交换空间（或程序文件）读出页面</li>
<li>如内存已满，使用<strong>页面置换算法</strong>淘汰一页</li>
</ul></li>
<li>更新页表</li>
<li>重新执行刚刚被中断的指令（透明给用户）</li>
</ol>
<hr>
<h3 id="三图书馆类比超经典">📌 三、图书馆类比（超经典🌟）</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">📚 你想找一本书（访问某页） → 书架上没有（页不在内存）  </span><br><span class="line">→ 请图书管理员（操作系统）从仓库取书（从磁盘加载页）  </span><br><span class="line">→ 如果书架满了，先移走一本冷门书（页面置换算法）  </span><br><span class="line">→ 把新书放上来（调页），然后你再来读（重新执行指令）</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="四页面置换算法简略提及">📌 四、页面置换算法（简略提及）</h3>
<p>在缺页中断中，内存满时必须移除某页：</p>
<ul>
<li>FIFO（先进先出）</li>
<li>LRU（最近最少使用）</li>
<li>最佳置换（OPT，理论最优）</li>
<li>Clock（二次机会）</li>
</ul>
<hr>
<h3 id="五缺页中断频率与性能关系">📌 五、缺页中断频率与性能关系</h3>
<table>
<thead>
<tr>
<th>缺页频率</th>
<th>系统状态</th>
</tr>
</thead>
<tbody>
<tr>
<td>偶尔发生</td>
<td>正常、可接受</td>
</tr>
<tr>
<td>高频发生</td>
<td>内存不足，性能下降，可能出现抖动（Thrashing）</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="总结对比速记">✅ 总结对比速记</h2>
<table>
<thead>
<tr>
<th>概念</th>
<th>交换空间（Swap）</th>
<th>缺页中断（Page Fault）</th>
</tr>
</thead>
<tbody>
<tr>
<td>本质</td>
<td>一块磁盘区域</td>
<td>一种中断机制</td>
</tr>
<tr>
<td>作用</td>
<td>扩展虚拟内存</td>
<td>调入缺失页</td>
</tr>
<tr>
<td>是否主动</td>
<td>被动使用</td>
<td>被动触发</td>
</tr>
<tr>
<td>位置</td>
<td>磁盘（Swap区）</td>
<td>CPU → OS</td>
</tr>
<tr>
<td>是否涉及 IO</td>
<td>是（涉及磁盘）</td>
<td>是（加载页面）</td>
</tr>
</tbody>
</table>
<hr>
<h1 id="页面置换算法详解">✅ 页面置换算法详解</h1>
<h2 id="一背景为什么需要页面置换算法">📌
一、背景：为什么需要页面置换算法？</h2>
<p>在虚拟内存系统中，<strong>物理内存容量有限</strong>，当程序访问的页面<strong>不在内存</strong>中，就会发生<strong>缺页中断</strong>。如果内存已满，就需要<strong>置换（替换）一个已有的页面</strong>出来，为新页面腾空间。</p>
<p>所以，<strong>页面置换算法的目标是：</strong></p>
<blockquote>
<p>在内存已满时，尽量选择“不太会再用的页面”进行淘汰，以<strong>减少缺页中断的次数（Page
Fault Rate）</strong>。</p>
</blockquote>
<hr>
<h2 id="二常见页面置换算法对比总览">📌 二、常见页面置换算法对比总览</h2>
<table style="width:100%;">
<colgroup>
<col style="width: 24%">
<col style="width: 6%">
<col style="width: 33%">
<col style="width: 12%">
<col style="width: 10%">
<col style="width: 12%">
</colgroup>
<thead>
<tr>
<th>算法名称</th>
<th>简写</th>
<th>思路</th>
<th>是否可实现</th>
<th>缺页率</th>
<th>实现复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td>最佳置换算法</td>
<td>OPT</td>
<td>淘汰将来最久不使用的页</td>
<td>❌ 理论存在</td>
<td>最低</td>
<td>高</td>
</tr>
<tr>
<td>先进先出算法</td>
<td>FIFO</td>
<td>淘汰最早进入内存的页</td>
<td>✅ 简单实现</td>
<td>容易抖动</td>
<td>低</td>
</tr>
<tr>
<td>最近最久未使用算法</td>
<td>LRU</td>
<td>淘汰最长时间没访问的页</td>
<td>✅ 常用</td>
<td>低</td>
<td>中-高</td>
</tr>
<tr>
<td>时钟算法（近似LRU）</td>
<td>Clock</td>
<td>使用“二次机会”淘汰未访问页</td>
<td>✅ 常用</td>
<td>接近LRU</td>
<td>中</td>
</tr>
<tr>
<td>最不常用算法</td>
<td>LFU</td>
<td>淘汰访问次数最少的页</td>
<td>✅ 偶用</td>
<td>可能失效</td>
<td>高</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="最佳页面置换算法opt">✅ ① 最佳页面置换算法（OPT）</h2>
<h3 id="原理-1">🔧 原理</h3>
<ul>
<li>理论最优：<strong>淘汰“未来最长时间不会使用的页面”</strong>。</li>
<li>设想你能知道程序将来要访问哪些页。</li>
</ul>
<h3 id="类比">🧠 类比</h3>
<blockquote>
<p>就像你知道接下来 1 小时你要读哪几本书，就先把不看的收起来。</p>
</blockquote>
<h3 id="优点-3">✅ 优点</h3>
<ul>
<li>缺页率最低，理论最优。</li>
</ul>
<h3 id="缺点-3">❌ 缺点</h3>
<ul>
<li>无法实现：<strong>操作系统无法预知未来访问情况</strong>。</li>
<li>仅用于衡量其他算法性能的基准（Benchmark）。</li>
</ul>
<hr>
<h2 id="先进先出页面置换算法fifo">✅ ② 先进先出页面置换算法（FIFO）</h2>
<h3 id="原理-2">🔧 原理</h3>
<ul>
<li><strong>淘汰最早进入内存的页面</strong>。</li>
<li>使用队列结构：新页进队尾，淘汰队头页。</li>
</ul>
<h3 id="类比-1">🧠 类比</h3>
<blockquote>
<p>像排队买票，最早排进去的最先被处理。</p>
</blockquote>
<h3 id="优点-4">✅ 优点</h3>
<ul>
<li>实现简单：只需要记录每页的进入时间顺序。</li>
</ul>
<h3 id="缺点-4">❌ 缺点</h3>
<ul>
<li>会出现 <strong>Belady 异常</strong>：页框增加反而缺页率增加。</li>
<li>不考虑页的实际使用频率。</li>
</ul>
<hr>
<h2 id="最近最久未使用算法lru">✅ ③ 最近最久未使用算法（LRU）</h2>
<h3 id="原理-3">🔧 原理</h3>
<ul>
<li><strong>淘汰最近最长时间未被访问的页面</strong>。</li>
<li>假设最近访问过的页面将来可能还会访问。</li>
</ul>
<h3 id="类比-2">🧠 类比</h3>
<blockquote>
<p>像你用微信聊天，常聊的人排前面，不聊的会被滑走。</p>
</blockquote>
<h3 id="优点-5">✅ 优点</h3>
<ul>
<li>接近最优效果，缺页率低。</li>
<li>实际中比较常用。</li>
</ul>
<h3 id="缺点-5">❌ 缺点</h3>
<ul>
<li>实现开销大，需要维护每个页的访问时间（可用链表或硬件支持）。</li>
</ul>
<hr>
<h2 id="时钟页面置换算法clock">✅ ④ 时钟页面置换算法（Clock）</h2>
<h3 id="原理-4">🔧 原理</h3>
<ul>
<li>是 LRU 的一种近似实现。</li>
<li>每个页有一个<strong>访问位（Use Bit）</strong>。</li>
<li>页面按环形队列排列，像时钟指针一样转圈。</li>
<li>当页面被访问时，访问位设为 1。</li>
<li>替换时：
<ul>
<li>如果访问位 = 1：清 0，跳过。</li>
<li>如果访问位 = 0：替换该页。</li>
</ul></li>
</ul>
<h3 id="类比-3">🧠 类比</h3>
<blockquote>
<p>一圈人轮流举手（被访问），没举手的人（未访问）要被请出圈。</p>
</blockquote>
<h3 id="优点-6">✅ 优点</h3>
<ul>
<li>性能较好，<strong>接近 LRU</strong>。</li>
<li>实现简单，开销小。</li>
</ul>
<h3 id="缺点-6">❌ 缺点</h3>
<ul>
<li>不是严格的 LRU，仅为近似。</li>
</ul>
<hr>
<h2 id="最不常用页面置换算法lfu">✅ ⑤ 最不常用页面置换算法（LFU）</h2>
<h3 id="原理-5">🔧 原理</h3>
<ul>
<li><strong>淘汰历史上被访问次数最少的页面</strong>。</li>
<li>统计每页的访问频率。</li>
</ul>
<h3 id="类比-4">🧠 类比</h3>
<blockquote>
<p>像删朋友圈，经常联系的人保留，冷淡的先删。</p>
</blockquote>
<h3 id="优点-7">✅ 优点</h3>
<ul>
<li>适合访问频率长期稳定的应用。</li>
</ul>
<h3 id="缺点-7">❌ 缺点</h3>
<ul>
<li>实现复杂，要记录访问计数。</li>
<li>可能把近期活跃但总访问次数少的页面误删。</li>
</ul>
<hr>
<h2 id="三图示对比类比简图理解">📌 三、图示对比类比（简图理解）</h2>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">内存页框数 = 3，访问序列：A B C A B D A B C D</span><br><span class="line"></span><br><span class="line">OPT：     淘汰未来最久不用的 → 缺页数最少（理想）</span><br><span class="line">FIFO：    淘汰最早进来的     → 缺页多，可能出现Belady异常</span><br><span class="line">LRU：     淘汰最长时间没访问 → 靠谱但实现复杂</span><br><span class="line">Clock：   淘汰使用位为0的页  → 接近LRU，效率高</span><br><span class="line">LFU：     淘汰使用最少的页   → 稳定但容易误伤“短期热点”</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="四总结记忆口诀">✅ 四、总结记忆口诀</h2>
<p>📘 <strong>记忆口诀：</strong></p>
<blockquote>
<p>最优看未来，先进靠时间，最近最久用，时钟转一圈，最少靠频率。</p>
</blockquote>
<table>
<thead>
<tr>
<th>算法</th>
<th>记忆点</th>
</tr>
</thead>
<tbody>
<tr>
<td>OPT</td>
<td>未来不会访问</td>
</tr>
<tr>
<td>FIFO</td>
<td>最早进来</td>
</tr>
<tr>
<td>LRU</td>
<td>最近没用</td>
</tr>
<tr>
<td>Clock</td>
<td>给二次机会</td>
</tr>
<tr>
<td>LFU</td>
<td>最少用的淘汰</td>
</tr>
</tbody>
</table>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.totorocatcat.top/">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A12/">http://totorocatcat.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A12/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8F%90%E9%AB%98/">提高</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%B8%AD%E5%9B%BD%E9%A3%8E%E5%85%83%E7%B4%A0-%E4%BA%91%E9%9B%BE%E8%83%8C%E6%99%AF.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A13/" title="操作系统八股3"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%B8%AD%E5%9B%BD%E9%A3%8E%E5%85%83%E7%B4%A0-%E4%BA%91%E9%9B%BE%E8%83%8C%E6%99%AF.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统八股3</div></div></a></div><div class="next-post pull-right"><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A11/" title="操作系统八股1"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%B8%AD%E5%9B%BD%E9%A3%8E%E5%85%83%E7%B4%A0-%E4%BA%91%E9%9B%BE%E8%83%8C%E6%99%AF.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统八股1</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/02%EF%BC%89/" title="CS61B 课程笔记（Lecture 02）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/v2-2ed7f4c9e1a7a699a3ef300a6f761abe_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-11</div><div class="title">CS61B 课程笔记（Lecture 02）</div></div></a></div><div><a href="/03%EF%BC%89/" title="CS61B 课程笔记（Lecture 03）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/v2-2ed7f4c9e1a7a699a3ef300a6f761abe_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-12</div><div class="title">CS61B 课程笔记（Lecture 03）</div></div></a></div><div><a href="/04%EF%BC%89/" title="CS61B 课程笔记（Lecture 04）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/2749a496aabc7d650b2912e256582e390a0a636b.jpg@1256w_1246h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-13</div><div class="title">CS61B 课程笔记（Lecture 04）</div></div></a></div><div><a href="/05%EF%BC%89/" title="CS61B 课程笔记（Lecture 05）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4ccebbc43a0ca31a719afadee2f86b4902402baf.jpg@1256w_786h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-14</div><div class="title">CS61B 课程笔记（Lecture 05）</div></div></a></div><div><a href="/'Lec2%20Logic%20and%20Proof,%20Sets,%20and%20Function'/" title="Lec2 Logic and Proof, Sets, and Function"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/1fe6130ca86bb9e7e6a37c9187a32c8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="title">Lec2 Logic and Proof, Sets, and Function</div></div></a></div><div><a href="/08%EF%BC%89/" title="CS61B 课程笔记（Lecture 08）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/ef0c9dc1434371965c925677e389b329298252208.png@1256w_1702h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-17</div><div class="title">CS61B 课程笔记（Lecture 08）</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%BE%A0%E5%AE%A2-%E6%AD%A6%E4%BE%A0%E5%9C%BA%E6%99%AF-%E6%B8%B8%E6%88%8F.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description">热爱文学的SCUT软件学院学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">864</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div><a id="card-info-btn" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A12"><span class="toc-text">操作系统八股2</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2thread-context-switch"><span class="toc-text">✅线程上下文切换（Thread
Context Switch）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2context-switch"><span class="toc-text">一、什么是上下文切换（Context
Switch）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-text">二、线程上下文切换的两种情况</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B%E5%B1%9E%E4%BA%8E%E4%B8%8D%E5%90%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">1️⃣
不同进程的线程之间切换（线程属于不同进程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B%E5%86%85%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%BA%BF%E7%A8%8B%E5%B1%9E%E4%BA%8E%E5%90%8C%E4%B8%80%E8%BF%9B%E7%A8%8B"><span class="toc-text">2️⃣
同一进程内的线程切换（线程属于同一进程）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94%E7%BA%BF%E7%A8%8B-vs-%E8%BF%9B%E7%A8%8B-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">三、总结对比：线程 vs 进程
上下文切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E6%97%B6%E6%9C%BA%E7%94%B1%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%86%B3%E5%AE%9A"><span class="toc-text">四、线程切换的时机（由内核线程调度器决定）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF%E7%AE%80%E6%B4%81%E8%A1%A8%E8%BE%BE"><span class="toc-text">五、面试答题模板（简洁表达）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">✅ 线程的三种实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">一、线程的本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%BB%E8%A6%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">二、线程的三种主要实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E7%BA%BF%E7%A8%8Buser-level-thread-ult"><span class="toc-text">1️⃣ 用户态线程（User-Level
Thread, ULT）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-text">✅ 定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-text">✅ 特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">✅ 示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F"><span class="toc-text">✅ 调度方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E6%80%81%E7%BA%BF%E7%A8%8Bkernel-level-thread-klt"><span class="toc-text">2️⃣ 内核态线程（Kernel-Level
Thread, KLT）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-1"><span class="toc-text">✅ 定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-1"><span class="toc-text">✅ 特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">✅ 示例：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%96%B9%E5%BC%8F-1"><span class="toc-text">✅ 调度方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0hybrid-thread-%E6%88%96-mn-%E6%A8%A1%E5%9E%8B"><span class="toc-text">3️⃣ 混合实现（Hybrid Thread 或
M:N 模型）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-2"><span class="toc-text">✅ 定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E7%BB%93%E6%9E%84"><span class="toc-text">✅ 模型结构：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-text">✅ 特点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">✅ 示例：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-text">三、三种线程实现方式对比总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E9%9D%A2%E8%AF%95%E7%AD%94%E9%A2%98%E6%A8%A1%E6%9D%BF%E7%AE%80%E6%B4%81%E8%A1%A8%E8%BE%BE"><span class="toc-text">四、面试答题模板（简洁表达）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%90%8C%E6%AD%A5thread-synchronization"><span class="toc-text">✅ 线程间同步（Thread
Synchronization）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">一、线程同步的目的</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-text">✨目标：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E4%B8%B4%E7%95%8C%E5%8C%BAcritical-section"><span class="toc-text">二、临界区（Critical Section）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-3"><span class="toc-text">✅ 定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-text">✅ 特性：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E5%B8%B8%E8%A7%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-text">三、线程同步的常见实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81mutex-lock"><span class="toc-text">1️⃣ 互斥锁（Mutex Lock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-text">✅ 原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%93%8D%E4%BD%9C"><span class="toc-text">✅ 关键操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-text">✅ 类型：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-text">✅ 示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphore"><span class="toc-text">2️⃣ 信号量（Semaphore）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-4"><span class="toc-text">✅ 定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%80%BCsem"><span class="toc-text">✅ 信号量值（sem）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-text">✅ 两个原子操作：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-4"><span class="toc-text">✅ 示例：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E4%BA%92%E6%96%A5%E9%94%81-vs-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AF%B9%E6%AF%94"><span class="toc-text">四、互斥锁 vs 信号量：对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E8%BF%9B%E9%98%B6%E6%9C%BA%E5%88%B6%E4%BA%86%E8%A7%A3"><span class="toc-text">五、线程同步进阶机制（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E6%80%BB%E7%BB%93%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE"><span class="toc-text">六、总结：线程同步的选择建议</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-text">✅死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81deadlock"><span class="toc-text">✅ 一、什么是死锁（Deadlock）？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%E5%BF%85%E9%A1%BB%E5%90%8C%E6%97%B6%E6%BB%A1%E8%B6%B3"><span class="toc-text">✅
二、死锁产生的四个必要条件（必须同时满足）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%BB%8F%E5%85%B8%E6%AD%BB%E9%94%81%E5%9C%BA%E6%99%AF%E4%B8%BE%E4%BE%8B"><span class="toc-text">✅ 三、经典死锁场景举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%80%BB%E7%BB%93"><span class="toc-text">✅ 四、总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%81%BF%E5%85%8D"><span class="toc-text">死锁的避免</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81deadlock-avoidance"><span class="toc-text">✅ 一、如何避免死锁（Deadlock
Avoidance）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E4%BA%92%E6%96%A5%E6%9D%A1%E4%BB%B6-%E9%80%9A%E5%B8%B8%E4%B8%8D%E8%83%BD%E7%A0%B4%E5%9D%8F"><span class="toc-text">🔹 1. 消除互斥条件
❌（通常不能破坏）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E5%8D%A0%E6%9C%89%E5%B9%B6%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-text">🔹 2. 消除“占有并等待”条件 ✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E4%B8%8D%E5%8F%AF%E5%89%A5%E5%A4%BA%E6%9D%A1%E4%BB%B6"><span class="toc-text">🔹 3. 消除“不可剥夺”条件 ✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E9%99%A4%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%E6%9D%A1%E4%BB%B6"><span class="toc-text">🔹 4. 消除“循环等待”条件 ✅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E6%AD%BB%E9%94%81%E9%81%BF%E5%85%8D%E6%96%B9%E6%B3%95%E5%AF%B9%E7%85%A7%E8%A1%A8"><span class="toc-text">🔄 总结：死锁避免方法对照表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E6%B4%BB%E9%94%81livelock%E4%B8%8E%E9%A5%A5%E9%A5%BFstarvation"><span class="toc-text">✅
二、活锁（Livelock）与饥饿（Starvation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BFstarvation"><span class="toc-text">🔸 饥饿（Starvation）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E9%94%81livelock"><span class="toc-text">🔸 活锁（Livelock）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF-vs-%E6%B4%BB%E9%94%81-%E5%AF%B9%E6%AF%94"><span class="toc-text">🔄 饥饿 vs 活锁 对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%80%BB%E7%BB%93"><span class="toc-text">✅ 三、总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98%E4%B8%8E%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-text">物理内存与虚拟内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98physical-memory"><span class="toc-text">✅ 一、物理内存（Physical
Memory）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-5"><span class="toc-text">📌 定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-3"><span class="toc-text">📌 特点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98virtual-memory"><span class="toc-text">✅ 二、虚拟内存（Virtual Memory）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-6"><span class="toc-text">📌 定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-4"><span class="toc-text">📌 特点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E4%B8%8E%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6"><span class="toc-text">✅ 三、地址转换与页表机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E7%BB%84%E6%88%90%E4%B8%8E%E7%BB%93%E6%9E%84"><span class="toc-text">✅ 四、虚拟内存的组成与结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">✅ 五、虚拟内存的优势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98-vs-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-text">✅ 六、物理内存 vs 虚拟内存
对比总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E5%85%B3%E9%94%AE%E6%9C%AF%E8%AF%AD%E5%9B%9E%E9%A1%BE"><span class="toc-text">✅ 七、关键术语回顾</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="toc-text">内存分段</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5segmentation"><span class="toc-text">✅
一、什么是内存分段（Segmentation）？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-7"><span class="toc-text">📌 定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">📌 核心思想：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80"><span class="toc-text">✅ 二、虚拟地址结构（逻辑地址）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%AE%B5%E8%A1%A8segment-table"><span class="toc-text">✅ 三、段表（Segment Table）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">✅ 四、地址转换过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E8%87%AA%E5%AE%9A%E4%B9%89%E7%A4%BA%E4%BE%8B%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-text">✅ 五、自定义示例：分段地址映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E9%97%AE%E9%A2%98-1"><span class="toc-text">🔍 示例问题 1：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E9%97%AE%E9%A2%98-2"><span class="toc-text">🔍 示例问题 2：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%88%86%E6%AE%B5%E7%9A%84%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-text">✅ 六、分段的优点与缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-text">✅ 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-text">❌ 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">✅ 七、分段与分页的比较</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5"><span class="toc-text">内存分页</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5paging"><span class="toc-text">✅ 一、什么是内存分页（Paging）？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89-8"><span class="toc-text">📌 定义：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-text">✅ 二、分页机制的核心思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E4%B8%8E%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-text">✅ 三、地址结构与转换过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-text">📌 虚拟地址结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B"><span class="toc-text">📌 地址转换流程：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%88%86%E9%A1%B5%E7%A4%BA%E4%BE%8B"><span class="toc-text">✅ 四、分页示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E7%9F%A5"><span class="toc-text">已知：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E9%97%AE%E9%A2%98"><span class="toc-text">🧠 示例问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%A2%98%E6%AD%A5%E9%AA%A4"><span class="toc-text">✍️ 解题步骤：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E5%88%86%E9%A1%B5%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-text">✅ 五、分页系统的性能问题与优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E9%9C%80%E8%A6%81%E4%B8%A4%E6%AC%A1%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE"><span class="toc-text">📌 访问内存需要两次内存访问：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tlbtranslation-lookaside-buffer"><span class="toc-text">✅ TLB（Translation Lookaside
Buffer）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%88%86%E9%A1%B5%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">✅ 六、分页的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-text">✅ 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-text">❌ 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E5%88%86%E9%A1%B5-vs-%E5%88%86%E6%AE%B5-%E5%AF%B9%E6%AF%94"><span class="toc-text">✅ 七、分页 vs 分段 对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-text">多级页表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-text">✅ 一、什么是多级页表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E8%83%8C%E6%99%AF%E5%8D%95%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">✅ 二、背景：单级页表的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3%E9%A1%B5%E8%A1%A8%E5%88%86%E9%A1%B5-%E5%88%86%E5%B1%82%E7%AE%A1%E7%90%86"><span class="toc-text">✅ 三、核心思想：页表分页 →
分层管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E4%BB%A5%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8%E4%B8%BA%E4%BE%8B"><span class="toc-text">📌
多级页表的基本结构（以两级页表为例）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E5%88%92%E5%88%86"><span class="toc-text">📌 虚拟地址划分：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E8%BF%87%E7%A8%8B%E4%B8%A4%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-text">✅ 四、地址转换过程（两级页表）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%86%E5%88%86%E5%9C%B0%E5%9D%80"><span class="toc-text">✍️ 1. 拆分地址：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%A1%A8%E8%BD%AC%E6%8D%A2"><span class="toc-text">✍️ 2. 查表转换：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E4%BC%98%E7%82%B9%E4%B8%8E%E7%BC%BA%E7%82%B9"><span class="toc-text">✅ 五、优点与缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-text">✅ 优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-text">❌ 缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%B8%B8%E8%A7%81%E7%9A%84%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-text">✅ 六、常见的多级页表结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E8%A1%A5%E5%85%85linux-%E5%9B%9B%E7%BA%A7%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84x86_64"><span class="toc-text">✅ 七、补充：Linux
四级页表结构（x86_64）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E6%80%BB%E7%BB%93"><span class="toc-text">✅ 八、总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E8%A1%A8"><span class="toc-text">快表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BF%AB%E8%A1%A8tlbtranslation-lookaside-buffer"><span class="toc-text">✅
什么是快表（TLB：Translation Lookaside Buffer）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AE%9A%E4%B9%89"><span class="toc-text">📌 一、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-text">📌 二、背景知识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89tlb-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%87%8F%E5%B0%91%E8%AE%BF%E9%97%AE%E5%86%85%E5%AD%98%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-text">📌 三、TLB
的作用：减少访问内存的次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E6%94%AF%E6%92%91"><span class="toc-text">📌 四、局部性原理支撑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94tlb-%E5%B7%A5%E4%BD%9C%E7%A4%BA%E6%84%8F%E5%9B%BE"><span class="toc-text">📌 五、TLB 工作示意图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E8%A1%A5%E5%85%85%E6%A6%82%E5%BF%B5"><span class="toc-text">📌 六、补充概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E4%B8%8E%E5%88%86%E6%AE%B5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">✅分页与分段的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E5%88%86%E9%A1%B5-vs-%E5%88%86%E6%AE%B5"><span class="toc-text">📌 补充：分页 vs 分段</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E9%80%9F%E8%AE%B0"><span class="toc-text">✅ 总结速记</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4swap-space"><span class="toc-text">✅ 27、什么是交换空间（Swap
Space）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AE%9A%E4%B9%89-1"><span class="toc-text">📌 一、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-swap"><span class="toc-text">📌 二、为什么需要 Swap？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89swap-%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="toc-text">📌 三、Swap 的位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9Bswap-%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-text">📌 四、Swap 的用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6%E7%AE%80%E8%A6%81"><span class="toc-text">📌 五、工作机制简要</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD%E5%9B%BE%E7%A4%BA%E7%B1%BB%E6%AF%94%E5%9B%BE%E4%B9%A6%E9%A6%86"><span class="toc-text">📌 六、图示类比（图书馆）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83%E4%BC%98%E7%82%B9-%E7%BC%BA%E7%82%B9"><span class="toc-text">📌 七、优点 &amp; 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%ADpage-fault"><span class="toc-text">✅什么是缺页中断（Page Fault）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AE%9A%E4%B9%89-2"><span class="toc-text">📌 一、定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B"><span class="toc-text">📌 二、详细过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%9B%BE%E4%B9%A6%E9%A6%86%E7%B1%BB%E6%AF%94%E8%B6%85%E7%BB%8F%E5%85%B8"><span class="toc-text">📌 三、图书馆类比（超经典🌟）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E7%AE%80%E7%95%A5%E6%8F%90%E5%8F%8A"><span class="toc-text">📌 四、页面置换算法（简略提及）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E9%A2%91%E7%8E%87%E4%B8%8E%E6%80%A7%E8%83%BD%E5%85%B3%E7%B3%BB"><span class="toc-text">📌 五、缺页中断频率与性能关系</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94%E9%80%9F%E8%AE%B0"><span class="toc-text">✅ 总结对比速记</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-text">✅ 页面置换算法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%83%8C%E6%99%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">📌
一、背景：为什么需要页面置换算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%B8%B8%E8%A7%81%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E5%AF%B9%E6%AF%94%E6%80%BB%E8%A7%88"><span class="toc-text">📌 二、常见页面置换算法对比总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95opt"><span class="toc-text">✅ ① 最佳页面置换算法（OPT）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-1"><span class="toc-text">🔧 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%AF%94"><span class="toc-text">🧠 类比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-text">✅ 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-text">❌ 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95fifo"><span class="toc-text">✅ ② 先进先出页面置换算法（FIFO）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-text">🔧 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%AF%94-1"><span class="toc-text">🧠 类比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-4"><span class="toc-text">✅ 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-4"><span class="toc-text">❌ 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E8%BF%91%E6%9C%80%E4%B9%85%E6%9C%AA%E4%BD%BF%E7%94%A8%E7%AE%97%E6%B3%95lru"><span class="toc-text">✅ ③ 最近最久未使用算法（LRU）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-text">🔧 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%AF%94-2"><span class="toc-text">🧠 类比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-5"><span class="toc-text">✅ 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-5"><span class="toc-text">❌ 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95clock"><span class="toc-text">✅ ④ 时钟页面置换算法（Clock）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-text">🔧 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%AF%94-3"><span class="toc-text">🧠 类比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-6"><span class="toc-text">✅ 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-6"><span class="toc-text">❌ 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%B8%8D%E5%B8%B8%E7%94%A8%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95lfu"><span class="toc-text">✅ ⑤ 最不常用页面置换算法（LFU）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-5"><span class="toc-text">🔧 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%AF%94-4"><span class="toc-text">🧠 类比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-7"><span class="toc-text">✅ 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-7"><span class="toc-text">❌ 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%9B%BE%E7%A4%BA%E5%AF%B9%E6%AF%94%E7%B1%BB%E6%AF%94%E7%AE%80%E5%9B%BE%E7%90%86%E8%A7%A3"><span class="toc-text">📌 三、图示对比类比（简图理解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E6%80%BB%E7%BB%93%E8%AE%B0%E5%BF%86%E5%8F%A3%E8%AF%80"><span class="toc-text">✅ 四、总结记忆口诀</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2013%E5%B9%B4408%E7%9C%9F%E9%A2%98%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/" title="2013年408真题操作系统篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%89%91%E5%AE%A2-%E6%B0%B4%E5%A2%A8-%E9%BB%91%E7%99%BD%E9%A3%8E.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2013年408真题操作系统篇"/></a><div class="content"><a class="title" href="/2013%E5%B9%B4408%E7%9C%9F%E9%A2%98%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/" title="2013年408真题操作系统篇">2013年408真题操作系统篇</a><time datetime="2025-05-09T14:19:09.000Z" title="发表于 2025-05-09 22:19:09">2025-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2012%E5%B9%B4408%E7%9C%9F%E9%A2%98%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/" title="2012年408真题操作系统篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%89%91%E5%AE%A2-%E6%B0%B4%E5%A2%A8-%E9%BB%91%E7%99%BD%E9%A3%8E.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2012年408真题操作系统篇"/></a><div class="content"><a class="title" href="/2012%E5%B9%B4408%E7%9C%9F%E9%A2%98%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/" title="2012年408真题操作系统篇">2012年408真题操作系统篇</a><time datetime="2025-05-09T13:11:57.000Z" title="发表于 2025-05-09 21:11:57">2025-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2011%E5%B9%B4408%E7%9C%9F%E9%A2%98%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/" title="2011年408真题操作系统篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91olor%E6%B0%B4%E5%A2%A8-olor%E6%B0%B4%E5%A2%A8%E4%B8%89%E7%8E%84%E8%89%B2.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2011年408真题操作系统篇"/></a><div class="content"><a class="title" href="/2011%E5%B9%B4408%E7%9C%9F%E9%A2%98%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/" title="2011年408真题操作系统篇">2011年408真题操作系统篇</a><time datetime="2025-05-09T12:35:27.000Z" title="发表于 2025-05-09 20:35:27">2025-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2010%E5%B9%B4408%E7%9C%9F%E9%A2%98%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/" title="2010年408真题操作系统篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E6%8F%92%E7%94%BB%E5%B8%85%E5%93%A5-%E9%BB%91%E7%99%BD%E6%B0%B4%E5%A2%A8%E9%A3%8E.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2010年408真题操作系统篇"/></a><div class="content"><a class="title" href="/2010%E5%B9%B4408%E7%9C%9F%E9%A2%98%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/" title="2010年408真题操作系统篇">2010年408真题操作系统篇</a><time datetime="2025-05-09T12:06:31.000Z" title="发表于 2025-05-09 20:06:31">2025-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2009%E5%B9%B4408%E7%9C%9F%E9%A2%98%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/" title="2009年408真题操作系统篇"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E6%8F%92%E7%94%BB%E5%B8%85%E5%93%A5-%E9%BB%91%E7%99%BD%E6%B0%B4%E5%A2%A8%E9%A3%8E.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2009年408真题操作系统篇"/></a><div class="content"><a class="title" href="/2009%E5%B9%B4408%E7%9C%9F%E9%A2%98%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AF%87/" title="2009年408真题操作系统篇">2009年408真题操作系统篇</a><time datetime="2025-05-09T11:15:48.000Z" title="发表于 2025-05-09 19:15:48">2025-05-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HT1PalaKkPaG1UqAXBhJXIu8-gzGzoHsz',
      appKey: 'iT0TnVVAwf9zuZ7NqwclQItY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="1" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;诗兴大发/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;诗兴大发/&quot;);" href="javascript:void(0);" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;诗兴大发/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;诗录/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4b31456c6f0f4489f99177f89e936de7286431045.png@1256w_708h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;诗录/&quot;);" href="javascript:void(0);" alt="">诗录</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;诗录/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;TotoroのPlan/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/51d37eba99d243607ddedfff6e91568f617436609.jpg@1256w_1884h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">TotoroのPlan</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;Markdown格式/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.48/img_482_1920x1080_96_null_normal.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;Markdown格式/&quot;);" href="javascript:void(0);" alt="">Markdown格式</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;Markdown格式/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS61B/&quot;);" href="javascript:void(0);">CS61B</a><span class="categoryBar-list-count">76</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/离散数学/&quot;);" href="javascript:void(0);">离散数学</a><span class="categoryBar-list-count">33</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/期末の旅/&quot;);" href="javascript:void(0);">期末の旅</a><span class="categoryBar-list-count">99</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题计划/&quot;);" href="javascript:void(0);">刷题计划</a><span class="categoryBar-list-count">60</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/区域赛の旅/&quot;);" href="javascript:void(0);">区域赛の旅</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Codeforcesの旅/&quot;);" href="javascript:void(0);">Codeforcesの旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/牛客の旅/&quot;);" href="javascript:void(0);">牛客の旅</a><span class="categoryBar-list-count">65</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACMの旅/&quot;);" href="javascript:void(0);">ACMの旅</a><span class="categoryBar-list-count">42</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构/&quot;);" href="javascript:void(0);">数据结构</a><span class="categoryBar-list-count">47</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/前端の旅/&quot;);" href="javascript:void(0);">前端の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数学建模/&quot;);" href="javascript:void(0);">数学建模</a><span class="categoryBar-list-count">26</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_24.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Atcoderの旅/&quot;);" href="javascript:void(0);">Atcoderの旅</a><span class="categoryBar-list-count">53</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_25.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-の旅/&quot;);" href="javascript:void(0);">C++の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_26.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS70の旅/&quot;);" href="javascript:void(0);">CS70の旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_27.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CSAPPの旅/&quot;);" href="javascript:void(0);">CSAPPの旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_28.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">47</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_29.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程基础/&quot;);" href="javascript:void(0);">编程基础</a><span class="categoryBar-list-count">14</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_30.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JAVAの旅/&quot;);" href="javascript:void(0);">JAVAの旅</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_31.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MIT-6-031-Software-Construction/&quot;);" href="javascript:void(0);">MIT 6.031:Software Construction</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_32.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS-110L/&quot;);" href="javascript:void(0);">CS 110L</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_33.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据库の旅/&quot;);" href="javascript:void(0);">数据库の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_34.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/灵魂の旅/&quot;);" href="javascript:void(0);">灵魂の旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_35.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/个人安排/&quot;);" href="javascript:void(0);">个人安排</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_36.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂项/&quot;);" href="javascript:void(0);">杂项</a><span class="categoryBar-list-count">13</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_37.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文学/&quot;);" href="javascript:void(0);">文学</a><span class="categoryBar-list-count">49</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_38.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/力扣の旅/&quot;);" href="javascript:void(0);">力扣の旅</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_39.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机网络/&quot;);" href="javascript:void(0);">计算机网络</a><span class="categoryBar-list-count">23</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/千里十二行/&quot;);" href="javascript:void(0);">千里十二行</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_41.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/少年游/&quot;);" href="javascript:void(0);">少年游</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_42.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/🗡指offer/&quot;);" href="javascript:void(0);">🗡指offer</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_43.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/操作系统/&quot;);" href="javascript:void(0);">操作系统</a><span class="categoryBar-list-count">31</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法提高课/&quot;);" href="javascript:void(0);">算法提高课</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/汇编の旅/&quot;);" href="javascript:void(0);">汇编の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_45.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-实训/&quot;);" href="javascript:void(0);">C++实训</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_46.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编译原理/&quot;);" href="javascript:void(0);">编译原理</a><span class="categoryBar-list-count">22</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_48.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS知识/&quot;);" href="javascript:void(0);">CS知识</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>