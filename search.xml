<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动态规划的引入</title>
      <link href="/2024/02/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%BC%95%E5%85%A5/"/>
      <url>/2024/02/14/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E5%BC%95%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="动态规划的引入"><a href="#动态规划的引入" class="headerlink" title="动态规划的引入"></a>动态规划的引入</h1><h1 id="USACO1-5-IOI1994-数字三角形-Number-Triangles"><a href="#USACO1-5-IOI1994-数字三角形-Number-Triangles" class="headerlink" title="[USACO1.5] [IOI1994]数字三角形 Number Triangles"></a>[USACO1.5] [IOI1994]数字三角形 Number Triangles</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>观察下面的数字金字塔。</p><p>写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。</p><p><img src="/images/ima95pzs0ne.png"></p><p>在上面的样例中，从 $7 \to 3 \to 8 \to 7 \to 5$ 的路径产生了最大权值。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一个行一个正整数 $r$ ,表示行的数目。</p><p>后面每行为这个数字金字塔特定行包含的整数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>单独的一行,包含那个可能得到的最大的和。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">7</span><br><span class="line">3 8</span><br><span class="line">8 1 0</span><br><span class="line">2 7 4 4</span><br><span class="line">4 5 2 6 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>【数据范围】<br>对于 $100%$ 的数据，$1\le r \le 1000$，所有输入在 $[0,100]$ 范围内。</p><p>题目翻译来自NOCOW。</p><p>USACO Training Section 1.5</p><p>IOI1994 Day1T1</p><p>解释：</p><p>正着推要搜索，显然会陷入超时</p><p>于是我们考虑逆着推导</p><blockquote><p>看样例分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        7 </span><br><span class="line">      3   8 </span><br><span class="line">8   1   0 </span><br><span class="line">  2   7   4   4 </span><br><span class="line">4   5   2   6   5</span><br><span class="line"></span><br><span class="line">看样例我们可以更新倒数第二排，因为一定是从倒数第一排走过来的，因为都是正数，更相信后，就会等于</span><br><span class="line">     7 </span><br><span class="line">      3   8 </span><br><span class="line">8   1   0 </span><br><span class="line">  7   12  10  10 </span><br><span class="line">最后一行就没有用了</span><br><span class="line">依次往上推</span><br><span class="line">最后输出初始值就可以了</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="type">int</span> n;  </span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>][<span class="number">1000</span>];  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;       </span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)  </span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">0</span>;i--)   </span><br><span class="line">&#123;  </span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=i;j++)</span><br><span class="line">a[i][j]+=<span class="built_in">max</span>(a[i+<span class="number">1</span>][j],a[i+<span class="number">1</span>][j+<span class="number">1</span>]); </span><br><span class="line">   </span><br><span class="line">    &#125; </span><br><span class="line">    cout&lt;&lt;a[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">不习惯从<span class="number">0</span>开始看下面</span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n,a[<span class="number">1005</span>][<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) cin&gt;&gt;a[i][j];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++) a[i][j]+=<span class="built_in">max</span>(a[i+<span class="number">1</span>][j],a[i+<span class="number">1</span>][j+<span class="number">1</span>]);</span><br><span class="line">cout&lt;&lt;a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2005-普及组-采药"><a href="#NOIP2005-普及组-采药" class="headerlink" title="[NOIP2005 普及组] 采药"></a>[NOIP2005 普及组] 采药</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是辰辰，你能完成这个任务吗？</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有 $2$ 个整数 $T$（$1 \le T \le 1000$）和 $M$（$1 \le  M \le 100$），用一个空格隔开，$T$ 代表总共能够用来采药的时间，$M$ 代表山洞里的草药的数目。</p><p>接下来的 $M$ 行每行包括两个在 $1$ 到 $100$ 之间（包括 $1$ 和 $100$）的整数，分别表示采摘某株草药的时间和这株草药的价值。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出在规定的时间内可以采到的草药的最大总价值。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">70 3</span><br><span class="line">71 100</span><br><span class="line">69 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p><strong>【数据范围】</strong></p><ul><li>对于 $30%$ 的数据，$M \le 10$；</li><li>对于全部的数据，$M \le 100$。</li></ul><p><strong>【题目来源】</strong></p><p>NOIP 2005 普及组第三题</p><blockquote><h2 id="01背包简介"><a href="#01背包简介" class="headerlink" title="01背包简介"></a>01背包简介</h2><p>01背包问题指有N件物品和一个容量为V的背包，每件物品都有一个价值和一个体积，目的是使用容量为V的背包装价值尽可能大的物品。01背包问题时最典型的动态规划问题之一，掌握01背包问题的动态规划解法很重要。</p></blockquote><p>动态规划递推公式及一维数组实现<br>动态规划解法：定义一个二维数组dp,dp的第一维用于枚举物品数量，第二位用于枚举容量，所以dp[i][j]代表：在前i件物品中选取总容量不超过j的物品能够获得的最大价值。所以当递推结束后，dp[N] [V]就是我们要的答案。有递推公式如下： d p [ i ] [ j ] &#x3D; m a x ( d p [ i − 1 ] [ j ] , d p [ i − 1 ] [ j − w [ i ] ] + v [ i ] ) </p><p>第i件物品只有2中状态：被选或者不被选(正因如此，所以才叫”01”背包)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10000</span>][<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> t[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> v[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=m ; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; t[i] &gt;&gt; v[i];</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j &gt;= t[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j - t[i]] + v[i], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">cout&lt;&lt;dp[m][n];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//压缩为一维要倒着枚举，不然会重复放东西，进阶为完全背包</span></span><br><span class="line">一维代码</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> w[<span class="number">105</span>], val[<span class="number">105</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t,m,res=<span class="number">-1</span>;    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;t,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;w[i],&amp;val[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=t;j&gt;=<span class="number">0</span>;j--) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dp[j]=<span class="built_in">max</span>(dp[j-w[i]]+val[i], dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,dp[t]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP1996-提高组-挖地雷"><a href="#NOIP1996-提高组-挖地雷" class="headerlink" title="[NOIP1996 提高组] 挖地雷"></a>[NOIP1996 提高组] 挖地雷</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个地图上有 $N\ (N \le 20)$ 个地窖，每个地窖中埋有一定数量的地雷。同时，给出地窖之间的连接路径。当地窖及其连接的数据给出之后，某人可以从任一处开始挖地雷，然后可以沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。设计一个挖地雷的方案，使某人能挖到最多的地雷。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>有若干行。</p><p>第 $1$ 行只有一个数字，表示地窖的个数 $N$。</p><p>第 $2$ 行有 $N$ 个数，分别表示每个地窖中的地雷个数。</p><p>第 $3$ 行至第 $N+1$ 行表示地窖之间的连接情况：</p><p>第 $3$ 行有 $n-1$ 个数（$0$ 或 $1$），表示第一个地窖至第 $2$ 个、第 $3$ 个 $\dots$ 第 $n$ 个地窖有否路径连接。如第 $3$ 行为 $11000\cdots 0$，则表示第 $1$ 个地窖至第 $2$ 个地窖有路径，至第 $3$ 个地窖有路径，至第 $4$ 个地窖、第 $5$ 个 $\dots$ 第 $n$ 个地窖没有路径。</p><p>第 $4$ 行有 $n-2$ 个数，表示第二个地窖至第 $3$ 个、第 $4$ 个 $\dots$ 第 $n$ 个地窖有否路径连接。</p><p>……</p><p>第 $n+1$ 行有 $1$ 个数，表示第 $n-1$ 个地窖至第 $n$ 个地窖有否路径连接。（为 $0$ 表示没有路径，为 $1$ 表示有路径）。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行表示挖得最多地雷时的挖地雷的顺序，各地窖序号间以一个空格分隔，不得有多余的空格。</p><p>第二行只有一个数，表示能挖到的最多地雷数。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">10 8 4 7 6</span><br><span class="line">1 1 1 0</span><br><span class="line">0 0 0</span><br><span class="line">1 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 3 4 5</span><br><span class="line">27</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p><strong>【题目来源】</strong></p><p>NOIP 1996 提高组第三题</p><blockquote><p>读完题没给我一种dp的感觉，反而是搜索，那就搜索罢</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">bool</span> f[<span class="number">100</span>][<span class="number">100</span>]; </span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">10000</span>];</span><br><span class="line"><span class="type">int</span> path[<span class="number">111000</span>];</span><br><span class="line"><span class="type">int</span> ans[<span class="number">100000</span>];</span><br><span class="line"><span class="type">int</span> cnt;</span><br><span class="line"><span class="type">int</span> cmax;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (f[x][i]&amp;&amp;!b[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> stp, <span class="type">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(x))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cmax&lt;sum)</span><br><span class="line">&#123;</span><br><span class="line">cmax = sum;</span><br><span class="line">cnt = stp;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=stp ; i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i] = path[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//更新答案</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (f[x][i]&amp;&amp;!b[i])</span><br><span class="line">&#123;</span><br><span class="line">b[i] = <span class="number">1</span>;</span><br><span class="line">path[stp + <span class="number">1</span>] = i;</span><br><span class="line"><span class="built_in">dfs</span>(i, stp + <span class="number">1</span>,  sum + a[i]);</span><br><span class="line">b[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//深搜过程</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;n ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt;=n ; j++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; f[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//输入</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">b[i] = <span class="number">1</span>;</span><br><span class="line">path[<span class="number">1</span>] = i;</span><br><span class="line"><span class="comment">//一个是记录遇见走过</span></span><br><span class="line"><span class="comment">//一个是记录路径</span></span><br><span class="line"><span class="built_in">dfs</span>(i, <span class="number">1</span>, a[i]);</span><br><span class="line">b[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//恢复现场1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=cnt ; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ans[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; cmax;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SHOI2002-滑雪"><a href="#SHOI2002-滑雪" class="headerlink" title="[SHOI2002] 滑雪"></a>[SHOI2002] 滑雪</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>Michael 喜欢滑雪。这并不奇怪，因为滑雪的确很刺激。可是为了获得速度，滑的区域必须向下倾斜，而且当你滑到坡底，你不得不再次走上坡或者等待升降机来载你。Michael 想知道在一个区域中最长的滑坡。区域由一个二维数组给出。数组的每个数字代表点的高度。下面是一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1   2   3   4   5</span><br><span class="line">16  17  18  19  6</span><br><span class="line">15  24  25  20  7</span><br><span class="line">14  23  22  21  8</span><br><span class="line">13  12  11  10  9</span><br></pre></td></tr></table></figure><p>一个人可以从某个点滑向上下左右相邻四个点之一，当且仅当高度会减小。在上面的例子中，一条可行的滑坡为 $24-17-16-1$（从 $24$ 开始，在 $1$ 结束）。当然    $25$－$24$－$23$－$\ldots$－$3$－$2$－$1$ 更长。事实上，这是最长的一条。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行为表示区域的二维数组的行数 $R$ 和列数 $C$。下面是 $R$ 行，每行有 $C$ 个数，代表高度(两个数字之间用 $1$ 个空格间隔)。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出区域中最长滑坡的长度。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">16 17 18 19 6</span><br><span class="line">15 24 25 20 7</span><br><span class="line">14 23 22 21 8</span><br><span class="line">13 12 11 10 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>对于 $100%$ 的数据，$1\leq R,C\leq 100$。</p><p>还是搜索的感觉（）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span> &#125;;</span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>] = &#123; <span class="number">1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line"><span class="type">int</span> n, m, a[<span class="number">201</span>][<span class="number">201</span>], s[<span class="number">201</span>][<span class="number">201</span>], ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s[x][y])<span class="keyword">return</span> s[x][y];</span><br><span class="line">    s[x][y] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> xx = dx[i] + x;</span><br><span class="line">        <span class="type">int</span> yy = dy[i] + y;<span class="comment">//四个方向</span></span><br><span class="line">        <span class="keyword">if</span> (xx &gt; <span class="number">0</span> &amp;&amp; yy &gt; <span class="number">0</span> &amp;&amp; xx &lt;= n &amp;&amp; yy &lt;= m &amp;&amp; a[x][y] &gt; a[xx][yy])</span><br><span class="line">        <span class="comment">//判断这个方向是否在地图范围内</span></span><br><span class="line">        <span class="comment">//判断这个点是否能滑到</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">dfs</span>(xx, yy);</span><br><span class="line">            s[x][y] = <span class="built_in">max</span>(s[x][y], s[xx][yy] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s[x][y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">dfs</span>(i, j));</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大食物链计数"><a href="#最大食物链计数" class="headerlink" title="最大食物链计数"></a>最大食物链计数</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个食物网，你要求出这个食物网中最大食物链的数量。</p><p>（这里的“最大食物链”，指的是<strong>生物学意义上的食物链</strong>，即<strong>最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者</strong>。）</p><p>Delia 非常急，所以你只有 $1$ 秒的时间。</p><p>由于这个结果可能过大，你只需要输出总数模上 $80112002$ 的结果。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，两个正整数 $n、m$，表示生物种类 $n$ 和吃与被吃的关系数 $m$。</p><p>接下来 $m$ 行，每行两个正整数，表示被吃的生物A和吃A的生物B。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，为最大食物链数量模上 $80112002$ 的结果。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">5 7</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">3 5</span><br><span class="line">2 5</span><br><span class="line">4 5</span><br><span class="line">3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>各测试点满足以下约定：</p><p> <img src="/images/12011.png"> </p><p>【补充说明】</p><p>数据中不会出现环，满足生物学的要求。（感谢 @AKEE ）</p><p>拓补排序+dp</p><p>dp用来计算食物链的条数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,ru[<span class="number">5005</span>],chu[<span class="number">5005</span>],a,b,f[<span class="number">5005</span>],ans;</span><br><span class="line"><span class="type">int</span> mp[<span class="number">5005</span>][<span class="number">5005</span>];</span><br><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">mp[a][b]=<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//b吃a</span></span><br><span class="line">chu[a]++;</span><br><span class="line">ru[b]++;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    最佳生产者 的入度一定为 0，而最佳消费者的出度也为 0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(ru[i]==<span class="number">0</span>) &#123;</span><br><span class="line">f[i]=<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//食物链起始，初始化为1</span></span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line"><span class="type">int</span> a=q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123;</span><br><span class="line"><span class="keyword">if</span>(mp[a][k]==<span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">f[k]+=f[a];</span><br><span class="line">f[k]%=<span class="number">80112002</span>;</span><br><span class="line">ru[k]--;</span><br><span class="line"><span class="keyword">if</span>(ru[k]==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line"><span class="keyword">if</span>(chu[k]==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//代表来到了食物链的顶端了</span></span><br><span class="line">ans+=f[k];</span><br><span class="line">ans%=<span class="number">80112002</span>;</span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">push</span>(k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个长度为 $n$ 的序列 $a$，选出其中连续且非空的一段使得这段和最大。</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个整数，表示序列的长度 $n$。</p><p>第二行有 $n$ 个整数，第 $i$ 个整数表示序列的第 $i$ 个数字 $a_i$。</p><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数表示答案。</p><h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2 -4 3 -1 2 -4 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><h4 id="样例-1-解释"><a href="#样例-1-解释" class="headerlink" title="样例 1 解释"></a>样例 1 解释</h4><p>选取 $[3, 5]$ 子段 ${3, -1, 2}$，其和为 $4$。</p><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul><li>对于 $40%$ 的数据，保证 $n \leq 2 \times 10^3$。</li><li>对于 $100%$ 的数据，保证 $1 \leq n \leq 2 \times 10^5$，$-10^4 \leq a_i \leq 10^4$。</li></ul><p>这个给我一种贪心的感觉（）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, n) for (int i = a; i &lt;= n; i++)</span></span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> f=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">-999999999</span>;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a;</span><br><span class="line">f=<span class="built_in">max</span>(f+a,a);</span><br><span class="line"><span class="comment">//如果加上比这个值本身还小，加他干什么呢</span></span><br><span class="line">ans=<span class="built_in">max</span>(f,ans);</span><br><span class="line"><span class="comment">//维护作用</span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-倍经验日"><a href="#5-倍经验日" class="headerlink" title="5 倍经验日"></a>5 倍经验日</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>现在乐斗有活动了！每打一个人可以获得 5 倍经验！absi2011 却无奈的看着那一些比他等级高的好友，想着能否把他们干掉。干掉能拿不少经验的。</p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在 absi2011 拿出了 $x$ 个迷你装药物（嗑药打人可耻…），准备开始与那些人打了。</p><p>由于迷你装药物每个只能用一次，所以 absi2011 要谨慎的使用这些药。悲剧的是，用药量没达到最少打败该人所需的属性药药量，则打这个人必输。例如他用 $2$ 个药去打别人，别人却表明 $3$ 个药才能打过，那么相当于你输了并且这两个属性药浪费了。</p><p>现在有 $n$ 个好友，给定失败时可获得的经验、胜利时可获得的经验，打败他至少需要的药量。</p><p>要求求出最大经验 $s$，输出 $5s$。</p><h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个数，$n$ 和 $x$。</p><p>后面 $n$ 行每行三个数，分别表示失败时获得的经验 $\mathit{lose}_i$，胜利时获得的经验 $\mathit{win}_i$ 和打过要至少使用的药数量 $\mathit{use}_i$。</p><h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，最多获得的经验的五倍。</p><h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 8</span><br><span class="line">21 52 1</span><br><span class="line">21 70 5</span><br><span class="line">21 48 2</span><br><span class="line">14 38 3</span><br><span class="line">14 36 1</span><br><span class="line">14 36 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1060</span><br></pre></td></tr></table></figure><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p><strong>【Hint】</strong></p><p>五倍经验活动的时候，absi2011 总是吃体力药水而不是这种属性药。</p><p><strong>【数据范围】</strong></p><ul><li>对于 $10%$ 的数据，保证 $x&#x3D;0$。</li><li>对于 $30%$ 的数据，保证 $0\le n\le 10$，$0\le x\le 20$。</li><li>对于 $60%$ 的数据，保证 $0\le n,x\le 100$， $10&lt;lose_i,win_i\le 100$，$0\le use_i\le 5$。</li><li>对于 $100%$ 的数据，保证 $0\le n,x\le 10^3$，$0&lt;lose_i\le win_i\le 10^6$，$0\le use_i\le 10^3$。</li></ul><p><strong>【题目来源】</strong></p><p>fight.pet.qq.com</p><p>absi2011 授权题目</p><blockquote><p>隐藏的小贪心</p><p>打不过，我用药还打不过，我用干嘛？</p><p>所以说，打得过的可以用药也可以并不用药</p><p>但打不过的一定不用药</p><p>这样分析就行</p><p>和01背包也是相差无几</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, x;</span><br><span class="line"><span class="type">int</span> f[<span class="number">100000</span>];</span><br><span class="line"><span class="type">int</span> w[<span class="number">100000</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1000</span>][<span class="number">111</span>];</span><br><span class="line"><span class="type">int</span> y[<span class="number">10000</span>];</span><br><span class="line"><span class="comment">//表示能够打败第i人所剩下j药剂时候的经验值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; x;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; f[i] &gt;&gt; w[i] &gt;&gt; y[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = x; j &gt;=<span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (j&gt;=y[i])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j - y[i]] + w[i], dp[i - <span class="number">1</span>][j] + f[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dp[i][j] = dp[i - <span class="number">1</span>][j] + f[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; dp[n][x]*<span class="number">5ll</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2002-普及组-过河卒"><a href="#NOIP2002-普及组-过河卒" class="headerlink" title="[NOIP2002 普及组] 过河卒"></a>[NOIP2002 普及组] 过河卒</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>棋盘上 $A$ 点有一个过河卒，需要走到目标 $B$ 点。卒行走的规则：可以向下、或者向右。同时在棋盘上 $C$ 点有一个对方的马，该马所在的点和所有跳跃一步可达的点称为对方马的控制点。因此称之为“马拦过河卒”。</p><p>棋盘用坐标表示，$A$ 点 $(0, 0)$、$B$ 点 $(n, m)$，同样马的位置坐标是需要给出的。</p><p><img src="/images/ipmwl52i-1707886395863-5.png"></p><p>现在要求你计算出卒从 $A$ 点能够到达 $B$ 点的路径的条数，假设马的位置是固定不动的，并不是卒走一步马走一步。</p><h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行四个正整数，分别表示 $B$ 点坐标和马的坐标。</p><h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示所有的路径条数。</p><h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 6 3 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>对于 $100 %$ 的数据，$1 \le n, m \le 20$，$0 \le$ 马的坐标 $\le 20$。</p><p><strong>【题目来源】</strong></p><p>NOIP 2002 普及组第四题</p><blockquote><p>一道对于几个月前的我焦头烂额，彻夜难眠的水题（）</p><p>实际上只需要进行控制点的跳过，然后进行递推就可以了</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 22</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[N][N];</span><br><span class="line"><span class="type">int</span> crt[N][N];</span><br><span class="line"><span class="type">int</span> d[<span class="number">9</span>][<span class="number">2</span>] = &#123; &#123;<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">1</span>&#125;,&#123;<span class="number">2</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">-2</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">2</span>&#125; &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m, hx, hy;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; hx &gt;&gt; hy;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> tempx = hx +d[i][<span class="number">0</span>];</span><br><span class="line"><span class="type">int</span> tempy = hy + d[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (tempx&gt;=<span class="number">0</span>&amp;&amp;tempx&lt;=n&amp;&amp;tempy&gt;=<span class="number">0</span>&amp;&amp;tempy&lt;=m)</span><br><span class="line">&#123;</span><br><span class="line">crt[tempx][tempy] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//控制点，用来跳过的</span></span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> - crt[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="comment">//由于这是初始点，还是特判一下，方便后面递推</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;=m ; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (crt[i][j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//控制点就跳过</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j] += a[i - <span class="number">1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i][j] += a[i][j - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">            <span class="comment">//避免出现数组越界</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; a[n][m];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2001-普及组-装箱问题"><a href="#NOIP2001-普及组-装箱问题" class="headerlink" title="[NOIP2001 普及组] 装箱问题"></a>[NOIP2001 普及组] 装箱问题</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个箱子容量为 $V$，同时有 $n$ 个物品，每个物品有一个体积。</p><p>现在从 $n$ 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。</p><h2 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行共一个整数 $V$，表示箱子容量。</p><p>第二行共一个整数 $n$，表示物品总数。</p><p>接下来 $n$ 行，每行有一个正整数，表示第 $i$ 个物品的体积。</p><h2 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h2><ul><li>共一行一个整数，表示箱子最小剩余空间。</li></ul><h2 id="样例-1-8"><a href="#样例-1-8" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-8"><a href="#样例输入-1-8" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">24</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">3</span><br><span class="line">12</span><br><span class="line">7</span><br><span class="line">9</span><br><span class="line">7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-8"><a href="#样例输出-1-8" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h2><p>对于 $100%$ 数据，满足 $0&lt;n \le 30$，$1 \le V \le 20000$。</p><p><strong>【题目来源】</strong></p><p>NOIP 2001 普及组第四题</p><blockquote><p>01背包裸题</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> dp[<span class="number">100000000</span>];</span><br><span class="line"><span class="type">int</span> a[<span class="number">100000000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> v, n;</span><br><span class="line">cin &gt;&gt; v &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> j = v;  j &gt;=<span class="number">0</span>;  j--)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j&gt;=a[i])</span><br><span class="line">&#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j - <span class="number">1</span>], dp[j - a[i]] + a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; v - dp[v];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="疯狂的采药"><a href="#疯狂的采药" class="headerlink" title="疯狂的采药"></a>疯狂的采药</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>此题为纪念 LiYuxiang 而生。</p><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”</p><p>如果你是 LiYuxiang，你能完成这个任务吗？</p><p>此题和原题的不同点：</p><p>$1$. 每种草药可以无限制地疯狂采摘。</p><p>$2$. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！</p><h2 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入第一行有两个整数，分别代表总共能够用来采药的时间 $t$ 和代表山洞里的草药的数目 $m$。</p><p>第 $2$ 到第 $(m + 1)$ 行，每行两个整数，第 $(i + 1)$ 行的整数 $a_i, b_i$ 分别表示采摘第 $i$ 种草药的时间和该草药的价值。</p><h2 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。</p><h2 id="样例-1-9"><a href="#样例-1-9" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-9"><a href="#样例输入-1-9" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">70 3</span><br><span class="line">71 100</span><br><span class="line">69 1</span><br><span class="line">1 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-9"><a href="#样例输出-1-9" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">140</span><br></pre></td></tr></table></figure><h2 id="提示-9"><a href="#提示-9" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul><li>对于 $30%$ 的数据，保证 $m \le 10^3$ 。</li><li>对于 $100%$ 的数据，保证 $1 \leq m \le 10^4$，$1 \leq t \leq 10^7$，且 $1 \leq m \times t \leq 10^7$，$1 \leq a_i, b_i \leq 10^4$。</li></ul><blockquote><p>完全背包，因此可以进行采药的正推版本</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//P1616 疯狂的采药</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[<span class="number">10000000</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> b[<span class="number">10000000</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dp[<span class="number">100000000</span>];</span><br><span class="line"><span class="comment">//表示采摘第i住草药花费的j时间有的价值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> t, m;</span><br><span class="line">cin &gt;&gt; t &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=m; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=m ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = a[i]; j &lt;=t; j++)</span><br><span class="line">&#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - a[i]] + b[i]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; dp[t]*<span class="number">1ll</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小A点菜"><a href="#小A点菜" class="headerlink" title="小A点菜"></a>小A点菜</h1><h2 id="题目背景-3"><a href="#题目背景-3" class="headerlink" title="题目背景"></a>题目背景</h2><p>uim 神犇拿到了 uoi 的 ra（镭牌）后，立刻拉着基友小 A 到了一家……餐馆，很低端的那种。</p><p>uim 指着墙上的价目表（太低级了没有菜单），说：“随便点”。</p><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>不过 uim 由于买了一些书，口袋里只剩 $M$ 元 $(M \le 10000)$。</p><p>餐馆虽低端，但是菜品种类不少，有 $N$ 种 $(N \le 100)$，第 $i$ 种卖 $a_i$ 元 $(a_i \le 1000)$。由于是很低端的餐馆，所以每种菜只有一份。</p><p>小 A 奉行“不把钱吃光不罢休”，所以他点单一定刚好把 uim 身上所有钱花完。他想知道有多少种点菜方法。</p><p>由于小 A 肚子太饿，所以最多只能等待 $1$ 秒。</p><h2 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是两个数字，表示 $N$ 和 $M$。</p><p>第二行起 $N$ 个正数 $a_i$（可以有相同的数字，每个数字均在 $1000$ 以内）。</p><h2 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个正整数，表示点菜方案数，保证答案的范围在 int 之内。</p><h2 id="样例-1-10"><a href="#样例-1-10" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-10"><a href="#样例输入-1-10" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 4</span><br><span class="line">1 1 2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-10"><a href="#样例输出-1-10" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-10"><a href="#提示-10" class="headerlink" title="提示"></a>提示</h2><p>2020.8.29，增添一组 hack 数据 by @yummy</p><blockquote><p>方案数可以考虑dp</p></blockquote><blockquote><p>（1）if(j&#x3D;&#x3D;第i道菜的价格)f[i] [j]&#x3D;f[i-1] [j]+1;</p><p>（2）if(j&gt;第i道菜的价格) f[i] [j]&#x3D;f[i-1] [j]+f[i-1] [j-第i道菜的价格];</p><p>（3）if(j&lt;第i道菜的价格) f[i] [j]&#x3D;f[i-1] [j];</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1010</span>], f[<span class="number">1010</span>][<span class="number">100010</span>] ;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == a[i])f[i][j] = f[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (j &gt; a[i]) f[i][j] = f[i - <span class="number">1</span>][j] + f[i - <span class="number">1</span>][j - a[i]];</span><br><span class="line">            <span class="keyword">if</span> (j &lt; a[i]) f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    cout&lt;&lt; f[n][m];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="NOIP2012-普及组-摆花"><a href="#NOIP2012-普及组-摆花" class="headerlink" title="[NOIP2012 普及组] 摆花"></a>[NOIP2012 普及组] 摆花</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>小明的花店新开张，为了吸引顾客，他想在花店的门口摆上一排花，共 $m$ 盆。通过调查顾客的喜好，小明列出了顾客最喜欢的 $n$ 种花，从 $1$ 到 $n$ 标号。为了在门口展出更多种花，规定第 $i$ 种花不能超过 $a_i$ 盆，摆花时同一种花放在一起，且不同种类的花需按标号的从小到大的顺序依次摆列。</p><p>试编程计算，一共有多少种不同的摆花方案。</p><h2 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含两个正整数 $n$ 和 $m$，中间用一个空格隔开。</p><p>第二行有 $n$ 个整数，每两个整数之间用一个空格隔开，依次表示 $a_1,a_2, \cdots ,a_n$。</p><h2 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示有多少种方案。注意：因为方案数可能很多，请输出方案数对 $10^6+7$ 取模的结果。</p><h2 id="样例-1-11"><a href="#样例-1-11" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-11"><a href="#样例输入-1-11" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 4</span><br><span class="line">3 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-11"><a href="#样例输出-1-11" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-11"><a href="#提示-11" class="headerlink" title="提示"></a>提示</h2><p>【数据范围】</p><p>对于 $20%$ 数据，有 $0&lt;n \le 8,0&lt;m \le 8,0 \le a_i \le 8$。</p><p>对于 $50%$ 数据，有 $0&lt;n \le 20,0&lt;m \le 20,0 \le a_i \le 20$。</p><p>对于 $100%$ 数据，有 $0&lt;n \le 100,0&lt;m \le 100,0 \le a_i \le 100$。</p><p>NOIP 2012 普及组 第三题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100000</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">10000000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = m; j&gt;=<span class="number">0</span>  ; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k =<span class="number">1</span> ; k &lt;=<span class="built_in">min</span>(a[i],j) ; k++)</span><br><span class="line">&#123;</span><br><span class="line">dp[j] = (dp[j] + dp[j - k]) % <span class="number">1000007</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//dp[i][j]的含义究竟是什么呢，就是摆第i种花的时候所能摆出多少盆花</span></span><br><span class="line"><span class="comment">//dp[i][j]可以从什么推导过来呢，假如我们这盆花不摆出来就是原样</span></span><br><span class="line"><span class="comment">//如果我们要摆我们就要摆多少盆呢，那我们是不是需要来个循环，枚举他的盆数，由于是方案我们要相加</span></span><br><span class="line"><span class="comment">//这是二维dp</span></span><br><span class="line">cout &lt;&lt; dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TJOI2007-线段"><a href="#TJOI2007-线段" class="headerlink" title="[TJOI2007] 线段"></a>[TJOI2007] 线段</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个 $n \times n$ 的平面上，在每一行中有一条线段，第 $i$ 行的线段的左端点是$(i, L_{i})$，右端点是$(i, R_{i})$。</p><p>你从 $(1,1)$ 点出发，要求沿途走过所有的线段，最终到达 $(n,n)$ 点，且所走的路程长度要尽量短。</p><p>更具体一些说，你在任何时候只能选择向下走一步（行数增加 $1$）、向左走一步（列数减少 $1$）或是向右走一步（列数增加 $1$）。当然，由于你不能向上行走，因此在从任何一行向下走到另一行的时候，你必须保证已经走完本行的那条线段。</p><h2 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有一个整数 $n$。</p><p>以下 $n$ 行，在第 $i$ 行（总第 $(i+1)$ 行）的两个整数表示 $L_i$ 和 $R_i$。</p><h2 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅包含一个整数，你选择的最短路程的长度。</p><h2 id="样例-1-12"><a href="#样例-1-12" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-12"><a href="#样例输入-1-12" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">2 6</span><br><span class="line">3 4</span><br><span class="line">1 3</span><br><span class="line">1 2</span><br><span class="line">3 6</span><br><span class="line">4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-12"><a href="#样例输出-1-12" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24</span><br></pre></td></tr></table></figure><h2 id="提示-12"><a href="#提示-12" class="headerlink" title="提示"></a>提示</h2><p>我们选择的路线是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1, 1) (1, 6)</span><br><span class="line">(2, 6) (2, 3)</span><br><span class="line">(3, 3) (3, 1)</span><br><span class="line">(4, 1) (4, 2)</span><br><span class="line">(5, 2) (5, 6)</span><br><span class="line">(6, 6) (6, 4) (6, 6)</span><br></pre></td></tr></table></figure><p>不难计算得到，路程的总长度是 $24$。 </p><p>对于 $100%$ 的数据中，$n \le 2 \times 10^4$，$1 \le L_i \le R_i \le n$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> l[<span class="number">600000</span>];</span><br><span class="line"><span class="type">int</span> r[<span class="number">60000</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">60000</span>][<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; l[i] &gt;&gt; r[i];</span><br><span class="line">&#125;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">1</span>] = r[<span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">f[<span class="number">1</span>][<span class="number">0</span>] = r[<span class="number">1</span>] - <span class="number">1</span> + r[<span class="number">1</span>] - l[<span class="number">1</span>];</span><br><span class="line"><span class="comment">//由于必须走完一整条线段</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">f[i][<span class="number">1</span>] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][<span class="number">0</span>] + r[i] - l[i] + <span class="built_in">abs</span>(l[i] - l[i - <span class="number">1</span>])+<span class="number">1</span>, f[i - <span class="number">1</span>][<span class="number">1</span>] + r[i] - l[i] + <span class="built_in">abs</span>(r[i - <span class="number">1</span>] - l[i])+<span class="number">1</span>);</span><br><span class="line">f[i][<span class="number">0</span>] = <span class="built_in">min</span>(f[i - <span class="number">1</span>][<span class="number">0</span>] + r[i] - l[i] + <span class="built_in">abs</span>(r[i] - l[i - <span class="number">1</span>])+<span class="number">1</span>, f[i - <span class="number">1</span>][<span class="number">1</span>] + r[i] - l[i] + <span class="built_in">abs</span>(r[i - <span class="number">1</span>] - r[i])+<span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="built_in">min</span>(f[n][<span class="number">1</span>]+n-r[n], f[n][<span class="number">0</span>]+n-l[n]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f[i][<span class="number">0</span>]表示走完第i行且停在第i行的左端点最少用的步数</span><br><span class="line"></span><br><span class="line">f[i][<span class="number">1</span>]同理，停在右端点的最少步数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="NOIP2006-提高组-金明的预算方案"><a href="#NOIP2006-提高组-金明的预算方案" class="headerlink" title="[NOIP2006 提高组] 金明的预算方案"></a>[NOIP2006 提高组] 金明的预算方案</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间金明自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $n$ 元钱就行”。今天一早，金明就开始做预算了，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：</p><table><thead><tr><th align="center">主件</th><th align="center">附件</th></tr></thead><tbody><tr><td align="center">电脑</td><td align="center">打印机，扫描仪</td></tr><tr><td align="center">书柜</td><td align="center">图书</td></tr><tr><td align="center">书桌</td><td align="center">台灯，文具</td></tr><tr><td align="center">工作椅</td><td align="center">无</td></tr></tbody></table><p>如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 $0$ 个、$1$ 个或 $2$ 个附件。每个附件对应一个主件，附件不再有从属于自己的附件。金明想买的东西很多，肯定会超过妈妈限定的 $n$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1 \sim 5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是 $10$ 元的整数倍）。他希望在不超过 $n$ 元的前提下，使每件物品的价格与重要度的乘积的总和最大。</p><p>设第 $j$ 件物品的价格为 $v_j$，重要度为$w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,\dots,j_k$，则所求的总和为：</p><p>$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2}+ \dots +v_{j_k} \times w_{j_k}$。</p><p>请你帮助金明设计一个满足要求的购物单。</p><h2 id="输入格式-13"><a href="#输入格式-13" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个整数，分别表示总钱数 $n$ 和希望购买的物品个数 $m$。</p><p>第 $2$ 到第 $(m + 1)$ 行，每行三个整数，第 $(i + 1)$ 行的整数 $v_i$，$p_i$，$q_i$ 分别表示第 $i$ 件物品的价格、重要度以及它对应的的主件。如果 $q_i&#x3D;0$，表示该物品本身是主件。</p><h2 id="输出格式-13"><a href="#输出格式-13" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数表示答案。</p><h2 id="样例-1-13"><a href="#样例-1-13" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-13"><a href="#样例输入-1-13" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1000 5</span><br><span class="line">800 2 0</span><br><span class="line">400 5 1</span><br><span class="line">300 5 1</span><br><span class="line">400 3 0</span><br><span class="line">500 2 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-13"><a href="#样例输出-1-13" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2200</span><br></pre></td></tr></table></figure><h2 id="提示-13"><a href="#提示-13" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定-2"><a href="#数据规模与约定-2" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于全部的测试点，保证 $1 \leq n \leq 3.2 \times 10^4$，$1 \leq m \leq 60$，$0 \leq v_i \leq 10^4$，$1 \leq p_i \leq 5$，$0 \leq q_i \leq m$，答案不超过 $2 \times 10^5$。</p><p>NOIP 2006 提高组 第二题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> v, p, q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">32005</span>;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> c[N];</span><br><span class="line"><span class="type">int</span> _w[N][<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> _c[N][<span class="number">6</span>];</span><br><span class="line"><span class="type">int</span> dp[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=m ; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; v &gt;&gt; p &gt;&gt; q;</span><br><span class="line"><span class="keyword">if</span> (!q)</span><br><span class="line">&#123;</span><br><span class="line">w[i] = v;</span><br><span class="line">c[i] = v * p;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">_w[q][<span class="number">0</span>]++;</span><br><span class="line">            <span class="comment">//记录个数</span></span><br><span class="line">_w[q][_w[q][<span class="number">0</span>]] = v;</span><br><span class="line">_c[q][_w[q][<span class="number">0</span>]] = v * p;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=m ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;=w[i]; j--)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            这个题的决策是五个，分别是：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1.不选，然后去考虑下一个</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2.选且只选这个主件</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">3.选这个主件，并且选附件1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">4.选这个主件，并且选附件2</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">5.选这个主件，并且选附件1和附件2.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + c[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (j&gt;=w[i]+_w[i][<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i] - _w[i][<span class="number">1</span>]]+ c[i] + _c[i][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j&gt;=w[i]+_w[i][<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i] - _w[i][<span class="number">2</span>]] + c[i] + _c[i][<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (j&gt;=w[i]+_w[i][<span class="number">1</span>]+_w[i][<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i] - _w[i][<span class="number">1</span>] - _w[i][<span class="number">2</span>]] + c[i] + _c[i][<span class="number">1</span>] + _c[i][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; dp[n]&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kkksc03考前临时抱佛脚"><a href="#kkksc03考前临时抱佛脚" class="headerlink" title="kkksc03考前临时抱佛脚"></a>kkksc03考前临时抱佛脚</h1><h2 id="题目背景-4"><a href="#题目背景-4" class="headerlink" title="题目背景"></a>题目背景</h2><p>kkksc03 的大学生活非常的颓废，平时根本不学习。但是，临近期末考试，他必须要开始抱佛脚，以求不挂科。</p><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>这次期末考试，kkksc03 需要考 $4$ 科。因此要开始刷习题集，每科都有一个习题集，分别有 $s_1,s_2,s_3,s_4$ 道题目，完成每道题目需要一些时间，可能不等（$A_1,A_2,\ldots,A_{s_1}$，$B_1,B_2,\ldots,B_{s_2}$，$C_1,C_2,\ldots,C_{s_3}$，$D_1,D_2,\ldots,D_{s_4}$）。</p><p>kkksc03 有一个能力，他的左右两个大脑可以同时计算 $2$ 道不同的题目，但是仅限于同一科。因此，kkksc03 必须一科一科的复习。</p><p>由于 kkksc03 还急着去处理洛谷的 bug，因此他希望尽快把事情做完，所以他希望知道能够完成复习的最短时间。</p><h2 id="输入格式-14"><a href="#输入格式-14" class="headerlink" title="输入格式"></a>输入格式</h2><p>本题包含 $5$ 行数据：第 $1$ 行，为四个正整数 $s_1,s_2,s_3,s_4$。</p><p>第 $2$ 行，为 $A_1,A_2,\ldots,A_{s_1}$ 共 $s_1$ 个数，表示第一科习题集每道题目所消耗的时间。</p><p>第 $3$ 行，为 $B_1,B_2,\ldots,B_{s_2}$ 共 $s_2$ 个数。</p><p>第 $4$ 行，为 $C_1,C_2,\ldots,C_{s_3}$ 共 $s_3$ 个数。</p><p>第 $5$ 行，为 $D_1,D_2,\ldots,D_{s_4}$ 共 $s_4$ 个数，意思均同上。</p><h2 id="输出格式-14"><a href="#输出格式-14" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行,为复习完毕最短时间。</p><h2 id="样例-1-14"><a href="#样例-1-14" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-14"><a href="#样例输入-1-14" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 2 1 3</span><br><span class="line">5</span><br><span class="line">4 3</span><br><span class="line">6</span><br><span class="line">2 4 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-14"><a href="#样例输出-1-14" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="提示-14"><a href="#提示-14" class="headerlink" title="提示"></a>提示</h2><p>$1\leq s_1,s_2,s_3,s_4\leq 20$。</p><p>$1\leq A_1,A_2,\ldots,A_{s_1},B_1,B_2,\ldots,B_{s_2},C_1,C_2,\ldots,C_{s_3},D_1,D_2,\ldots,D_{s_4}\leq60$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//四份01背包</span></span><br><span class="line"><span class="comment">//每一科都是一样的复习方式</span></span><br><span class="line"><span class="comment">//所以相当于有4组数据</span></span><br><span class="line"><span class="comment">//因此可以只分析一组</span></span><br><span class="line"><span class="comment">//而一组我们可以分析理想情况，就是其中一部分的和等于总和的一半</span></span><br><span class="line"><span class="comment">//那么问题很明朗</span></span><br><span class="line"><span class="comment">//就是用一部分题目去尽量装满总和的一半这个背包</span></span><br><span class="line"><span class="comment">//然后+上总和减去的部分即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> len[<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> sub[<span class="number">30</span>];</span><br><span class="line"><span class="type">int</span> f[<span class="number">21</span>][<span class="number">1201</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++) cin&gt;&gt;len[i];</span><br><span class="line">    <span class="type">int</span> tot=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> v=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len[i];j++) cin&gt;&gt;sub[j],v+=sub[j];</span><br><span class="line">        <span class="built_in">sort</span>(sub,sub+len[i]);</span><br><span class="line">        <span class="type">int</span> t1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len[i];j++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;=v/<span class="number">2</span>;k++)&#123;</span><br><span class="line">                f[j][k]=f[j<span class="number">-1</span>][k];</span><br><span class="line">                <span class="keyword">if</span>(k&gt;=sub[j])f[j][k]=<span class="built_in">max</span>(f[j][k],f[j<span class="number">-1</span>][k-sub[j]]+sub[j]);</span><br><span class="line">                t1=<span class="built_in">max</span>(f[j][k],t1);</span><br><span class="line">            &#125;</span><br><span class="line">        tot+=<span class="built_in">max</span>(t1,v-t1);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;tot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯后端开发C++</title>
      <link href="/2024/02/14/%E8%85%BE%E8%AE%AF%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91C/"/>
      <url>/2024/02/14/%E8%85%BE%E8%AE%AF%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91C/</url>
      
        <content type="html"><![CDATA[<h2 id="腾讯后端开发-C"><a href="#腾讯后端开发-C" class="headerlink" title="腾讯后端开发 C++"></a>腾讯后端开发 C++</h2><blockquote><p>来自伟大的ACM集训队群前群主</p></blockquote><ul><li><p>32位机和64位机中数据类型的区别</p><ul><li>linux下，long和指针所占字节不一致，都从4byte变成8byte</li><li>windows下，指针所占字节不一致，从4byte变成8byte</li></ul></li><li><p>代码在内存中的分布都有哪些区？宏定义存在刚才你说的哪个区域？堆栈有什么区别啊？堆中的数据会回收吗？</p><ul><li>5个区，堆、栈、自由存储区、全局&#x2F;静态存储区、常量存储区</li><li>栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数、函数返回信息等。 对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。栈是机器系统提供的数据结构，计算机会在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。</li><li>堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制。堆内存用来保存类和对象。一般一个new就要对应一个delete。如果没有被释放掉，那么在程序结束后，操作系统会自动回收。  对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向。堆都是动态分配的，没有静态分配的堆。堆是C&#x2F;C++函数库提供的，它的机制是很复杂的，例如为了分配一块内存，库函数会按照一定的算法在堆内存中搜索可用的足够大小的空间，如果没有足够大小的空间，就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低得多。  </li><li>全局&#x2F;静态存储区，全局变量和静态变量被分配到同一块内存中</li><li>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）  </li><li>宏定义没有分配在哪个区，因为宏只是在编译前的预处理做文本替换</li><li>堆中的数据在程序运行过程中不会自动回收，全靠程序逻辑回收，程序结束后被操作系统回收。</li></ul></li><li><p>引用</p><ul><li>引用是C++语法做的优化，引用的本质还是靠指针来实现的。引用相当于变量的别名。</li><li>引用可以改变指针的指向，还可以改变指针所指向的值。</li><li>声明引用的时候必须初始化，且一旦绑定，不可把引用绑定到其他对象；即引用必须初始化，不能对引用重定义；对引用的一切操作，就相当于对原对象的操作。</li></ul></li><li><p>顶层const，底层const</p><ul><li><p>这个是常识了</p></li><li><pre><code class="C++">const int* p=&amp;a; //底层int* const p=&amp;a; //顶层</code></pre></li></ul></li><li><p>volatile</p><ul><li>volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：int volatile vInt;</li><li>当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。</li><li>volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i 的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i 是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。</li><li>一般说来，volatile用在如下的几个地方：<ul><li>中断服务程序中修改的供其它程序检测的变量需要加volatile</li><li>多任务环境下各任务间共享的标志应该加volatile</li><li>存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义</li></ul></li><li>volatile跟const一样，也有顶层底层之分</li><li>可以把一个非volatile int赋给volatile int，但是不能把非volatile对象赋给一个volatile对象。</li></ul></li><li><p>左值、右值</p><ul><li>左值代表一个在内存中占有确定地址的对象，右值可以在内存也可以在CPU寄存器。一个对象被用作右值时，使用的是它的内容(值)，被当作左值时，使用的是它的地址。</li><li>函数并不是只能返回右值，也可以返回左值。C++从函数中返回左值的能力对于实现一些运算符重载时很重要。</li><li>不是所有的左值都可修改，比如有const限定的就不行</li><li>通常来说，语言构造一个对象的值要求右值作为参数</li><li>解引用可以把右值转化为左值，而取地址符&amp;拿左值作为参数得到一个右值</li></ul></li><li><p>左值引用、右值引用</p><ul><li>左值引用的语法是<code>type &amp;Name = lvalueExpression</code></li><li>右值引用的语法是<code>type &amp;&amp;Name = rvalueExpression</code></li><li>右值引用的意义在于延长右值的生存期。因为右值在表达式结束后就会消亡。如果想继续使用右值，那就会动用昂贵的拷贝构造函数。</li><li>右值引用是用来支持转移语义的。转移语义可以将资源 ( 堆，系统对象等 ) 从一个对象转移到另一个对象，这样能够减少不必要的临时对象的创建、拷贝以及销毁，能够大幅度提高 C++ 应用程序的性能。临时对象的维护 ( 创建和销毁 ) 对性能有严重影响。</li><li>右值引用是对临时对象的一种引用，它是在初始化时完成引用的，但是右值引用不代表引用临时对象后，就不能改变右值引用所引用对象的值。仍然可以在初始化后改变临时对象的值。</li><li>如果一个右值引用有名字，那么它是左值，否则为右值</li></ul></li><li><p>malloc&#x2F;free和new&#x2F;delete有什么区别？(malloc: 咩力克)</p><ul><li>malloc&#x2F;free是C语言提供的系统函数，需要头文件支持；new&#x2F;delete是C++关键字(运算符)，需要编译器支持。</li><li>使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。</li><li>new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void* ，需要通过强制类型转换将void*指针转换成我们需要的类型。</li><li>new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现），然后调用类型的构造函数，初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。malloc&#x2F;free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作，所以得到的一片新内存中，其值将是随机的。</li><li>new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存，操作系统中有一个记录空闲内存地址的链表，当操作系统收到程序的申请时，就会遍历该链表，然后就寻找第一个空间大于所申请空间的堆结点，然后就将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。自由存储区不等于堆，如上所述，布局new就可以不位于堆中。</li><li>C++允许重载new&#x2F;delete操作符，malloc不允许重载。</li><li>new内存分配失败时，会抛出bad_alloc异常。malloc分配内存失败时返回NULL。</li><li>如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，结果也会导致程序出错。</li><li>空指针可以释放无数次，相当于什么都没有做</li><li>delete指针之后应重设指针的值为nullptr，否则指针会指向之前的地址，变成悬垂指针。</li><li>内存泄漏对于new和malloc都能检测出来，而new可以指明是哪个文件的哪一行，malloc不可以。</li></ul></li><li><p>重写(override)和重载(overload)的区别</p><ul><li>override是指派生类重写基类的虚函数，重写的函数必须有一致的参数表和返回值。</li><li>overload约定成俗的被翻译为“重载”。是指编写一个与已有函数同名但是参数表不同的函数。</li><li>相同参数不同返回值可以重载吗？不能</li></ul></li><li><p>函数隐藏、函数覆盖</p><ul><li>函数隐藏是指派生类中函数与基类中的函数同名，但是这个函数在基类中并没有被定义为虚函数，这种情况就是函数的隐藏。所谓隐藏是指使用常规的调用方法，派生类对象访问这个函数时，会优先访问派生类中的这个函数，基类中的这个函数对派生类对象来说是隐藏起来的。 但是隐藏并不意味这不存在或完全不可访问。</li><li>函数覆盖特指由基类中定义的虚函数引发的一种多态现象。在某基类中声明为 virtual 并在一个或多个派生类中被重新定义的成员函数，用法格式为：virtual 函数返回类型 函数名（参数表） {函数体}；实现多态性，通过指向派生类的基类指针或引用，访问派生类中同名覆盖成员函数。函数覆盖条件有三：<ul><li>基类中的成员函数被virtual关键字声明为虚函数</li><li>生类中该函数必须和基类中函数的名称、参数类型和个数等完全一致</li><li>将派生类的对象赋给基类指针或者引用，实现多态</li></ul></li><li>函数覆盖（多态）实现了一种基类访问（不同）派生类的方法。我们把它称为基类的逆袭。</li></ul></li><li><p>类和结构体的区别（博主一般以类是引用类型，结构体是值类型入手）</p><ul><li>最本质的区别是继承访问权限。到底默认是public继承还是private继承<strong>，</strong>取决于子类而不是基类。</li><li>struct作为数据结构的实现体，它默认的数据访问控制是public的，而class作为对象的实现体，它默认的成员变量访问控制是private的</li><li>class这个关键字还用于定义模板参数，就像typename。但关键字struct不用于定义模板参数</li></ul></li><li><p>怎么禁止隐式转换</p><ul><li>使用explicit关键字，在类的构造函数前面加上该关键字就能禁止隐式转换。</li></ul></li><li><p>字节对齐，怎么让编译器按指定大小对齐的？</p><ul><li>许多实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数k(通常它为4的倍数，这就是所谓的字节对齐，而这个k则被称为该数据类型的对齐模数(alignment modulus)。当一种类型S的对齐模数与另一种类型T的对齐模数的比值是大于1的整数，我们就称类型S的对齐要求比T强(严格)，而称T比S弱(宽松)。</li><li>内置类型的自身对齐模数(有符号无符号相同) char 1 short 2 int 4 float 4 double 8</li><li>自定义类型的自身对齐模数等同于其成员中最大的自身对齐模数</li><li>通过预编译命令#pragma pack(n)来指定对齐模数，n为2的整数幂</li><li>有效对齐模数：指定对齐模数与类型自身对齐模数的较小的值，就是实际生效的对齐模数。</li><li>字节对齐的细节和具体编译器实现相关，但一般而言，满足三个准则：<ul><li>结构体变量的首地址能够被其最宽基本类型成员的大小所整除</li><li>结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节</li><li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节</li></ul></li><li>在C++类里在没有任何数据类型变量的时候，会有一个字节的空间占用，如果有数据类型变量就会有字节对齐</li></ul></li><li><p>C++当中一个class,拥有一个char和int,加起来占用多大内存空间？</p><ul><li>我的电脑跑出来是8byte，因为字节对齐，所以4+4&#x3D;&#x3D;8</li><li>首先，类大小的计算遵循结构体的对齐原则</li><li>类的大小与普通数据成员有关，与成员函数和静态成员无关。即普通成员函数，静态成员函数，静态数据成员，静态常量数据成员均对类的大小无影响</li><li>虚函数对类的大小有影响，是因为虚函数表指针带来的影响。有虚函数表会有一个指向虚函数表的指针，这个指针受字节对齐影响。不管有没有发生虚函数的覆盖或者增加，大小计算方法不变。继承了多少个类，就会有多少个虚函数表，就会有多少个指针。</li><li>虚继承对类的大小有影响，是因为虚基表指针带来的影响。不管是否虚继承，gcc都是将虚表指针在整个继承关系中共享的，不共享的是指向虚基类的指针。更多看<a href="https://blog.csdn.net/fengxinlinux/article/details/72836199">这里</a>。</li><li>空类的大小是一个特殊情况，空类的大小为1。C++标准规定，凡是一个独立的(非附属)对象都必须具有非零大小，不同的对象不能具有相同的地址。</li><li>静态数据成员之所以不计算在类的对象大小内，是因为类的静态数据成员被该类所有的对象所共享，并不属于具体哪个对象，静态数据成员定义在内存的全局区</li><li>有两种特殊情况需要注意：<ul><li>第一种情况，涉及到空类的继承。当派生类继承空类后，派生类如果有自己的数据成员，而空基类的一个字节并不会加到派生类中去。</li><li>第二种情况，一个类包含一个空类对象数据成员。这种情况下空类的1字节会被算进去，而且受到字节对齐的影响。</li></ul></li></ul></li><li><p>vector</p><ul><li>vector底层实现为数组。有三个指针：_Myfirst, _Mylast, _Myend。first和end指向数组的一头一尾，last指向现在用到的位置。size&#x3D;last-first, capacity&#x3D;end-first，分别对应于resize()和reserve()这两个函数</li><li>vector是一个封装了动态大小数组的顺序容器，按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</li><li>vector提供了在序列末尾相对快速地添加&#x2F;删除元素的操作。</li><li>push_back是O(c)的，这是因为vector扩容是按照倍数扩大来保证的。如果扩容是固定大小扩容，push_back就会变成O(n)的。如果以成倍方式增长，假定插入n个元素，倍增因子为m。那么要完成这n个元素的push_back，需要重新分配$\log_mn$次内存，第i次重新分配会复制$m^i$个旧空间的元素，总时间复杂度约为$\frac{nm}{m-1}$。均摊为常量。如果以大于等于2倍的方式扩容，下一次申请的内存会大于之前分配内存的总和，导致之前分配的内存不能再被使用。所以其实大于1小于2是最合适的。</li><li>vector预留空间不足时，push_back之前会先调整vector内存大小，效率会变得很低。</li><li>vector使用一个内存分配器对象来动态地处理它的存储需求。vector的内存管理策略是：一旦空间不足，则增长一倍。重新分配内存时会拷贝当前已有的所有元素到新的内存区域。如果已有元素很多，这个操作将变得非常昂贵。如何避免重新分配内存？使用reserve。该函数会分配一块指定大小的空间，但不进行任何初始化，所以分配出来的空间不包含元素，也就不能访问。然后用同样的方式使用push_back函数，此时只要不超过之前reserve的空间，vector不会进行内存重新分配，只是简单的依次往后摆放。</li><li>创建一个 <code>vector</code> ，里面存了5个元素 <code>1 2 3 4 5</code>，把迭代器指向 5，然后在 vector 的最前面插入一个 0 ，问刚才那个迭代器指向几？写了，答案是4。插入前后迭代器地址不变。</li><li>vector的容量增长的题目，vector a; push_back八次对象，求总共调用多少次拷贝构造函数。答案是4次。</li></ul></li><li><p>list</p><ul><li>list底层是一个双向链表(某些版本的STL里是双向循环链表)，支持快速增删。相比双向链表结构的好处是在构建 list 容器时，只需借助一个指针即可轻松表示 list 容器的首尾元素。</li><li>list节点包含指向上一个节点的prev指针，指向下一个节点的next指针，存储值的成员变量myval</li><li>list每分配一个元素都会从内存中分配,每删除一个元素都会释放它占用的内存.</li><li>迭代器的移动就是通过操作节点的指针实现的。</li><li>为了更方便地实现 list 模板类提供的函数，该模板类在构建容器时，会刻意在容器链表中添加一个空白节点，并作为 list 链表的首个节点（又称头节点）。使用双向链表实现的 list 容器，其内部通常包含 2 个指针，并分别指向链表中头部的空白节点和尾部的空白节点（也就是说，其包含 2 个空白节点）</li><li>list&lt;指针&gt;完全是性能最低的做法，这种情况下还是使用vector&lt;指针&gt;好，因为指针没有构造与析构，也不占用很大内存</li></ul></li><li><p>set</p><ul><li>set是有序集合，内部数据结构为红黑树</li><li>插入和查找效率都是$\log{N}$的，仅仅需要指针操作节点即可完成，不涉及到内存移动和拷贝，map也一样。插入的时候只需要稍做变换，把节点的指针指向新的节点就可以了。删除的时候类似，稍做变换后把指向删除节点的指针指向其他节点也OK了。这里的一切操作就是指针换来换去，和内存移动没有关系。</li><li>每次insert之后，以前保留的迭代器不会失效。删了才会失效，而且删了的那部分，迭代器指向的内存和值都没变。</li><li>存储自定义类型时需要重载&lt;</li></ul></li><li><p>map</p><ul><li>内部数据结构也是红黑树，查询很快，插入较慢(因为要维护红黑树)</li><li>存储自定义类型时需要重载&lt;</li></ul></li><li><p>unordered_map (C++11)</p><ul><li>unordered_map记录元素的hash值，根据hash值判断元素是否相同。即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储（用红黑树实现），进行中序遍历会得到有序遍历。所以使用时map的key需要定义operator&lt;。而unordered_map需要定义hash_value函数并且重载operator&#x3D;&#x3D;。</li></ul></li><li><p>deque</p><ul><li><p>双端队列。底层数据结构为一个中央控制器和多个缓冲区，支持首尾（中间不能）快速增删，也支持随机访问。</p></li><li><p>deque也是在堆中保存内容的.它的保存形式如下:</p><p>[堆1] –&gt; [堆2] –&gt;[堆3] –&gt; …</p><p>每个堆保存好几个元素,然后堆和堆之间有指针指向。</p></li></ul></li><li><p>stack和queue</p><ul><li>他们都是对容器的再封装，所以应该叫适配器。底层一般用list或deque实现，然后封闭头部即可。</li></ul></li><li><p>priority_queue</p><ul><li>优先队列，底层用堆来实现，队首元素一定是优先级最高的一个</li></ul></li><li><p>STL容器的数据实际存在什么位置？</p><ul><li>比如vector，指针会存在栈里，元素会存在堆里。</li></ul></li><li><p>STL迭代器什么情况下会失效，各个容器都说一下</p><ul><li>vector在push_back和pop_back时都会引起迭代器失效。erase迭代器失效是在删除一个元素的时候，后面的元素要向前挪动，所以迭代器指向的位置就会被前面的覆盖，这时候++迭代器，就会跳过删除元素的后一个。正确用法是不要在循环里it++，erase方法会返回被删除的元素的下一个元素的迭代器。</li><li>list迭代器失效也发生在erase中。当迭代器指向的节点被删除后，迭代器++会失效</li><li>增加元素时，对于vector和string，如果容器内存被重新分配，iterators,pointers,references失效；如果没有重新分配，那么插入点之前的iterator有效，插入点之后的iterator失效；对于deque，如果插入点位于除front和back的其它位置，iterators,pointers,references失效；当我们插入元素到front和back时，deque的迭代器失效，但reference和pointers有效；对于list和forward_list，所有的iterator,pointer和refercnce有效。</li><li>删除元素时，对于vector和string，插入点之前的iterators,pointers,references有效；off-the-end迭代器总是失效的；对于deque，如果插入点位于除front和back的其它位置，iterators,pointers,references失效；当我们插入元素到front和back时，off-the-end失效，其他的iterators,pointers,references有效；对于list和forward_list，所有的iterator,pointer和refercnce有效。</li><li>在循环中refresh迭代器，当处理vector,string,deque时，当在一个循环中可能增加或移除元素时，要考虑到迭代器可能会失效的问题。一定要refresh迭代器。</li><li>在循环不变式中不要store off-the-end迭代器。增加或移除元素之后，off-the-end失效了，不store的话，每次从end()函数中取的都是最新的off-the-end，自然不会失效。</li></ul></li><li><p>Algorithm里面有哪些内容</p><ul><li>挑一些常用的说</li><li>不修改序列的：all_of, for_each</li><li>修改序列的：fill, swap, reverse, unique</li><li>排序：sort</li><li>二分查找：upper_bound, lower_bound, binary_search</li><li>堆操作：is_heap, make_heap, push&#x2F;pop&#x2F;sort_heap</li><li>min&#x2F;max</li><li>next&#x2F;prev_permutation</li></ul></li><li><p>深拷贝浅拷贝</p><ul><li>简单来说，浅拷贝是增加了一个指针，指向原来已经有的内存；深拷贝是增加一个指针，开辟一块新的内存，让指针指向这块新内存。</li><li>在多个指针指向同一块内存时，若该内存被释放之后再次被释放，就会出错。</li><li>这个问题写个重载赋值就懂了</li></ul></li><li><p>Main函数执行之前还会执行什么？</p><ul><li>main函数执行之前，主要就是初始化系统相关资源</li><li>操作系统创建进程后，把控制权交给程序的入口函数，这个函数往往是运行时库的某个入口函数。 </li><li>入口函数对运行库和程序运行环境进行初始化，包括堆，I&#x2F;O，线程，全局变量构造（constructor）等。</li><li>调用MAIN函数，正式开始执行程序主体。</li><li>执行MAIN完毕，返回入口函数，进行清理工作，包括全局变量析构，堆销毁，关闭I&#x2F;O等，然后进行系统调用介绍进程</li></ul></li><li><p>C++ 友元函数、友元类</p><ul><li>一个类中可以有 public、protected、private 三种属性的成员，通过对象可以访问 public 成员，只有本类中的函数可以访问本类的 private 成员。现在，我们来介绍一种例外情况——友元（friend）。借助友元（friend），可以使得其他类中的成员函数以及全局范围内的函数访问当前类的 private 成员。</li><li>在当前类以外定义的、不属于当前类的函数也可以在类中声明，但要在前面加 friend 关键字，这样就构成了友元函数。友元函数可以是不属于任何类的非成员函数，也可以是其他类的成员函数。</li><li>注意，友元函数不同于类的成员函数，在友元函数中不能直接访问类的成员，必须要借助对象。必须通过参数传递对象（可以直接传递对象，也可以传递对象指针或对象引用），并在访问成员时指明对象。</li><li>friend 函数不仅可以是全局函数（非成员函数），还可以是另外一个类的成员函数。一个函数可以被多个类声明为友元函数，这样就可以访问多个类中的 private 成员。</li><li>不仅可以将一个函数声明为一个类的“朋友”，还可以将整个类声明为另一个类的“朋友”，这就是友元类。友元类中的所有成员函数都是另外一个类的友元函数。</li><li>友元的关系是单向的而不是双向的。如果声明了类 B 是类 A 的友元类，不等于类 A 是类 B 的友元类，类 A 中的成员函数不能访问类 B 中的 private 成员。</li><li>友元的关系不能传递。如果类 B 是类 A 的友元类，类 C 是类 B 的友元类，不等于类 C 是类 A 的友元类。</li></ul></li><li><p>C++继承</p><ul><li>搞清楚公有继承、保护继承、私有继承就行<a href="https://blog.csdn.net/qq_35644234/article/details/52825311">这里</a></li></ul></li><li><p>虚继承</p><ul><li>为了解决从不同途径继承来的同名的数据成员在内存中有不同的拷贝造成数据不一致问题，将共同基类设置为虚基类。这时从不同的路径继承过来的同名数据成员在内存中就只有一个拷贝，同一个函数名也只有一个映射。这样不仅就解决了二义性问题，也节省了内存，避免了数据不一致的问题。</li><li>虚继承的目的是让某个类做出声明，承诺愿意共享它的基类。其中，这个被共享的基类就称为虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含一份虚基类的成员。</li><li>实例化顺序是，首先执行虚基类的构造函数，多个虚基类的构造函数按照被继承的顺序构造；执行基类的构造函数，多个基类的构造函数按照被继承的顺序构造；执行成员对象的构造函数，多个成员对象的构造函数按照申明的顺序构造；执行派生类自己的构造函数。析构以与构造相反的顺序执行。</li><li>在多继承情况下，虚基类关键字的作用范围和继承方式关键字相同，只对紧跟其后的基类起作用。</li><li>声明了虚基类之后，虚基类在进一步派生过程中始终和派生类一起，维护同一个基类子对象的拷贝。</li><li>观察类构造函数的构造顺序，拷贝也只有一份。</li><li>必须在虚派生的真实需求出现前就已经完成虚派生的操作。虚派生只影响从指定了虚基类的派生类中进一步派生出来的类，它不会影响派生类本身。</li></ul></li><li><p>虚函数原理，虚函数与纯虚函数</p><ul><li>虚函数是C++中用于实现多态(polymorphism)(同一代码可以产生不同效果的特点，被称为多态)的机制，核心理念就是通过基类访问派生类定义的函数。</li><li>虚函数虚在所谓“推迟联编”或者“动态联编”上，一个类函数的调用并不是在编译时刻被确定的，而是在运行时刻被确定的。由于编写代码的时候并不能确定被调用的是基类的函数还是哪个派生类的函数，所以被成为“虚”函数。</li><li>虚函数只能借助于指针或者引用来达到多态的效果</li><li>虚函数实际上是如何被编译器处理的呢？编译器发现一个类中有被声明为virtual的函数，就会为其创建一个虚函数表，也就是VTABLE。VTABLE实际上是一个函数指针的数组，每个虚函数占用这个数组的一个slot。一个类只有一个VTABLE，不管它有多少个实例。派生类有自己的VTABLE，但是派生类的VTABLE与基类的VTABLE有相同的函数排列顺序，同名的虚函数被放在两个数组的相同位置上。在创建类实例的时候，编译器还会在每个实例的内存布局中增加一个vptr字段，该字段指向本类的VTABLE。通过这些手段，编译器在看到一个虚函数调用的时候，就会将这个调用改写。</li><li>基类声明的虚函数，在派生类中也是虚函数，即使不再使用virtual关键字。</li><li>在基类中仅仅给出声明，不对虚函数实现定义，而是在派生类中实现。这个虚函数称为纯虚函数。普通函数如果仅仅给出它的声明而没有实现它的函数体，这是编译不过的。纯虚函数没有函数体。纯虚函数的意思是：我是一个抽象类！不要把我实例化！纯虚函数用来规范派生类的行为，实际上就是所谓的“接口”。它告诉使用者，我的派生类都会有这个函数。</li><li>private虚函数的语意是：最好重写这个函数，但是不要管它如何使用，也不要调用这个函数。</li><li>一个类的虚函数在它自己的构造函数和析构函数中被调用的时候，它们就变成普通函数了。也就是说不能在构造函数和析构函数中让自己“多态”。</li><li>在你设计一个基类的时候，如果发现一个函数需要在派生类里有不同的表现，那么它就应该是虚的。从设计的角度讲，出现在基类中的虚函数是接口，出现在派生类中的虚函数是接口的具体实现。通过这样的方法，就可以将对象的行为抽象化。</li><li>其实虚函数表的本质就是一种迟后联编的过程，正常编译都是先期联编的，但是当代码遇到了virtual时，就会把它当做迟后联编，但是为了迟后编译，我么就生成了局部变量–虚函数表，这就增大了一些空间上的消耗。（前提是两个函数的返回类型，参数类型，参数个数都得相同，不然就起不到多态的作用）</li><li>有一种特殊的情况，那就是如果基类中虚函数返回一个基类指针或引用，派生类中返回一个派生类的指针或引用，则c++将其视为同名虚函数而进行迟后联编</li><li>使用虚函数的一些限制：<ul><li>只有类成员函数才能声明为虚函数，这是因为虚函数只适用于有继承关系的类对象中。</li><li>静态成员函数不能说明为虚函数，因为静态成员函数不受限与某个对象，整个内存中只有一个，所以不会出现混淆的情况</li><li>内联函数不可以被继承，因为内联函数是不能子啊运行中动态的确认其位置的。</li><li>构造函数不可以被继承。</li><li>析构函数可以被继承，而且通常声明为虚函数。</li></ul></li></ul></li><li><p>抽象类</p><ul><li>含有纯虚函数的类被称为抽象类。抽象类只能作为派生类的基类，不能定义对象，但可以定义指针。在派生类实现该纯虚函数后，定义抽象类对象的指针，并指向或引用子类对象。<ul><li>在定义纯虚函数时，不能定义虚函数的实现部分；</li><li>在没有重新定义这种纯虚函数之前，是不能调用这种函数的。</li></ul></li><li>抽象类的唯一用途是为派生类提供基类，纯虚函数的作用是作为派生类中的成员函数的基础，并实现动态多态性。继承于抽象类的派生类如果不能实现基类中所有的纯虚函数，那么这个派生类也就成了抽象类。因为它继承了基类的抽象函数，只要含有纯虚函数的类就是抽象类。纯虚函数已经在抽象类中定义了这个方法的声明，其它类中只能按照这个接口去实现。</li></ul></li><li><p>C++接口和抽象类的区别</p><ul><li>一般说的接口，表示对外提供的方法，提供给外部调用。是沟通外部跟内部的桥梁。也是以类的形式提供的，但一般该类只具有成员函数，不具有数据成员。</li><li>抽象类可以既包含数据成员又包含方法。</li></ul></li><li><p>基类指针和派生类指针之间的转换</p><ul><li>基类指针指向基类对象、派生类指针指向派生类对象。这是正常的。</li><li>基类指针指向派生类对象。这种情况是允许的，通过定义一个基类指针和一个派生类对象，把基类指针指向派生类对象，但是需要注意，通常情况这时的指针调用的是基类的成员函数。分四种情况：<ul><li>函数在基类和派生类中都存在。这时通过指向派生类对象的基类指针调用成员函数，调用的是基类的成员函数。</li><li>函数在基类中不存在，在派生类中存在。编译器报错</li><li>将基类指针强制转换为派生类指针。这种是向下的强制类型转换，转换之后“指向派生类的基类指针”就可以访问派生类的成员函数</li><li>如果基类中的成员函数被定义为虚函数，并且在派生类中也实现了该函数，则通过“指向派生类的基类指针” 访问虚函数，访问的是派生类中的实现。允许“基类指针指向派生类”这个操作，最大的意义也就在此，通过虚函数和函数覆盖，实现了“多态”（指向不同的派生类，实现不同功能）。</li></ul></li><li>派生类指针指向基类对象，会编译错误。基类对象无法被当作派生类对象，派生类中可能具有只有派生类才有的成员或成员函数。即便是使用强制转换，将派生类指针强制转换成基类指针，通过这个“强制指向基类的派生类指针”访问的函数依然是派生类的成员函数。</li><li>综上，可以通过基类指针访问派生类方法（强制转换和虚函数），不存在通过派生类指针调用基类成员函数的方法（即便是强制转换）。</li></ul></li><li><p>C++编译时多态，运行时多态</p><ul><li>编译时多态又叫静态联编，主要通过函数重载和运算符重载来实现</li><li>运行时多态又叫动态联编，主要通过继承和虚函数来实现</li></ul></li><li><p>c++11新特性</p><ul><li>右值引用与std::move()避免右值对象拷贝</li><li>初始化列表</li><li>explicit</li><li>auto<ul><li>auto不会有任何的效率损失，都是基于编译期的推导</li><li>auto还会带来更好的安全性</li></ul></li><li>decltype</li><li>nullptr(与nil等价)</li><li>default启用编译器提供的默认函数实现</li><li>delete关键字禁止生成默认方法实现</li><li>static_assert()提供编译期断言</li><li>range for</li><li>constexpr</li><li>lambda表达式</li><li>enum class</li></ul></li><li><p>构造函数和析构函数能否抛出异常</p><ul><li>构造函数可抛出异常。动态创建对象要进行两个操作：分配内存和调用构造函数。若在分配内存时出错，会抛出bad_alloc异常；若在调用构造函数初始化时出错，会不会存在内存泄漏呢？答案是不会。</li><li>析构函数也可抛出异常，但不推荐抛出。原因如下：<ul><li>如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。 [正常情况下调用析构函数抛出异常导致资源泄露]</li><li>通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。 [在发生异常的情况下调用析构函数抛出异常，会导致程序崩溃]</li></ul></li><li>如果非要抛出异常，解决方案如下：<ul><li>如果某个操作可能会抛出异常，class应提供一个普通函数（而非析构函数），来执行该操作。目的是给客户一个处理错误的机会。</li><li>如果析构函数中异常非抛不可，那就用try catch来将异常吞下，必须要把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外。</li></ul></li></ul></li><li><p>构造函数中有哪些注意事项？</p><ul><li>默认情况下，c++编译器至少为我们写的类增加3个函数<ul><li>默认构造函数(无参，函数体为空)、默认析构函数(无参，函数体为空)、默认拷贝构造函数(对类中非静态成员属性简单值拷贝)</li></ul></li><li>如果用户定义拷贝构造函数，c++不会再提供任何默认构造函数</li><li>如果用户定义了普通构造函数(非拷贝)，c++不再提供默认无参构造，但是会提供默认拷贝构造</li></ul></li><li><p>构造函数和析构函数可以是虚函数吗？</p><ul><li>构造函数不能为虚函数，而析构函数可以且常常是虚函数。</li><li>当一个类打算被用作其它类的基类时，它的析构函数必须是虚的。</li><li>析构函数也可以是虚的，甚至是纯虚的。纯虚的析构函数并没有什么作用，是虚的就够了。通常只有在希望将一个类变成抽象类，而这个类又没有合适的函数可以被纯虚化的时候，可以使用纯虚的析构函数来达到目的。</li></ul></li><li><p>子类析构会调用父类的析构函数吗？执行顺序是什么？</p><ul><li>析构情况需要分类讨论<ul><li>父类析构函数不是虚函数，并使用父类指针指向子类对象，析构该子类对象时，只会调用父类析构函数，因为不具多态性。如何解决？父类析构函数改为虚函数。</li><li>父类析构函数不是虚函数，并使用子类指针指向子类对象，那么会先调用子类析构函数，再调用父类析构函数，子类释放子类中分配的，父类分配父类中分配的。</li></ul></li></ul></li><li><p>C++默认成员函数</p><ul><li>默认构造函数、默认拷贝构造函数、默认析构函数、默认赋值运算符、取址运算符和取址运算符const</li><li>注意，如果一个类中只存在一个参数为&amp;ClassName的拷贝构造函数，那么就不能使用const ClassName或volatile ClassName的对象实行拷贝初始化。</li></ul></li><li><p>sizeof和strlen</p><ul><li>sizeof是运算符，strlen是函数</li><li>sizeof操作符的结果是size_t，该类型保证能容纳实现所建立的最大对象的字节大小</li><li>sizeof可以用类型做参数，strlen只能用char*做参数，且必须以“\0”结尾</li><li>数组作为sizeof的参数不退化，但是传递给strlen时就退化为指针了</li><li>大部分编译程序在编译的时候sizeof就被计算过了，这就是sizeof（x）可以作为定义数组维数的原因。strlen的结果要在运行的时候才能计算出来，它用来计算字符串的长度，不是类型占内存的大小。</li><li>sizeof后如果是类型必须加括弧，如果变量名可以不加括弧。这是因为sizeof是个操作符，不是个函数。</li><li>sizeof计算的是分配的数组所占内存空间的大小，不受里面存储内容的改变而改变。</li><li>sizeof用途<ul><li>与存储分配和I&#x2F;O系统的例程进行通信</li><li>查看某个类型的对象在内存中所占的单元字节</li><li>动态分配对象时，可以使系统知道要分配多少内存。</li><li>便于一些类型的扩充，在Windows中很多结构类型有一个专用的字段是用来存放该类型的字节大小。</li><li>由于操作数的字节数在实现时可能出现变化，建议在涉及到操作数字节大小时用sizeof来代替常量计算。</li><li>如果操作数是函数中的数组形参或函数类型的形参，sizeof给出其指针的大小。</li></ul></li></ul></li><li><p>内联函数和宏定义的区别</p><ul><li>使用宏和内联函数都可以节省在函数调用方面所带来的时间和空间开销。二者都采用了空间换时间的方式，在其调用处进行展开</li><li>在预编译时期，宏定义在调用处执行字符串的原样替换。在编译时期，内联函数在调用处展开，同时进行参数类型检查。</li><li>内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员。而当一个表达式涉及到类保护成员或私有成员时，宏就不能实现了(无法将this指针放在合适位置)。</li><li>在编写内联函数时，函数体应该短小而简洁，不应该包含循环等较复杂结构，否则编译器不会将其当作内联函数看待，而是把它决议成为一个静态函数。</li><li>频繁的调用内联函数和宏定义容易造成代码膨胀，消耗更大的内存而造成过多的换页操作。</li></ul></li><li><p>C++ shared_ptr</p><p>- </p></li><li><p>循环引用，weak_ptr</p></li><li><p>程序编译过程、静态链接和动态链接等</p></li><li><p>C++ RAII</p><ul><li>RAII是Resource Acquisition Is Initialization（wiki上面翻译成 “资源获取就是初始化”）的简称，是C++语言的一种管理资源、避免泄漏的惯用法。利用的就是C++构造的对象最终会被销毁的原则。RAII的做法是使用一个对象，在其构造时获取对应的资源，在对象生命期内控制对资源的访问，使之始终保持有效，最后在对象析构的时候，释放构造时获取的资源。RAII是用来管理资源、避免资源泄漏的方法。</li><li>当我们在一个函数内部使用局部变量，当退出了这个局部变量的作用域时，这个变量也就被销毁了；当这个变量是类对象时，这个时候，就会自动调用这个类的析构函数，而这一切都是自动发生的，不要程序员显示的去调用完成。RAII就是这样去完成的。</li><li>由于系统的资源不具有自动释放的功能，而C++中的类具有自动调用析构函数的功能。如果把资源用类进行封装起来，对资源操作都封装在类的内部，在析构函数中进行释放资源。当定义的局部变量的生命结束时，它的析构函数就会自动的被调用，如此，就不用程序员显示的去调用释放资源的操作了。</li><li>作者：zhaozhengcoder<br>链接：<a href="https://www.jianshu.com/p/b7ffe79498be">https://www.jianshu.com/p/b7ffe79498be</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</li></ul></li><li><p>C++ static</p><ul><li>static关键词作用于成员变量和成员函数</li><li>静态变量作用范围在一个文件内，程序开始时分配空间，结束时释放空间，默认初始化为0，使用时可以改变其值。静态变量或静态函数只有本文件内的代码才能访问它，它的名字在其它文件中不可见。</li><li>函数内部声明的static变量，可作为对象间的一种通信机制。如果一局部变量被声明为static，那么将只有唯一的一个静态分配的对象，它被用于在该函数的所有调用中表示这个变量。这个对象将只在执行线程第一次到达它的定义使初始化。</li><li>对于局部静态对象，构造函数是在控制线程第一次通过该对象的定义时调用。在程序结束时，局部静态对象的析构函数将按照他们被构造的相反顺序逐一调用，没有规定确切时间。</li><li>如果一个变量是类的一部分，但却不是该类的各个对象的一部分，它就被成为是一个static静态成员。一个static成员只有唯一的一份副本，而不像常规的非static成员那样在每个对象里各有一份副本。同理，一个需要访问类成员，而不需要针对特定对象去调用的函数，也被称为一个static成员函数。</li><li>类的静态成员函数只能访问类的静态成员(变量或函数)。</li></ul></li><li><p>shared_ptr 线程安全，引用计数如何实现的，原子操作的原理</p><ul><li>shared_ptr在C++11版本之后提供，包含在头文件<code>&lt;memory&gt;</code>中，有shared_ptr,unique_ptr和weak_ptr。</li><li></li></ul></li><li><p>有关于内存分配的问题，怎么实现自主在堆中进行内存分配(因为我自己实现了malloc函数，所以就是简单回答用sbrk() 的系统调用对于堆进行内存分配)</p></li><li><p>1G内存，void * p &#x3D; malloc(1.2g) 可行吗，用 for 循环对所分配的内存依次写入，到后面会发生什么，哪些会被置换, 32位系统的进程空间分布，malloc的内存在哪里， p 呢</p></li><li><p>实现一个C++string operator&#x3D;()函数, 白纸写. 这个写的还可以, 要注意的点 : 自身复制, 异常安全.</p></li><li><p>实现strncpy函数, 没啥毛病, 注意鲁棒性</p></li><li><p>空对象的大小，加虚析构函数又怎样呢。</p><ul><li>空对象大小为1，加了虚析构函数就是指针大小，32位系统大小为4，64位系统大小为8</li></ul></li><li><p>假设我现在开辟了一片共享内存，然后我想在这块共享内存上使用stl库，该怎么做呢。比如说我使用vector，我想要它的元素全部在共享内存上，就算是新添加的元素也是被分配在共享内存上。（我们可以重写一个allocator，把共享内存划分给它，用这些共享内存实现一个内存池，让allocator来对它进行管理）</p></li><li><p>把C++多态的实现讲一下吧（从虚表表、虚函数表、虚函数表指针去具体介绍，然后介绍了构造析构过程中虚函数表指针的变化过程，然后从这些变化过程去解释语言级别的现象）</p></li><li><p>gcc选项知道哪些（-O优化选项、-W加强警告…还有分阶段编译：-E预编译生成.i文件，-S预编译+编译生成.s文件，-c生成.o文件，-o指定输出文件，-l指定链接库，差不多用得多的就这些了）加调试信息（-gstabs）多线程编译呢（不支持）</p></li><li><p>介绍一下STL allocator</p></li><li><p>介绍一下迭代器与容器之间的耦合关系（在SGI STL中只有容器对迭代器的依赖关系，而迭代器并没有对容器的耦合关系。所以，比如说vector扩容之后，迭代器会失效，解引用这样的迭代器可能会造成非法访问。但是以前用VisualStudio使用它的C++的STL库CRT的时候，如果容器进行了扩容，然后解引用它们已失效的迭代器的时候，会引发异常。所以我猜想它们的实现里，一定是将迭代器与容器进行了关联，每次对迭代器进行操作时候，都会根据容器检验迭代器的有效性，如果无效就抛出异常。）</p></li><li><p>类型萃取有什么作用</p><ul><li>C++模板中的类型参数T是抽象的，我们并不能在模板内部直接获得它的具体特征。类型萃取（抽取）技术就是要抽取类型的一些具体特征(trait)，比如它是哪种具体类型，它是引用类型，内建类型，还是类类型等。可见，类型萃取技术其实就是trait模板技术的具体体现。</li><li>类型信息是编译期的实体，现在要针对类型来进行编程，这其实就是模板元编程的一个方面。我们平常使用的if&#x2F;else，while，for等基本的逻辑结构都是运行期的行为，在面向类型的编程中并不能使用，这就需要用到一些特殊的模板技术。实现类型萃取要用到的基本思想一个是特化，一个就是用typedef来携带类型信息。实际上，我们在用模板做设计时，一般建议在模板定义内部，为模板的每个类型参数提供typedef定义，这样在泛型代码中可以很容易地访问或抽取这些类型。</li><li>在C和C++中，普通的函数可以称为值函数，它们接受的参数是某些值，返回的结果也是值。而所谓的类型函数接受的实参是类型，返回的是被抽取出来的类型或常量值等（即用typedef定义的类型别名，一般不同的具体类型都定义统一的别名）。如类模板就是类型函数，sizeof是内建的类型函数，返回给定类型实参的大小。在类型编程中，很多地方都要用到sizeof。</li></ul></li><li><p>hashmap底层实现原理，hashmap存储结构怎么样，怎么处理的hash冲突，当查询时，其时间复杂度怎么样</p></li><li><p>gdb用过吗？可以，那来讲下死锁应该怎么调试吧</p></li><li><p>查内存泄露用什么工具？自己使用过么</p></li><li><p>Java和C++的最主要的区别是什么</p><ul><li>第一点是，在C++中，支持面向过程，函数可以与类隔离单独存在，而Java的函数必须在类里面。第二点是内存管理，C++需要程序员自己去管理内存，而Java是通过垃圾回收自动管理内存。（关于多继承和单继承的区别忘记回答了。。接口也忘了回答了，有点紧张）</li></ul></li><li><p>怎么弄出一个不能被继承的类</p><ul><li><a href="https://www.cnblogs.com/yanenquan/p/4006691.html">https://www.cnblogs.com/yanenquan/p/4006691.html</a></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法(总)</title>
      <link href="/2024/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-1/"/>
      <url>/2024/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-1/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote><p>各位新年快乐，祝你也祝我新年依然保持一份温柔—世间温柔，不过是芳春柳摇染花香，槐序蝉鸣入深巷，白茂叶落醉故乡。</p></blockquote><h1 id="背景与前置知识"><a href="#背景与前置知识" class="headerlink" title="背景与前置知识"></a>背景与前置知识</h1><blockquote><p>随着应用程序变得越来越复杂和数据越来越丰富，几百万、几十亿甚至几百亿的数据就会出现，而对这么大对数据进行搜索、插入或者排序等的操作就越来越慢，数据结构就是用来解决这些问题的。</p></blockquote><p>总而言之</p><blockquote><p>数据结构指的是“一组数据的存储结构”，算法指的是“操作数据的一组方法”。<br>数据结构是为算法服务的，算法是要作用再特定的数据结构上的。</p></blockquote><p>需要学习</p><blockquote><p>这里面有10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</p></blockquote><blockquote><p>数据结构三要素：逻辑结构、存储结构、数据的运算；其中逻辑结构包括线性结构（线性表、栈、队列）和非线性结构（树、图、集合）</p></blockquote><blockquote><p>数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</p></blockquote><blockquote><p>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。</p><p>数据元素是数据的基本单位，可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位，<br>数据对象是具有相同性质的数据元素的集合，是数据的一个子集</p><p>数据类型是一个值的集合和定义在此集合上的一组操作的总称</p><p>数据类型包括：原子类型、结构类型、抽象数据类型</p><p>1）原子类型。其值不可再分的数据类型。<br>2）结构类型。其值可以再分解为若干成分（分量）的数据类型。</p><p>3）抽象数据类型。抽象数据组织及与之相关的操作。</p><p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合，它包括逻辑结构、存储结构和数据运算三方面内容</p><p>（1）集合结构</p><p>数据元素之间除了“属于同一集合”的关系外，别无其他关系。例如，确定一名学生是否为班级成员，只需将班级看做一个集合结构。</p><p>（2）线性结构</p><p>数据元素之间存在一对一的关系。例如，将学生信息数据按照其入学报到的时间先后顺序进行排列，将组成一个线性结构。</p><p>（3）树结构</p><p>数据元素之间存在一对多的关系。例如，在班级的管理体系中，班长管理多个组长，每位组长管理多名组员，从而构成树形结构。</p><p>（4）图结构或网状结构</p><p>数据元素之间存在多对多的关系。例如，多位同学之间的朋友关系，任何两位同学都可以是朋友，从而构成图形结构或网状结构。</p><p>数据的逻辑结构和存储结构是密不可分的，算法的设计取决于所选定的逻辑结构，而算法的实现依赖于采用的存储结构</p><h2 id="数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储"><a href="#数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储" class="headerlink" title="数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储"></a>数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储</h2><blockquote><p>顺序存储：把逻辑上相邻的数据元素存储在物理位置也相邻的存储单元里，元素之间的关系由存储单元之间的位置关系，即相邻关系来体现。如顺序表。<br>优点：容易实现随机存取，每个元素占用最少的存储空间。<br>缺点：只能使用相邻的一整块存储空间，容易产生较多的外部内存碎片。<br>链式存储：使用表示元素存储地址的指针来表示元素之间的逻辑关系，此时不要求逻辑上相邻的数据元素在物理位置上也相邻。如单链表。<br>优点：不会出现碎片内存，能充分利用存储单元。<br>缺点：每个元素由于存储指针而占用额外的存储空间，且只能通过遍历实现顺序存取。<br>索引存储：在存储数据元素的同时，建立一个附加的索引表。索引表中的每一项称为索引项项，其形式通常为（关键字，地址）。<br>优点：检索速度快。<br>缺点：附加的索引表会占用额外的存储空间。在添加或者删除数据元素时，需要同步修改索引表，因此会花费额外的时间。<br>散列存储：根据元素的关键字以某种方式计算出该元素的存储地址，又称为 hash 存储。如哈希表。<br>优点：检索、添加、删除的操作速度都很快。<br>如果散列函数（或者 hash 函数）设计不好的话，可能会出现 hash 冲突，解决冲突又会增加时间和空间开销。</p></blockquote><p>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤</p><p>在存储数据时，通常不仅要存储各数据元素的值，而且要存储数据元素之间的关系</p><p>对于两种不同的数据结构，逻辑结构或物理结构一定不同吗？</p><p>数据运算也是数据结构的一个重要方面。对于两种不同的数据结构，他们的逻辑结构和物理结构完全有可能相同（比如二叉树和二叉排序树）</p><p>链式存储设计时，各个不同结点的存储空间可以不连续，但结点内的存储单元地址必须连续</p><p>算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每条指令包括一个或多个操作。</p><p>算法的五个特性：有穷性、确定性、可行性、输入、输出（字面意思，第一遍看的话建议看看书具体概念）</p><p>通常设计一个好的算法应考虑：正确性、可读性、健壮性、效率与低存储量需求</p><p>算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入数据的性质</p><p>若输入数据所占空间只取决于问题本身而和算法无关，则只需分析除输入和程序之外的额外空间</p><p>算法原地工作是指算法所需辅助空间为常量，即O(1)</p><p>一个算法应该是问题求解步骤的描述</p><p>所谓时间复杂度，是指最坏情况下估算算法执行时间的一个上界</p><p>同一个算法，实现语言的级别越高，执行效率越低</p></blockquote><h1 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h1><h2 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h2><p>算法效率分析分为两种：第一种是<strong>时间效率</strong>，第二种是<strong>空间效率</strong>。时间效率被称为<strong>时间复杂度</strong>，而空间效率被称作<strong>空间复杂度</strong>。</p><p>时间复杂度主要衡量的是一个算法的<strong>运行速度</strong>，而空间复杂度主要衡量一个算法所<strong>需要的额外空间</strong>。</p><h2 id="大O的表示法规则"><a href="#大O的表示法规则" class="headerlink" title="大O的表示法规则"></a>大O的表示法规则</h2><p>时间复杂度和空间复杂度一般都使用大O的渐进表示法进行表示，大O的渐进表示法规则如下：</p><p><strong>1、所有常数都用常数1表示。<br>2、只保留最高阶项。<br>3、如果最高阶项存在且不是1，则去除与这个项的系数，得到的结果就是大O阶。</strong></p><p>常见的时间复杂度量级有：</p><ul><li>常数阶O(1)</li><li>对数阶O(logN)</li><li>线性阶O(n)</li><li>线性对数阶O(nlogN)</li><li>平方阶O(n²)</li><li>立方阶O(n³)</li><li>K次方阶O(n^k)</li><li>指数阶(2^n)</li></ul><blockquote><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h4 id="事后统计法"><a href="#事后统计法" class="headerlink" title="事后统计法"></a>事后统计法</h4><p>T(n) &#x3D; O( f(n) )</p><p>这种方法可行，但不是一个好的方法。该方法有两个缺陷：一是要想对设计的算法的运行性能进行评测，必须先依据算法编制相应的程序并实际运行；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优势。</p><p>事前分析估算的方法<br>因事后统计方法更多的依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优劣。因此人们常常采用事前分析估算的方法。<br>在编写程序前，依据统计方法对算法进行估算。一个程序在计算机上运行时所消耗的时间取决于下列因素：<br>(1) 算法采用的策略、方法；(2).编译产生的代码质量；(3) 问题的输入规模；(4)机器执行指令的速度。</p></blockquote><p>常数阶</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br></pre></td></tr></table></figure><p>线性阶</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对数阶</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线性对数阶</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;n; m++)</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>平方阶</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(x=1; i&lt;=n; x++)</span><br><span class="line">&#123;</span><br><span class="line">   for(i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一种O（m*n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=m; x++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余以此类推</p><p>空间复杂度</p><p>O(1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>O(n)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] m = <span class="keyword">new</span> <span class="type">int</span>[n]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ACM时间复杂度"><a href="#ACM时间复杂度" class="headerlink" title="ACM时间复杂度"></a>ACM时间复杂度</h2><blockquote><p>O(1) &lt; O ( l o g n )  &lt; O ( n ) &lt; O ( n l o g n )  &lt; O ( n 2 ) &lt; O ( n 3 ) &lt;O(2^n)&lt; O ( n ! )</p><p>n&lt;200, 可以选择复杂度为O ( n 3 )的算法。例：dp，floyd<br>n &lt; 5000，可以选择复杂度为O(n^2)的算法。例：dp，Dijkstra,朴素版Prim<br>n &lt; 1 e 6 ,可以选择复杂度为O ( n l o g n ) 或(O(n^2logn)的算法。例：sort，线段树，树状数组，set，map，spfa，凸包，二分<br>n &lt; 1 e 7 ，可以选择复杂度为O ( n ) 的算法。例：哈希，双指针，kmp，AC自动机。部分sort，树状数组，spfa<br>n &lt; 1 e 8 ，可以选择复杂度为O ( n )的算法。例：双指针，kmp，AC自动机，线性筛<br>n &lt; 1 e 9，可以选择复杂度为 O(sqrt(n))的算法。例：判断质数<br>n &lt; 1 e 18 ，可以选择复杂度为O ( l o g n ) 的算法。例：二分，欧几里得算法，幂运算</p></blockquote><h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="一、线性表的定义"><a href="#一、线性表的定义" class="headerlink" title="一、线性表的定义"></a>一、线性表的定义</h2><p>线性表（List）：零个或多个数据元素的有限序列。</p><blockquote><p>元素数据类型相同，可以是整型也可以是结构体。</p></blockquote><blockquote><p>有限一词的解释</p><ul><li><h3 id="有限："><a href="#有限：" class="headerlink" title="有限："></a><strong>有限</strong>：</h3><p>表中的数据元素个数为<strong>n</strong>（也叫做<strong>线性表的长度</strong>，n&gt;&#x3D;0），是有限个元素。当线性表长度n&#x3D;0时，此时线性表是一个空表。</p></li><li><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>一列，一对一</p></li></ul></blockquote><p>线性表的数据集合为{a1,a2,…,an}，假设每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</p><blockquote><p>除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且只有一个直接后继。</p><p>a1是唯一的“第一个”元素，又称<strong>表头元素</strong>；an是唯一的“最后一个元素”，又称<strong>表尾元素。</strong></p><p>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。在这种情况下，常把数据元素称为记录，含有大量记录的线性表又称为文件</p><p>注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。</p></blockquote><blockquote><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul><li>线性表的置空操作clear()：将一个已经存在的线性表置为空表；</li><li>线性表判空操作isEmpty()：判断线性表是否为空，若为空，则返回true；否则，返回为false；</li><li>求线性表的长度操作length()：求线性表中的数据元素的个数并返回其值；</li><li>取元素操作get(i)：读取并返回线性表中的第i个数据元素的值。其中i的取值范围为0≤i≤length()-1；</li><li>插入操作insert(i,x)：在线性表的第i个数据元素之前插入一个值为x的数据元素。其中i的取值范围为0≤i≤length()。当i&#x3D;0时，在表头插入x；当i&#x3D;length()时，在表尾插入x；</li><li>删除操作remove(i)：删除并返回线性表中第i个数据元素。其中i的取值范围为0≤i≤length()-1；</li><li>查找操作indexOf(x)：返回线性表中首次出现的指定的数据元素的位序号，若线性表中不包含此数据元素，则返回-1；</li></ul></blockquote><h2 id="二、线性表的存储结构"><a href="#二、线性表的存储结构" class="headerlink" title="二、线性表的存储结构"></a>二、线性表的存储结构</h2><h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><blockquote><p>顺序存储是用一组地址连续的存储单元依次存放线性表中各个元素的存储结构。</p><p>顺序表的特点就是逻辑顺序与物理顺序相同</p></blockquote><blockquote><ul><li>在线性表中逻辑上相邻的数据元素，在物理存储上也是相邻的；</li><li>存储密度高，但要预先分配“足够应用”的存储空间，这可能会造成存储空间的浪费；</li><li>便于随机存储；</li><li>不便于插入和删除操作，这是因为在顺序表上进行的插入和删除操作会引起大量数据元素的移动；</li></ul></blockquote><h2 id="代码实现步骤"><a href="#代码实现步骤" class="headerlink" title="代码实现步骤"></a>代码实现步骤</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//头文件部分</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//变量空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100                  <span class="comment">//最大值</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;                <span class="comment">//元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType* elem;                  <span class="comment">//存储空间动态申请</span></span><br><span class="line"><span class="type">int</span> length;                      <span class="comment">//顺序表的长度</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; Ok, Error &#125;;               <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个空表，并将length置零，初始化存储容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">InitSeqList</span><span class="params">(SeqList&amp; L)</span></span></span><br><span class="line"><span class="function"><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">L.elem = <span class="keyword">new</span> ElemType[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!L.elem)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;申请空间失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">插入操作</span></span><br><span class="line"><span class="comment">在顺序表L的第i（1≤i≤L.length+1）个位置插入新元素e。如果 i 的输入不合法，则返回false，表示插入失败；否则，将顺序表的第 i 个元素以及其后的所有元素右移一个位置，腾出一个空位置插入新元素e，顺序表长度增加1，插入成功，返回true。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">算法思路：</span></span><br><span class="line"><span class="comment">1.判断 i 的值是否正确</span></span><br><span class="line"><span class="comment">2.判断表长是否超过数组长度</span></span><br><span class="line"><span class="comment">3.从后向前到第 i 个位置，分别将这些元素都向后移动一位</span></span><br><span class="line"><span class="comment">4.将该元素插入位置 i 并修改表长</span></span><br><span class="line"><span class="comment">线性表插入算法的平均时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">SeqListInsert</span><span class="params">(SeqList&amp; L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((i &lt; <span class="number">1</span>) || (i &gt; L.length + <span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i位置不合法&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (L.length == MAXSIZE)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;顺序表已满&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = L.length<span class="number">-1</span>; j &gt;= i<span class="number">-1</span>; j--) &#123;</span><br><span class="line">L.elem[j + <span class="number">1</span>] = L.elem[j];</span><br><span class="line">&#125;</span><br><span class="line">L.elem[i<span class="number">-1</span>] = e;</span><br><span class="line">L.length++;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除操作</span></span><br><span class="line"><span class="comment">删除顺序表L中第i（1≤i≤L.length）个位置的元素，成功则返回true，并将被删除的元素用引用变量e返回，否则返回false。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">算法思路：</span></span><br><span class="line"><span class="comment">1.判断 i 的值是否正确</span></span><br><span class="line"><span class="comment">2.取删除的元素</span></span><br><span class="line"><span class="comment">3.将被删元素后面的所有元素都依次向前移动一位</span></span><br><span class="line"><span class="comment">4.修改表长</span></span><br><span class="line"><span class="comment">线性表删除算法的平均时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">SeqListDelete</span><span class="params">(SeqList&amp; L, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i位置不合法&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//i后的元素向前移动一位</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; L.length; j++)</span><br><span class="line">&#123;</span><br><span class="line">L.elem[j - <span class="number">1</span>] = L.elem[j];</span><br><span class="line">&#125;</span><br><span class="line">L.length--;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseSeqList</span><span class="params">(SeqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;顺序表为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; L.elem[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空线性表中数据</span></span><br><span class="line"><span class="function">Status <span class="title">ClearList</span><span class="params">(SeqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;线性表为空&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; L.length; j++)</span><br><span class="line">&#123;</span><br><span class="line">L.elem[j] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">L.length = <span class="number">0</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;线性表已经数据已清空&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线性表</span></span><br><span class="line"><span class="function">Status <span class="title">DestroySeqList</span><span class="params">(SeqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!L.elem)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;线性表不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(L.elem);</span><br><span class="line">L.elem = <span class="literal">NULL</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;顺序表成功销毁&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线性表是否为空</span></span><br><span class="line"><span class="function">Status <span class="title">ListEmpty</span><span class="params">(SeqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线性表的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">(SeqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回e在线性表中的位置</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询某个值在顺序表中是否存在，存在时，其位置是多少，其实就是将顺序表从第一个元素开始依次和这个值相比较。最多比较length次，最少比较一次。（表非空的情况下）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SeqList&amp; L, ElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> currentIndex = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;当前线性表为空&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> currentIndex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (L.elem[i] == e)</span><br><span class="line">&#123;</span><br><span class="line">currentIndex = i + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (currentIndex == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;数据  &quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;  不存在当前线性表中&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> currentIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PriorElem</span><span class="params">(SeqList&amp; L, ElemType cur_e, ElemType&amp; pre_e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//查找cur_e所在的位置</span></span><br><span class="line"><span class="type">int</span> flag = <span class="built_in">LocateElem</span>(L, cur_e);</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;该数据不存在直接前驱&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">pre_e = L.elem[flag - <span class="number">2</span>];</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果cur_e不是最后一个的值，就next_e返回cur_e后一个值</span></span><br><span class="line"><span class="function">Status <span class="title">NextElem</span><span class="params">(SeqList&amp; L, ElemType cur_e, ElemType&amp; next_e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> flag = <span class="built_in">LocateElem</span>(L, cur_e);</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == L.length)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;该数据不存在直接后继&quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">next_e = L.elem[flag];</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线性表的链式存储和实现"><a href="#线性表的链式存储和实现" class="headerlink" title="线性表的链式存储和实现"></a>线性表的链式存储和实现</h2><p><strong>一、定义</strong></p><p>链表属于一种离散的存储方式，离散是与连续相对的，数组是常见的连续存储方式。</p><p>线性的链式存储结构（链表）是指用任意的存储单元来依次存放线性表的结点，<strong>这组单元既可以是连续的，也可以是不连续的，甚至是零散的分布在内存中的任意位置上。</strong>因此，链表中的结点的逻辑次序和物理次序不一定相同。为了正确表示结点间的逻辑结构，在存储每个结点值的同时，还必须存储指示其后继结点的地址（或位置）信息，这两部分组成了链表中的结点结构（如图）。</p><p>链式存储的结构包含两个域：一个用于存储数据元素的信息，另一个用于存储直接后继的存储位置；<strong>存储数据元素信息的域称为数据域</strong>，<strong>存储直接后继存储位置的域称为指针域</strong>。</p><p><img src="/images/v2-6f53b0cb799d8142cba20b2babf771c2_720w.png" alt="img"></p><p>其中，data是数据域，用来存放结点的值。Next是指针域（也称链域），用来存放后继结点的地址。链表正是通过每个结点的链域将线性表的n个结点按其逻辑次序连接在一起的。结点有一个链域的称为单链表</p><p>整个单链表的存取必须从头结点开始进行，头指针指向head指向第一个结点。同时，由最后一个结点无后继，故其指针域为空，即NULL。</p><blockquote><p>数据结构中，在单链表的开始结点之前一般要附设一个类型相同的结点，称之为<strong>头结点</strong>。<em><strong>头结点的数据域可以不存储任何信息，头结点的指针域存储指向开始结点的指针</strong></em>，即第一个元素结点的存储位置。</p><p>头结点的好处：</p><ol><li>便于首元结点的处理</li></ol><p>首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理;</p><p>   2.便于空表和非空表的统一处理</p><p>无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。</p><p>在单链表中，任何两个元素的存储位置之间没有固定的联系，每个元素的存储位置都包含在其直接前驱结点的信息中。因此，单链表，在单链表中，想要取得第i个数据元素，必须从头指针出发寻找。所以，单链表是非随机存取的存储结构。</p></blockquote><h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100                  <span class="comment">//最大值</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;                <span class="comment">//元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">ElemType  data;               <span class="comment">//数据域 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LNode</span>* next;          <span class="comment">//指针域,指向一整个结点(结构体,该结构体中包含数据域和指针域) </span></span><br><span class="line">&#125;LNode, * LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了方便，可以利用typedef 给某种数据类型起个别名；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; Ok, Error &#125;;               <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个空的头结点</span></span><br><span class="line"><span class="function">Status <span class="title">InitList_L</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">L = <span class="keyword">new</span> LNode;      <span class="comment">//产生头结点，并使L指向该头结点(L也称头指针)</span></span><br><span class="line"><span class="keyword">if</span> (!L)  <span class="keyword">return</span> Error;          <span class="comment">//如果存储空间分配失败，返回ERROR</span></span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;                <span class="comment">//将指针域赋值为NULL</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;空的头结点创建成功/n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对线性表进行赋值 </span></span><br><span class="line"><span class="function">Status <span class="title">ValueList_L</span><span class="params">(LinkList&amp; L, ElemType e)</span> </span>&#123;</span><br><span class="line">LinkList s, p;</span><br><span class="line">p = L;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">s = <span class="keyword">new</span> LNode;       <span class="comment">//生成一个新结点 </span></span><br><span class="line">s-&gt;data = e;                 <span class="comment">//将e赋值给新结点的数据域 </span></span><br><span class="line">s-&gt;next = p-&gt;next;           <span class="comment">//将新结点与后一个结点的地址连接</span></span><br><span class="line">p-&gt;next = s;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对线性表进行销毁</span></span><br><span class="line"><span class="comment">//注意是销毁，头节点要删除</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在对单链表进行销毁操作时，从头结点开始逐一释放，释放前使q指向开始释放的结点，当开始结点不为空时，执行释放过程，先释放头结点，然后将L，q都向后移，依次释放，因为q始终是L的后继，所以最后一定是L留到最后，最后释放L结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么在delete L;之后还要将L赋值为空？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因为delete函数只是将之前动态分配给L的内存归还给系统，但是指针类型的结点L仍然存在，为了防止之后发生野指针访问，将L赋值为NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">DistoryList_L</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!L) &#123;            <span class="comment">//如果线性表不存在，返回ERROR </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;线性表不存在/n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line">LinkList q = L-&gt;next;    <span class="comment">//使q指向单链表的首元结点  </span></span><br><span class="line"><span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;     <span class="comment">//当q结点不为空时一直进入循环 </span></span><br><span class="line"><span class="keyword">delete</span> L;          <span class="comment">//释放L结点 </span></span><br><span class="line">L = q;            <span class="comment">//将q结点赋值给L结点 </span></span><br><span class="line">q = L-&gt;next;      <span class="comment">//将q结点赋值给L结点以后使q结点指向L的下一个结点 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> L;    <span class="comment">//此时q的值为NULL，L指向尾结点，将其释放</span></span><br><span class="line">L = <span class="literal">NULL</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;线性表已销毁/n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对线性表进行重置</span></span><br><span class="line"><span class="comment">//重置则是不销毁头结点</span></span><br><span class="line"><span class="function">Status <span class="title">ClearList_L</span><span class="params">(LinkList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!L-&gt;next) &#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;线性表为空表，不需要重置/n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line">LinkList p, q;</span><br><span class="line">p = L-&gt;next;          <span class="comment">//将单链表的头结点赋值给p</span></span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">q = p-&gt;next;      <span class="comment">//将单链表的首元结点赋值给q</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = q;</span><br><span class="line">&#125;</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//将头结点的指针域赋值为空 </span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;线性表已重置/n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线性表是否为空</span></span><br><span class="line"><span class="function">Status <span class="title">ListEmpty_L</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (L) &#123;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)       <span class="comment">//如果首元结点不存在 </span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;线性表是空表/n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;线性表不是空表/n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;线性表不存在，无法判断/n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线性表的长度</span></span><br><span class="line"><span class="comment">//获取线性表长度的核心思路是遍历单链表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength_L</span><span class="params">(LinkList L, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//L为带头结点的单链表的头指针，count为计数器</span></span><br><span class="line">LinkList p = L-&gt;next;    <span class="comment">//定义p为单链表L的指针域 </span></span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线性表某一位置对应的元素/</span></span><br><span class="line"><span class="comment">//与获取单链表的长度思路一样，获取单链表某一位置的元素也需要遍历单链表，只不过什么时候停止遍历由自己决定，可能不需要全部遍历。</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList p;</span><br><span class="line">p = L-&gt;next;       <span class="comment">//使p指向L的首元结点</span></span><br><span class="line"><span class="type">int</span>  count = <span class="number">1</span>;    <span class="comment">//count为计数器 ，赋值等于1的原因是从首元结点开始计数 </span></span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; count &lt; index) &#123;    <span class="comment">//顺着指针向后查找，直到p指向第index个元素或p为空 </span></span><br><span class="line">p = p-&gt;next;</span><br><span class="line">count++;        <span class="comment">//此时p一直指向第count个元素 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || count &gt; index) &#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;当前位置没有元素/n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;index&lt;&lt;<span class="string">&quot;个元素的值是：&quot;</span>&lt;&lt; p-&gt;data&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在线性表某一位置插入元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList&amp; L, <span class="type">int</span> index, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList p, q;</span><br><span class="line">p = L;      <span class="comment">//将线性表的头结点赋值给p</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;    <span class="comment">//count为计数器 </span></span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; count &lt; index - <span class="number">1</span>) &#123;      <span class="comment">//寻找第index-1个结点 </span></span><br><span class="line">p = p-&gt;next;         <span class="comment">//此时的p结点指向第index-1个结点 </span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!p || count &gt; index - <span class="number">1</span>) &#123;        <span class="comment">//越界判断,index小于1或是index大于表长加1 </span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;当前结点无法插入元素/n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line">q = <span class="keyword">new</span> LNode;</span><br><span class="line">q-&gt;data = e;            <span class="comment">//将e赋值到q的数据域当中</span></span><br><span class="line">q-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = q;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;元素插入成功/n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除线性表某一位置的元素</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteList_L</span><span class="params">(LinkList&amp; L, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList p, q;</span><br><span class="line">p = L;           <span class="comment">//将线性表的头结点赋值给p</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;   <span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; count &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">count++;            <span class="comment">//此时p一直指向第count个结点 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;next) || count &gt; index - <span class="number">1</span>) &#123;     <span class="comment">//越界判断 </span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;当前位置无法删除元素/n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line">q = <span class="literal">NULL</span>;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;当前位置元素已删除/n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//求线性表某一元素的前驱 </span></span><br><span class="line"><span class="function">Status <span class="title">PriorElem_L</span><span class="params">(LinkList L, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList p;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;       <span class="comment">//count为计数器 </span></span><br><span class="line">p = L;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next &amp;&amp; count &lt; index - <span class="number">1</span>) &#123;       <span class="comment">//寻找第index-1个结点 </span></span><br><span class="line">p = p-&gt;next;            <span class="comment">//p一直指向第count个结点 </span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(p-&gt;next) || count &gt; index - <span class="number">1</span>) &#123;       <span class="comment">//越界判断 </span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;当前位置无法求该元素的前驱/n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p != L)            <span class="comment">//如果要获取第一个元素的前驱，就是获取头结点数据域的值 </span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;该元素的前驱为：&quot;</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot;/n&quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;该位置的前驱是头结点/n头结点的数据域中存储的值为&quot;</span>&lt;&lt; p-&gt;data&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//求线性表某一元素的后继 </span></span><br><span class="line"><span class="function">Status <span class="title">NextElem_L</span><span class="params">(LinkList L, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">LinkList p;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">p = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; count &lt; index) &#123;        <span class="comment">//不断遍历寻找第index之后的结点 </span></span><br><span class="line">p = p-&gt;next;      <span class="comment">//p一直指向index-1的后一个结点 </span></span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//!p的目的是为了确保i不大于表长-1，count&gt;index的目的是为了确保index不小于0 </span></span><br><span class="line"><span class="keyword">if</span> (!p || count &gt; index) &#123;          <span class="comment">//越界判断</span></span><br><span class="line">cout&lt;&lt;<span class="string">&quot;当前位置无法求该元素的后继/n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line"> cout&lt;&lt;<span class="string">&quot;该元素的后继为：&quot;</span>&lt;&lt; p-&gt;data&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印线性表</span></span><br><span class="line"><span class="function">Status <span class="title">PrintList_L</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!L) &#123;            <span class="comment">//如果线性表不存在，返回ERROR </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;线性表不存在，无法打印/n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line">LinkList p;</span><br><span class="line">p = L-&gt;next;    <span class="comment">//将L的首元结点赋值给p ,为了不将头结点打印出来 </span></span><br><span class="line"><span class="keyword">while</span> (p) &#123;</span><br><span class="line">cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;   <span class="comment">//将p结点的数据域输出 </span></span><br><span class="line">p = p-&gt;next;    <span class="comment">//结点不断的向后移动 </span></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="介绍两种插法，头插法和尾插法"><a href="#介绍两种插法，头插法和尾插法" class="headerlink" title="介绍两种插法，头插法和尾插法"></a>介绍两种插法，头插法和尾插法</h2><p>头插法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">LinkList  <span class="title">CreateList1</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//从表尾到表头逆向建立单链表 L ，每次均在头结点之后插入元素</span></span><br><span class="line"></span><br><span class="line">                  LNode  *s ;</span><br><span class="line">                  <span class="type">int</span>  x ;</span><br><span class="line">                  L =<span class="keyword">new</span> LNode  ;                 </span><br><span class="line">     <span class="comment">// 创建头结点</span></span><br><span class="line">                  L-&gt;next = <span class="literal">NULL</span> ;                                                   </span><br><span class="line">     <span class="comment">// 初始为空链表</span></span><br><span class="line">                cin&gt;&gt;x;                                               </span><br><span class="line">     <span class="comment">// 输入结点的值</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">while</span>( x!= <span class="number">0</span>)&#123;                                                      </span><br><span class="line">                   <span class="comment">// 输入0 表示结束</span></span><br><span class="line">                         s = <span class="keyword">new</span> LNode  ;         </span><br><span class="line">                    <span class="comment">// 创建新结点</span></span><br><span class="line">                         s-&gt;data =  x ;</span><br><span class="line">                         s-&gt;next = L-&gt;next;                                          </span><br><span class="line">                     <span class="comment">// 将新结点插入表中，L为头指针</span></span><br><span class="line">                         L-&gt;next = s ;</span><br><span class="line">                      cin&gt;&gt;x;                                     </span><br><span class="line">                  &#125;                                                                         </span><br><span class="line">                 <span class="keyword">return</span>  L;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*采用头插法建立单链表，读入数据的顺序与生成的链表中元素的顺序是相反的。</span></span><br></pre></td></tr></table></figure><p>尾插法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList  <span class="title">CreateList2</span><span class="params">( LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                   <span class="comment">// 从表头到表尾正向建立单链表 L ，每次均在表尾插入元素</span></span><br><span class="line">                   <span class="type">int</span>  x ;                                      <span class="comment">// 设置元素类型为整型</span></span><br><span class="line">                   L = <span class="keyword">new</span> LNode  ;</span><br><span class="line">                   LNode  *s , *r = L ;                    <span class="comment">// r 为表尾指针</span></span><br><span class="line">                cin&gt;&gt;x ;                 <span class="comment">// 输入结点的值</span></span><br><span class="line">                   <span class="keyword">while</span>( x!= <span class="number">0</span>)&#123;                       <span class="comment">// 输入 0 表示结束</span></span><br><span class="line">                         s = <span class="keyword">new</span> LNode  ;</span><br><span class="line">                         s-&gt;data = x;</span><br><span class="line">                         r-next = s ;</span><br><span class="line">                         r = s ;                              <span class="comment">// r 指向新的表尾结点</span></span><br><span class="line">                         cin&gt;&gt;x ;</span><br><span class="line">                   &#125;</span><br><span class="line">                   r-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">// 尾结点指针置空</span></span><br><span class="line">                   <span class="keyword">return</span>  L ;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><blockquote><p>知识点</p><ol><li>头指针和头结点区分：不管带不带头结点，头指针都始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息</li><li>采用头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的，每个结点插入时间为O(1)一共为O(n)</li></ol></blockquote><h2 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><blockquote><ul><li><p>数据元素的个数可以自由扩充</p></li><li><p>插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高</p></li></ul></blockquote><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><blockquote><ul><li><p>存储密度小</p></li><li><p>存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问（顺藤摸瓜）</p></li></ul></blockquote><h2 id="其他链表"><a href="#其他链表" class="headerlink" title="其他链表"></a>其他链表</h2><p><a href="https://blog.csdn.net/wkd_007/article/details/130108368">【数据结构与算法】 - 双向链表 - 详细实现思路及代码_c语言双向链表不同结构体怎么找链表数据-CSDN博客</a></p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a><code>双向链表</code></h2><p>：在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</p><blockquote><p>双向链表每个结点除了存储数据data外，还有两个指针记录上一个结点和下一个结点的地址，分别是前驱指针prev和后继指针next.</p><p>这两个指针使得双向链表的插入、删除等操作不需要像单向链表那样需要遍历整个链表来寻找前驱节点，提高了链表的操作效率。双向链表与单链表的区别</p><p>单向链表是一种链表，在每个节点中包含指向下一个节点的指针。这意味着在单向链表中，节点只能从头开始遍历到尾部。在单向链表中，每个节点只存储指向下一个节点的指针，而不存储指向前一个节点的指针。</p><p>双向链表是一种链表，在每个节点中包含指向下一个节点和前一个节点的指针。这意味着在双向链表中，节点可以被从头到尾或从尾到头遍历。在双向链表中，每个节点存储指向前一个节点和下一个节点的指针。</p><p>因此，双向链表可以更方便地进行双向遍历，但是需要更多的内存空间来存储每个节点的两个指针。相比之下，在单向链表中，只需要一个指针来指向下一个节点，因此内存占用量更小。</p></blockquote><p>单链表</p><p><img src="/images/8241119f9a7f45b387906eb4567170c4.png" alt="img"></p><p>双向链表</p><p><img src="/images/65a12ddb33ec4ea29c2e4f967175456b.png" alt="在这里插入图片描述"></p><blockquote><p>特点</p><p>双向链表的特点：</p><ol><li>双向链表可以反向访问到链表的结点，因为它有指向前一个结点的指针piror；</li><li>带有头结点的双向链表，<strong>为空链表时，头结点的两个指针域都指向</strong><code>NULL</code>。</li><li>带有头结点的双向链表，为非空链表时，<br>头结点的前驱指针域指向<code>NULL</code>，后驱指针域指向第一个结点；<br>最后一个结点的前驱指针域指向前一个结点，后驱指针域指向<code>NULL</code>；<br>其他结点的前驱指针域指向前一个结点，后驱指针域指向后一个结点；</li></ol></blockquote><h3 id="代码综述"><a href="#代码综述" class="headerlink" title="代码综述"></a>代码综述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_DoubleListNode</span></span><br><span class="line">&#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_DoubleListNode</span>* prior;<span class="comment">// 前驱指针</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_DoubleListNode</span>* next;<span class="comment">// 后驱指针</span></span><br><span class="line">&#125;DoubleListNode,* DoubleLinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; Ok, Error &#125;;               <span class="comment">//枚举类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、分配一个结点的存储空间作为头结点，并将头指针指向头结点；</span></span><br><span class="line"><span class="comment">2、让头结点的 prior指针 和 next指针 都指向NULL，头结点的数据填一个无效值；</span></span><br><span class="line"><span class="comment">3、将头指针返回给函数调用者。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">DoubleLinkList <span class="title">ListInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DoubleLinkList list = <span class="keyword">new</span> DoubleListNode;</span><br><span class="line">list-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">list-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">list-&gt;data = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表插入数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">双向链表插入数据大致分为两个步骤：首先，找到插入位置n的前一个结点；其次，是插入新结点，可以：先连接新结点、再指向新结点的顺序。</span></span><br><span class="line"><span class="comment">先连接新结点：是先把新结点的两个指针域分别连接当前结点和下个结点，_new-&gt;prior = cur;、_new-&gt;next = cur-&gt;next;</span></span><br><span class="line"><span class="comment">再指向新结点：将当前节点的的指针域指向新节点，与旧节点断开，cur-&gt;next-&gt;prior = _new;、cur-&gt;next = _new;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListInsert</span><span class="params">(DoubleLinkList list, <span class="type">int</span> data, <span class="type">int</span> n)</span><span class="comment">// 将node插入到第n位,n从1开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (list == <span class="literal">NULL</span> || n &lt; <span class="number">1</span>) <span class="comment">// 判断参数有效性</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">DoubleListNode* cur = list;<span class="comment">// cur指向当前结点，初始化指向头结点</span></span><br><span class="line"><span class="type">int</span> cur_i = <span class="number">0</span>;<span class="comment">// cur_i表示当前结点的序号,0-头结点</span></span><br><span class="line"><span class="keyword">while</span> (cur &amp;&amp; cur_i &lt; (n - <span class="number">1</span>))<span class="comment">// 当前结点有效，且不是插入位置的前一个结点，就后移一个</span></span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">cur_i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!cur)<span class="comment">// 当前结点无效，说明已经移动到最后</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">&#125;</span><br><span class="line">DoubleListNode* _new = <span class="keyword">new</span> DoubleListNode;</span><br><span class="line">_new-&gt;data = data;</span><br><span class="line">_new-&gt;prior = cur;</span><br><span class="line">_new-&gt;next = cur-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;next)<span class="comment">// 在最后一个结点插入时，cur-&gt;next==NULL</span></span><br><span class="line">cur-&gt;next-&gt;prior = _new;</span><br><span class="line">cur-&gt;next = _new;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表删除数据</span></span><br><span class="line"><span class="comment">// 删除第n个结点，且将删除的值通过data传出</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListDelete</span><span class="params">(DoubleLinkList list, <span class="type">int</span>* data, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (list == <span class="literal">NULL</span> || data == <span class="literal">NULL</span> || n &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">DoubleListNode* cur = list;<span class="comment">// cur指向当前结点，初始化指向头结点</span></span><br><span class="line"><span class="type">int</span> cur_i = <span class="number">0</span>;<span class="comment">// cur_i表示当前结点的序号,0-头结点</span></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur_i &lt; (n - <span class="number">1</span>))</span><br><span class="line">&#123;<span class="comment">// 下个结点有效，且当前位置不是删除位置的前一个，就后移一个</span></span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">cur_i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!cur-&gt;next)<span class="comment">// 下个结点无效，说明已经移动到最后</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">&#125;</span><br><span class="line">DoubleListNode* _delete = cur-&gt;next;</span><br><span class="line">_delete-&gt;prior-&gt;next = _delete-&gt;next;</span><br><span class="line">_delete-&gt;next-&gt;prior = _delete-&gt;prior;</span><br><span class="line"><span class="keyword">delete</span> _delete;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表查找数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListFind</span><span class="params">(DoubleLinkList list, <span class="type">int</span>* data, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (list == <span class="literal">NULL</span> || data == <span class="literal">NULL</span> || n &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">DoubleListNode* cur = list-&gt;next;<span class="comment">// 指向第一个节点</span></span><br><span class="line"><span class="type">int</span> cur_i = <span class="number">1</span>;<span class="comment">// i表示当前结点的序号</span></span><br><span class="line"><span class="keyword">while</span> (cur &amp;&amp; cur_i &lt; n)<span class="comment">// 当前结点有效，且当前位置不是查找位置n，就往后移动一个</span></span><br><span class="line">&#123;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">cur_i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!cur)<span class="comment">// 当前结点无效，说明已经移动到最后</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>; </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">&#125;</span><br><span class="line">*data = cur-&gt;data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;个结点值为&quot;</span> &lt;&lt; *data &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表的销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListDestroy</span><span class="params">(DoubleLinkList list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">DoubleListNode* cur = list-&gt;next;<span class="comment">// 指向第一个节点</span></span><br><span class="line">DoubleListNode* next = <span class="literal">NULL</span>;<span class="comment">// 用于保存下个结点地址</span></span><br><span class="line"><span class="keyword">while</span> (cur)<span class="comment">// 当前结点有效，就往后移动</span></span><br><span class="line">&#123;</span><br><span class="line">next = cur-&gt;next;<span class="comment">// 保存下个结点地址</span></span><br><span class="line"><span class="keyword">delete</span> cur;<span class="comment">// 删除当前结点、并释放内存</span></span><br><span class="line">cur = next;<span class="comment">// 将当前结点指针指向下个结点</span></span><br><span class="line">&#125;</span><br><span class="line">list-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">list-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote><ol><li><p><strong>循环链表</strong>:是一种头尾相接的链表(表中最后一个结点的指针域指向头结点，整个链表形成一个环</p></li><li><p><strong>优点:</strong> 从表中任一结点出发均可找到表中其他结点</p><ol start="3"><li><p>循环链表中<strong>没有NULL指针</strong>，当遍历链表时，终止条件是<strong>最后一个结点的指针域是否等于头指针</strong></p></li><li><p>尾指针表示单循环链表:</p><pre><code>首元结点的存储位置: R-&gt;next-&gt;next;最后一个结点的存储位置: R</code></pre><p>&#x2F;&#x2F;用尾指针表示单循环链表访问首尾结点时间复杂度都为O(1)</p><p>需要注意的是，虽然循环链表成环状，但本质上还是链表，因此在循环链表中，依然能够找到头指针和首元节点等。循环链表和普通链表相比，唯一的不同就是循环链表首尾相连，其他都完全一样。</p><p><img src="/images/1b33a2d3487c49b18886e28aa559e148.png" alt="在这里插入图片描述"></p></li></ol></li></ol></blockquote><h3 id="代码综述-1"><a href="#代码综述-1" class="headerlink" title="代码综述"></a>代码综述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ListNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_ListNode</span>* next; <span class="comment">// 指向结点的指针</span></span><br><span class="line">&#125;ListNode,* CyclicList;<span class="comment">//定义链表结点：包含数据域，指针域 .定义循环链表头指针，是指向结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; Ok, Error &#125;;               <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环链表初始化</span></span><br><span class="line"><span class="function">CyclicList <span class="title">ListInit</span><span class="params">()</span><span class="comment">// 创建一个头结点，让其指针域指向自己，并返回头结点地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">CyclicList list = <span class="keyword">new</span> ListNode;</span><br><span class="line">list-&gt;next = list; <span class="comment">// 指向头结点</span></span><br><span class="line">list-&gt;data = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环链表插入数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListInsert</span><span class="params">(CyclicList list, <span class="type">int</span> data, <span class="type">int</span> n)</span><span class="comment">// 将node插入到第n位,n从1开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (list == <span class="literal">NULL</span> || n &lt; <span class="number">1</span>) <span class="comment">// 判断参数有效性</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">ListNode* cur = list;<span class="comment">// cur指向当前结点，初始化指向头结点</span></span><br><span class="line"><span class="type">int</span> cur_i = <span class="number">0</span>;<span class="comment">// i表示当前结点的序号,0-头结点</span></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next != list &amp;&amp; cur_i &lt; (n - <span class="number">1</span>))</span><br><span class="line">&#123;<span class="comment">//不是最后一个结点，且不是插入位置的前一个结点，就后移一个</span></span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">cur_i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;next == list)<span class="comment">// 移动到最后结点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur_i != (n - <span class="number">1</span>))<span class="comment">// 仍然不是插入位置前一个结点，出错</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">ListNode* _new = <span class="keyword">new</span> ListNode;</span><br><span class="line">_new-&gt;data = data;</span><br><span class="line">_new-&gt;next = cur-&gt;next;</span><br><span class="line">cur-&gt;next = _new;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环链表删除数据</span></span><br><span class="line"><span class="comment">// 删除第n个结点，且将删除的值通过data传出</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListDelete</span><span class="params">(CyclicList list, <span class="type">int</span>* data, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (list == <span class="literal">NULL</span> || data == <span class="literal">NULL</span> || n &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">ListNode* cur = list;<span class="comment">// cur指向当前结点，初始化指向头结点</span></span><br><span class="line"><span class="type">int</span> cur_i = <span class="number">0</span>;<span class="comment">// i表示当前结点的序号,0-头结点</span></span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next != list &amp;&amp; cur_i &lt; (n - <span class="number">1</span>))</span><br><span class="line">&#123;<span class="comment">//不是最后一个结点，且不是删除位置的前一个结点，就后移一个</span></span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">cur_i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;next == list)<span class="comment">// 移动到最后结点 </span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">&#125;</span><br><span class="line">ListNode* _delete = cur-&gt;next;</span><br><span class="line">cur-&gt;next = _delete-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> _delete;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环链表查找数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListFind</span><span class="params">(CyclicList list, <span class="type">int</span>* data, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (list == <span class="literal">NULL</span> || data == <span class="literal">NULL</span> || n &lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">ListNode* cur = list-&gt;next;<span class="comment">// 指向第一个节点</span></span><br><span class="line"><span class="type">int</span> cur_i = <span class="number">1</span>;<span class="comment">// i表示当前结点的序号</span></span><br><span class="line"><span class="keyword">if</span> (cur == list)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (cur-&gt;next != list &amp;&amp; cur_i &lt; n)</span><br><span class="line">&#123;<span class="comment">//不是最后一个结点，且当前位置不是查找位置n，就往后移动一个</span></span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">cur_i++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur-&gt;next == list)<span class="comment">// 移动到最后结点 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cur_i != n)<span class="comment">// 仍然不是查找位置n，出错</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">*data = cur-&gt;data;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;个结点的值是&quot;</span> &lt;&lt; *data &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环链表的销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListDestroy</span><span class="params">(CyclicList list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ListNode* cur = list-&gt;next;<span class="comment">// 指向第一个节点</span></span><br><span class="line">ListNode* next = <span class="literal">NULL</span>;<span class="comment">// 用于保存下个结点地址</span></span><br><span class="line"><span class="keyword">while</span> (cur != list)<span class="comment">// 不是最后一个结点的指针域就后移</span></span><br><span class="line">&#123;</span><br><span class="line">next = cur-&gt;next;<span class="comment">// 保存下个结点地址</span></span><br><span class="line"><span class="keyword">delete</span> cur;<span class="comment">// 删除当前结点、并释放内存</span></span><br><span class="line">cur = next;<span class="comment">// 将当前结点指针指向下个结点</span></span><br><span class="line">&#125;</span><br><span class="line">list-&gt;next = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>选择数组还是链表？</li></ul><p>1.插入、删除和随机访问的时间复杂度<br>数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。<br>链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。</p><p>2.数组缺点<br>1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。<br>2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。<br>3.链表缺点<br>1）内存空间消耗更大，因为需要额外的空间存储指针信息。<br>2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片。<br>4.如何选择？<br>数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。<br>如果代码对内存的使用非常苛刻，那数组就更适合。</p></blockquote><h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="一、栈的基本概念"><a href="#一、栈的基本概念" class="headerlink" title="一、栈的基本概念"></a>一、栈的基本概念</h3><h4 id="1、栈的定义"><a href="#1、栈的定义" class="headerlink" title="1、栈的定义"></a>1、栈的定义</h4><p><strong>栈</strong>（Stack）：是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。</p><p><img src="/images/20210218204524571.png" alt="img"></p><p><strong>栈顶</strong>（Top）：线性表允许进行插入删除的那一端。<br><strong>栈底</strong>（Bottom）：固定的，不允许进行插入和删除的另一端。<br><strong>空栈</strong>：不含任何元素的空表。</p><p><strong>栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构</strong></p><h3 id="二、栈的顺序存储结构"><a href="#二、栈的顺序存储结构" class="headerlink" title="二、栈的顺序存储结构"></a>二、栈的顺序存储结构</h3><p>1、栈的顺序存储<br>采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。<br>若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定位top等于-1。<br>栈的基本操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 50  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;   <span class="comment">//ElemType的类型根据实际情况而定，这里假定为int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top;    <span class="comment">//用于栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; Ok, Error &#125;;               <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack* S)</span> </span>&#123;</span><br><span class="line">    S-&gt;top = <span class="number">-1</span>;    <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//栈空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//不空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入元素e为新的栈顶元素*/</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack* S, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//满栈</span></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == MAXSIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;top++;   <span class="comment">//栈顶指针增加一</span></span><br><span class="line">    S-&gt;data[S-&gt;top] = e;    <span class="comment">//将新插入元素赋值给栈顶空间</span></span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack* S, ElemType* e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = S-&gt;data[S-&gt;top];   <span class="comment">//将要删除的栈顶元素赋值给e</span></span><br><span class="line">    S-&gt;top--;   <span class="comment">//栈顶指针减一</span></span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*读栈顶元素*/</span></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack *S, ElemType* e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>) &#123;   <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = S-&gt;data[S-&gt;top];   <span class="comment">//记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="偏向于ACM的栈实现"><a href="#偏向于ACM的栈实现" class="headerlink" title="偏向于ACM的栈实现"></a>偏向于ACM的栈实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"><span class="comment">// 这里使用 st[0] (即 *st) 代表栈中元素数量，同时也是栈顶下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 压栈 ：</span></span><br><span class="line">st[++*st] = var1;</span><br><span class="line"><span class="comment">// 取栈顶 ：</span></span><br><span class="line"><span class="type">int</span> u = st[*st];</span><br><span class="line"><span class="comment">// 弹栈 ：注意越界问题, *st == 0 时不能继续弹出</span></span><br><span class="line"><span class="keyword">if</span> (*st) --*st;</span><br><span class="line"><span class="comment">// 清空栈</span></span><br><span class="line">*st = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++ 中的 STL 也提供了一个容器 std::stack，使用前需要引入 stack 头文件。</span></span><br><span class="line"><span class="comment">STL 中的 stack 容器提供了一众成员函数以供调用，其中较为常用的有：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">元素访问</span></span><br><span class="line"><span class="comment">st.top() 返回栈顶</span></span><br><span class="line"><span class="comment">修改</span></span><br><span class="line"><span class="comment">st.push() 插入传入的参数到栈顶</span></span><br><span class="line"><span class="comment">st.pop() 弹出栈顶</span></span><br><span class="line"><span class="comment">容量</span></span><br><span class="line"><span class="comment">st.empty() 返回是否为空</span></span><br><span class="line"><span class="comment">st.size() 返回元素数量</span></span><br><span class="line"><span class="comment">此外，std::stack 还提供了一些运算符。较为常用的是使用赋值运算符 = 为 stack 赋值，示例：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 新建两个栈 st1 和 st2</span></span><br><span class="line"><span class="comment">std::stack&lt;int&gt; st1, st2;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 为 st1 装入 1</span></span><br><span class="line"><span class="comment">st1.push(1);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 将 st1 赋值给 st2</span></span><br><span class="line"><span class="comment">st2 = st1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 输出 st2 的栈顶元素</span></span><br><span class="line"><span class="comment">cout &lt;&lt; st2.top() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// 输出: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="共享栈（两栈共享空间）"><a href="#共享栈（两栈共享空间）" class="headerlink" title="共享栈（两栈共享空间）"></a>共享栈（两栈共享空间）</h4><h5 id="（1）共享栈概念"><a href="#（1）共享栈概念" class="headerlink" title="（1）共享栈概念"></a>（1）共享栈概念</h5><p>利用栈底位置相对不变的特征，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如下图所示：</p><p><img src="/images/2021021909353762.png" alt="在这里插入图片描述"></p><p><strong>两个栈的栈顶指针都指向栈顶元素，top0&#x3D;-1时0号栈为空，top1&#x3D;MaxSize时1号栈为空；仅当两个栈顶指针相邻（top0+1&#x3D;top1）时，判断为栈满。当0号栈进栈时top0先加1再赋值，1号栈进栈时top1先减一再赋值出栈时则刚好相反。</strong></p><h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*两栈共享空间结构*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 50  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;   <span class="comment">//ElemType的类型根据实际情况而定，这里假定为int</span></span><br><span class="line"><span class="comment">/*两栈共享空间结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">ElemType data[MAXSIZE];</span><br><span class="line"><span class="type">int</span> top0=<span class="number">0</span>;<span class="comment">//栈0栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1 = MAXSIZE;<span class="comment">//栈1栈顶指针</span></span><br><span class="line">&#125;SqDoubleStack;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; Ok, Error &#125;;               <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入元素e为新的栈顶元素*/</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqDoubleStack* S, ElemType e, <span class="type">int</span> stackNumber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top0 + <span class="number">1</span> == S-&gt;top1) &#123;   <span class="comment">//栈满</span></span><br><span class="line">        <span class="keyword">return</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stackNumber == <span class="number">0</span>) &#123;   <span class="comment">//栈0有元素进栈</span></span><br><span class="line">        S-&gt;data[++S-&gt;top0] = e; <span class="comment">//若栈0则先top0+1后给数组元素赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber == <span class="number">1</span>) &#123; <span class="comment">//栈1有元素进栈</span></span><br><span class="line">        S-&gt;data[--S-&gt;top1] = e; <span class="comment">//若栈1则先top1-1后给数组元素赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqDoubleStack* S, ElemType* e, <span class="type">int</span> stackNumber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stackNumber == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S-&gt;top0 == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Error;   <span class="comment">//说明栈0已经是空栈，溢出</span></span><br><span class="line">        &#125;</span><br><span class="line">        *e = S-&gt;data[S-&gt;top0--]; <span class="comment">//将栈0的栈顶元素出栈，随后栈顶指针减1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S-&gt;top1 == MAXSIZE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Error;   <span class="comment">//说明栈1是空栈，溢出</span></span><br><span class="line">        &#125;</span><br><span class="line">        *e = S-&gt;data[S-&gt;top1++];    <span class="comment">//将栈1的栈顶元素出栈，随后栈顶指针加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三、栈的顺序存储结构"><a href="#三、栈的顺序存储结构" class="headerlink" title="三、栈的顺序存储结构"></a>三、栈的顺序存储结构</h3><p>　对于链栈来说，基本不存在栈满的情况，除非内存已经没有使用空间了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*两栈共享空间结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StackNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> data;<span class="comment">//结点数据域</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">StackNode</span>* next;<span class="comment">//结点指针域</span></span><br><span class="line">&#125;StackNode, * Linktop;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈的数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkStack</span></span><br><span class="line">&#123;</span><br><span class="line">Linktop top;   <span class="comment">//栈顶结点,定义了一个指向上个结构体的指针</span></span><br><span class="line"><span class="type">int</span> count;<span class="comment">//元素个数</span></span><br><span class="line">&#125;LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈:先将压入元素放入到链表表中，然后再将栈顶指针指向压入的元素，然后count+1.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(LinkStack* stack, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!stack)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">StackNode* node = <span class="keyword">new</span> StackNode;</span><br><span class="line">node-&gt;next = stack-&gt;top;           <span class="comment">//将元素加入链表中</span></span><br><span class="line">node-&gt;data = e;</span><br><span class="line">stack-&gt;top = node;                 <span class="comment">//栈顶元素指向压入元素</span></span><br><span class="line">stack-&gt;count++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹栈:栈顶指针指向要弹出元素前置结点，然后释放弹出元素内存空间，然后count-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(LinkStack* stack, <span class="type">int</span>* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!stack &amp;&amp; stack-&gt;count)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span><span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">StackNode* node = stack-&gt;top;</span><br><span class="line">*e = node-&gt;data;</span><br><span class="line">stack-&gt;top = node-&gt;next;   <span class="comment">//栈顶指针指向新的栈顶元素</span></span><br><span class="line"><span class="keyword">delete</span> node;                <span class="comment">//释放元素空间</span></span><br><span class="line">stack-&gt;count--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。</p><p>为了描述方便，以下举例及伪代码以维护一个整数的单调递增栈为例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert x</span><br><span class="line"><span class="keyword">while</span> !sta.<span class="built_in">empty</span>() &amp;&amp; sta.<span class="built_in">top</span>()&lt;x</span><br><span class="line">    sta.<span class="built_in">pop</span>()</span><br><span class="line">sta.<span class="built_in">push</span>(x)</span><br></pre></td></tr></table></figure><h3 id="洛谷单调栈"><a href="#洛谷单调栈" class="headerlink" title="洛谷单调栈"></a>洛谷单调栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for(int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e6</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> stk[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; !(a[stk[top]]&gt;=a[i]))</span><br><span class="line">ans[stk[top--]]=i;</span><br><span class="line">stk[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造一个单调递减栈</span></span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h3 id="一、队列的基本概念"><a href="#一、队列的基本概念" class="headerlink" title="一、队列的基本概念"></a>一、队列的基本概念</h3><h4 id="1、队列的定义"><a href="#1、队列的定义" class="headerlink" title="1、队列的定义"></a>1、队列的定义</h4><p><strong>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</strong><br>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p><p><img src="/images/20210219144731888.png" alt="img"></p><p><strong>队头（Front）</strong>：允许删除的一端，又称队首。<br><strong>队尾（Rear）</strong>：允许插入的一端。<br><strong>空队列</strong>：不包含任何元素的空表。</p><p>向队列中插入新的数据元素称为<strong>入队</strong>，新入队的元素就成为了队列的队尾元素。</p><p>从队列中删除队头元素称为<strong>出队</strong>，其后继元素成为新的队头元素。</p><h3 id="二、队列的顺序存储结构"><a href="#二、队列的顺序存储结构" class="headerlink" title="二、队列的顺序存储结构"></a>二、队列的顺序存储结构</h3><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针 front指向队头元素，队尾指针 rear 指向队尾元素的下一个位置。</p><p>但是会有假溢出的出现，因此需要另外一种队列，这种<strong>队列的这种头尾相接的顺序存储结构称为循环队列。</strong></p><p>当队首指针Q-&gt;front &#x3D; MAXSIZE-1后，再前进一个位置就自动到0，这可以利用除法取余运算（%）来实现。</p><p>初始时：Q-&gt;front &#x3D; Q-&gt;rear&#x3D;0。<br>队首指针进1：Q-&gt;front &#x3D; (Q-&gt;front + 1) % MAXSIZE。<br>队尾指针进1：Q-&gt;rear &#x3D; (Q-&gt;rear + 1) % MAXSIZE。<br>队列长度：(Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 50<span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">QElemType data[MAXSIZE];<span class="comment">//存放队列元素</span></span><br><span class="line"><span class="type">int</span> front, rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span>&#123;OK,ERROR&#125;;</span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(QElemType c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; c&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化一个空队列Q */</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue* Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将Q清为空队列 */</span></span><br><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(SqQueue* Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="comment">/* 队列空的标志 */</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回Q的元素个数，也就是队列的当前长度 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  (Q.rear - Q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(SqQueue Q, QElemType* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="comment">/* 队列空 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue* Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front)    <span class="comment">/* 队列满的判断 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = e;            <span class="comment">/* 将元素e赋值给队尾 */</span></span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE;<span class="comment">/* rear指针向后移一位置， */</span></span><br><span class="line">    <span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line">    <span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从队头到队尾依次对队列Q中每个元素输出 */</span></span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    i = Q.front;</span><br><span class="line">    <span class="keyword">for</span> (i = Q.front; i != Q.rear; i = (i + <span class="number">1</span>) % MAXSIZE) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(Q.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ACM队列相关"><a href="#ACM队列相关" class="headerlink" title="ACM队列相关"></a>ACM队列相关</h2><blockquote><p>队列（queue）是一种具有「先进入队列的元素一定先出队列」性质的表。由于该性质，队列通常也被称为先进先出（first in first out）表，简称 FIFO 表。</p></blockquote><blockquote><h2 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h2><p>通常用一个数组模拟一个队列，用两个变量标记队列的首尾。</p><p>队列操作对应的代码如下：</p><ul><li>插入元素：<code>q[++qr] = x;</code></li><li>删除元素：<code>ql++;</code></li><li>访问队首：<code>q[ql]</code></li><li>访问队尾：<code>q[qr]</code></li><li>清空队列：<code>ql = 1; qr = 0;</code></li></ul></blockquote><blockquote><p>STL 中的 <code>queue</code> 容器提供了一众成员函数以供调用。其中较为常用的有：</p><ul><li>元素访问<ul><li><code>q.front()</code> 返回队首元素</li><li><code>q.back()</code> 返回队尾元素</li></ul></li><li>修改<ul><li><code>q.push()</code> 在队尾插入元素</li><li><code>q.pop()</code> 弹出队首元素</li></ul></li><li>容量<ul><li><code>q.empty()</code> 队列是否为空</li><li><code>q.size()</code> 返回队列中元素的数量</li></ul></li></ul></blockquote><blockquote><p>STL 中的 <code>deque</code> 容器提供了一众成员函数以供调用。其中较为常用的有：</p><ul><li>元素访问<ul><li><code>q.front()</code> 返回队首元素</li><li><code>q.back()</code> 返回队尾元素</li></ul></li><li>修改<ul><li><code>q.push_back()</code> 在队尾插入元素</li><li><code>q.pop_back()</code> 弹出队尾元素</li><li><code>q.push_front()</code> 在队首插入元素</li><li><code>q.pop_front()</code> 弹出队首元素</li><li><code>q.insert()</code> 在指定位置前插入元素（传入迭代器和元素）</li><li><code>q.erase()</code> 删除指定位置的元素（传入迭代器）</li></ul></li><li>容量<ul><li><code>q.empty()</code> 队列是否为空</li><li><code>q.size()</code> 返回队列中元素的数量</li></ul></li></ul></blockquote><h3 id="三、队列的链式存储结构"><a href="#三、队列的链式存储结构" class="headerlink" title="三、队列的链式存储结构"></a>三、队列的链式存储结构</h3><blockquote><h4 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h4><p><strong>队列的链式存储结构表示为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表，只不过它只能尾进头出而已</strong>。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 50<span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="comment">/*链式队列结点*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">ElemType data;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LinkNode</span>* next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="comment">/*链式队列*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">LinkNode* front, * rear;<span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span>&#123;OK,ERROR&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队列初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue* Q)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Q-&gt;front = Q-&gt;rear = <span class="keyword">new</span> LinkNode;<span class="comment">//建立头结点</span></span><br><span class="line">Q-&gt;front-&gt;next = <span class="literal">NULL</span>;<span class="comment">//初始为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队列入队</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue* Q, ElemType e)</span> </span>&#123;</span><br><span class="line">LinkNode *s = <span class="keyword">new</span> LinkNode;</span><br><span class="line">s-&gt;data = e;</span><br><span class="line">s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">Q-&gt;rear-&gt;next = s;<span class="comment">//把拥有元素e新结点s赋值给原队尾结点的后继</span></span><br><span class="line">Q-&gt;rear = s;<span class="comment">//把当前的s设置为新的队尾结点</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR*/</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue* Q, ElemType* e)</span> </span>&#123;</span><br><span class="line">LinkNode *p;</span><br><span class="line"><span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) &#123;</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line">p = Q-&gt;front-&gt;next;<span class="comment">//将欲删除的队头结点暂存给p</span></span><br><span class="line">*e = p-&gt;data;<span class="comment">//将欲删除的队头结点的值赋值给e</span></span><br><span class="line">Q-&gt;front-&gt;next = p-&gt;next;<span class="comment">//将原队头结点的后继赋值给头结点后继</span></span><br><span class="line"><span class="comment">//若删除的队头是队尾，则删除后将rear指向头结点</span></span><br><span class="line"><span class="keyword">if</span> (Q-&gt;rear == p) </span><br><span class="line">&#123;</span><br><span class="line">Q-&gt;rear = Q-&gt;front;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列（deque）是队列的一种变形，一般队列只能在队尾添加元素（push），在队首删除元素（pop），双端队列则同时在队首或者队尾执行添加和删除工作。C++中，使用双端队列需要包含头文件<deque>。C++中队列的基本操作如下：</deque></p><blockquote><p>push_back()：在队列尾部添加元素，无返回值。这个操作跟普通队列（queue）的push()方法类似，在队列的尾部添加一个元素；<br>push_front()：在队列头部添加元素，无返回值；<br>pop_back()：删除队列尾部的元素，无返回值；<br>pop_front()：删除队列头部的元素，无返回值；<br>front() ：获得队列头部元素。此函数返回值为队列的头部元素，常与pop_front()函数一起，先通过front()获得队列头部元素，然后用pop_front()将其从队列中删除；<br>back()： 获得队列尾部元素。此函数返回值为队列的尾部元素，常与pop_back()函数一起，先通过back()获得队列头部元素，然后用pop_back()将其从队列中删除；<br>size()：获得队列大小。此函数返回队列的大小，返回值是“size_t”类型的数据，“size_t”是“unsigned int”的别名；<br>empty() ：判断队列是否为空。此函数返回队列是否为空，返回值是bool类型。队列空：返回true；不空：返回false。</p></blockquote><blockquote><p>堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于&#x2F;小于等于其父亲的键值。</p><p>每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆。STL 中的 <code>priority_queue</code> 其实就是一个大根堆。</p><p>（小根）堆主要支持的操作有：插入一个数、查询最小值、删除最小值、合并两个堆、减小一个元素的值。</p></blockquote><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>顾名思义，单调队列的重点分为「单调」和「队列」。</p><p>「单调」指的是元素的「规律」——递增（或递减）。</p><blockquote><p>例如我们构造一个单调递增的队列会如下：</p><p>原序列为：</p><table><thead><tr><th><code>1</code></th><th><code>1 3 -1 -3 5 3 6 7 </code></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>因为我们始终要维护队列保证其 <strong>递增</strong> 的特点，所以会有如下的事情发生：</p><table><thead><tr><th align="left">操作</th><th align="left">队列状态</th></tr></thead><tbody><tr><td align="left">1 入队</td><td align="left"><code>&#123;1&#125;</code></td></tr><tr><td align="left">3 比 1 大，3 入队</td><td align="left"><code>&#123;1 3&#125;</code></td></tr><tr><td align="left">-1 比队列中所有元素小，所以清空队列 -1 入队</td><td align="left"><code>&#123;-1&#125;</code></td></tr><tr><td align="left">-3 比队列中所有元素小，所以清空队列 -3 入队</td><td align="left"><code>&#123;-3&#125;</code></td></tr><tr><td align="left">5 比 -3 大，直接入队</td><td align="left"><code>&#123;-3 5&#125;</code></td></tr><tr><td align="left">3 比 5 小，5 出队，3 入队</td><td align="left"><code>&#123;-3 3&#125;</code></td></tr><tr><td align="left">-3 已经在窗体外，所以 -3 出队；6 比 3 大，6 入队</td><td align="left"><code>&#123;3 6&#125;</code></td></tr><tr><td align="left">7 比 6 大，7 入队</td><td align="left"><code>&#123;3 6 7&#125;</code></td></tr></tbody></table></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, n) for (int i = a; i &lt;= n; i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> frep(i, a, n) for (int i = a; i &gt;= n; i--)</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> q2[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; q[h] + m &lt;= i)</span><br><span class="line">&#123;</span><br><span class="line">    h++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; a[i]&lt;a[q[t]])</span><br><span class="line">&#123;</span><br><span class="line">    t--;</span><br><span class="line">&#125;</span><br><span class="line">q[++t] = i;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=m)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;a[q[h]]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"> h = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h &lt;= t &amp;&amp; q2[h] + m &lt;= i)</span><br><span class="line">    &#123;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &lt;= t &amp;&amp; a[i] &gt; a[q2[t]])</span><br><span class="line">    &#123;</span><br><span class="line">        t--;</span><br><span class="line">    &#125;</span><br><span class="line">    q2[++t] = i;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= m)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[q2[h]] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><blockquote><p>串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集</p><p>串的存储结构：定长顺序存储表示、堆分配存储表示、块链存储表示</p><p>子串的定位操作通常称为串的模式匹配，它求的是子串在主串中的位置。</p></blockquote><p>1、<strong>串的概念</strong><br>字符串简称串，是一种特殊的<a href="https://so.csdn.net/so/search?q=%E7%BA%BF%E6%80%A7%E8%A1%A8&spm=1001.2101.3001.7020">线性表</a>，它的数据元素仅由一个字符组成。</p><p>2、<strong>串的定义</strong><br>串(String)是由零个或多个字符组成的有限序列，又称字符串。</p><blockquote><p>其中s是串名,用双引号括起来的字符序列为串值，但引号本身并不属于串的内容。ai(1&lt;&#x3D;i&lt;&#x3D;n)是一个任意字符,它称为串的元素,是构成串的基本单位，i是它在整个串中的序号；n为串的长度,表示串中所包含的字符个数。</p></blockquote><ul><li><p><strong>串的长度</strong>：串中字符的个数</p></li><li><p><strong>空串</strong>：长度为0的串</p></li><li><p><strong>空格串</strong>：0个或多个空格字符组成的串</p></li><li><p><strong>子串</strong>：串中任意连续字符组成的子序列</p></li><li><p><strong>主串</strong>：包含子串的串</p></li><li><p><strong>位置</strong>：字符在串中的序号。子串在主串中的位置是其第一个字符在主串中的位置。</p></li><li><p><strong>串的相等</strong>：长度和对应位置字符都相等</p></li><li><p><strong>连接 concatenation</strong>：连接是一个重要的二进制操作。对于任意两个主串中的子串s和t，它们的连接根据放置s和t 的前后顺序来定符号序列。例如，子串s &#x3D; love，t &#x3D; hug，那么st 就是lovehug，ts 就是huglove。</p></li><li><p><strong>前缀和后缀 prefixes and suffixes</strong>：字符串s 可以说是t 的前缀，如果存在一个字符串u 满足条件t &#x3D;su。如果u 是非空的，那么可以说s 是t 的一个合适的前缀；相应地，串s 可以说t 的后缀如果存在一个串u 满足条件t&#x3D;us。如果u 是非空的，s 可以说是t 的一个合适的后缀。前缀和后缀可以说是t 的子串。</p></li><li><p><strong>旋转</strong>：串s &#x3D; uv 可以被说成t 的旋转如果t &#x3D; vu. 举个例子，当u &#x3D; 00110, v &#x3D; 01的时候，串0011001 是0100110 的旋转。</p></li><li><p><strong>逆转</strong>:串的逆转就是具有相同符号单顺序相反的字符串。例如，如果s&#x3D;abc（a、b和c是字母表中符号），那么s 的逆转就是cba。一个与自身相反的字符串（例如，s&#x3D;madam，逆转还是madam）被称为回文 palindrome，它还包括空字符串和所有长度为1的字符串。</p><p>设A和B分别为 A&#x3D;‘This is a string’ B&#x3D;‘is’ 则B是A的子串，A为主串。B在A中出现了两次，其中首次出现所对应的主串位置是3。因此，称B在A中的位置为3。 特别地，空串是任意串的子串，任意串是其自身的子串。</p></li></ul><h3 id="二、串的存储结构"><a href="#二、串的存储结构" class="headerlink" title="二、串的存储结构"></a>二、串的存储结构</h3><h4 id="1、定长顺序存储表示"><a href="#1、定长顺序存储表示" class="headerlink" title="1、定长顺序存储表示"></a>1、定长顺序存储表示</h4><p>类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 255   <span class="comment">//串的最大存储容量定义为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> SString[MAXSTRLEN + <span class="number">1</span>];   <span class="comment">//定义串的类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> status;</span><br><span class="line"><span class="comment">//创建一个串</span></span><br><span class="line"><span class="function">status <span class="title">STrAssign</span><span class="params">(SString&amp; T, <span class="type">char</span>* chars)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//创建一个值等于chars的串</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(chars) &gt; MAXSTRLEN)  <span class="keyword">return</span> ERROR;</span><br><span class="line">T[<span class="number">0</span>] = <span class="built_in">strlen</span>(chars);</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= T[<span class="number">0</span>]; i++)</span><br><span class="line">&#123;</span><br><span class="line">T[i] = *(chars + i - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断串是否为空串</span></span><br><span class="line"><span class="function">status <span class="title">StrEmpty</span><span class="params">(SString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//判断S是否为空串</span></span><br><span class="line"><span class="keyword">if</span> (S[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrPrint</span><span class="params">(SString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//输出字符串T</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= T[<span class="number">0</span>]; i++)</span><br><span class="line">cout &lt;&lt; T[i];</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回串的元素个数</span></span><br><span class="line"><span class="function">status <span class="title">Strlength</span><span class="params">(SString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//返回串的元素个数</span></span><br><span class="line"><span class="keyword">return</span> S[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将串清空</span></span><br><span class="line"><span class="function">status <span class="title">ClearString</span><span class="params">(SString S)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//将S清为空串 </span></span><br><span class="line">S[<span class="number">0</span>] = <span class="number">0</span>;              <span class="comment">/* 直接令串长为零 */</span></span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将串S复制到串T中</span></span><br><span class="line"><span class="function">status <span class="title">StrCopy</span><span class="params">(SString&amp; T, SString&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//由串S复制得串T</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= S[<span class="number">0</span>]; i++)</span><br><span class="line">T[i] = S[i];</span><br><span class="line">T[<span class="number">0</span>] = S[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较串S和串T</span></span><br><span class="line"><span class="comment">//若S &gt; T, 则返回值 &gt; 0; 若S = T, 则返回值 = 0; 若S &lt; T, 则返回值 &lt; 0</span></span><br><span class="line"><span class="function">status <span class="title">StrCompare</span><span class="params">(SString S, SString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">StrEmpty</span>(S) || <span class="built_in">StrEmpty</span>(T)) <span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= S[<span class="number">0</span>] &amp;&amp; i &lt;= T[<span class="number">0</span>]; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (S[i] != T[i]) <span class="keyword">return</span> S[i] - T[i];    <span class="comment">//如果不相等，直接返回不相等的值的相减</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> S[<span class="number">0</span>] - T[<span class="number">0</span>];                          <span class="comment">//如果字符全部相等，返回他们字符长度的差值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除串中第pos个字符起长度为len的子串</span></span><br><span class="line"><span class="function">status <span class="title">StrDelete</span><span class="params">(SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 从串S中删除第pos个字符起长度为len的子串 </span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;S[<span class="number">0</span>] - len + <span class="number">1</span> || len &lt; <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">for</span> (i = pos + len; i &lt;= S[<span class="number">0</span>]; i++)</span><br><span class="line">S[i - len] = S[i];</span><br><span class="line">S[<span class="number">0</span>] -= len;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在串的第pos个字符之后插入串T</span></span><br><span class="line"><span class="function">status <span class="title">StrInsert</span><span class="params">(SString&amp; S, <span class="type">int</span> pos, SString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//在串S的第pos个字符之后插入串T。完全插入返回TRUE, 部分插入返回FALSE</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;MAXSTRLEN) <span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">if</span> (S[<span class="number">0</span>] + T[<span class="number">0</span>] &lt;= MAXSTRLEN)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = S[<span class="number">0</span>]; i &gt;= pos; i--)</span><br><span class="line">S[i + T[<span class="number">0</span>]] = S[i];</span><br><span class="line"><span class="keyword">for</span> (i = pos; i &lt; pos + T[<span class="number">0</span>]; i++)</span><br><span class="line">S[i] = T[i - pos + <span class="number">1</span>];</span><br><span class="line">S[<span class="number">0</span>] = S[<span class="number">0</span>] + T[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;  <span class="comment">//部分插入</span></span><br><span class="line"><span class="keyword">for</span> (i = MAXSTRLEN; i &gt;= pos + T[<span class="number">0</span>]; i--)</span><br><span class="line">S[i] = S[i - T[<span class="number">0</span>]];</span><br><span class="line"><span class="keyword">for</span> (i = pos; i &lt; pos + T[<span class="number">0</span>]; i++)</span><br><span class="line">S[i] = T[i - pos + <span class="number">1</span>];</span><br><span class="line">S[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回串中第pos个字符起，长度为len的子串</span></span><br><span class="line"><span class="function">status <span class="title">SubString</span><span class="params">(SString&amp; Sub, SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//求串S中第pos个字符起，长度为len的子串</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (pos &lt; <span class="number">1</span> || pos &gt; S[<span class="number">0</span>] || len &lt; <span class="number">0</span> || pos + len - <span class="number">1</span> &gt; S[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">return</span> ERROR;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">&#123;</span><br><span class="line">Sub[i] = S[pos+i<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line">Sub[<span class="number">0</span>] = len;</span><br><span class="line"><span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//联接两个串组成新串</span></span><br><span class="line"><span class="function">status <span class="title">Concat</span><span class="params">(SString&amp; T, SString s1, SString s2)</span></span></span><br><span class="line"><span class="function"><span class="comment">//两串用T返回S1和S2联接而成的新串。若未截断，则返回TRUE，否则FALSE</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">if</span> (s1[<span class="number">0</span>] + s2[<span class="number">0</span>] &lt;= MAXSTRLEN)  <span class="comment">//串一和串二长度的总和小于主串的最大容量,未截断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= s1[<span class="number">0</span>]; i++)     T[i] = s1[i];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= s2[<span class="number">0</span>]; i++)     T[s1[<span class="number">0</span>] + i] = s2[i];</span><br><span class="line">T[<span class="number">0</span>] = s1[<span class="number">0</span>] + s2[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s1[<span class="number">0</span>] &lt; MAXSTRLEN)    <span class="comment">//两串的长度的总和超过最大容量，串一未超过,串二被截断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= s1[<span class="number">0</span>]; i++)   T[i] = s1[i];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MAXSTRLEN - s1[<span class="number">0</span>]; i++)  T[s1[<span class="number">0</span>] + i] = s2[i];</span><br><span class="line">T[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>                         <span class="comment">//两串均超过最大容量，均被截断，取串一中的元素</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= MAXSTRLEN; i++)   T[i] = s1[i];</span><br><span class="line">T[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line"><span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串的定长顺序存储表示，SString[0]用来存储串的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">串的实际长度只能小于等于MAXLEN，超过预定义长度的串值会被舍去，称为截断。</span></span><br><span class="line"><span class="comment">顺序存储，例如串S=”sjjg”，其中从S.ch[0]开始存放串，最后以字符’/0’来表示串值的结束，如下图：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="2、堆分配存储表示"><a href="#2、堆分配存储表示" class="headerlink" title="2、堆分配存储表示"></a>2、堆分配存储表示</h4><p>堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中动态分配得到的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line"><span class="type">char</span> *ch;<span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line"><span class="type">int</span> length;<span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3、块链存储表示"><a href="#3、块链存储表示" class="headerlink" title="3、块链存储表示"></a>3、块链存储表示</h4><p>类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性(每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符， 也可以存放多个字符。每个结点称为块，整个链表称为块链结构。</p><h3 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h3><p>子串的定位操作是找子串在主串中从第pos个字符后首次出现的位置，又被称为串的模式匹配</p><h4 id="一、BF模式匹配算法"><a href="#一、BF模式匹配算法" class="headerlink" title="一、BF模式匹配算法"></a>一、BF模式匹配算法</h4><p>BF算法思想:Brute-Force算法又称蛮力匹配算法(简称BF算法),从主串S的第pos个字符开始，和模式串T的第一个字符进行比较，若相等，则继续比较后续字符；否则回溯到主串S的第pos+1个字符开始重新和模式串T进行比较。以此类推，直至模式串T中的每一个字符依次和主串S中的一个连续的字符序列相等，则称模式匹配成功，此时返回模式串T的第一个字符在主串S中的位置；否则主串中没有和模式串相等的字符序列，称模式匹配不成功。</p><ul><li>算法分析:</li><li><ul><li>BF算法的思想比较简单，但当在最坏情况下，算法的时间复杂度为O(n*m),其中n和m分别是主串和模式串的长度。</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一轮：子串中的第一个字符与主串中的第一个字符进行比较</span></span><br><span class="line"><span class="comment">若相等，则继续比较主串与子串的第二个字符</span></span><br><span class="line"><span class="comment">若不相等，进行第二轮比较</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二轮：子串中的第一个字符与主串中第二个字符进行比较......</span></span><br><span class="line"><span class="comment">第N轮：依次比较下去，直到全部匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ViolentMatch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> sLen = <span class="built_in">strlen</span>(s);  </span><br><span class="line">    <span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++      </span></span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0      </span></span><br><span class="line">            i = i - j + <span class="number">1</span>;  </span><br><span class="line">            j = <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//匹配成功，返回模式串p在文本串s中的位置，否则返回-1  </span></span><br><span class="line">    <span class="keyword">if</span> (j == pLen)  </span><br><span class="line">        <span class="keyword">return</span> i - j;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><blockquote><p>这种算法简单易懂，却存在着一个很大的缺点，那就是需要多次回溯，效率低下，若主串为 000000000001 子串为00001，这就意味着每一轮都要比较到子串的最后一个字符才会匹配失败，有没有更好的办法呢？下面的KMP模式匹配算法就很好的解决了这一问题</p></blockquote><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。</p><p>朴素模式匹配算法，主串的 i 值会不断的进行回溯，但是 KMP模式匹配算法：</p><ul><li><blockquote><p>KMP 方法算法就利用之前判断过的信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间。</p></blockquote></li></ul><p>将这种没必要的回溯省略掉了，所以减少了执行次数</p><blockquote><p>什么是最长公共前后缀<br>字符串的前缀是指不包含最后一个字符的所有以第一个字符（索引为0）开头的连续子串</p><p>比如字符串 “ABABA” 的前缀有：A，AB，ABA，ABAB</p><p>字符串的后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</p><p>比如字符串 “ABABA” 的后缀有：BABA，ABA，BA，A</p><p>公共前后缀：一个字符串的 所有前缀连续子串 和 所有后缀连续子串 中相等的子串</p><p>比如字符串 “ABABA”</p><p>前缀有：A，AB，ABA，ABAB<br>后缀有：BABA，ABA，BA，A<br>因此公共前后缀有：A ，ABA</p><p>最长公共前后缀：所有公共前后缀 的 长度最长的 那个子串</p><p>比如字符串 “ABABA” ，公共前后缀有：A ，ABA</p><p>由于 ABA 是 三个字符长度，A 是一个字符长度，那么最长公共前后缀就是 ABA</p></blockquote><blockquote><p>再比如说一个字符串 str &#x3D; “ABCABD”</p><p>对于str从 索引为0 开始的子串 “A” 而言：</p><p>前缀：不包含最后一个字符A的 所有以第一个字符A开头 的 连续子串 不存在<br>后缀：不包含第一个字符A 的 所有以最后一个字符A结尾 的 连续子串 不存在<br>因此该子串的最长公共前后缀 为 0</p><p>对于str从 索引为0 开始的子串 “AB” 而言：</p><p>前缀：不包含 最后一个字符B 的 所有以第一个字符A开头 的 连续子串 有 —— “A”<br>后缀：不包含 第一个字符A 的 所有以最后一个字符B结尾 的 连续子串 有 —— “B”<br>因此该子串的最长公共前后缀 为 0</p><p>对于str从 索引为0 开始的子串 “ABC” 而言：</p><p>前缀：不包含 最后一个字符C 的 所有以第一个字符A开头 的 连续子串 有 —— “A”，“AB”<br>后缀：不包含 第一个字符A 的 所有以最后一个字符C 结尾 的 连续子串有 —— “BC”，“C”<br>前缀与后缀的连续子串不存在相同的，因此该子串的最长公共前后缀 为 0</p><p>对于str从 索引为0 开始的子串 “ABCA” 而言：</p><p>前缀：不包含 最后一个字符A 的 所有以第一个字符A开头 的 连续子串 有 —— “A”，“AB”，“ABC”<br>后缀：不包含 第一个字符A 的 所有以最后一个字符A 结尾 的 连续子串有 —— “BCA”，“CA”，“A”<br>前缀与后缀的连续子串中存在相同且最长的子串 A，因此该子串的最长公共前后缀 为 1</p><p>对于str从 索引为0 开始的子串 “ABCAB” 而言：</p><p>前缀：不包含 最后一个字符B 的 所有以第一个字符A开头 的 连续子串 有 —— “A”，“AB”，“ABC”，“ABCA”<br>后缀：不包含 第一个字符A 的 所有以最后一个字符B 结尾 的 连续子串有 —— “BCAB”，“CAB”，“AB”，“B”<br>前缀与后缀的连续子串中存在相同且最长的子串 AB，因此该子串的最长公共前后缀 为 2</p><p>对于str从 索引为0 开始的子串 “ABCABD” 而言：</p><p>前缀：不包含 最后一个字符D 的 所有以第一个字符A开头 的 连续子串 有 —— “A”，“AB”，“ABC”，“ABCA”，“ABCAB”<br>后缀：不包含 第一个字符A 的 所有以最后一个字符D 结尾 的 连续子串有 —— “BCABD”，“CABD”，“ABD”，“BD”，“D”<br>前缀与后缀的连续子串不存在相同的，因此该子串的最长公共前后缀 为 0<br><a href="https://blog.csdn.net/qq_62982856/article/details/128003067">https://blog.csdn.net/qq_62982856/article/details/128003067</a></p><p>因此kmp算法本质是求解两次最长公共前后缀的过程。</p></blockquote><blockquote><p>正常的算法是暴力，然后i，j开始匹配，不相同回溯，i回溯到1，j回溯到0，简单粗暴，时间复杂度高，算法时间复杂度很高。</p><p>优化就是大名鼎鼎的kmp算法。</p><p>利用匹配失败后的信息，尽量减少模式串与主串的匹配次数。</p><p>前置知识：</p><p>前缀集合</p><p>后缀集合。</p><p>kmp算法中不回溯i，只回溯j。</p><p>a子串的后缀与b子串的前缀集合相等时候就可以</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> kmp[N];</span><br><span class="line"><span class="type">int</span> la,lb,j; </span><br><span class="line">string a;</span><br><span class="line">string b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    cin&gt;&gt;b;</span><br><span class="line">    a=<span class="string">&quot; &quot;</span>+a;</span><br><span class="line">    b=<span class="string">&quot; &quot;</span>+b;</span><br><span class="line">    la=a.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    lb=b.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=lb;i++)</span><br><span class="line">   &#123;     </span><br><span class="line">   <span class="keyword">while</span>(j&amp;&amp;b[i]!=b[j+<span class="number">1</span>])</span><br><span class="line">        j=kmp[j];     </span><br><span class="line">       <span class="keyword">if</span>(b[j+<span class="number">1</span>]==b[i])j++;    </span><br><span class="line">        kmp[i]=j;</span><br><span class="line">       &#125;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=la;i++)</span><br><span class="line">   &#123;</span><br><span class="line">          <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;b[j+<span class="number">1</span>]!=a[i])</span><br><span class="line">           j=kmp[j];</span><br><span class="line">          <span class="keyword">if</span> (b[j+<span class="number">1</span>]==a[i]) </span><br><span class="line">           j++;</span><br><span class="line">          <span class="keyword">if</span> (j==lb) </span><br><span class="line">  &#123;</span><br><span class="line">  cout&lt;&lt;i-lb+<span class="number">1</span>&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">  j=kmp[j];</span><br><span class="line">  &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lb;i++)</span><br><span class="line">    cout&lt;&lt;kmp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p><a href="https://blog.csdn.net/Real_Fool_/article/details/113930623">数据结构：树(Tree)【详解】_数据结构 树-CSDN博客</a></p><p>存储的是具有“一对多”关系的数据元素的集合。</p><h4 id="1、树的定义"><a href="#1、树的定义" class="headerlink" title="1、树的定义"></a>1、树的定义</h4><blockquote><p>树是n（n&gt;&#x3D;0）个结点的有限集。当n &#x3D; 0时，称为空树。在任意一棵非空树中应满足：</p><ol><li>有且仅有一个特定的称为根的结点。</li><li>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一棵树，并且称为根的子树。</li></ol></blockquote><p>树天生适合递归。</p><p><img src="/images/image-20240211011754677.png" alt="image-20240211011754677"></p><blockquote><ol><li>树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。</li><li>树中所有结点可以有零个或多个后继。</li><li>结点：使用树结构存储的每一个数据元素都被称为“结点”。</li><li>父结点（双亲结点）、子结点和兄弟结点</li><li>孩子结点：结点的直接后继</li><li>双亲结点：结点的直接前驱</li><li>兄弟结点：同一双亲结点的孩子结点互称兄弟结点</li><li>树根结点（简称“根结点”）：每一个非空树都有且只有一个被称为根的结点。树根的判断依据为：如果一个结点没有父结点，那么这个结点就是整棵树的根结点。</li><li>叶子结点：如果结点没有任何子结点，那么此结点称为叶子结点（叶结点）</li><li>空树：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。</li><li>树是由根结点和若干棵子树构成的。</li><li>对于一个结点，拥有的子树数（结点有多少分支）称为结点的度（Degree）。如图度最大值为3</li><li>结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。一棵树的深度（高度）是树中结点所在的最大的层次。</li><li>如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树。</li><li>由 m（m &gt;&#x3D; 0）个互不相交的树组成的集合被称为森林。</li><li><strong>结点的深度</strong>是从根结点开始自顶向下逐层累加的。<br><strong>结点的高度</strong>是从叶结点开始自底向上逐层累加的。</li><li>树的高度和深度是树中结点的最大层数。</li><li>路径和路径长度。树中两个结点之间的<strong>路径</strong>是由这两个结点之间所经过的结点序列构成的,而<strong>路径长度</strong>是路径上所经过的边的个数。</li><li>二叉树：有限的结点的集合，由根结点和不相交的二叉子树组成</li><li>二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。</li><li><strong>n个结点的树中有n-1条边</strong></li></ol></blockquote><p>满足以下两个条件的树形结构叫做二叉树：</p><blockquote><ul><li>每个结点至多只有两棵子树</li><li>二叉树的子树有左右之分，其次序不能颠倒。树可以有序可以无序</li></ul></blockquote><blockquote><h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><p>树具有如下基本的性质：<br>1）树中的结点数 &#x3D; 所有结点的度数 + 1<br>  这个很容易理解：每个结点的度数 &#x3D; 孩子结点的个数，最后再加上根结点，就是树中的结点数了。</p><p>2）度为m的树中，第i层上至多有m（i-1）方个结点<br>  求最多的结点数，那么每个结点的度均为m。<br>  第 i 层上的结点数 &#x3D; 第 i-1 层结点的度数，也就是m*(第 i-1 层的结点个数) &#x3D; m<em>m</em>(第 i-2 层的结点个数) &#x3D; … &#x3D; mi-1*（第1层的结点数）&#x3D; mi-1（共乘了i次）。</p><p>3）高度为h的m叉树至多有(mh-1)&#x2F;(m-1)个结点<br>  由树的上个性质可知，m叉树第 i 层至多有mi-1个结点。那么高度为h的m叉树的结点数至多：<br>  S &#x3D; mh-1 + mh-2 + mh-3 + … + m + 1 &#x3D; (mh-1)&#x2F;(m-1)<br>  该树现在是个满m叉树。</p><p>等比数列求和即可</p><p>4）具有n个结点的m叉树的最小高度为⌈logm(n(m-1)+1)⌉<br>  求最小高度也就是每层结点数最多时的高度，即该树是一棵完全m叉树，设其高度为h。<br>  由树的第4个性质，有 n ≤ (mh-1)&#x2F;(m-1)，解得 h ≥ logm(n(m-1)+1) 。<br>  故h为⌈logm(n(m-1)+1)⌉。<br>  另外，实际上有 (mh-1-1)&#x2F;(m-1) +1≤ n ≤ (mh-1)&#x2F;(m-1)，故最小高度h也可以为 ⌊logm((n-1)(m-1)+1)⌋ + 1。</p><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p><strong>性质1：在二叉树的第i层上至多有2的(i-1)次方个结点（i&gt;&#x3D;1）。</strong></p><p><strong>性质2：深度为k的二叉树至多有2（k）-1次方个结点（k&gt;&#x3D;1）。</strong></p><h3 id="性质3：具有n个结点的完全二叉树的深度为-log2-n-1"><a href="#性质3：具有n个结点的完全二叉树的深度为-log2-n-1" class="headerlink" title="性质3：具有n个结点的完全二叉树的深度为|log2(n)| + 1"></a>性质3：具有n个结点的完全二叉树的深度为|log2(n)| + 1</h3><h3 id="性质4：包含n个结点的二叉树的高度至少为-log2-n-1-。"><a href="#性质4：包含n个结点的二叉树的高度至少为-log2-n-1-。" class="headerlink" title="性质4：包含n个结点的二叉树的高度至少为**log2 (n+1)**。"></a><strong>性质4</strong>：包含n个结点的二叉树的高度至少为**log2 (n+1)**。</h3><p><strong>性质5：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0&#x3D;n2+1</strong></p><p>n&#x3D;n0+n1+n2</p><p>n&#x3D;n1+2n2+1</p><p>即可</p></blockquote><h3 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h3><blockquote><p>满二叉树：每层结点均满，每层均具有最大结点数，又称完美二叉树</p><p>除最后一层无任何子<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E8%8A%82%E7%82%B9">节点</a>外，每一层上的所有结点都有两个子结点二叉树。</p><p>　　国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p><p>　　国外(国际)定义:a binary tree T is full if each node is either a leaf or possesses exactly two childnodes.大意为：如果一棵二叉树的结点要么是叶子结点，要么它有两个孩子结点，这样的树就是满二叉树。</p></blockquote><blockquote><p>1、第i+1层的节点数为2^i</p><p>2、如果完美二叉树高度为n，那么总的节点数为2^n - 1</p><p>3、如果完美二叉树中叶子节点为m，非终端节点为k，那么m&#x3D;k+1</p><p>4、如果完美二叉树中某节点下标为n，那么它的左节点下标为2n，右节点下标为2n+1</p></blockquote><ul><li>完全二叉树：与满二叉树的编号对应，但不要求每层均具有最大结点数</li></ul><blockquote><p>完全二叉树是由满二叉树而引出来的，若设二叉树的<code>深度为h</code>，<code>除第 h 层外</code>，<code>其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)</code>，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p><ul><li>若一棵二叉树至多只有最下面两层的结点的度数可以小于2，并且最下层的结点都集中在该层最左边的若干位置上，则此二叉树为完全二叉树。</li><li>若i为奇数且i&gt;1，那么tree[i]的左兄弟为tree[i-1]； </li><li>若i为偶数且i&lt;n，那么tree[i]的右兄弟为tree[i+1]；</li><li>若i&gt;n&#x2F;2，那么tree[i]为叶子结点</li><li>若i&lt;(n-1)&#x2F;2，那么tree必有两个孩子</li><li>完全二叉树第i层至多有2^(i-1)个节点，共i层的完全二叉树最多有2^i-1个节点。</li></ul></blockquote><p>区别于联系：满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</p><p><strong>二叉查找树</strong>，<strong>二叉搜索树、二叉排序树、BST</strong></p><p><strong>定义</strong>：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;&#x3D; key[x]；如果y是x的右子树的一个结点，则key[y] &gt;&#x3D; key[x]。</p><blockquote><p>在二叉查找树中：<br>(01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>(02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>(03) 任意节点的左、右子树也分别为二叉查找树。<br>(04) 没有键值相等的节点（no duplicate nodes）。</p></blockquote><h3 id="斜树"><a href="#斜树" class="headerlink" title="斜树"></a>斜树</h3><p>所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>树上任一结点的左子树和右子树的深度之差不超过1。</p><p>平衡二叉树必定是二叉搜索树。</p><p><strong>霍夫曼树</strong></p><blockquote><p>带权路径最短的二叉树称为哈夫曼树或最优二叉树。</p></blockquote><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p><strong>顺序存储结构</strong></p><p><strong>链式存储结构</strong></p><p>主要有：</p><p>&lt;1&gt; 双亲表示法<br> &lt;2&gt; 孩子表示法<br> &lt;3&gt; 孩子兄弟表示法</p><p>双亲表示法</p><p>采用<strong>一组连续空间</strong>来存储每个结点。</p><p><strong>根节点没有双亲</strong>，所以其在数组中存储的值为**-1**。</p><p><strong>其余的节点</strong>，只需要存储其父节点<strong>对应的数组下标即可</strong></p><p><img src="/images/20210222174500547.png" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100  <span class="comment">//树中最多结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;  <span class="comment">//树的结点定义</span></span><br><span class="line">    <span class="type">char</span> data;  <span class="comment">//数据元素</span></span><br><span class="line">    <span class="type">int</span> parent;  <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;  <span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MaxSize];  <span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>孩子表示法</p><p>将每个节点的孩子节点都用单链表连接起来形成一个线性结构，n个节点具有n个孩子链表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孩子表示法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CNode</span> *next;</span><br><span class="line">&#125;CNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CNode</span> *child;</span><br><span class="line">&#125;PNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTree</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode nodes[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;CTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>孩子兄弟表示法</p><p><strong>任意一棵树， 它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。 因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</strong>。</p><p><img src="/images/20210222181409121.png" alt="在这里插入图片描述"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *FirstChild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *NextBrother;</span><br><span class="line">    </span><br><span class="line">&#125;Node,TREE;</span><br></pre></td></tr></table></figure><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p><p>二叉树的定义是递归式的。因此后续基本操作中，我们基本都是按照该概念来实现的</p><blockquote><p>四种主要的遍历思想为：</p><p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p><p>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</p><p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p><p>层次遍历：只需按层次遍历即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置</span></span><br><span class="line"><span class="comment">//递归建树</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//结构体的封装</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTree</span>&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTree</span> *leftchild,*rightchild;</span><br><span class="line">&#125;BiTree;</span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateTree</span><span class="params">(BiTree *&amp;T)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="string">&#x27;#&#x27;</span>) T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTree;</span><br><span class="line">        T-&gt;data=x;</span><br><span class="line">        <span class="built_in">CreateTree</span>(T-&gt;leftchild);</span><br><span class="line">        <span class="built_in">CreateTree</span>(T-&gt;rightchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">visit</span>(T);<span class="comment">//访问根节点</span></span><br><span class="line"><span class="built_in">PreOrder</span>(T-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line"><span class="built_in">PreOrder</span>(T-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">InOrder</span>(T-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line"><span class="built_in">visit</span>(T);<span class="comment">//访问根结点</span></span><br><span class="line"><span class="built_in">InOrder</span>(T-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//力扣版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">inorder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">PostOrder</span>(T-&gt;lchild);<span class="comment">//递归遍历左子树</span></span><br><span class="line"><span class="built_in">PostOrder</span>(T-&gt;rchild);<span class="comment">//递归遍历右子树</span></span><br><span class="line"><span class="built_in">visit</span>(T);<span class="comment">//访问根结点</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line"><span class="built_in">InitQueue</span>(Q);<span class="comment">//初始化辅助队列</span></span><br><span class="line">BiTree p;</span><br><span class="line"><span class="built_in">EnQueue</span>(Q, T);<span class="comment">//将根节点入队</span></span><br><span class="line"><span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(Q))&#123;<span class="comment">//队列不空则循环</span></span><br><span class="line"><span class="built_in">DeQueue</span>(Q, p);<span class="comment">//队头结点出队</span></span><br><span class="line"><span class="built_in">visit</span>(p);<span class="comment">//访问出队结点</span></span><br><span class="line"><span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">EnQueue</span>(Q, p-&gt;lchild);<span class="comment">//左子树不空，则左子树根节点入队</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line"><span class="built_in">EnQueue</span>(Q, p-&gt;rchild);<span class="comment">//右子树不空，则右子树根节点入队</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p><a href="https://zhuanlan.zhihu.com/p/134184036">#图解 数据结构：轻松搞定线索二叉树 - 知乎 (zhihu.com)</a></p><p>（几乎完全抄袭）</p><p>背景来源：</p><blockquote><ul><li><p>在n个结点的二叉树中，必定有n+1个空链域（叶子结点的左右子树空间浪费了）</p><p>解释：</p><p>在N个节点的二叉树中，每个节点有2个指针，所以一共有2N个指针，除了根节点以外，每一个节点都有一个指针从它的父节点指向它，所以一共使用了N-1个指针，所以剩下2N-(N-1)也就是N+1个空指针；</p></li><li><p>二叉树的遍历，无论是递归还是非递归算法，效率都不算高。</p></li></ul></blockquote><blockquote><p>而知道了“前驱”和“后继”信息，就可以把二叉树看作一个<strong>链表结构</strong>，从而可以像遍历链表那样来遍历二叉树，<strong>进而提高效率</strong>。<strong>线索化</strong> —-引出</p></blockquote><p><img src="/images/v2-3323632a025312529a6394f2db1287c6_720w.png" alt="img"></p><p>核心：所有<strong>原本为空的右(孩子)指针</strong>改为<strong>指向该节点在中序序列中的后继</strong>，所有原本为空的左(孩子)指针改为指向该节点的中序序列的前驱。</p><p>定义以下规则：</p><ol><li><p>ltag&#x3D;0<strong>，表示指向节点的</strong>左孩子。</p></li><li><p>ltag&#x3D;1<strong>，则表示</strong>lchild为线索<strong>，指向节点的</strong>直接前驱**</p></li><li><p>rtag&#x3D;0<strong>，表示指向节点的</strong>右孩子。</p></li><li><p>rtag&#x3D;1<strong>，则表示</strong>rchild为线索<strong>，指向节点的</strong>直接后继**</p><blockquote><p>这种指向前驱和后继的<strong>指针</strong>称为<strong>线索</strong>，加上了线索的二叉树就是线索二叉树；</p></blockquote></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TBNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> data;</span><br><span class="line"><span class="type">int</span> ltag,rtag;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TBNode</span> *lchild;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TBNode</span> *rchild;</span><br><span class="line"></span><br><span class="line">&#125;TBNode;</span><br></pre></td></tr></table></figure><p>实现思路：按某种次序遍历二叉树，在遍历过程中用线索取代空指针即可。</p><h2 id="中序线索二叉树"><a href="#中序线索二叉树" class="headerlink" title="中序线索二叉树"></a>中序线索二叉树</h2><p><img src="/images/image-20240212005342768.png" alt="image-20240212005342768"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Thread</span>* left_node, *right_node;<span class="comment">//左右指针</span></span><br><span class="line"><span class="type">int</span> data;<span class="comment">//需要存放的数据</span></span><br><span class="line"><span class="comment">/*默认0代表左右孩子 1代表前驱或者后继*/</span></span><br><span class="line"><span class="type">int</span> left_type;<span class="comment">//类型标志</span></span><br><span class="line"><span class="type">int</span> right_type;<span class="comment">//类型标志</span></span><br><span class="line">&#125;Node;</span><br><span class="line"> </span><br><span class="line">Node* pre;<span class="comment">//前驱结点的变量</span></span><br><span class="line">Node* head;<span class="comment">//头指针 指向某种遍历的第一个结点</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderThreadTree</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//如果当前结点为NULL 直接返回</span></span><br><span class="line"><span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//先处理左子树</span></span><br><span class="line"><span class="built_in">inOrderThreadTree</span>(node-&gt;left_node);</span><br><span class="line"><span class="keyword">if</span> (node-&gt;left_node == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设置前驱结点</span></span><br><span class="line">node-&gt;left_type = <span class="number">1</span>;</span><br><span class="line">node-&gt;left_node = pre;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果结点的右子节点为NULL 处理前驱的右指针</span></span><br><span class="line"><span class="keyword">if</span> (pre !=<span class="literal">NULL</span> &amp;&amp; pre-&gt;right_node == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//设置后继</span></span><br><span class="line">pre-&gt;right_node = node;</span><br><span class="line">pre-&gt;right_type = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每处理一个节点 当前结点是下一个节点的前驱</span></span><br><span class="line">pre = node;</span><br><span class="line"><span class="comment">//最后处理右子树</span></span><br><span class="line"><span class="built_in">inOrderThreadTree</span>(node-&gt;right_node);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//从根节点开始先找到最左边</span></span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node* temp = root;</span><br><span class="line"><span class="comment">//先找到最左边结点 然后根据线索化直接向右遍历</span></span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;left_type == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">temp = temp-&gt;left_node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">temp = temp-&gt;right_node;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="树二叉树的转化"><a href="#树二叉树的转化" class="headerlink" title="树二叉树的转化"></a>树二叉树的转化</h3><h4 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h4><blockquote><p>树转换为二义树的规则:每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。</p></blockquote><p>森林实际同理，只是把每一颗树当成兄弟，除此无别</p><h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>树的遍历的定义：以某种方式访问树中的每一个结点，且仅访问一次。<br>树的遍历主要有先根遍历和后根遍历。</p><p>先根遍历：若树非空，则先访问根结点，再按照从左到右的顺序遍历根结点的每一棵子树。这个访问顺序与这棵树对应的二叉树的先序遍历顺序相同。</p><p>后根遍历：若树非空，则按照从左到右的顺序遍历根结点的每一棵子树，之后再访问根结点。其访问顺序与这棵树对应的二叉树的中序遍历顺序相同。</p><h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树。<br>二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：</p><ol><li>非空左子树的所有键值小于其根结点的键值。</li><li>非空右子树的所有键值大于其根结点的键值。</li><li>左、右子树都是二叉搜索树。</li></ol><p>结构</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TNode</span> *Position;</span><br><span class="line"><span class="keyword">typedef</span> Position BinTree; <span class="comment">/* 二叉树类型 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TNode</span>&#123; <span class="comment">/* 树结点定义 */</span></span><br><span class="line">    ElementType Data; <span class="comment">/* 结点数据 */</span></span><br><span class="line">    BinTree Left;     <span class="comment">/* 指向左子树 */</span></span><br><span class="line">    BinTree Right;    <span class="comment">/* 指向右子树 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查找</p><p>递归版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( ElementType X, BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( !BST ) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/*查找失败*/</span></span><br><span class="line"><span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Find</span>( X, BST-&gt;Right ); <span class="comment">/*在右子树中继续查找*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Find</span>( X, BST-&gt;Left ); <span class="comment">/*在左子树中继续查找*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="comment">/* X == BST-&gt;Data */</span></span><br><span class="line"><span class="keyword">return</span> BST; <span class="comment">/*查找成功，返回结点的找到结点的地址*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>非递归版本</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">IterFind</span><span class="params">( ElementType X, BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">while</span>( BST ) </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line"> BST = BST-&gt;Right; <span class="comment">/*向右子树中移动，继续查找*/</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line"> BST = BST-&gt;Left; <span class="comment">/*向左子树中移动，继续查找*/</span></span><br><span class="line"> <span class="keyword">else</span> <span class="comment">/* X == BST-&gt;Data */</span></span><br><span class="line"> <span class="keyword">return</span> BST; <span class="comment">/*查找成功，返回结点的找到结点的地址*/</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/*查找失败*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查找最小值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>( !BST ) </span><br><span class="line"> <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/*空的二叉搜索树，返回NULL*/</span></span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span>( !BST-&gt;Left )</span><br><span class="line"> <span class="keyword">return</span> BST; <span class="comment">/*找到最左叶结点并返回*/</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> <span class="keyword">return</span> <span class="built_in">FindMin</span>( BST-&gt;Left ); <span class="comment">/*沿左分支继续查找*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>查找最大值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(BST )</span><br><span class="line"> <span class="keyword">while</span>( BST-&gt;Right )  <span class="comment">/*沿右分支继续查找，直到最右叶结点*/</span></span><br><span class="line"> BST = BST-&gt;Right;</span><br><span class="line"> <span class="keyword">return</span> BST;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>插入：二叉搜索树在插入前，肯定要找到插入的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !BST )&#123; <span class="comment">/* 若原树为空，生成并返回一个结点的二叉搜索树 */</span></span><br><span class="line">        BST =<span class="keyword">new</span> TNode;</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 开始找要插入元素的位置 */</span></span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Left = <span class="built_in">Insert</span>( BST-&gt;Left, X );   <span class="comment">/*递归插入左子树*/</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Right = <span class="built_in">Insert</span>( BST-&gt;Right, X ); <span class="comment">/*递归插入右子树*/</span></span><br><span class="line">        <span class="comment">/* else X已经存在，什么都不做 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>删除：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Position Tmp; </span><br><span class="line">    <span class="keyword">if</span>( !BST ) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到&quot;</span>); </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Left = <span class="built_in">Delete</span>( BST-&gt;Left, X );   <span class="comment">/* 从左子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &gt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Right = <span class="built_in">Delete</span>( BST-&gt;Right, X ); <span class="comment">/* 从右子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; <span class="comment">/* BST就是要删除的结点 */</span></span><br><span class="line">            <span class="comment">/* 如果被删除结点有左右两个子结点 */</span> </span><br><span class="line">            <span class="keyword">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 从右子树中找最小的元素填充删除结点 */</span></span><br><span class="line">                Tmp = <span class="built_in">FindMin</span>( BST-&gt;Right );</span><br><span class="line">                BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">                <span class="comment">/* 从右子树中删除最小元素 */</span></span><br><span class="line">                BST-&gt;Right = <span class="built_in">Delete</span>( BST-&gt;Right, BST-&gt;Data );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123; <span class="comment">/* 被删除结点有一个或无子结点 */</span></span><br><span class="line">                <span class="comment">//想象一下，如果删除的结点原来相对于父结点是左子树，而且它只有一个孩子结点，那这个孩子结点是不是一定会比当前结点的父亲结点小</span></span><br><span class="line">                <span class="comment">//同理，如果删除的结点原来相对于父结点是右子树，那么则大，因此直接指向子结点就是对的</span></span><br><span class="line">                Tmp = BST; </span><br><span class="line">                <span class="keyword">if</span>( !BST-&gt;Left )       <span class="comment">/* 只有右孩子或无子结点 */</span></span><br><span class="line">                    BST = BST-&gt;Right; </span><br><span class="line">                <span class="keyword">else</span>                   <span class="comment">/* 只有左孩子 */</span></span><br><span class="line">                    BST = BST-&gt;Left;</span><br><span class="line">                <span class="keyword">delete</span> Tmp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结为：对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。因此取决于二叉搜索树的形状，不能太极端，不然无法近似为二分，因此我们希望构建出一颗平衡二叉树。</p><h2 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>二叉搜索树一定程度上可以提高搜索效率，但是当原序列有序时，很容易使得二叉树退化成单链表，搜索效率降低为 O(n)。</p><p>毫无疑问</p><p>保持树的左右两端保持平衡，树的查找效率最高。</p><p>调平衡</p><p>平衡因子</p><p>*<em><strong>定义：</strong>某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。</em>*</p><p><img src="/images/image-20240212015251378.png" alt="image-20240212015251378"></p><p><img src="/images/image-20240212015327333.png" alt="image-20240212015327333"></p><p><img src="/images/image-20240212015403240.png" alt="image-20240212015403240"></p><p><img src="/images/image-20240212015508291.png" alt="image-20240212015508291"></p><p>实际上只有LL和RR</p><h4 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVLNode</span> *Tree;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> depth; <span class="comment">//深度，这里计算每个结点的深度，通过深度的比较可得出是否平衡</span></span><br><span class="line">    Tree parent; <span class="comment">//该结点的父节点</span></span><br><span class="line">    ElementType val; <span class="comment">//结点值</span></span><br><span class="line">    Tree lchild;</span><br><span class="line">    Tree rchild;</span><br><span class="line">    <span class="built_in">AVLNode</span>(<span class="type">int</span> val=<span class="number">0</span>) &#123;</span><br><span class="line">        parent = <span class="literal">NULL</span>;</span><br><span class="line">        depth = <span class="number">0</span>;</span><br><span class="line">        lchild = rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>最小失衡子树</strong>：在<code>新插入的结点</code>向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。也就是说，<code>一棵失衡的树，是有可能有多棵子树同时失衡的</code>。而这个时候，<code>我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。</code></p><p>根据旋转的方向有两种处理方式，<code>左旋</code> 与 <code>右旋</code> 。</p><table><thead><tr><th>LL</th><th>在 A 的左子树根节点的左子树上插入节点而破坏平衡</th><th>右旋转</th></tr></thead><tbody><tr><td>RR</td><td>在 A 的右子树根节点的右子树上插入节点而破坏平衡</td><td>左旋转</td></tr><tr><td>LR</td><td>在A的左子树根节点的右子树上插入节点而破坏平衡</td><td>先左旋后右旋</td></tr><tr><td>RL</td><td>在 A 的右子树根节点的左子树上插入节点而破坏平衡</td><td>先右旋后左旋</td></tr></tbody></table><p>右旋</p><p>（1）将失衡结点变为其左孩子的右孩子（2）将其原本的左孩子的右孩子变为的左孩子</p><p><img src="/images/20180722222413303.gif" alt="img"></p><p>左旋</p><p>（1）将失衡结点变为其右孩子的左孩子（2）将其原本的右孩子的左孩子变为的右孩子</p><p>总结：</p><blockquote><p> 1.RR型和LL型，以被破坏节点为基础进行其反向的旋转即可，即RR型进行左旋，LL型进行右旋。</p><p>   2.RL型和LR型，先以被破坏节点的LR或RL首字母的节点进行LR或RL首字母旋转，再以被破坏节点为基础进行LR或RL尾字母旋转，即RL型先以被破坏节点的R（右）节点为基础进行一次R（右）选，再以被破坏节点为基础进行一次L（左）旋；LR旋先以被破坏节点的L（左）节点为基础进行一次L（左）选，再以被破坏节点为基础进行一次R（右）旋。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElenmentType; </span><br><span class="line"><span class="comment">//平衡二叉树的结构 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVLNode</span>&#123;</span><br><span class="line"><span class="type">int</span> depth;<span class="comment">//深度</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span> *left;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span> *right;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span> *parent;</span><br><span class="line">ElenmentType value; </span><br><span class="line"><span class="comment">//构造器 </span></span><br><span class="line"><span class="built_in">AVLNode</span>(ElenmentType value=<span class="number">0</span>)&#123;</span><br><span class="line">parent = <span class="literal">NULL</span>;</span><br><span class="line">        depth = <span class="number">0</span>;</span><br><span class="line">        left = right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value=value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;AVLtree,Tree;</span><br><span class="line"><span class="comment">//LL型调整函数</span></span><br><span class="line"><span class="comment">//返回根结点</span></span><br><span class="line"><span class="function">Tree* <span class="title">LL_rotate</span><span class="params">(Tree *root)</span></span>&#123;<span class="comment">//LL执行右旋 </span></span><br><span class="line"><span class="comment">//root是原来的平衡二叉树的根结点</span></span><br><span class="line">Tree *temp;<span class="comment">//临时变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取根结点的左孩子</span></span><br><span class="line">temp = root-&gt;left;</span><br><span class="line"><span class="comment">//根结点的左孩子变更为其原来左孩子的右孩子</span></span><br><span class="line">root-&gt;left = temp-&gt;right;</span><br><span class="line"></span><br><span class="line"><span class="comment">//原来的根结点的左孩子变为了根结点</span></span><br><span class="line">temp-&gt;right = root;</span><br><span class="line"><span class="keyword">return</span> temp; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RR型调整函数</span></span><br><span class="line"><span class="comment">//返回根结点 </span></span><br><span class="line"><span class="function">Tree* <span class="title">RR_rotate</span><span class="params">(Tree * root)</span></span>&#123;<span class="comment">//RR执行左旋 </span></span><br><span class="line">    Tree* temp;</span><br><span class="line">    temp = root-&gt;right;<span class="comment">//获取根结点的右孩子 </span></span><br><span class="line">    root-&gt;right = temp-&gt;left;<span class="comment">//根结点的右孩子变为其原来右孩子的左孩子 </span></span><br><span class="line">    temp-&gt;left = root;<span class="comment">//原来的根结点的右孩子变为了新的根结点 </span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1、LR型，先左旋转，再右旋转</span></span><br><span class="line"><span class="comment">//返回：新父节点</span></span><br><span class="line"><span class="function">Tree* <span class="title">LR_rotate</span><span class="params">(Tree* root)</span></span>&#123;</span><br><span class="line"> Tree* temp;</span><br><span class="line"> temp = root-&gt;left;</span><br><span class="line">    root-&gt;left =<span class="built_in">RR_rotate</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LL_rotate</span>(root);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//2RL型，先右旋转，再左旋转</span></span><br><span class="line"><span class="comment">//返回:新父节点</span></span><br><span class="line"><span class="function">Tree* <span class="title">RL_rotate</span><span class="params">(Tree* root)</span></span>&#123;</span><br><span class="line"> Tree* temp;</span><br><span class="line"> temp = root-&gt;right;</span><br><span class="line">    root-&gt;right=<span class="built_in">LL_rotate</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RR_rotate</span>(root);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//树高</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(<span class="type">const</span> Tree* root)</span><span class="comment">//求树高，递归 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left) , </span><br><span class="line"></span><br><span class="line"><span class="built_in">height</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//平衡因子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">diff</span><span class="params">(<span class="type">const</span> Tree* root)</span><span class="comment">//求平衡因子，即当前节点左右子树的差</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(root-&gt;left) - <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//平衡操作</span></span><br><span class="line"><span class="function">Tree* <span class="title">Balance</span><span class="params">(Tree* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//printf(&quot;平衡函数&quot;);</span></span><br><span class="line">    <span class="type">int</span> balanceFactor = <span class="built_in">diff</span>(root);<span class="comment">//diff用来计算平衡因子（左右子树高度差）</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span>)<span class="comment">//左子树高于右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">diff</span>(root-&gt;left) &gt; <span class="number">0</span>)<span class="comment">//LL的情况 </span></span><br><span class="line">            root=<span class="built_in">LL_rotate</span>(root);</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//LR的情况 </span></span><br><span class="line">            root=<span class="built_in">LR_rotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (balanceFactor &lt; <span class="number">-1</span>)<span class="comment">//右子树高于左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">diff</span>(root-&gt;right) &gt; <span class="number">0</span>)<span class="comment">//RL的情况 </span></span><br><span class="line">            root=<span class="built_in">RL_rotate</span>(root);</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//RR的情况 </span></span><br><span class="line">            root=<span class="built_in">RR_rotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//插入结点</span></span><br><span class="line"><span class="function">Tree* <span class="title">Insert</span><span class="params">(Tree* root,ElenmentType k )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == root)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">AVLNode</span>(k);<span class="comment">//如果根结点为null，则直接将值为根结点 </span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;<span class="comment">//递归返回条件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; root-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">Insert</span>(root-&gt;left, k);<span class="comment">//递归左子树</span></span><br><span class="line">        <span class="comment">//balance operation</span></span><br><span class="line">        root = <span class="built_in">Balance</span>(root);<span class="comment">//平衡操作包含了四种旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k&gt;root-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">Insert</span>(root-&gt;right, k);<span class="comment">//递归右子树</span></span><br><span class="line">        <span class="comment">//balance operation</span></span><br><span class="line">        root = <span class="built_in">Balance</span>(root);<span class="comment">//平衡操作包含了四种旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//中序遍历,获取的数列是有序的 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayTree</span><span class="params">(Tree* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">displayTree</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node-&gt;value);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">displayTree</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找value，成功则返回该结点 </span></span><br><span class="line"><span class="function">Tree* <span class="title">binaryTreeSearch</span><span class="params">(Tree *node,<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;value==value)</span><br><span class="line"><span class="keyword">return</span> node;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;value&gt;value)&#123;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">binaryTreeSearch</span>(node-&gt;left,value);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">binaryTreeSearch</span>(node-&gt;right,value);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p><h3 id="路径和路径长度"><a href="#路径和路径长度" class="headerlink" title="路径和路径长度"></a>路径和路径长度</h3><p>在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。</p><p>通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。</p><h3 id="节点的权和带权路径长度"><a href="#节点的权和带权路径长度" class="headerlink" title="节点的权和带权路径长度"></a>节点的权和带权路径长度</h3><p>若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。</p><p>*<em>树的路径长度：</em>从树根到每一个结点的路径长度之和．记作：ＴＬ</p><p>树的的带权路径长度&#x2F;**：树中所有叶子结点的带权路径长度之和．记作:WPL(Weighted Path Length)</p><p><strong>WPL 最小的二叉树</strong> 称为 <strong>霍夫曼树（Huffman Tree）</strong>。</p><p><img src="/images/huffman-tree-1.png" alt="img"></p><p>哈夫曼算法</p><p>（１）根据n个给定的权值构成n棵二叉树的森林，森林中每一棵树只有一个带权的根结点（构造森林全是根）</p><p>（２）在森林中，选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和．（选用两小造新树）</p><p>（３）在森林中删除这两棵树，同时将新得到的二叉树加入到森林中．（删除两小添新人）</p><p>（４）重复（２）和（３），直到森林中只有一棵树为止，这棵树即为哈夫曼树．（重复２，３剩单根）<br><img src="/images/huffman-tree-2.png" alt="img"></p><h3 id="为哈夫曼树进行编码"><a href="#为哈夫曼树进行编码" class="headerlink" title="为哈夫曼树进行编码"></a>为哈夫曼树进行编码</h3><p>将二叉树分支中的左分支编为 0，右分支编为 1：</p><p>可以发现每个字符都在树的叶子节点上，因此要获取每个字符的哈夫曼编码，就通过根节点遍历到对应的子节点所经历的路径就是这个字符的编码：</p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><blockquote><p><strong>对于未建好的霍夫曼树，直接求其 WPL</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getWPL</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;  <span class="comment">// 对于未建好的霍夫曼树，直接求其 WPL</span></span><br><span class="line">  priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; huffman;  <span class="comment">// 小根堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) huffman.<span class="built_in">push</span>(arr[i]);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x = huffman.<span class="built_in">top</span>();</span><br><span class="line">    huffman.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> y = huffman.<span class="built_in">top</span>();</span><br><span class="line">    huffman.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> temp = x + y;</span><br><span class="line">    res += temp;</span><br><span class="line">    huffman.<span class="built_in">push</span>(temp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h3><blockquote><p>排序</p></blockquote><p>哈夫曼树是一个带权的二叉树，而在哈夫曼编码中，字符的出现频率就是字符的权重。因此要根据字符的频率放入优先队列中进行排序。然后根据这些字符构建一棵哈夫曼树。</p><p>将队列中的每一个元素都看成一棵树。</p><blockquote><p>合并</p></blockquote><p>进行迭代，每次都去除队列中的前面两个元素，也就是权值最小的两棵子树进行合并成一棵子树。直到最终所有的元素合并成一棵树。这棵树就是哈夫曼树。</p><h3 id="为哈夫曼树进行编码-1"><a href="#为哈夫曼树进行编码-1" class="headerlink" title="为哈夫曼树进行编码"></a>为哈夫曼树进行编码</h3><p>将二叉树分支中的左分支编为 0，右分支编为 1：</p><p><a href="https://oi-wiki.org/ds/huffman-tree/">霍夫曼树 - OI Wiki (oi-wiki.org)</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HNode</span> &#123;</span><br><span class="line">  <span class="type">int</span> weight;</span><br><span class="line">  HNode *lchild, *rchild;</span><br><span class="line">&#125; * Htree;</span><br><span class="line"></span><br><span class="line"><span class="function">Htree <span class="title">createHuffmanTree</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  Htree forest[N];</span><br><span class="line">  Htree root = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 将所有点存入森林</span></span><br><span class="line">    Htree temp;</span><br><span class="line">    temp = <span class="keyword">new</span> HNode;</span><br><span class="line">    temp-&gt;weight = arr[i];</span><br><span class="line">    temp-&gt;lchild = temp-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    forest[i] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在每次循环中，动态分配了一个 HNode 类型的结构体，并将其权重初始化为数组 arr[] 的第 i 个元素，左右子节点指针初始化为 NULL。然后将该结构体的指针赋值给 forest[i]。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;  <span class="comment">// n-1 次循环建哈夫曼树</span></span><br><span class="line">    <span class="type">int</span> minn = <span class="number">-1</span>, minnSub;  <span class="comment">// minn 为最小值树根下标，minnsub 为次小值树根下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (forest[j] != <span class="literal">NULL</span> &amp;&amp; minn == <span class="number">-1</span>) &#123;</span><br><span class="line">        minn = j;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (forest[j] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        minnSub = j;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      这段代码的目的是初始化两个变量 minn 和 minnSub，以便后续在森林中找到权重最小和次小的两颗树。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = minnSub; j &lt; n; j++) &#123;  <span class="comment">// 根据 minn 与 minnSub 赋值</span></span><br><span class="line">      <span class="keyword">if</span> (forest[j] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (forest[j]-&gt;weight &lt; forest[minn]-&gt;weight) &#123;</span><br><span class="line">          minnSub = minn;</span><br><span class="line">          minn = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (forest[j]-&gt;weight &lt; forest[minnSub]-&gt;weight) &#123;</span><br><span class="line">          minnSub = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      for (int j = minnSub; j &lt; n; j++) &#123;  // 根据 minn 与 minnSub 赋值</span></span><br><span class="line"><span class="comment">开始一个循环，从 minnSub 开始遍历 forest 数组中的剩余元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (forest[j] != NULL) &#123;</span></span><br><span class="line"><span class="comment">在每次循环中，首先检查当前位置的 forest[j] 是否不为 NULL。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (forest[j]-&gt;weight &lt; forest[minn]-&gt;weight) &#123;</span></span><br><span class="line"><span class="comment">  minnSub = minn;</span></span><br><span class="line"><span class="comment">  minn = j;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">如果当前位置的树的权重小于 minn 所指示的树的权重，那么将 minnSub 更新为 minn，表示原来的 minn 变成了次小的树，然后将 minn 更新为 j，表示当前的树是最小的树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else if (forest[j]-&gt;weight &lt; forest[minnSub]-&gt;weight) &#123;</span></span><br><span class="line"><span class="comment">  minnSub = j;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">否则，如果当前位置的树的权重小于 minnSub 所指示的树的权重，那么将 minnSub 更新为 j，表示找到了比当前 minnSub 指示的树更小的树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这段代码的目的是在剩余的非空树中找到权重最小和次小的两颗树，并将它们的下标分别存储在 minn 和 minnSub 中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建新树</span></span><br><span class="line">    root = <span class="keyword">new</span> HNode;</span><br><span class="line">    root-&gt;weight = forest[minn]-&gt;weight + forest[minnSub]-&gt;weight;</span><br><span class="line">    root-&gt;lchild = forest[minn];</span><br><span class="line">    root-&gt;rchild = forest[minnSub];</span><br><span class="line"></span><br><span class="line">    forest[minn] = root;     <span class="comment">// 指向新树的指针赋给 minn 位置</span></span><br><span class="line">    forest[minnSub] = <span class="literal">NULL</span>;  <span class="comment">// minnSub 位置为空</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计算构成霍夫曼树的 WPL</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HNode</span> &#123;</span><br><span class="line">  <span class="type">int</span> weight;</span><br><span class="line">  HNode *lchild, *rchild;</span><br><span class="line">&#125; * Htree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getWPL</span><span class="params">(Htree root, <span class="type">int</span> len)</span> </span>&#123;  <span class="comment">// 递归实现，对于已经建好的霍夫曼树，求 WPL</span></span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>)  <span class="comment">// 叶节点</span></span><br><span class="line">      <span class="keyword">return</span> root-&gt;weight * len;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">int</span> left = <span class="built_in">getWPL</span>(root-&gt;lchild, len + <span class="number">1</span>);</span><br><span class="line">      <span class="type">int</span> right = <span class="built_in">getWPL</span>(root-&gt;rchild, len + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于给定序列，计算霍夫曼编码</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HNode</span> &#123;</span><br><span class="line">  <span class="type">int</span> weight;</span><br><span class="line">  HNode *lchild, *rchild;</span><br><span class="line">&#125; * Htree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">huffmanCoding</span><span class="params">(Htree root, <span class="type">int</span> len, <span class="type">int</span> arr[])</span> </span>&#123;  <span class="comment">// 计算霍夫曼编码</span></span><br><span class="line">  <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;结点为&quot;</span>&lt;&lt;root-&gt;weight&lt;&lt;<span class="string">&quot;的字符的编码为: &quot;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr[len] = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">huffmanCoding</span>(root-&gt;lchild, len + <span class="number">1</span>, arr);</span><br><span class="line">      arr[len] = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">huffmanCoding</span>(root-&gt;rchild, len + <span class="number">1</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><blockquote><p>图论（Graph Theory）是数学的一个分支。它以图为研究对象。图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些实体之间的某种特定关系，用点代表实体，用连接两点的线表示两个实体间具有的某种关系。<br>图是一种较线性表和树更加复杂的数据结构。在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。</p></blockquote><p><strong>图的定义</strong>：</p><ul><li>一个图（Graph）G是一个有序对(G,V)，其中V是一些顶点的集合，G是一个连接这些顶点的边的集合。边可以是有向的（连接两个顶点的有序对）或者是无向的（连接两个顶点的无序对）。</li></ul><p><strong>顶点和边</strong>：</p><ul><li>图中的每个元素称为顶点（Vertex），通常用字母表示，如V、W、X等。</li><li>顶点之间的连接称为边（Edge），它可以是有向的或者是无向的。</li></ul><p>图可以被表示为 G&#x3D;{V, E}，其中 V&#x3D;{v1, … , vN}，E&#x3D; {e1, … , eM}。</p><p>V表示图G中顶点的个数，也称图G的阶</p><p>E代表图G边的条数</p><p>图中不能一个顶点也没有，图的顶点集V一定非空，但边集E可以为空</p><p>图可能是无向的，这意味着图中的边在连接顶点时无需区分方向。否则，称图是有向的</p><blockquote><p><strong>有向图和无向图</strong>：</p><ul><li>如果图中的边具有方向，则称该图为有向图（Directed Graph）。</li><li>如果图中的边没有方向，则称该图为无向图（Undirected Graph）。</li></ul></blockquote><p><strong>路径和环</strong>：</p><ul><li><p>路径（Path）是图中连接顶点的一个序列，其中顶点之间通过边相连。</p></li><li><p>环（Cycle）是指图中的一个路径，起始顶点和结束顶点相同。</p></li><li><p>若一个图有n个顶点，并且有大于n − 1条边，则此图一定有环。</p></li><li><p>简单路径是指图中不包含重复顶点的路径</p></li><li><p>简单路径满足以下条件：</p><ol><li>顶点不重复：路径中的所有顶点各不相同。</li><li>边不重复：路径中的所有边各不相同。</li></ol></li><li><p><strong>简单回路（简单环）：除路径起点和终点相同外，其余顶点均不相同的路径。</strong></p></li></ul><p><strong>树</strong>：</p><ul><li>如果一个无向图是一个连通图且没有环，则称该图为树（Tree）。</li><li>树是一种特殊的图结构，它没有回路，并且任意两个顶点之间只有一条简单路径。</li></ul><p><strong>子图</strong>：</p><ul><li>子图（Subgraph）是原始图的一个子集，它包含原始图中的一些顶点和边，这些顶点和边之间的连接关系和方向（如果是有向图）保持不变。</li><li>例如，如果原始图有5个顶点和7条边，而子图中只选择了其中的3个顶点和5条边，那么这个子图就是原始图的一个子图。</li></ul><p><strong>生成子图</strong>：</p><ul><li>如果一个子图包含了原始图中的所有顶点，那么这个子图被称为原始图的生成子图（Spanning Subgraph）。</li><li>生成子图通常是指包含了原始图中所有顶点的最小连通子图，如果是无向图，通常是最小生成树。</li></ul><p><strong>图的连通性：</strong>在图论中，连通图基于连通的概念。在一个无向图 G 中，若从顶点 i 到顶点 j 有路径相连（当然从j到i也一定有路径），则称 i 和 j 是连通的。如果 G 是有向图，那么连接i和j的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）。图的连通性是图的基本性质。</p><ol><li><p><strong>连通</strong>：</p><p>在一个图中，如果任意两个顶点之间都存在路径，那么该图被称为是连通的。换句话说，对于图中的任意两个顶点u和v，都存在一条从顶点u到顶点v的路径。如果一个图不是连通的，则被称为是非连通的。</p><p>在上图中，图是连通的，因为任意两个顶点之间都存在路径。例如，顶点A和顶点E之间存在路径A -&gt; B -&gt; C -&gt; E。</p></li><li><p><strong>连通图</strong>：</p><p>如果一个图是连通的，即图中的任意两个顶点之间都存在路径，那么该图被称为是连通图。换句话说，一个图是连通图，当且仅当该图是一个连通的子图，即该图包含原始图中的所有顶点，并且顶点之间的连接关系和方向（如果是有向图）保持不变。</p><p>上图中的图是一个非连通图，因为它包含了两个不连通的子图：左侧的子图包含了顶点A、B、C，右侧的子图包含了顶点D、E、F。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>-<span class="attr">--B</span>    D-<span class="attr">--E</span></span><br><span class="line">  |  /       /</span><br><span class="line">  | /         /</span><br><span class="line">  C            F</span><br></pre></td></tr></table></figure></li><li><p><strong>连通分量</strong>：</p><p>在一个非连通图中，如果将该图分解为多个连通子图，且每个子图都是连通的，那么这些连通的子图被称为是该图的连通分量。换句话说，连通分量是将一个非连通图分割为连通子图的过程，其中每个连通子图都是极大连通子图（即无法再添加顶点或边使得其保持连通性）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>-<span class="attr">--B</span>    D-<span class="attr">--E</span></span><br><span class="line">|           /</span><br><span class="line">|            /</span><br><span class="line">C             F</span><br><span class="line">   </span><br></pre></td></tr></table></figure><p>上图中的非连通图被分解为了两个连通分量：左侧的连通分量包含了顶点A、B、C，右侧的连通分量包含了顶点D、E、F。</p><h3 id="无权图和有权图"><a href="#无权图和有权图" class="headerlink" title="无权图和有权图"></a>无权图和有权图</h3><p>连接节点与节点的边是否有数值与之对应，有的话就是有权图，否则就是无权图。</p><ol><li><p><strong>无权图（Unweighted Graph）</strong>：</p><ul><li>无权图是指图中的边没有赋予任何权重或者成本的图。</li><li>在无权图中，边只表示顶点之间的连接关系，而不包含额外的信息。</li><li>通常用于表示简单的关系或者连接情况，例如社交网络中的好友关系图。</li></ul></li><li><p><strong>有权图（Weighted Graph）</strong>：</p><ul><li>有权图是指图中的边具有特定的权重或者成本的图。</li><li>在有权图中，每条边都被赋予了一个权重值，表示连接两个顶点之间的成本、距离或者其他衡量标准。</li><li>有权图可以用于模拟现实世界中的各种情况，例如道路网络中的距离、通信网络中的传输延迟等。</li></ul><p><strong>生成树（Spanning Tree）</strong>：</p><ul><li>一个连通图的生成树是指一个包含图中所有顶点且无环的子图。</li><li>换句话说，生成树是一个树形结构，它包含了图中所有的顶点，并且用最少的边来连接所有的顶点，从而保持图的连通性。</li><li>如果一个图是连通的，则一定存在至少一棵生成树。而对于非连通图，可以通过计算每个连通分量的生成树来得到整个图的生成树。</li></ul><h3 id="度"><a href="#度" class="headerlink" title="度"></a>度</h3><ol><li><p><strong>顶点的度（Degree）</strong>：</p><p>顶点的度是指与该顶点相邻的边的数量。对于无向图来说，顶点的度等于与该顶点相邻的边的数量；对于有向图来说，顶点的度等于该顶点的出度和入度之和。</p></li><li><p><strong>出度（Out-degree）</strong>：</p><p>对于有向图中的一个顶点，其出度是指从该顶点出发的边的数量。换句话说，出度表示了从该顶点指向其他顶点的边的数量。</p></li><li><p><strong>入度（In-degree）</strong>：</p><p>对于有向图中的一个顶点，其入度是指指向该顶点的边的数量。换句话说，入度表示了指向该顶点的边的数量。</p></li></ol><p>在有向图中，顶点的度可以进一步分为出度和入度，这是因为有向图中的边具有方向性，从而导致了边的起点和终点的区别。而在无向图中，顶点的度只有一个值，即与该顶点相邻的边的数量。</p></li></ol></li></ol><blockquote><ul><li>对于无向图中的一个顶点，其度等于与该顶点相邻的边的数量。</li><li>对于有向图中的一个顶点，其出度等于从该顶点出发的边的数量，入度等于指向该顶点的边的数量。</li></ul></blockquote><h3 id="稠密图、稀疏图"><a href="#稠密图、稀疏图" class="headerlink" title="稠密图、稀疏图"></a>稠密图、稀疏图</h3><p>边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身是模糊的概念，稀疏图和稠密图常常是相对而言的。一般当图G满足∣ E ∣ &lt; ∣ V ∣ l o g ∣ V ∣时，可以将G视为稀疏图。<br>其他一些知识</p><blockquote><p><strong>完全图：</strong>完全是一个简单的无向图，其中每对不同的顶点之间都恰连有一条边相连。</p><p><img src="/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NTE4NDYx,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述"></p><p><strong>自环边：</strong>一条边的起点终点是一个点。</p><p><strong>平行边：</strong>两个顶点之间存在多条边相连接。</p><h4 id="简单图：一个图G若满足-①不存在重复边-②不存在顶点到自身的边，则称图G为简单图。"><a href="#简单图：一个图G若满足-①不存在重复边-②不存在顶点到自身的边，则称图G为简单图。" class="headerlink" title="简单图：一个图G若满足:①不存在重复边;②不存在顶点到自身的边，则称图G为简单图。"></a>简单图：一个图G若满足:①不存在重复边;②不存在顶点到自身的边，则称图G为简单图。</h4><h4 id="多重图"><a href="#多重图" class="headerlink" title="多重图"></a>多重图</h4><p>若图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则G为多重图。</p></blockquote><h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h2 id="直接存边"><a href="#直接存边" class="headerlink" title="直接存边"></a>直接存边</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或者使用多个数组分别存起点，终点和边权。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> u, v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;Edge&gt; e;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cin &gt;&gt; e[i].u &gt;&gt; e[i].v;</span><br></pre></td></tr></table></figure><h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p><img src="/images/20130429131721379.jpeg" alt="img"></p><h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><p>使用一个二维数组 <code>adj</code> 来存边，其中 <code>adj[u][v]</code> 为 1 表示存在 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="u"> 到 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="v"> 的边，为 0 表示不存在。如果是带边权的图，可以在 <code>adj[u][v]</code> 中存储 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="u"> 到 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="v"> 的边的边权。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; adj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> adj[u][v]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vis[u]) <span class="keyword">return</span>;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj[u][v]) &#123;</span><br><span class="line">      <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  vis.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">  adj.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    adj[u][v] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向有权</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mat[u][v] = w;</span><br><span class="line">    mat[v][u] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>邻接矩阵只适用于没有重边（或重边可以忽略）的情况。</p><p>其最显著的优点是可以 O(1)查询一条边是否存在。</p><p>由于邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会在稠密图上使用邻接矩阵。</p><blockquote><p>如果有权值没有边的就不能设置为0，而是应该设置为无穷参数</p></blockquote><h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h3><p>使用一个支持动态增加元素的数据结构构成的数组，如 <code>vector&lt;int&gt; adj[n + 1]</code> 来存边，其中 <code>adj[u]</code> 存储的是点 u的所有出边的相关信息（终点、边权等)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; adj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; adj[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj[u][i] == v) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vis[u]) <span class="keyword">return</span>;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; adj[u].<span class="built_in">size</span>(); ++i) <span class="built_in">dfs</span>(adj[u][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  vis.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">  adj.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有权值，即是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge e = &#123;to, w&#125;;</span><br><span class="line">    edges[from].<span class="built_in">push_back</span>(e);  <span class="comment">//向vector的最后添加一条边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无向图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(u, v, w);</span><br><span class="line">    <span class="built_in">add</span>(v, u, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><p>逃避了很久这个东西，终究还是逃不过了（）</p><p><a href="https://blog.csdn.net/sugarbliss/article/details/86495945">链式前向星–最通俗易懂的讲解-CSDN博客</a></p><p>讲的很好，一看就很清晰了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span><span class="comment">//加边，u起点，v终点，w边权</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v; <span class="comment">//终点</span></span><br><span class="line">    edge[cnt].w = w; <span class="comment">//权值</span></span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//以u为起点上一条边的编号，也就是与这个边起点相同的上一条边的编号</span></span><br><span class="line">    head[u] = cnt++;<span class="comment">//更新以u为起点上一条边的编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如说我们</p><p>1 2 1</p><p>1 3 5</p><p>1 5 6</p><p>这三条边，他们出现的顺序依次是0，3，5</p><p>那么我们head[1]就从一开始的-1—0—3—-5</p><p>最后我们得到的就是从5，开始的</p><p>而5的next就是3</p><p>3的next就是0</p><p>0的next就是-1，也就是我们的遍历的终止条件。</p><p>感觉链式前向星就是邻接表的静态版本，也就是为什么快的原因</p><p>遍历方式——————</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//n个起点</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = head[i]; j != <span class="number">-1</span>; j = edge[j].next)<span class="comment">//遍历以i为起点的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].to &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].w &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>感谢那位大佬，讲的真的好。</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h1 id="【深基18-例3】查找文献"><a href="#【深基18-例3】查找文献" class="headerlink" title="【深基18.例3】查找文献"></a>【深基18.例3】查找文献</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 K 喜欢翻看洛谷博客获取知识。每篇文章可能会有若干个（也有可能没有）参考文献的链接指向别的博客文章。小 K 求知欲旺盛，如果他看了某篇文章，那么他一定会去看这篇文章的参考文献（如果他之前已经看过这篇参考文献的话就不用再看它了）。</p><p>假设洛谷博客里面一共有 n篇文章（编号为 1 到 n）以及 m 条参考文献引用关系。目前小 K 已经打开了编号为 1 的一篇文章，请帮助小 K 设计一种方法，使小 K 可以不重复、不遗漏的看完所有他能看到的文章。</p><p>这边是已经整理好的参考文献关系图，其中，文献 X → Y 表示文章 X 有参考文献 Y。不保证编号为 1 的文章没有被其他文章引用。</p><p><img src="/images/f4n4tlhi.png"></p><p>请对这个图分别进行 DFS 和 BFS，并输出遍历结果。如果有很多篇文章可以参阅，请先看编号较小的那篇(因此你可能需要先排序)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">8 9</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">4 7</span><br><span class="line">4 8</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 5 6 3 7 8 4 </span><br><span class="line">1 2 3 4 5 6 7 8</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt; <span class="type">int</span> &gt;g[<span class="number">1000000</span>];</span><br><span class="line"><span class="type">bool</span> visit[<span class="number">10000000</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">visit[x] = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (cur==n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visit[g[x][i]])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">dfs</span>(g[x][i], cur + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="built_in">sizeof</span>(visit));</span><br><span class="line">visit[x] = <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(x);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">cout &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[v].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!visit[g[v][i]])</span><br><span class="line">&#123;</span><br><span class="line">visit[g[v][i]] = <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(g[v][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=m ; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">sort</span>(g[i].<span class="built_in">begin</span>(), g[i].<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"><span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><strong>如果一个无向连通图不包含回路(连通图中不存在环),那么就是一个树。</strong></p><p>注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。</p><h4 id="prim-普里姆算法"><a href="#prim-普里姆算法" class="headerlink" title="prim(普里姆算法)"></a>prim(普里姆算法)</h4><blockquote><p>Prim算法是采用从点方面考虑来构建MST的一种算法，Prim 算法在稠密图中比Kruskal优，通常步骤如下</p><p>1.从源点出发，将所有与源点连接的点加入一个待处理的集合中<br>2.从集合中找出与源点的边中权重最小的点，从待处理的集合中移除标记为确定的点<br>3.将找到的点按照步骤1的方式处理<br>4.重复2，3步直到所有的点都被标记</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[maxn],dist[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">dist[pos] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 一共有 n 个点,就需要 遍历 n 次,每次寻找一个权值最小的点,记录其下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="type">int</span> cur = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!vis[j] &amp;&amp; (cur == <span class="number">-1</span> || dist[j] &lt; dist[cur])) &#123;</span><br><span class="line">cur = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里需要提前终止</span></span><br><span class="line"><span class="keyword">if</span>(dist[cur] &gt;= INF) <span class="keyword">return</span> INF;</span><br><span class="line">sum += dist[cur];</span><br><span class="line">vis[cur] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++) &#123;</span><br><span class="line">    <span class="comment">// 只更新还没有找到的最小权值</span></span><br><span class="line"><span class="keyword">if</span>(!vis[k]) dist[k] = <span class="built_in">min</span>(dist[k],a[cur][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">memset</span>(a,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">a[u][v] = <span class="built_in">min</span>(a[u][v],w);</span><br><span class="line">a[v][u] = <span class="built_in">min</span>(a[v][u],w);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> value = <span class="built_in">prim</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span>(value &gt;= INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="kruskal-克鲁斯卡尔算法"><a href="#kruskal-克鲁斯卡尔算法" class="headerlink" title="kruskal (克鲁斯卡尔算法)"></a>kruskal (克鲁斯卡尔算法)</h4><p><strong>一种巧妙利用并查集来求最小生成树的算法。</strong></p><blockquote><p>对于图G(V,E)，以下是算法描述：</p><p>输入： 图G<br>输出： 图G的最小生成树<br>具体流程：<br>(1)将图G看做一个森林，每个顶点为一棵独立的树<br>(2)将所有的边加入集合S，即一开始S &#x3D; E<br>(3)从S中拿出一条最短的边(u,v)，如果(u,v)不在同一棵树内，则连接u,v合并这两棵树，同时将(u,v)加入生成树的边集E’<br>(4)重复(3)直到所有点属于同一棵树，边集E’就是一棵最小生成树</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line"><span class="type">int</span> x,y,z;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.z &lt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u,v,w; </span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">cin&gt;&gt;edge[i].x&gt;&gt;edge[i].y&gt;&gt;edge[i].z);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">fa[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(edge + <span class="number">1</span>,edge + <span class="number">1</span> + m,cmp);</span><br><span class="line"><span class="comment">// 每次加入一条最短的边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line"><span class="type">int</span> x = <span class="built_in">get</span>(edge[i].x);</span><br><span class="line"><span class="type">int</span> y = <span class="built_in">get</span>(edge[i].y);</span><br><span class="line"><span class="keyword">if</span>(x == y) <span class="keyword">continue</span>;</span><br><span class="line">fa[y] = x;</span><br><span class="line">sum += edge[i].z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line"><span class="keyword">if</span>(i == fa[i]) ans ++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(ans &gt; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a><strong>Dijkstra算法</strong></h3><p>Dijkstra 算法是一个基于「贪心」、「广度优先搜索」、「动态规划」求一个图中一个点到其他所有点的最短路径的算法，时间复杂度 O(n2)</p><h4 id="什么是dijkstra"><a href="#什么是dijkstra" class="headerlink" title="什么是dijkstra?"></a>什么是d<strong>i</strong>j<strong>k</strong>s<strong>t</strong>ra?</h4><p><img src="/images/image-20240213183713595.png" alt="image-20240213183713595"></p><p><strong>1.算法介绍</strong></p><p>Dijkstra算法通常是求解单源最短路中最快的算法，但它无法处理存在负权边的情况。Dijkstra本质上是一种贪心算法，通过不断调整每个点的“当前距离”最终得到最优结果，</p><p><code>dijkstra的算法思想</code>是从以上最短距离数组中每次选择一个最近的点，将其作为下一个点，然后重新计算从起始点经过该点到其他所有点的距离，更新最短距离数据。已经选取过的点就是确定了最短路径的点，不再参与下一次计算。</p><p>堆优化找最短路径的过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line">vector&lt;PII&gt;E[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dj</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">dis[i]=INF;</span><br><span class="line">vis[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t=q.<span class="built_in">top</span>().second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[t])&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[t]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,l=E[t].<span class="built_in">size</span>();i&lt;l;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v=E[t][i].first;</span><br><span class="line"><span class="type">int</span> w=E[t][i].second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[t]+w)</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[t]+w;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">E[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dj</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;dis[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>Floyd算法是基于动态规划的，从结点 i 到结点 j 的最短路径只有两种：<br>1、直接 i 到 j<br>2、i 经过若干个结点到 k 再到 j<br>对于每一个k，我们都判断 d[i][j] 是否大于 d[i][k] + d[k][j]，如果大于，就可以更新d[i][j]了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=n; k++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="拓补排序"><a href="#拓补排序" class="headerlink" title="拓补排序"></a>拓补排序</h2><p>在图论中，<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。</p><blockquote><p>有向无环图（DAG）才有拓扑排序</p></blockquote><p>步骤：</p><blockquote><ol><li><p>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</p></li><li><p>从图中删除该顶点和所有以它为起点的有向边。</p></li><li><p>重复 1 和 2 直到当前的 DAG 图为空或<strong>当前图中不存在无前驱的顶点为止</strong>。后一种情况说明有向图中必然存在环。</p><p><img src="/images/20150507001759702.png" alt="img"></p><p>一个有向无环图可以有<strong>一个或多个</strong>拓扑排序序列</p></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//by dpcc</span></span><br><span class="line"><span class="comment">//世间温柔</span></span><br><span class="line"><span class="comment">//不过是芳春柳摇染花香</span></span><br><span class="line"><span class="comment">//槐序蝉鸣入深巷</span></span><br><span class="line"><span class="comment">//白茂叶落醉故乡</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span> ;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n)  for(re int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> frep(i,a,n) for(re int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;a[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> du[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> n2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!du[i])</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">b[++n2]=x;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="type">int</span> t=a[x].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">0</span>,t)</span><br><span class="line">&#123;</span><br><span class="line">du[a[x][i]]--;</span><br><span class="line"><span class="keyword">if</span>(!du[a[x][i]])</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(a[x][i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">frep</span>(i,n2,<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;b[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[t].<span class="built_in">push_back</span>(i);</span><br><span class="line">du[i]++;</span><br><span class="line">cin&gt;&gt;t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>一、查找的基本概念<br><strong>查找定义：</strong>根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p><p>查找表(Search Table)：是由同一类型的数据元素(或记录)构成的集合。</p><p>关键字(Key)：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</p><p>静态查找表(Static Search Table)：只作查找操作的查找表。<br>**动态查找表(Dynamic Search Table)**： 在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。</p><p><strong>平均查找长度（Average Search Length，ASL）：</strong>需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。</p><p>　　对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL &#x3D; Pi*Ci的和。<br>　　Pi：查找表中第i个数据元素的概率。<br>　　Ci：找到第i个数据元素时已经比较过的次数。</p><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SequenceSearch</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==value)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>O（N）</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote><p><strong>元素必须是有序的，如果是无序的则要先进行排序操作。</strong></p><p><strong>折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要****频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。</strong></p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch1</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">            high = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">-1</span>;  <span class="comment">// 未搜索到数据返回-1下标</span></span><br><span class="line">  <span class="type">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);  <span class="comment">// 直接平均可能会溢出，所以用这个算法</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; key)</span><br><span class="line">      start = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">      end = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 最后检测相等是因为多数搜索情况不是大于就是小于</span></span><br><span class="line">      ret = mid;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;  <span class="comment">// 单一出口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>背景：</p><blockquote><p>当我们从字典中查找 “apple” 这个单词的时候，我们肯定不会傻傻地像二分查找一样首先从中间开始。相反，**我们会从首字母为 a 的地方开始查找。</p></blockquote><p>插值查找是一种在<strong>有序数组</strong>（前提条件）中查找某一特定元素的查找算法。插值查找基于二分查找，不同的是插值查找每次从自适应mid处开始查找，提高查找效率。</p><p>归根到底只是Mid不同罢了</p><p>插值查找的平均复杂度为 Θ(log⁡log⁡n) ，</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插值查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InsertionSearch</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = low+(value-a[low])/(a[high]-a[low])*(high-low);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">InsertionSearch</span>(a, value, low, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">InsertionSearch</span>(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）对于<strong>数据量较大，关键字分布比较均匀</strong>的查找表来说，采用插值查找时速度较快。<br>（2）<strong>在关键字分布不均匀的情况下，插值查找不一定比折半查找好</strong>。</p><h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p><strong>斐波那契</strong>查找原理与<strong>二分查找</strong>相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于<strong>黄金分割点</strong>附近。</p><p> 前置<strong>n &#x3D; Fu - 1</strong></p><ul><li>若相等，则查找成功</li><li>若key &lt; a[Fu-1] ，则继续在 a[1] 至 a[Fu-1 - 1] 的子表中进行查找</li><li>若key &gt; a[Fu-1] ，则继续在 a[Fu-1 + 1] 至 a[Fu - 1] 的子表中进行查找。该子表的长度为 Fu-2 -1</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契查找.cpp </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_size=<span class="number">20</span>;<span class="comment">//斐波那契数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造一个斐波那契数组*/</span> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> * F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    F[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;max_size;++i)</span><br><span class="line">        F[i]=F[i<span class="number">-1</span>]+F[i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义斐波那契查找法*/</span>  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FibonacciSearch</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span>  <span class="comment">//a为要查找的数组,n为要查找的数组长度,key为要查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> high=n<span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> F[max_size];</span><br><span class="line">  <span class="built_in">Fibonacci</span>(F);<span class="comment">//构造一个斐波那契数组F </span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)<span class="comment">//计算n位于斐波那契数列的位置</span></span><br><span class="line">      ++k;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>  * temp;<span class="comment">//将数组a扩展到F[k]-1的长度</span></span><br><span class="line">  temp=<span class="keyword">new</span> <span class="type">int</span> [F[k]<span class="number">-1</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(temp,a,n*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;F[k]<span class="number">-1</span>;++i)</span><br><span class="line">     temp[i]=a[n<span class="number">-1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(key&lt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">      high=mid<span class="number">-1</span>;</span><br><span class="line">      k-=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">     low=mid+<span class="number">1</span>;</span><br><span class="line">     k-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(mid&lt;n)</span><br><span class="line">           <span class="keyword">return</span> mid; <span class="comment">//若相等则说明mid即为查找到的位置</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> n<span class="number">-1</span>; <span class="comment">//若mid&gt;=n则说明是扩展的数值,返回n-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">delete</span> [] temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">16</span>,<span class="number">24</span>,<span class="number">35</span>,<span class="number">47</span>,<span class="number">59</span>,<span class="number">62</span>,<span class="number">73</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line">    <span class="type">int</span> key=<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> index=<span class="built_in">FibonacciSearch</span>(a,<span class="built_in">sizeof</span>(a)/<span class="built_in">sizeof</span>(<span class="type">int</span>),key);</span><br><span class="line">    cout&lt;&lt;key&lt;&lt;<span class="string">&quot; is located at:&quot;</span>&lt;&lt;index;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>索引查找又称为分块查找，是一种介于顺序查找和二分查找之间的一种查找方法，索引查找的基本思想是：首先查找索引表，可用二分查找或顺序查找，然后在确定的块中进行顺序查找。</p><p>在实现索引查找算法前需要弄清楚以下三个术语。</p><p>（1）主表：即要查找的序列。</p><p>（2）查找表：一般我们会将主表分成几个块，每个块中的元素被称为是查找表。</p><p>（3）索引表：即索引项的集合。</p><p>在利用索引查找时，需要先对数据进行分块。</p><p>就是分块然后进行查找</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="type">int</span> i, startValue;</span><br><span class="line">　　i = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">while</span> (i&lt;<span class="number">3</span> &amp;&amp; key&gt;newIndex[i].key) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　<span class="comment">// 确定在哪个块中，遍历每个块，确定key在哪个块中</span></span><br><span class="line">　　　　i++;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">if</span> (i&gt;=<span class="number">3</span>) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　<span class="comment">//大于分得的块数，则返回0</span></span><br><span class="line">　　　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　startValue = newIndex[i].start; <span class="comment">//startValue等于块范围的起始值</span></span><br><span class="line">　　<span class="keyword">while</span> (startValue &lt;= startValue+<span class="number">5</span> &amp;&amp; a[startValue]!=key)</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　startValue++;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">if</span> (startValue&gt;startValue+<span class="number">5</span>) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　<span class="comment">//如果大于块范围的结束值，则说明没有要查找的数</span></span><br><span class="line">　　　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> startValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h2><p>哈希表又称散列表，一种以「key-value」形式存储数据的数据结构。所谓以「key-value」形式存储数据，是指任意的键值 key 都唯一对应到内存中的某个位置。只需要输入查找的键值，就可以快速地找到其对应的 value。可以把哈希表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。</p><p>冲突：<code>key1≠key2; Hash（key1）==Hash（key2）</code>，即两个不同关键字，具有相同地址时，就叫发生冲突。</p><p><img src="/images/20210517094111543.png" alt="关键字和存储地址之间的对应关系"></p><h3 id="1、直接定址法"><a href="#1、直接定址法" class="headerlink" title="1、直接定址法"></a>1、直接定址法</h3><p>哈希地址：f(key) &#x3D; a*key+b (a,b为常数)</p><p>这种方法的优点是：简单，均匀，不会产生冲突。但是需要事先知道 key 的分布情况，适合查找表较小并且连续的情况。</p><h3 id="2、数字分析法"><a href="#2、数字分析法" class="headerlink" title="2、数字分析法"></a>2、数字分析法</h3><p>若我们现在要存储某家公司员工登记表，如果用手机号码作为 key，那么极有可能前7位都是相同的，所以我们选择最后四位作为 f(key) 就是不错的选择。</p><h3 id="3、平方取中法"><a href="#3、平方取中法" class="headerlink" title="3、平方取中法"></a>3、平方取中法</h3><p>故名思义，比如 key 是1234，那么它的平方就是1522756，再抽取中间的3位就是227作为 f(key) 。</p><h3 id="4、折叠法"><a href="#4、折叠法" class="headerlink" title="4、折叠法"></a>4、折叠法</h3><p>折叠法是将 key 从左到右分割成位数相等的几个部分(最后一部分位数不够可以短些)，然后将这几部分叠加求和，并按哈希表的表长，取后几位作为 f(key) 。</p><p>比如我们的 key 是 9876543210，哈希表的表长为3位，我们将 key 分为4组，987|654|321|0 ，然后将它们叠加求和 987+654+321+0&#x3D;1962，再取后3位即得到 f(key) &#x3D; 962 。</p><h3 id="5、除留余数法"><a href="#5、除留余数法" class="headerlink" title="5、除留余数法"></a>5、除留余数法</h3><p>哈希地址：f(key) &#x3D; key mod p (p&lt;&#x3D;m) m为哈希表表长。</p><p><strong>这种方法是最常用的哈希函数构造方法。</strong></p><h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><blockquote><h3 id="1-开放地址法（闭散列法）："><a href="#1-开放地址法（闭散列法）：" class="headerlink" title="1.开放地址法（闭散列法）："></a>1.开放地址法（闭散列法）：</h3><p>核心思想是，把发生冲突的元素放到哈希表中的另外一个位置。<br>线性探测法：发生冲突时，逐位往后挪动，寻找合适位置，只要哈希表没满，就一定能找到一个不发生冲突的位置。<br>addressi&#x3D;( Hash(key) + di )，其中 di &#x3D; 1，2，3··</p><p>二次探测法：发生冲突时，每次向后挪动k2个单位（k为挪动次数）。<br>addressi&#x3D;( Hash(key) + di )，其中 di &#x3D; 12，22，32···</p><p>伪随机探测法：发生冲突时，每次向后挪动k个单位（k为伪随机生成数）。</p><p>线性探测法的优点是：只要散列表未填满，总能找到一个不发生冲突的地址。缺点是：会产生 ”二次聚集“ 现象。而二次探测法和伪随机探测法的优点是：可以避免 “二次聚集“ 现象。缺点也很显然：不能保证一定找到不发生冲突的地址。</p><h3 id="2-链地址法（开散列法）："><a href="#2-链地址法（开散列法）：" class="headerlink" title="2.链地址法（开散列法）："></a>2.链地址法（开散列法）：</h3><ul><li>链地址法的基本思想是：把具有相同散列地址的记录放在同一个单链表中，称为同义词链表。有 m个散列地址就有 m个单链表，同时用数组 HT[0…m-1]存放各个链表的头指针，凡是散列地址为 i 的记录都以结点方式插入到以HT[i]为头结点的单链表中。</li></ul></blockquote><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p><p><img src="/images/bubbleSort.gif" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>* pa, <span class="type">int</span>* pb)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> tmp = *pa;</span><br><span class="line">*pa = *pb;</span><br><span class="line">*pb = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line"><span class="comment">//单趟</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - j; ++i) &#123;</span><br><span class="line"><span class="comment">//前一个数大于后一个数，就交换</span></span><br><span class="line"><span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) &#123;</span><br><span class="line"><span class="built_in">Swap</span>(&amp;a[i - <span class="number">1</span>], &amp;a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>选择排序（ Selection sort）是一种简单直观的排序算法。它的工作原理是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。</strong></p><p><img src="/images/selectionSort.gif" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select_Sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span>   <span class="comment">//arr为数据数组，n为数组长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line"><span class="type">int</span> min = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">min = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min != i) &#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>排序：即将一组混乱的数据按从小到大或者从大到小的顺序进行有序的排列出来。</p><p><img src="/images/insertionSort.gif" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> *beauties, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> index;<span class="comment">// 存储待比较的的索引</span></span><br><span class="line"><span class="type">int</span> ret;<span class="comment">// 保存待插入数据</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">index = i - <span class="number">1</span>;<span class="comment">// 保存待插入数据的前一个数据的索引</span></span><br><span class="line">ret = beauties[i];<span class="comment">// 保存待插入数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 当索引大于等于零，且所有对应的数值大于待插入数据</span></span><br><span class="line"><span class="keyword">while</span> (index &gt;= <span class="number">0</span> &amp;&amp; beauties[index] &gt; ret) &#123;</span><br><span class="line">beauties[index + <span class="number">1</span>] = beauties[index];<span class="comment">// 将当前索引的数值往后移动一个位置</span></span><br><span class="line">index--;<span class="comment">// 索引减一</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当索引为-1或者索引对应的值要比ret小时，就可以退出循环，ret就可以插入到索引加一的位置了</span></span><br><span class="line">beauties[index + <span class="number">1</span>] = ret;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序是一个稳定的排序方法。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><img src="/images/20200708163800850.gif" alt="在这里插入图片描述"></p><p>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。希尔排序是记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><p><strong>1. 时间复杂度：</strong>最坏情况下，每两个数都要比较并交换一次，则<strong>最坏情况下的时间复杂度为O（n2）</strong>, 最好情况下，数组是有序的，不需要交换，只需要比较，则<strong>最好情况下的时间复杂度为O（n）。</strong></p><p>经大量人研究，希尔排序的<strong>平均时间复杂度为O（n1.3）</strong></p><p><strong>2. 空间复杂度：</strong>希尔排序，只需要一个变量用于两数交换，与n的大小无关，所以<strong>空间复杂度为：O（1）。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> grp = len / <span class="number">2</span>;<span class="comment">// 计算增量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (; grp &gt; <span class="number">0</span>; grp = grp / <span class="number">2</span>) &#123;<span class="comment">// 每次计算完一轮，增量再除以二</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择排序</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = grp; i &lt; len; i++) &#123;</span><br><span class="line"><span class="type">int</span> cur = arr[i];<span class="comment">// 先空出第二个数的位置</span></span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据增量往前比较，小的在前，大的在后</span></span><br><span class="line"><span class="keyword">for</span> (j = i - grp; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; cur; j = j - grp) &#123;</span><br><span class="line">arr[j + grp] = arr[j];<span class="comment">// 符合条件将前面的数据移动到空出的位置</span></span><br><span class="line">&#125;</span><br><span class="line">arr[j + grp] = cur;<span class="comment">// 最后将待插入数据cur插入到前面空出的位置</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序算法有两个基本的操作，一个是分，也就是把原数组划分成两个子数组的过程。另一个是治，它将两个有序数组合并成一个更大的有序数组。</p><p>将待排序的线性表不断地切分成若干个子表，直到每个子表只包含一个元素，这时，可以认为只包含一个元素的子表是有序表。<br>将子表两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。</p><p><img src="/images/20200209185525881.gif" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(a,l,mid),<span class="built_in">merge_sort</span>(a,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l,j=l,k=mid+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(j==mid+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]=a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k==r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]=a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a[j]&lt;=a[k])</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]=a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t[i]=a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法性能"><a href="#算法性能" class="headerlink" title="算法性能"></a>算法性能</h2><p>速度仅次于快速排序。</p><h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>**O(nlogn)**。</p><h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p>**O(N)**，归并排序需要一个与原数组相同长度的数组做辅助来排序。</p><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p><strong>稳定</strong>。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src="/images/quickSort.gif" alt="img"></p><p>采用“分治”的思想，对于一组数据，选择一个基准元素（base），通常选择第一个或最后一个元素，通过第一轮扫描，比base小的元素都在base左边，比base大的元素都在base右边，再有同样的方法递归排序这两部分，直到序列中所有数据均有序为止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qSortArray</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> start, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> low = start;</span><br><span class="line"><span class="type">int</span> high = last;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (array[low] &lt;= array[start] &amp;&amp; low &lt; last)</span><br><span class="line">&#123;</span><br><span class="line">low++;<span class="comment">//满足小于基准的条件，指针右移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (array[high] &gt;= array[start] &amp;&amp; high &gt; start)</span><br><span class="line">&#123;</span><br><span class="line">high--;<span class="comment">//满足大于基准的条件，指针左移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">swap</span>(array[low], array[high]);<span class="comment">//交换两个不满足条件的元素</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(array[start], array[high]);<span class="comment">//插入基准元素</span></span><br><span class="line"><span class="built_in">qSortArray</span>(array, start, high - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">qSortArray</span>(array, high + <span class="number">1</span>, last);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆结构</p><p>解释在代码里</p><p>这是大根堆</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for(int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//一个是数组，一个是最后一个节点所在位置</span></span><br><span class="line"><span class="comment">//1.top操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//返回堆顶也就是最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>||w[x]&lt;w[x/<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//就是你已经到达根顶了，或者你已经小于你的父节点了</span></span><br><span class="line">    <span class="comment">//这样就行了实际上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(w[x],w[x/<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//这也正是没有达到上述情况，那么你就要交换</span></span><br><span class="line"><span class="built_in">modify</span>(x/<span class="number">2</span>);</span><br><span class="line"><span class="comment">//交换完继续处理上一个节点</span></span><br><span class="line"><span class="comment">//递归处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[++tot]=x;<span class="comment">//加入元素直接在尾部进行加入</span></span><br><span class="line">    <span class="built_in">modify</span>(tot);<span class="comment">//自底向上修复</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">repair</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x*<span class="number">2</span>&gt;tot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//已经到达叶子节点，和上个modify操作一样</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tar=<span class="number">2</span>*x;</span><br><span class="line"><span class="keyword">if</span>(x*<span class="number">2</span>+<span class="number">1</span>&lt;=tot)</span><br><span class="line">&#123;</span><br><span class="line">    tar=w[x*<span class="number">2</span>]&gt;w[x*<span class="number">2</span>+<span class="number">1</span>]?x*<span class="number">2</span>:x*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(w[x]&lt;w[tar])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(w[x],w[tar]);</span><br><span class="line">    <span class="built_in">repair</span>(tar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(w[<span class="number">1</span>],w[tot--]);</span><br><span class="line">    <span class="comment">//这一步有两个操作，第一个是交换头尾，第二个是删除尾部</span></span><br><span class="line">   <span class="comment">//接下来我们要修复头部</span></span><br><span class="line">   <span class="built_in">repair</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="built_in">push</span>(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;-<span class="built_in">top</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p><img src="/images/countingSort.gif" alt="img"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(MAX, <span class="number">0</span>)</span></span>;           <span class="comment">//统计每个数字出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : a)</span><br><span class="line">count[x]++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num = <span class="number">0</span>; num &lt; MAX; num++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(count[num])&#123;</span><br><span class="line">        a[k++] = num;</span><br><span class="line">        count[num]--;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(count);           <span class="comment">//相当于用一个空直接换掉</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : v)</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">int</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">        a.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">show</span>(a);</span><br><span class="line">    <span class="built_in">CountingSort</span>(a);</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">show</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>桶排序按下列步骤进行：</p><ol><li>设置一个定量的数组当作空桶；</li><li>遍历序列，并将元素一个个放到对应的桶中；</li><li>对每个不是空的桶进行排序；</li><li>从不是空的桶里把元素再放回原来的序列中。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w, a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; bucket[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> key = A[i];</span><br><span class="line">    <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; key) &#123;</span><br><span class="line">      A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">    A[j + <span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucket_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> bucket_size = w / n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    bucket[i].<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    bucket[a[i] / bucket_size].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">insertion_sort</span>(bucket[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; bucket[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">      a[++p] = bucket[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STLsort"><a href="#STLsort" class="headerlink" title="STLsort"></a>STLsort</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[0] .. a[n - 1] 为需要排序的数列</span></span><br><span class="line"><span class="comment">// 对 a 原地排序，将其按从小到大的顺序排列</span></span><br><span class="line">std::<span class="built_in">sort</span>(a, a + n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cmp 为自定义的比较函数</span></span><br><span class="line">std::<span class="built_in">sort</span>(a, a + n, cmp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span> &#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> data rhs) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a == rhs.a) ? (b &lt; rhs.b) : (a &lt; rhs.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; da[<span class="number">1009</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> data u1, <span class="type">const</span> data u2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (u1.a == u2.a) ? (u1.b &gt; u2.b) : (u1.a &gt; u2.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">std::<span class="built_in">sort</span>(da + <span class="number">1</span>, da + <span class="number">1</span> + <span class="number">10</span>);  <span class="comment">// 使用结构体中定义的 &lt; 运算符，从小到大排序</span></span><br><span class="line">std::<span class="built_in">sort</span>(da + <span class="number">1</span>, da + <span class="number">1</span> + <span class="number">10</span>, cmp);  <span class="comment">// 使用 cmp 函数进行比较，从大到小排序</span></span><br></pre></td></tr></table></figure><h2 id="本文的主要参考（抄袭对象）"><a href="#本文的主要参考（抄袭对象）" class="headerlink" title="本文的主要参考（抄袭对象）"></a>本文的主要参考（抄袭对象）</h2><p><a href="https://blog.csdn.net/real_fool_/category_10818355.html">数据结构_UniqueUnit的博客-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第二十四章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第二十四章-中考余波"><a href="#第二十四章-中考余波" class="headerlink" title="第二十四章.中考余波"></a>第二十四章.中考余波</h1><p>中考成绩出来，有人欢喜有人愁。</p><p>对于苏瑾来说，这已然是一个相当不错的成绩，苏瑾将成绩截图后发给了老姐，老班。</p><p>老姐大吃一惊，准备回去好好请他吃一顿。</p><p>老板则是发了一句好样的，恭喜便匆匆跑去询问下一个同学成绩了。</p><p>苏瑾点开聊天框，还没回复许穆清的消息呢，<br>爱静的苏打：老许，考的不赖嘛，可惜，我更胜一筹，我考了695</p><p>叮咚<br>老许：被你装到了<br>老许：不过这成绩确实牛，估计你这次有全校前五了，说不定还能得到市的奖学金</p><p>爱静的苏打：运气有些好<br>爱静的苏打：其他人怎么样？</p><p>老许：我刚刚问了其他人，叶杨考了704，这家伙还是一如既往的稳健，不知道有没有希望超过夏沫，顾千羽674，洛云初699，陈凡685，大家江南中学都能上的了，就是不知道能不能一个班级。</p><p>爱静的苏打：不错嘛，大家都考的可以，运气好一些应该可以一个班的了</p><p>老许：期望吧，过几天就可以填志愿了，先等江南中学预估一下分数线，再填吧</p><p>爱静的苏打：没问题</p><p>老许：我妈叫我回老家，我先下了</p><p>爱静的苏打：欧克</p><p>另一旁的夏沫家，夏沫和笑猫呆在卧室里，夏沫虽然是大佬中的大佬，但在这种时刻，也还是有些紧张，手指揪着衣角，眼睛一眨也不眨的盯着屏幕。</p><p>夏沫：笑猫，你说我能考好吗？</p><p>笑猫：喵呜（你肯定没问题的，主人那么厉害）<br>笑猫用毛茸茸的脑袋摩擦着夏沫的小手，试图缓解夏沫心中无处安放的紧张感。</p><p>对于夏沫，这不仅仅是分数的问题，但凭分数，夏沫上个江南中学真是太简单了，这包括她能否拿到高额的奖学金，为这个家庭出一份力量，减缓老爸夏皓的压力。</p><p>手机上的小圆圈不停的转啊转，夏沫却胆小的闭上了了眼睛，双手合上，也不知道在祈祷些什么。</p><p>耳边不断传来声音，<br>“喵呜，喵呜”<br>“喵，喵….”<br>夏沫睁开眼睛，小圆圈已经消失不见，夏沫没有立刻看右下角的成绩所在地，而是一个字一个字的认真看着成绩查询的的结果，小脸红扑扑的，心跳也开始加快。<br>考生姓名：夏沫<br>………<br>……….<br>考生总成绩：731</p><p>夏沫一把抱住了眼前的笑猫，一人一猫开心的蹦蹦跳跳，<br>“我考了731哇”<br>“模拟考最高也才716”<br>“真的和做梦一样”</p><p>“喵呜，喵呜”</p><p>夏沫像突然想到了什么一样，又突然坐了回去，对着手机屏幕再三确认，在确保那三个数字不会无端消失后，她总算长出了一口气。</p><p>夏沫滑动手指，将成绩截屏后发给了正在上班的老爸夏皓。</p><p>夏沫抱着笑猫走到窗前，微风吹起少女的秀发，少女低声与风述说，<br>“妈，你看见了吗，女儿没有辜负期望……”</p><p>音量很小，小到笑猫都只能听到几个词语，但声音传的很远，顺着风声，绵长而悠扬……</p><p>两房相邻，两份喜悦相逢……</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第二十三章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第二十三章-中考成绩出炉"><a href="#第二十三章-中考成绩出炉" class="headerlink" title="第二十三章.中考成绩出炉"></a>第二十三章.中考成绩出炉</h1><p>“起床了，苏瑾哥哥”</p><p>一大清早，苏瑾的房门就被打开，孟嫣然大呼小叫的冲了进来，掀开苏瑾的被子。</p><p>“别闹，嫣然，让哥哥再睡一会”苏瑾迷迷糊糊的睁开眼，拉上被子，随即又不争气的闭上。</p><p>“苏瑾哥哥是大懒虫，还不起床”孟嫣然嘴角微微嘟起来，呆萌的声音带些糯糯感。</p><p>嫣然哪里能惯着这个懒虫，直接跳到苏瑾的床上，对着苏瑾一顿不痛不痒的输出。</p><p>苏瑾不情不愿的起了床，摸了摸小表妹的额头，<br>“还真拿你没办法，大姨载你过来的对吧”</p><p>“嗯，我自己要来的，就让妈妈载我了”</p><p>“昨天说要来，今天就来了，你还真是守约”<br>“那大姨人呢”</p><p>“她和姨说了几句话就走了”嫣然傲娇的抬起头来，<br>“我还带来了礼物”</p><p>苏瑾注意到小女孩旁边的小袋子，<br>“袋子里装的是什么”</p><p>孟嫣然赶忙拿起小袋子，紧紧地抓在身前，嘴角向上扬起，<br>“现在不能给你，是秘密，要等你查成绩之前给你”。</p><p>“神神秘秘的，查成绩应该要10点后，”<br>苏瑾被这一提醒，才记起老班说的查成绩这件事情。</p><p>提起成绩，不自觉便有一大块石头压在胸前，纵然他已觉得考场上已然尽力发挥，但想到几个小时自己即将知道这场考试的结果，还是有一种恍惚感与不可避免的紧张感。</p><p>孟嫣然的声音把苏瑾由思考拉回现实，<br>“要这么久啊，那我先去找格格米玩咯”说着，孟嫣然便蹦蹦跳跳跑出了苏瑾房间。</p><p>苏瑾整理好情绪，走出房间。</p><p>老妈雪玲芳女士在拖地，老爸苏晨嘛，还在睡觉。当然，苏晨可不是每天都睡这么晚，确实是这些天学校事情多，待会学生成绩出来还要通知每个学生汇报成绩，虽然教育局明令禁止这种行为，不过学校还是会暗暗进行。</p><p>“儿子，待会查成绩的时候不要紧张啊”<br>“要看仔细了”<br>“之前你大姑的儿子，查成绩，540分都能看错，看成504分，还好最后他又回去查了一遍……”<br>老妈雪玲芳神神叨叨的话语在耳边不断响起，苏瑾其实不怎么紧张的，反倒是老妈，她比苏瑾还要紧张，大清早就睡不着觉，起来做家务了，似乎这样做才可以不那么心神不宁。</p><p>苏瑾成绩一贯稳定，很少出现滑铁卢的状况，至于大姑儿子那件事情，苏瑾已经听了不下10次了，他已经快可以原文背诵了。</p><p>“好嘞，我知道了，妈，我不紧张”</p><p>在阳台和格格米戏耍的孟嫣然一听两人的对话，火急火燎的插上一句，</p><p>“苏瑾哥哥那么厉害，姨姨你就放心吧”苏瑾脸上微笑浮起，这个表妹虽然有时候有的小笨，但总是这么可爱和会说话。</p><p>孟嫣然叽叽喳喳的和雪玲芳女士说着自己在家里，在学校里的种种行为，时而逗得雪玲芳眉开眼笑，连脸上的仅有的几条皱纹都冲淡了，果真是家有一小，似有一宝啊。</p><p>一切准备就绪，时间的钟声已经悄无声息的走到了9点半。</p><p>老爸苏晨坐在旁边，和领导讨论着学校事务，老妈雪玲芳则是在旁和大姨打着视频电话，苏瑾和孟嫣然则在卧室里面静候成绩，当然，还有他的袋子。</p><p>查成绩时候爸妈围在旁边这种事太让人紧张了，苏瑾决定自己查完再告诉二老，至于孟嫣然嘛，盯上了苏瑾的小学时候几本漫画书，正看的津津有味，姑且就让她也陪着一起吧。</p><p>苏瑾打开手机，手机的消息已然爆炸性上升。若不是自己开启了静音，恐怕每一刻都要叮咚叮咚的响个不停。</p><p>老姐：老弟，我听妈说你成绩今天出来，你姐我那是过来人，安安心心查就是了，你的实力那比起我是只强不差<br>苏瑾莞尔一笑，老姐还是很关心自己的，期末那么忙还抽空给自己打气。</p><p>爱静的苏打：谢谢这位老姐，你肯定会收到第一手成绩，新鲜出炉的<br>一个多来A梦表情包弹了出来。</p><p>苏瑾退出对话框，打开班群，当然是没有老师的学生班群，<br>一条条信息不断弹出，<br>A同学：老师说待会要发总分，再发截图<br>A同学：私信<br>B同学：不想发<br>C同学：可以不发吗<br>C同学：丢人<br>C同学：哭脸<br>D同学：我现在好紧张啊，难受<br>A同学：分还没出就说丢人？<br>C同学：这叫预测（哭脸）</p><p>…….<br>大家都很紧张啊，苏瑾感叹。</p><p>莫名的焦虑弥漫在整个九年级群体，也直接影响了苏瑾的情绪。</p><p>不想了不想了，苏瑾将群消息调为消息免打扰，随即关闭手机。</p><p>苏瑾从书桌上选了一本书，《活着》，余华著作，上次买完后还未翻开过，反正也没什么好做的，于是翻开书页，开始阅读。</p><p>文字的力量是无限的，苏瑾一进入这个属于福贵的世界，便深陷其中…..</p><p>故事开始于一个老人喜欢回想过去，喜欢讲述自己，故事结束于老人和牛渐渐远去，歌声在空旷的傍晚像风一样飘扬。</p><p>苏瑾眼眶泛红，原来这就是所谓苦痛吗？最无奈莫过于我认识的人一个挨着一个死去，我还活着……</p><p>苏瑾合上书本，或许他不会再打开这本书了，竟然沉重至此，一滴泪划过脸庞。</p><p>孟嫣然不知何时，出现在苏瑾眼前，有些诧异的看着，<br>“苏瑾哥哥，你怎么哭了，是成绩不好吗”<br>“没事，以后妹妹帮你打败这个中考，这个大恶魔，好可恶”</p><p>苏瑾看着为自己打抱不平的可爱表妹，不由得一笑，自己何其幸运，拥有着如此生活。</p><p>苏瑾摸了摸孟嫣然的头，温柔的开口，<br>“哥哥没事，现在跟哥哥一起查成绩好不好”</p><p>“好耶，等等”<br>孟嫣然拿起身旁的袋子递给苏瑾，闪着水灵灵的大眼睛，<br>“苏瑾哥哥，我的礼物”</p><p>“那我打开了哦”苏瑾打开袋子，里面有个两个外表有着鲜艳图案的盒子，</p><p>“还有一层啊”苏瑾有些呆滞，不会有好几层吧。</p><p>“苏瑾哥哥继续打开”孟嫣然俏皮一笑。</p><p>苏瑾沉下气，打开第一个盒子。</p><p>是满满的一叠千纸鹤，形态各异但栩栩如生，还用蜡笔染了不一样的颜色。</p><p>苏瑾问道“这些都是你做的？”</p><p>“有几个是妈妈做的，我让她教我做，来报答苏瑾哥哥教我学习”孟嫣然一脸得意，脸上写满了“快夸我”三个大字。</p><p>苏瑾有些感动，没想到这小家伙将教学习那事记到现在，还真是…不错呢，应该好好夸她一下。</p><p>“嫣然变得很腻害呢”苏瑾模仿着嫣然的口音说到。</p><p>“苏瑾哥哥总算念对了，就是腻害啦”<br>孟嫣然眼睛一亮，跳了起来。</p><p>苏瑾接着又打开一盒，这次是满满的幸运星，苏瑾拿出一个放在桌上，另一个拿在手上端详。</p><p>“这个也是我做的，嘿嘿”</p><p>“星星很好看”苏瑾惊叹，这小女孩还真是长大了呢，星星都会做了。</p><p>“我很喜欢”苏瑾微微点头，对小女孩竖起大拇指。</p><p>“苏瑾哥哥还是只会用大拇指夸人，哼”孟嫣然虽然嘴上说着，心里却是和吃了蜜一样甜。</p><p>“那我们开始查成绩吧，现在10点过了一小会了”<br>“你的千纸鹤和幸运星很不错，肯定会起作用的”</p><p>“那当然”</p><p>叮咚，苏瑾手机传来信息，<br>老许：老苏，你成绩查了没，我查到了，我考了663（总分770）啊，模拟考都没这么高过，江南中学肯定稳上了。</p><p>苏瑾决定查后再回复这位老友，想罢便点开小程序广东教育考试院。</p><p>“苏瑾哥哥，不…紧张，不紧….张”<br>孟嫣然在旁边用颤抖的声线说着硬气的话语，把苏瑾逗乐了。</p><p>苏瑾高挂的心早已平静下来，查询界面，苏瑾淡定的输入，页面卡顿着，手机上的加载小圆圈转啊转啊，一刹那，苏瑾瞥见了自己的分数—695。</p><p>孟嫣然的大眼睛也瞧见了这个成绩，<br>“姨，姨丈，苏瑾哥哥考了695啊”<br>边说边冲出房门，一刻不停的重复着那个数字。</p><p>老妈雪玲芳猛地一个跳起，<br>“真的吗，真的考了695吗”雪玲芳声音也有些震颤，连忙跑到房间，这分数比她姐当时的分数还要高出十多分啊。</p><p>“真的，是真的”孟嫣然连连用力点头，“就是那三个数字，我学过的”随机嫣然用及其夸张的动作比划3那3个数字</p><p>老爸苏晨反应则没有这么大，也许是要维护男士沉稳的形象，又或是早有意料，他悄无声息的跟在老妈雪玲芳后面走进了房间。</p><p>苏晨拍了拍苏瑾的肩膀，“干的漂亮，过阵子爸带你去钓鱼”</p><p>苏瑾一脸黑线，这老爸又要钓鱼了，每次都比自己钓的少。</p><p>“别听你爸胡扯，待会妈叫你大姨过来，今天妈妈和你大姨一起下厨，给你好好吃一顿”</p><p>“喵呜，喵呜”<br>……</p><p>所念皆所现了嘛，此刻初中三年才算真正拉下帷幕了罢，苏瑾心想。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第二十二章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第二十二章-表妹（她只是我的妹妹，妹妹说紫色很有韵味）"><a href="#第二十二章-表妹（她只是我的妹妹，妹妹说紫色很有韵味）" class="headerlink" title="第二十二章.表妹（她只是我的妹妹，妹妹说紫色很有韵味）"></a>第二十二章.表妹（她只是我的妹妹，妹妹说紫色很有韵味）</h1><p>格格米呆在电动车的前方，苏瑾的脚下，安静的躺着，时不时睁开朦胧的双眼看着身后渐行渐远的楼房。</p><p>笑猫则躺在夏沫怀里，它哪里坐过电动车这种奇异物件，好奇的眼神东张西望，对什么都发出喵喵喵的叫声，格格米则给予回应，两猫的谜语交流，自然是让坐在车上的两人摸不着头脑，只当是出行的兴奋吧。</p><p>清晨的风带来宜人的凉爽，苏瑾早起的些许疲惫感也尽数吹散。</p><p>后视镜的夏沫微低着头，轻轻的抚摸着笑猫的小背。</p><p>“上次，你的额头那里怎么样了”<br>苏瑾突然回忆起上次的白猫堵车事件，关切的问道。</p><p>“啊？…已经没事了”夏沫习惯性的呆滞一秒，然后才反应过来。</p><p>“那就好”</p><p>夏沫心里有些暖暖的，没想到上次一件小事，他都能记得那么深刻。</p><p>车子稳稳的前行，在城镇的中心停下，这是一栋墙面由玻璃幕墙与金属材质交错构成的建筑，蓝色的光泽，散发着流线型的美感，建筑上方赫然有着四个大字“生福百货”。</p><p>两人并排走在一起，宛如刻意穿上了情侣装一般，加上身旁各自的一只白猫大护法，朝气中有些奇异，引得路人频频注目。</p><p>商场宠物区，</p><p>格格米和笑猫躺在手推车里，喵喵喵的小声交流着。</p><p>苏瑾手里拿着一款猫粮<br>“夏沫，刚开始这款猫粮比较好，价格也很实惠可以考虑一下，如果可以，也可以搭配一些晚饭给笑猫吃”</p><p>“嗯，那要这个”夏沫点点头，心里暗暗感慨有前辈引路真好，不然自己这个养猫萌新，连几款猫粮都挑不明白。</p><p>苏瑾核查了一下生产日期和密封情况，拿了两包猫粮放进行李箱，摸了摸笑猫的头。<br>“以后就有猫粮可以吃了，笑猫”</p><p>笑猫温馨一笑，对眼前的苏瑾好感又加了几分。</p><p>“猫粮是以后就这款嘛”夏沫有些好奇。</p><p>“猫粮两三个月可以考虑换一款，这样子可以保证营养均衡，那时候你可以买这几款，猫粮A，猫粮B，和猫粮C，可以做一下替换，这样笑猫就不会产生厌恶的情绪”苏瑾耐心的解释道。</p><p>夏沫乖巧的点了点头，一一记下了各自猫粮的名字。</p><p>“我们接下来去看看其他的”</p><p>“好”</p><p>“猫砂盆这种会比较好，一方面容易清洗……..”</p><p>“这种猫砂盆可以对应这种铲子，还有，我们铲的时候呢，要注意……”</p><p>“猫床，我之前买过这款，但格格米用起来不好，后来换了这种就很好了，你可以挑选一个喜欢的颜色”</p><p>“还有梳子，猫的毛比较独特，家里的梳子使用起来会不太顺手，可能对猫毛造成伤害，这个会好一些，对了，梳毛的时候可以这样……”</p><p>一波波的挑选和解释，对于每样东西苏瑾都耐心的给予解释，关于这种东西的具体用法和注意事项，苏瑾还会回忆起之前的养猫经历，述说一些自己养格格米的酸甜苦辣，夏沫的心情也由一开始的紧张变得踏实起来，有时候还被逗得扑哧一笑。</p><p>夏沫侧过头，看着眼前的少年，拿着梳子缓缓的，温柔的給笑猫梳着毛发，她向上看去，灯光洒在少年脸上，某中闪着清幽，烁着光芒，似乎时间就此停在这一刻也未尝不可。</p><p>祥和总是在不经意间被打破，比如软萌的一声，</p><p>“苏瑾哥哥”<br>夏沫看到苏瑾的眼神波动了一下，嘴角挂着淡淡的微笑。</p><p>这叫声，便是来自于苏瑾的二年级表妹孟嫣然。</p><p>苏瑾在初二暑假去大姨家住了一阵子去，同时嘛，也充当了表妹孟嫣然的半个家教，负责教100以内的加减法，这小女孩，什么都好，就是有点笨，不过嘛，长相十分可爱，眼睛又大又灵动，留着齐肩头发。</p><p>苏瑾抬起头，眼前的表妹已经光速跑过来，嘻嘻笑着开始撸猫，</p><p>“苏瑾哥哥，怎么猫多了一只啊，除了格格米，另外一只是哪来的”</p><p>“是我旁边这位姐姐的，她叫夏沫，夏沫，这是我的表妹孟嫣然”<br>苏瑾指着夏沫介绍道。</p><p>孟嫣然这时才意识到苏瑾旁有个女生，抬起头好奇的打量着眼前的少女，然后嘛，则是语不惊人死不休，</p><p>“苏瑾哥哥这么快就娶老婆了，怎么没给我发喜糖”</p><p>苏瑾一脸黑线：……</p><p>夏沫则是：？自己出来逛个商场就把自己嫁了？</p><p>“不是的！不是的！我不是她的老婆”<br>夏沫极力的辩解着。</p><p>孟嫣然则根本没有理解夏沫的话，顺着自己的逻辑说下去，<br>“苏瑾哥哥和这位漂亮姐姐什么时候结婚的”</p><p>“她不是我老婆”苏瑾耐心的解释道。</p><p>“那肯定是还没结婚，那什么时候开始结婚啊”</p><p>“你要叫她姐姐，她是我的一个同学和朋友，不是老婆”</p><p>“那以后会变成老婆吗”</p><p>苏瑾迟疑了一会，自己在解释什么劲，还是直截了当一些，不然肯定被她绕进去，越解释越乱。</p><p>“你叫她夏沫姐姐就好了”</p><p>孟嫣然像是听懂了一般，瞪着水灵灵的大眼睛，点了点头。</p><p>“夏沫姐姐，你好好看”<br>孟嫣然端详着夏沫，发出自己的评价。</p><p>夏沫弯下腰，牵着她的手，<br>“你很可爱”</p><p>孟嫣然还是小孩子，被这一夸就好像吃了蜜糖一般，赖在夏沫身旁不走了。</p><p>“嫣然，你是一个人来的？”苏瑾有些不放心，开口问道，<br>“对，我来这里玩一玩”孟嫣然俏皮的回答。</p><p>“大姨知道吗”</p><p>“我和她说了，不过她那时候在睡觉”</p><p>苏瑾大脑过载，<br>“嫣然，你现在要回去”</p><p>“不嘛，好不容易见到苏瑾哥哥，不想那么快回去”孟嫣然苦苦哀求，连夏沫不经也生出几分不忍。</p><p>夏沫抬头看向苏瑾，苏瑾会意。</p><p>“那你和我们逛完商场后再回去，怎么样，在这期间你要跟在你夏沫姐姐旁边，不许乱跑”</p><p>“好耶，苏瑾哥哥最好了”<br>孟嫣然欢呼。</p><p>她一直都很崇拜苏瑾，认为苏瑾哥哥大概是世界上最厉害的人了，那么难的数学问题在苏瑾这里宛如砍瓜切菜，对于自己一些问题妈妈和爸爸不回答的他也能回答，知道为什么天是蓝的，为什么人不能飞起来，为什么飞机可以飞起来……</p><p>“那我们去买最后一样东西，猫玩具”</p><p>“夏沫姐姐，你那只猫猫叫什么名字啊”</p><p>“它叫笑猫，它会笑哦”</p><p>“真的吗，我还从来没有见过会笑的猫欸”<br>“你看，笑猫”</p><p>笑猫心领神会，面对如此卡哇伊的萝莉，笑猫直接奉上自己最真挚的笑容。</p><p>“真的哇，夏沫姐姐和苏瑾哥哥一样腻害”孟嫣然心里大大的佩服和震撼，瞬间把夏沫抬到了和苏瑾一样的高度。</p><p>苏瑾嘴角微微上扬，纠正道<br>“是厉害”</p><p>“腻害，就是腻害”</p><p>“厉害”</p><p>“你读错了，我才是对的，明明就是腻害”</p><p>夏沫看苏瑾如此吃瘪，不由得一笑，对眼前的小萝莉好感又加几分。</p><p>在苏瑾和嫣然的建议下，最后夏沫给笑猫挑选了一个皮球和一副五子棋，皮球嘛，笑猫自己玩，至于五子棋嘛，培养笑猫和格格米一起玩。</p><p>商场门口，孟嫣然依依不舍地和苏瑾，夏沫告别，<br>“苏瑾哥哥，过几天我和我妈说，去你家玩”</p><p>苏瑾摸了摸小萝莉的头，<br>“嗯，等你”</p><p>“还有，你们结婚一定要告诉我啊，夏沫姐姐，不然我可不走了”<br>傲娇的孟嫣然大有不走的架势，苏瑾又是一脸黑线，没想到她还没忘记这事，苏瑾无法，只能撇头看向旁边裹上一层红的夏沫，夏沫羞涩的微微点头，苏瑾这才答应下来，送走了这位无法无天的表妹。</p><p>耳边的风热烈的吹过，车座上有的是意气风发的少年，面色红润的少女，还有偶尔的喵喵叫声……</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第二十一章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>第二十一章.商场走起</p><p>听完一曲的苏瑾精神焕发，叠好被子走到阳台，与在阳台晒着太阳的两猫打了个照面。</p><p>“喵呜”两只猫异口同声，向着苏瑾打着招呼。</p><p>“格格米和..笑猫啊，你们两个这么快就见面了”</p><p>“喵呜（是啊是啊），喵呜”格格米率先回应，笑猫则嘴角上扬，一个微笑。</p><p>“格格米，你看，笑猫会笑”</p><p>格格米已经知道自己的老弟有这本领，转头看去，笑猫嘴角向右扬起，活脱脱的歪嘴战猫。</p><p>格格米把爪子放在笑猫肩上，<br>“喵喵”（老弟已经震慑了我主人了，太行了）</p><p>“喵呜，喵”（我还会其他的）笑猫喵罢便展示了一波苦笑，坏笑，狂笑，冷笑，狞笑，嘲笑，皮笑肉不笑，比起取毕业证那天更加丰富的表情接连流露，笑猫真乃名副其实。</p><p>另一旁的夏沫也刚刚起来，见到本应躺在被中的笑猫灵异消失，不由想到了初来乍到时的格格米，这两只白猫还真是很相像呢，夏沫心想。</p><p>“说起来，今天要去给笑猫买一些必备品，不过要买什么好呢？”</p><p>要不问一下苏瑾？<br>不行不行，不能什么事情都麻烦他，还是我先查查。</p><p>夏沫打开尘封已久的百度，在搜素框输入“猫咪必备用品”，点击搜索，开头嘛，是不可避免的广告，然后是琳琅满目的商品和推荐，点进去则或多或少带些弹窗，眼花缭乱，夏沫果断退出百度，夏沫微微苦笑，还是问苏瑾吧。</p><p>夏沫打开聊天框，<br>简单的夏末：我想给笑猫买一些用品，你有什么推荐吗？<br>苏瑾家，<br>电视上播放着猫和老鼠，格格米和笑猫坐在沙发上，看着电视上的汤姆和杰瑞斗智斗勇，却屡次失败，接连发出喵喵的婉惜声。</p><p>叮咚，苏瑾手机呼吸灯一亮。</p><p>正在沙发上看小说的苏瑾合上书本，拿起手机，看了一下夏沫的信息，随即思索了一下，列了一份清单。</p><p>爱静的苏打：<br>1.猫砂盆，猫砂，猫砂铲<br>2.猫粮和水盆<br>3.可以考虑一些猫玩具<br>4.猫床<br>5.猫毛梳子<br>目前我想到的是这些。</p><p>简单的夏末：谢谢</p><p>简单的夏末：这些东西在哪里可以买到？</p><p>爱静的苏打：你家现在有人吗？</p><p>夏沫有些疑惑，怎么突然跑题了。</p><p>简单的夏沫：现在就我一个人</p><p>爱静的苏打：我去你家讨论吧，顺便把格格米和笑猫带过去，他们在我家看电视</p><p>“不会吧”夏沫高呼，自己这刚起床还没洗脸，夏沫来不及回消息立刻往洗手间跑去，转念一想昂，又立刻跑回来拿起手机，速速敲打着手机键盘，</p><p>简单的夏末：等等，你10分钟后再过来</p><p>随即夏沫往洗手间跑去。</p><p>苏瑾看着信息，有些奇怪，回了个好之后，拿起书本又津津有味的看了起来。</p><p>大约过了一会，苏瑾站起身来，走到卧室，依然是熟悉的换了一身白色衬衫，黑色短裤，再穿上一双运动白鞋，一套动作行云流水，走出卧室，连两猫都一致认为干净而清爽。</p><p>“格格米，笑猫，我们去夏沫家，讨论一下给笑猫买东西的事情，顺便给格格米也买点猫粮”</p><p>“喵呜（好哇）”两猫异口同声。</p><p>苏瑾拿起遥控器，关掉电视，写了张小纸条留在桌上，带上两猫，走出了家门。</p><p>“喵呜（这下你也可以看看我家了）”笑猫一脸得意。<br>“喵呜（我可是第二次来了）”格格米反将一军。<br>……<br>“咚咚咚”苏瑾来到门前，象征性的敲了几下门。</p><p>爱静的苏打：我到你家门口了</p><p>夏沫一番洗漱后换了身白色衬衫，以及老爸生日送的一条黑色长裙，十分正式，一身服装被17岁的清秀少女穿起，可爱而端庄。</p><p>叮咚，你的好友爱静的苏打发来了一条消息。</p><p>夏沫撇了眼信息，便着急慌忙的小跑出去开门。</p><p>哐当，<br>“早上好，夏沫”映入眼帘的是少年脸上挂着笑意，挥着手，打着招呼，配合上清晨的阳光勾勒，颇有一些秀致佳绝，看了使人心情舒畅。</p><p>“早上好”夏沫莞尔，礼貌的微微摇手，随着她的动作，几缕发丝滑落下来，乌黑的发尾，盘成一个圈，衬着一张秀丽的脸庞，眼中闪过一丝紧张与羞涩，长睫一动，美目流转，似有艳光流过。</p><p>两猫则不管三七二十一，相视一眼，你知我知，立刻跑进了家里。</p><p>苏瑾算是夏沫搬家后家中第一个客人了，夏沫看着少年一身装扮，心里暗暗吐槽，精心挑选的服装，竟然会有种情侣装的感觉，都是白色上身和黑色下装，是设计好的吗，他没注意到吗？</p><p>夏沫走在前方，心里不停的打着预防针，苏瑾嘛，则打样着夏沫的家，干净整洁，简洁之中不输大方，房间窗户也是精致的贴上了窗花，映衬着少女亲自做的风铃，也是别有一番风味。</p><p>夏沫刚坐下，突然一个激灵，似乎想起了什么，留下一句等我一下，便径直走向卧室，留下苏瑾一脸茫然。</p><p>只是一会，夏沫面带微笑的拿出纸张和钢笔，面对着苏瑾坐下。</p><p>苏瑾心里大大的疑惑<br>“你…这是要考试吗？夏沫”</p><p>“不是要讨论笑猫的用品吗？”夏沫歪歪头。</p><p>“那个，我们直接去商场选吧，在路上讨论”苏瑾已经有所计划，在这里讨论的东西商场不一定会有，到时夏沫可能还是不知道选什么，自己和她亲自去比较保险。</p><p>“啊？”夏沫被打了个措不及防。</p><p>“我可以现场指导” </p><p>“那也…….”夏沫语塞当场，一方面不想再麻烦苏瑾，另一方面，穿着类似情侣装的服装出去逛商场，这比一起取毕业证还要尴尬啊，这也太雷了。夏沫转头用求助的眼光望向躺在沙发上的两猫，似乎将希望寄托在双猫上，<br>“那它们要去吗，万一它们不想过去呢”</p><p>“让它们举手投票一下”<br>“笑猫，格格米”<br>“喵呜”</p><p>“要不要去商场，要去举起爪子”</p><p>两毛坐在沙发上听着两人说话，面对问题两猫都没有立刻举起爪子。</p><p>笑猫拿不定主意，看向老大格格米，“喵呜（格格米老兄，我们去不去，主人听起来是想去的，你看她在盯着我）</p><p>“喵呜（我也觉得她肯定想去，商场我还没去过，我们跟着他们一起去看看）”</p><p>两猫丝毫没有注意到夏沫眼里饱含的求助信号，都认为夏沫是想去商场的，直接举起双爪，一致表示同意。</p><p>夏沫有些恨猫不成钢，笑猫竟然完全倒向了格格米，不过是自己挖下的坑，含泪也要跳下去了。</p><p>苏瑾语气闲淡，从沙发上站起，<br>“那我们可以出发了”</p><p>笑猫，格格米：“喵呜”（出发喽）</p><p>夏沫嘛，脸色有些红润，弱弱的回了声好，便没了下文。</p><p>于是，两人时隔一日再次共骑，不过这次不是自行车，而是苏瑾心爱的电动车，不仅仅是两个人，还有两只白猫。</p><p>队伍浩荡，商场走起！</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第二十章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第二十章-两猫会议"><a href="#第二十章-两猫会议" class="headerlink" title="第二十章.两猫会议"></a>第二十章.两猫会议</h1><p>清晨，阳光还未照进窗内，睡在夏沫临时铺好的床垫上的笑猫清醒过来。</p><p>“喵呜（这一晚太舒服了）”</p><p>感受着棉被的柔软和少女房间特有的香气，笑猫嘴角微微扬起，迈着步子，走出了家门。</p><p>笑猫走在巷子里，懒洋洋的走着猫步，迎面走来另外一只白猫，哪有那么多白猫，细看那个英姿飒爽，自然是格格米将军。</p><p>两只白猫见面，各自吓了一大跳，后退了几步。</p><p>格格米秉持着友好的原则，率先扬起爪子，挥了挥，就当是打招呼了。</p><p>笑猫何等精明，也举起小爪，象征性的扬起。</p><p>笑猫率先开口，进行着猫语交流，<br>“猫兄，尊姓大名啊”</p><p>“我叫格格米”格格米略微抬起头，有些得意。</p><p>“我叫笑猫”笑猫对自己的名字也是很满意，两猫气势上不相上下。</p><p>“我们找个地方好好聊天？怎么样，笑猫老弟”格格米起了兴致，自己还未见过和自己一样纯白的猫咪。</p><p>“好嘞”笑猫自从昨天见识过夏沫家后，对人类是百般好奇，心中正有万千问题要询问，当即就连忙点头答应眼前看起来资历更深的格格米。</p><p>“你家在哪里，去你家怎么样”格格米用爪子拍了拍笑猫的肩膀，颇有老大哥的风范。</p><p>“老兄，跟我来”</p><p>笑猫带着格格米，两猫奔走在小巷中，格格米看着这路线，心想，这不就是我家的路吗，一阵疑惑涌上心头。</p><p>笑猫在苏瑾家旁停下，扬起爪子，指了指夏沫家的房门，<br>有些得意的开口，<br>“这就是我家”</p><p>“猫生有幸啊，笑猫老弟，我家就在你家旁边，奇怪，我之前从没看过你”<br>格格米也举起爪子，指了指旁边的另一栋房子。</p><p>“我是昨天被养的”笑猫没好意思说自己被养的经历，用爪子挠了挠头，有些尴尬。</p><p>“是一个人类女孩吗”格格米想到了那个刚搬来的少女。</p><p>“对对对，就是她，她人太好了，不仅养我，昨天还特地去找了一床棉被给我，太舒服了”笑猫用兴奋的语气谈论着，时而眯着眼，回味着昨日的棉被的舒适，表情写满幸福。</p><p>“我认得那个人类女孩，昨天她应该和我主人去拿毕业证了，我闻到我家自行车上有她的气味”格格米的鼻子一向灵动，苏瑾一回家就被它发现身上有股淡淡的香气，狐疑的格格米便想到了夏沫，一番推理就得出了以上结论。</p><p>“你家主人，是一个男的吗，说起来我还要好好感谢他，他简直是我的大恩人，没有他，我现在肯定还在漂泊”笑猫回忆起曾经被猫族排斥，刁难的经历，脸上有些苦涩。</p><p>“笑猫老弟曾经过的不好啊”格格米注意到了笑猫的表情变化，关切地询问。</p><p>笑猫将久久压在心中的过往经历通通述说给了格格米，从它发现自己会笑开始说起，笑猫脸上时而兴奋，更多的则是悲伤，和怀才不遇的一种悲愤。</p><p>“笑猫老弟，他们嫉妒你的才华，没事，以后有我格格米罩着你，我们就是兄弟了了”格格米有些气愤，用猫爪重重的拍打着地板，激起了一些灰尘。</p><p>“谢谢你，格格米老兄”笑猫脸上再次浮现笑容，一种终觅知音的快感让他心里暖烘烘的。</p><p>“笑猫老弟肯定能会展现自己的才华的”格格米祝福这位猫中奇猫。</p><p>“对了，格格米老兄，关于人类我有很多不懂，你可以给我一些答案吗”笑猫知道人类的生活和猫的生活是大相径庭，故而虚心请教。</p><p>“那是当然，你尽管问”格格米的猫爪拍拍胸脯，打了包票。</p><p>“先从刚刚开始，你知道人类的毕业证是什么意思吗，格格米老兄”</p><p>“我想一下…人类只要长得比较高，就要去一个叫学校的地方，在那里学习考试，如果在那里学完了几年就可以毕业了，然后就可以领毕业证了”</p><p>“那考试又是什么意思”笑猫歪了歪头，再次发问</p><p>“我听苏瑾说考试就是把学到要看看一下你学会了没，考完要打分，最高分应该是100分，考到100就很厉害，考几分的话好像就不行的，我家主人好像很厉害，经常能考90几分”格格米一脸自豪，对自己的主人自信满满。</p><p>“原来是这样，不知道我家主人能考几分”笑猫挠了挠毛茸茸的脑瓜，有些好奇夏沫的成绩。</p><p>“ 她比我家主人还厉害，好像次次都是第一名”</p><p>“第一名，那不是很差吗？照格格米老兄说，第100名才厉害呢”笑猫有些摸不着头脑，眼睛一闪一闪。</p><p>“第一名就是考100分的人”格格米耐心的解释。</p><p>“哇，那她好厉害的，人还那么好，我捡到宝了”笑猫猛地跳起，音量不由得也加大了几分。</p><p>“笑猫老弟有大福了”格格米一脸老父亲的慈祥样，看着兴奋的上蹿下跳的笑猫。</p><p>“那人类要学习多久啊？”冷静下来的笑猫继续发出疑问。</p><p>“苏瑾的爸爸经常说学无止境，可能要学习一辈子”格格米回想起这句话就有些后怕，身子哆嗦了一下。</p><p>“那人不是很累吗，一辈子都要学习，不像我们猫，就很自在”</p><p>“我也觉得很累，不过人类有句话叫活在当下，似乎在那个当下做到该做的事情，可能人就不那么累了”格格米只能用苏瑾口中的只言片语来回答。</p><p>“有点难懂”笑猫一下子接收了这么多新知识，脑子都大了，爪子把猫毛都抓下来几根。</p><p>“我也不太懂，感觉只要活的比较快乐就好了”这话就是格格米的猫道了，格格米自信的将其展露了出来。</p><p>“我们的主人也要快乐”笑猫立刻补充道。</p><p>“那是当然，笑猫老弟还没去过我家吧，我带你去游玩一下”<br>格格米极具老大风范，说着就要带笑猫参观一下。</p><p>“好嘞，人类世界好有趣，我要好好研究研究”笑猫摇了摇脑袋，求知的态度让格格米都有些钦佩。</p><p>如果旁人路过，定会觉得这两只白猫在那里喵喵叫个不停，是在争吵，殊不知只稍一会，这两猫便已经是至交，再来一桌一茶便可学老者畅聊天上地下。</p><p>格格米率先带着笑猫来到苏瑾的房间，苏瑾房间放着音乐，苏瑾已经起来了，他习惯起床后放一首歌，美名其曰给自己一首歌的时间精神一下再起床。</p><p>格格米指着床上的少年，<br>“他就是我主人，在听歌，他一直都很喜欢听歌，渐渐的，我也开始喜欢听歌了”格格米微微眯着眼，享受着旋律。</p><p>“雨水滴在我的外套”<br>“思念浸透我的衣角”<br>“你给的暗号”<br>“微微一笑”<br>“出现的刚刚好”</p><p>“好听哇，这个得得得的声音好轻快，听起来很轻松”笑猫一下子就沉浸在美妙的音符中，脑袋跟着旋律摇啊摇，晃啊晃。</p><p>“是吧，我主人会弹吉他，以后让他弹给你听”格格米指着书架旁的吉他。</p><p>“好耶”</p><p>“走，跟我来，小声一点，隔壁房间是苏瑾的爸爸和妈妈”格格米化身猫导游，带着笑猫迁移到另外一处。</p><p>“奇怪，他们为什么在一起睡觉”未经世事的笑猫摸不着头脑，立刻发问。</p><p>“他们是夫妻，人类一个男的一个女的在一起睡觉，然后就生下来了另一个人类”</p><p>笑猫半懂不懂，<br>“那你的主人和我的主人可以睡觉吗”笑猫脑子转的很快，一下子就学会了举一反三。</p><p>“我感觉可以，你这个想法好哇，我怎么就没想到，笑猫老弟好头脑”<br>格格米对这个想法是赞叹不已，连连拍打笑猫的肩膀。</p><p>“嘿嘿，那我们要不想办法让他们在一起睡觉”笑猫微微挪动身体，跃跃欲试。</p><p>“要看他们两个开不开心，我们可以看看他们两个在一起的表情”格格米还是稳重，决定徐徐图之。</p><p>“如果他们两个可以在一起，那我就可以和格格米老兄天天聊天了”笑猫嘿嘿一笑，不过这种放在旁人猥琐的笑容，在笑猫这却有些痞帅。</p><p>“太棒了，我们任重而道远啊”<br>格格米从苏瑾的口中学到了这句话，随口脱出。</p><p>“任重道远是什么啊”</p><p>“就是压力很大的意思”</p><p>“格格米老兄说话好厉害”笑猫双爪拍打，对格格米那是充满了敬佩。</p><p>“那是”格格米十分自豪，可惜它不会笑，只能勉勉强强让嘴角挪动，逗得笑猫前仰后合。</p><p>两只猫不断小声的喵喵叫着，友谊就此建立。</p><p>此次会谈，史称：双猫会议，参加者，格格米，笑猫。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第十九章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B9%9D%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第十九章-新的一员"><a href="#第十九章-新的一员" class="headerlink" title="第十九章.新的一员"></a>第十九章.新的一员</h1><p>夏沫用钥匙打开大门，白猫十分自来熟的迈着步子，跨过了门槛，开始了住家的旅途。</p><p>夏沫家并不小，有三个房间，一个是夏沫的，另一个则是老爸夏皓的，还有一个则是预留下来给到访的亲戚居住的，至于吃厅，则和客厅相连，也有一席煮饭之地。</p><p>家里的地板干净整洁，窗边挂着几个风铃，风吹铃响，甚是美好。</p><p>白猫在新的环境中好奇地闻嗅着每一个角落，尾巴高高地翘起，展示着好奇心，<br>“喵呜”<br>（原来这就是人类少女住的地方）</p><p>白猫兴奋的发出叫声，一会跳到电视台上，一会跳到桌上，散发着无限活力，分明是在宣告着自己成为这个家庭的成员。</p><p>夏沫看着四处乱跑的白猫，想出声呼叫白猫过来，发现还没给它取个名字，话卡在嘴边。</p><p>夏沫走到白猫跟前，向白猫招了招手，示意过来这边。</p><p>白猫心领神会，乖巧的走到夏沫身旁，伸出两只小脚，夏沫顺势将白猫抱起，坐在沙发上。</p><p>“猫猫，给你取个名字好不好啊，如果不好叫一声，好的话叫两声”</p><p>“喵，喵（好哇，好哇）”<br>猫猫用舌头舔了舔猫爪。</p><p>夏沫欣喜白猫能听懂自己的话，不过这个名字倒令她犯难，取个什么样的名字呢？</p><p>“叫你柔柔，秀秀这种的怎么样”</p><p>“喵呜，喵呜（不要啊，本喵可是男猫，这种名字让我怎么在猫界混下去）”<br>白猫连忙伸出猫爪，拼命的摇晃着，</p><p>“喵呜，喵呜（看我，看我）”白猫不断晃着脑袋。</p><p>“不要啊”夏沫的手托着脸，有些犯难。</p><p>白猫点着头，心里一阵欣慰，只要不取这种名字，什么都好。</p><p>叮咚，夏沫放在桌上的手机呼吸灯一亮，夏沫瞬间有了主意，遇猫不决，求助苏瑾。</p><p>夏沫点开手机，刚刚的叮咚只是一个中考成绩通知，两天后即可在广东教育考试院进行查看，不过嘛，眼下的白猫是大事，中考成绩对夏沫来说反而是小巫见大巫，被夏沫弃置一旁。</p><p>夏沫打开聊天框，思索片刻，开始打字，</p><p>简单的夏末：我想给路上的猫起个名字，你感觉什么样的名字好</p><p>夏沫放下手机，怀里的猫咪眼睛一闪一闪的，注意到少女的眼睛朝这边看来，嘴角咧开，露出个十分治愈的微笑。</p><p>夏沫突然有了主意，也在这时候，手机传来了消息的通知声。</p><p>爱静的苏打：我想一想</p><p>简单的夏末：你觉得笑猫这个名字怎么样？</p><p>爱静的苏打：哈，这只猫会好多种笑，叫做笑猫也名副其实，不错的，很有命名天赋嘛你</p><p>苏瑾也觉得这名字符合，还有一部分原因是夏沫觉得符合那他不得附和一波，这波还顺带夸了一波，简直一举三得，苏瑾心情舒畅。</p><p>屏幕前的夏沫莞尔一笑，眸光流动，看的白猫一呆一呆的。</p><p>那双眼睛，盯着屏幕，流光溢彩，闪着夺目的光芒，似乎任何修辞手法都不能形容这一刻的美丽。</p><p>“喵呜喵呜（这个人类少女笑起来真好看）”白猫看的有些花痴。</p><p>简单的夏末：嗯，那我去和白猫沟通一下。</p><p>爱静的苏打：好</p><p>夏沫被这一小夸有些害羞，还是溜了再说。</p><p>“以后就叫你笑猫了好不好”</p><p>“喵呜，喵呜，喵呜（这好啊，太好了，那个黑色壳子是什么魔物，竟然让我主人一下子变得这么聪明）”</p><p>会笑最终以笑猫命名，白猫差点潸然泪下，没想到竟然会以笑来命名，因为会笑，自己没少被巷子的那群野猫排挤，都快觉得笑是个灾星了，终于，在这里，夏沫的家里，笑被赋予了意义。</p><p>白猫的叫声难掩兴奋，夏沫这次没有使用苏瑾的方法，因为看到眼前活蹦乱跳的笑猫，她知道这个名字很好，因为它很喜欢。</p><p>“喵呜喵呜（我笑猫，就在这里住了）”笑猫兴奋一跳，翻阅猫生新篇章。</p><p>晚上。</p><p>“我回来了”<br>父亲宋皓雄浑的声音响起。</p><p>和夏沫一起待在房间的笑猫捕捉到陌生人的声音，率先冲了出去。</p><p>笑猫站在宋皓面前，不停的叫唤，想要赶走这位突然到访的客人。</p><p>“喵呜，喵呜（你是谁，闯进我笑猫的家作甚）”笑猫抬头看着眼前的壮实男子，丝毫没有恐惧，张牙舞爪，意气风发，想将他尽快叉出去。</p><p>宋皓看着突然出现的猫咪，一阵疑惑。</p><p>笑猫看着不战表情先怂的敌人，心想，原来区区人类也不过如此，在我笑猫的威压下还是选择屈服了吗？笑猫嘴角上扬，邪魅一笑。</p><p>夏沫连忙从房间走出来，没好气的说<br>“笑猫，他是我爸”</p><p>笑猫的笑容凝固在空气中。</p><p>空气也随之安静下来。</p><p>宋皓看着猫咪丰富的表情变化，饶是沉稳的他也不经捧腹大笑。</p><p>“爸，这是笑猫，我在路边捡到的，我可以留他在家吗”</p><p>“我保证它会听话的”</p><p>“喵呜，喵，喵（原来我可不可以住还要靠他，那我刚才那么对她岂不是完蛋了，不行不行，得做点什么）”<br>笑猫迈着步子小跑到夏皓脚下，用头蹭着夏皓的裤脚，</p><p>“喵呜（留下本喵吧，本喵很好的）”</p><p>夏皓被这猫的机警吸引了，蹲下身去将猫咪抱起，<br>“当然可以，这只猫很有趣”</p><p>“喵呜哇（哦耶，我成功了）”<br>笑猫抑制不住嘴角，开始狂笑。</p><p>夏皓微微一笑，他工作一直都比较忙，能陪伴夏沫的时间大都集中在晚上，有时候晚上吃完饭就要去写一些方案，虽然职位水涨船高，可以赚的钱也越来越多，而陪伴女儿的时间反而日益缩减，夏皓心里很是难受。现在有一只猫可以陪伴夏沫，夏皓自然是很开心。</p><p>“太棒了，谢谢爸”夏沫莞尔一笑，喜上眉梢。</p><p>夏皓看着女儿，彷佛看到了些许妻子的影子，有些恍惚。</p><p>笑猫用毛茸茸的身体蹭着夏皓的手臂，似乎在弥补刚才的不礼貌行为。</p><p>夏皓将笑猫高高抱起，<br>“喵呜哇（本喵太幸福了）”<br>笑猫哪受过这种考验，兴奋的不能自已。</p><p>夏沫眼中光芒微微闪着，唇边浅浅微笑，心中无限温馨……</p><p>窗外银河倾泻，屋内两人一猫，共进晚餐，喵喵叫声，长久不已……</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第十八章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E5%85%AB%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第十八章-你也养一只"><a href="#第十八章-你也养一只" class="headerlink" title="第十八章.你也养一只"></a>第十八章.你也养一只</h1><p>阳光洒满街道，二人一车，穿梭在小道。</p><p>“喵呜，喵呜”<br>一只白猫突然叫着往苏瑾他们骑车的方向奔来。</p><p>苏瑾大脑来不及思索，下意识两个刹车并上，事出突然，夏沫与苏瑾的后背撞了个满怀。</p><p>万幸的是白猫没有被撞到，不过这猫反而不感到害怕，反而盘坐在自行车下，顺势摆烂，活脱脱的猫咪中的讹钱老大爷。</p><p>苏瑾连忙弄下自行车脚架，走到夏沫身旁，关切的问道：<br>“你还好吗”<br>苏瑾看着夏沫额头上一小块红红的，饶是性情极好的他脸色也有些冷，<br>“抱歉，我……害得你……”<br>苏瑾有些语无伦次。</p><p>“我没事，不怪你的”<br>夏沫第一感觉是额头有些疼痛的，随即则是发现少年盯着自己的脸蛋端详，虽然知道他是在看自己有没有受伤，但还是不自主开始紧张起来，没一会，脸蛋已经和额头那一块一样红润。</p><p>“你……可以继续开车的，我没事”<br>夏沫试图让苏瑾的注意力从她身上移走。</p><p>“好”<br>苏瑾看到夏沫整张脸都红了，随即会心一笑，转过身去。</p><p>始作俑者白猫还待在犯罪现场不愿离去，苏瑾走到白猫身前，蹲下身去，拿出安抚格格米的套路，一只手抚摸着白猫的腰背，另一只手指着别处，示意让白猫不要停在这里挡着路。</p><p>“喵呜”</p><p>这招确实灵验。白猫眯了眯眼睛，不过嘛，就这就想打发我喵星人是不可能滴，白猫站起。</p><p>苏瑾眼眸一闪，以为这只猫就要离开了。</p><p>谁料，这只猫一个180°转弯，直接来了个反方向盘坐，似乎在向苏瑾发言<br>：“想让本喵走，换一边伺候着，伺候舒服了就走”</p><p>苏瑾满脸无奈，准备把车调转一下，绕过这只狡猾的猫。</p><p>白猫何许猫也，意识到这少年明修栈道不过，想要暗度陈仓，立刻上前阻了苏瑾的去路，苏瑾移到哪里，白猫就跟在前面，不让苏瑾向前半步。</p><p>夏沫没见过苏瑾这么吃瘪过，嘴角微微上扬，露出一个笑容。</p><p>这只白猫注意到了这个人类少女，箭步跑来，一跃，跳到了少女的怀里。</p><p>夏沫有些惊讶，不过有格格米的前车之鉴，也很快就镇定下来，用细嫩的小手梳理着白猫略显杂乱的猫毛。</p><p>果真是英雄猫难过美人关，前有格格米，后有无名白猫。<br>“喵，喵”</p><p>白猫闪着青绿色的大眼，盯着苏瑾，嘴角向右扬起，露出个笑容来。</p><p>“夏沫，这只猫，似乎会歪嘴笑”<br>苏瑾有些吃惊，从未见过格格米这样笑过。</p><p>夏沫低头看着怀里的白猫，白猫的大眼到了来自人类少女好奇的目光，极尽全力的展示着自我，先是嘴角向右扬起，后又向左扬起，一会又皱着眉头苦笑，一会又皮笑肉不笑，把夏沫看的一愣一愣的。</p><p>“它好像还不止一种笑容”<br>夏沫语调升高，彷佛发现了新大陆。</p><p>“这只猫好神奇”<br>从未见过表情如此丰富的白猫，苏瑾决定介绍这位猫兄给格格米认识认识。</p><p>“我们先回家，再研究一下这只奇怪的猫”</p><p>苏瑾说完直接坐上了自行车，向巷尾开去。</p><p>“好，还真是一只不太一样的猫”<br>夏沫端详着这只猫的模样。</p><p>蜷缩在少女怀里的白猫，浑身雪白，葡萄般大的眼睛溢出了一股灵气，懒懒的样子实在可爱至极。</p><p>白猫松散的眼神眨着，茸茸的脚垫向前一搭，夸张至极的抻了一个懒腰，向盯着它看的少女甜甜的喵了一声，表达善意。</p><p>夏沫对这只白猫好感度暴涨，毕竟很少有女生能拒绝毛茸茸的猫咪，尤其是这么可爱的猫咪，叫声还这么呆萌，最主要的是还会各种笑容，真的很难不爱。</p><p>没过多久，苏瑾慢慢的刹车，稳稳地停在了夏沫家门口。</p><p>“可以下车了，夏沫”</p><p>“嗯”</p><p>苏瑾先坐在车座上，防止自己下来后车失去平衡。</p><p>夏沫抱着白猫走下了车，轻轻放下了白猫。</p><p>白猫顺势在夏沫家门口盘起，不愿离去。</p><p>“谢谢你”<br>夏沫轻声道谢，少女的嗓音带着江南女子的糯糯感，甜甜的，像一首歌浪漫的副歌桥段。</p><p>“哈，小事”<br>苏瑾顺着副歌轻轻的附和。</p><p>接下来就有个大问题了，这只猫又要怎么处理呢？</p><p>“它听得懂人话吗？<br>夏沫有些好奇，请教于养过猫的苏瑾。</p><p>“听得懂的，我有时叫格格米拿东西，他都会拿过来，有时候够不到还会回来叫我，要不我们问一下这只猫要不要走吧”</p><p>白猫内心一喜，我的机会来了。</p><p>“我试一下”<br>夏沫蹲下身，轻轻拍了一下白猫的后背，<br>“你想走吗”</p><p>“喵呜”（不要）<br>随即绕着夏沫走了一圈。</p><p>“看来它是想离开”夏沫断言。</p><p>白猫原本开开心心的绕着认定的主人转圈，听了这话那还的了，气的一蹦一跳，<br>“喵呜，喵呜，喵呜，喵呜（不是这样，不是这样，你听不懂本喵讲话啊，太不公平了，只有我听的懂你的，你却听不懂我的）</p><p>苏瑾不由得有些担心全级第一的智商，哪有这样问猫的？</p><p>“这样问有点难问出来的”</p><p>白猫将求助目光投向眼前的少年(要是你帮助本喵，以后本喵好处少不了你的)</p><p>“喵呜，喵呜（只能靠你了，救救本喵吧）”白猫一脸苦楚，耷拉着脑袋。</p><p>“那要怎么问才好”</p><p>夏沫有些疑惑，不过智商还是很快安装了回来，这个问题让猫咪怎么回答呢，回答了人又怎么知道猫咪喵一声怎么知道是要还是不要呢？</p><p>“可以这样问，你如果想离开喵一声，不想就喵两声”<br>苏瑾耐心解释道。</p><p>“喵呜喵呜（这样好，这样好啊，本喵以后一定不会亏待你的）”</p><p>夏沫恍然大悟，随即一脸佩服，<br>“苏瑾，你真厉害，懂这么多”</p><p>没有一个男生能经得起这句“你好厉害”的夸奖，尤其是来则于年级第一的夏沫由衷的夸奖，对于未经世事的苏瑾来说，还有比这更美妙的了吗？</p><p>夏沫当即把苏瑾的话付诸实现。</p><p>白猫听了这话，心里感叹了一句“终于有人懂本喵了”，随即喵喵了两声，走到夏沫跟前，用毛茸茸的额头蹭着夏沫的腿。</p><p>“看来它是想跟你走，你果然很受猫咪的喜欢”</p><p>“啊，那我要养它是吗”</p><p>“喵呜（对对对）”</p><p>“我已经有格格米了，你也养一只？这只猫看上去很神奇哦”</p><p>“喵呜，喵，喵（你真是我的大恩人，还在帮我，太感动本喵了）”白猫盯着苏瑾，嘴角咧开，奉献出一个最好看的笑容。</p><p>夏沫想了想，决定先留下这只猫，她心里是想养的，不过她得问一下老爸夏皓的意见。</p><p>“我养一段时间试试看”夏沫抚摸着猫咪的额头，温柔的说道。</p><p>“喵呜（太棒了，本喵有地方住喽）”白猫一蹦三尺高，绕着两人奔跑，扬起的嘴角放不下去。</p><p>“看起来它很开心”夏沫还未曾见过哪只猫这种举动。</p><p>“也许是因为你”苏瑾一语中的。<br>“有什么疑惑的，可以微信问我，说不定有帮助”</p><p>“真的吗？太谢谢了”<br>夏沫有些惊喜，再次道谢。</p><p>“不用总是谢谢的，我们是朋友还是邻居不是吗，有一天我有问题，你也肯定会帮我”</p><p>“嗯，是朋友”<br>夏沫点点头，微微一笑，好似沙漠中一朵花中盛开，令人心旷神怡。</p><p>“那我先走了，回头见”<br>苏瑾走向单车，将手高高举起，挥了挥。</p><p>“好，拜拜”夏沫也挥了挥手，带着笑。</p><p>夏日的故事，永远在当下发生，美好的感动，也是如此。</p><p>青春待续，在这个夏天，他们共同翻越了岁月斑驳的一页……</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第十七章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%83%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第十七章-取毕业证"><a href="#第十七章-取毕业证" class="headerlink" title="第十七章.取毕业证"></a>第十七章.取毕业证</h1><p>清晨的阳光透过薄雾洒在大地上，一天的曙光渐渐照亮了整个小镇。</p><p>叮咚<br>叮咚<br>叮咚<br>苏瑾睁开睡眼朦胧的双眼，扒拉了一下地板，摸索到手机，九年级16班老陈发来三条信息，<br>老陈，这是苏瑾对班主任陈建斌的爱称<br>“【通知】<br>请诸位同学于今天上午10点到明天上午10点到江南中学取毕业证”<br>“如果有同学出远门的可以叫同学代拿，再进行转交”<br>“望诸位悉知，并转告身边同学”</p><p>了无生趣的群聊在这波催化剂的催化下直接恢复了往日的热闹，<br>“老师，有没有毕业典礼啊”</p><p>“没有”</p><p>“那有没有什么仪式什么的，不会毕业除了毕业证可以拿什么都没有吧”</p><p>“对啊，学校会有纪念品啥的对吧”</p><p>“预计是没有，不过可以帮你们争取一下”</p><p>“还是老班最好了”</p><p>“膜拜老班”</p><p>……</p><p>苏瑾习惯性窥屏，不过却很少主动发出信息。</p><p>叮咚，老许（许穆清）发来一条消息</p><p>老许：“老苏，帮我拿一下，你家那么近，走两步就到了，回头找你拿”</p><p>穆清这家伙，竟然想不劳而获<br>爱静的苏打：“不行不行，你开个车也不慢对吧”</p><p>老许：“我请你喝水”</p><p>爱静的苏打：好说，好说，我待会帮你</p><p>其实就算不说喝水，苏瑾也会拿的，不过既然说了，那肯定是白嫖至上。</p><p>叮咚，少年游（顾千羽）发来一条消息<br>少年游：在吗在吗</p><p>爱静的苏打：嗯，怎么了</p><p>少年游：帮我拿一下毕业证，顺便拿一下洛云初的，靠你了</p><p>苏瑾一脸黑线，家近有时候还真是不太讨好，拿东西的重任屡屡落下。</p><p>爱静的苏打：问一下叶扬和陈凡，干脆都拿了，穆清也叫我拿</p><p>少年游：你家近，下次打球再给我们，我去问一下他们</p><p>爱静的苏打：好</p><p>苏瑾看向手机右下角，8点05分，还是有很大的准备空间的，先出去吃个早饭再说。</p><p>苏瑾草草整理了一下床垫，虽然不能折叠出豆腐状，但也还算整洁。</p><p>苏瑾走到临近自己房间的一间卧室，苏晨还在呼呼大睡，苏瑾顺手把房门关了，打着哈欠向卫生间走去。</p><p>“起来了啊”老妈雪玲芳正在准备早餐，苏瑾嗯了一声，一手拿起牙刷，一手拿起牙膏。</p><p>“妈，待会我要去学校取毕业证”</p><p>“毕业证是吗，几点去，先喝完粥再去”</p><p>“大概一个小时后，绰绰有余的”</p><p>“不用太急，再喝一碗”……</p><p>一番洗漱准备后，9点35分，苏瑾身着白色衬衫，灰色短裤准备出门了，他可以不用这么早就去的，但准时一贯是苏瑾的原则，至于上次打球嘛，那是个意外。</p><p>“妈，跟爸说一下，我借他自行车一用”</p><p>停靠在院子里的自行车一贯是苏晨必备的上班工具，美名其曰“锻炼身体”，苏晨对这老宝贝爱惜得很，一周擦个好几次都是见怪不怪，不过嘛，也造就了这车开了数年还崭新如初。</p><p>邻居夏沫，也是个准时的主，这会换上整洁的毫无褶皱的校服，走出门来，谁料刚一出门就瞧见白衣少年骑着白马，不对，那是一辆白自行车。</p><p>“夏沫，要不上车，你应该也是取毕业证吧”苏瑾发出邀请，这一段路虽然不远，但如此火热的太阳走过去也是避免不了大汗淋漓。</p><p>“嗯”夏沫顿感不妙，竟然下意识回答第二个问题，共骑这件事怎么想都不太对劲。</p><p>苏瑾略微歪头看着眼前魂不守舍的少女，<br>“那么，上来？”</p><p>夏沫有些结巴 ，“这个，这个，我……”</p><p>苏瑾略微蹙眉，<br>“其实我车技还不赖，你不用担心的”</p><p>“不是……不是这个”</p><p>夏沫耳朵都有些红了起来，莫名越来越紧张起来，她虽然有点想了解眼前的少年，但绝不是以共骑这种方式，在这样一个奇怪的时间点。</p><p>“那我跟你步行去？”</p><p>夏沫低着头，小脑筋转啊转，步行肯定更尴尬，骑车一下子就到了，一溜烟就过去了，嗯，还是骑车去，对，还是骑车好，不愧是我，心理建设再次完美闭环。</p><p>“我们骑车去吧”</p><p>“好”</p><p>夏沫丝毫没意识到自己完全可以让苏瑾骑车，自己步行，紧张的少女直接把自己弄进了一个二元选择中，平时好用的脑瓜在这时却发挥不出作用，就这样，夏沫这只小羔羊就糊里糊涂上了贼车。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第十六章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第十六章-实践出真知"><a href="#第十六章-实践出真知" class="headerlink" title="第十六章.实践出真知"></a>第十六章.实践出真知</h1><p>“老爸，该你去洗了” 苏瑾从浴室走出，浑身冒着热气，拿着白色毛巾擦着头发走进了房间。</p><p>“好”</p><p>苏晨嘴上答应着，但眼睛还是盯着手里的书籍，身体却未曾挪动半分。</p><p>雪玲芳女士面带微笑，散发着强大无形的杀气，缓缓走向苏晨，趁着一不留神，抓住苏晨手里的那最脆弱的上肢略瘦那一部分，直接一个90度拧转，下手可谓是毫不留情。</p><p>“啊，我这就去洗，放手吧，我的好夫人”苏晨连忙放下收中的书，高举一只手以示求饶。</p><p>战斗往往是这样以苏晨的求饶加示弱结束，苏瑾在房间已经是听怪不怪，他知道老爸的妻管严已经没救了，这深深的启示着苏瑾，他以后一定要找一个温柔贤惠的老婆，不能像老妈那样强势，不过听老爸说老妈年轻时候还是很温柔的，乖的和猫咪一样，不过这也许真的是真的，除了骂老爸的时候老妈还是很温柔的，这点苏瑾还是相当认同。</p><p>苏瑾拿起手机，打开微信，赫然在目的姐姐苏诗雨的信息，</p><p>“你那个朋友尝试的怎么样”</p><p>“我这妙计如何”</p><p>苏瑾这才想起还没有实验军师老姐的精囊妙计，不过当下先搪塞一波再说</p><p>“老姐简直是当代女诸葛”</p><p>“我朋友已经在实践当中了”</p><p>“他说有什么问题还得问你”</p><p>“一个狗头表情包”</p><p>“那是”</p><p>“我就放心了”</p><p>“我去准备期末了”</p><p>“过阵子再回去”</p><p>“一个挥手表情包”</p><p>“好嘞，您慢走”苏瑾三句送走热心老姐，随即打开与夏沫的聊天对话框，</p><p>“老姐说可以先从兴趣下手”</p><p>“可这样会不会有点唐突”</p><p>“要不还是打声招呼，嗯，很合理，就这样”</p><p>爱静的苏打：晚上好，夏沫</p><p>接着从一堆猫咪，狗狗，熊猫中挑选了一只白猫招手的发了过去，</p><p>叮咚，夏沫正在卧室看着借来的高中教材，放在一旁播放着音乐的手机呼吸灯一亮，</p><p>锁屏显示：你的好友爱静的苏打发来一条信息</p><p>夏沫连忙放下手中的书籍，拿起手机点开微信，捏了捏下巴，划了划小手，开始打字回复</p><p>简单的夏沫：晚上好</p><p>顺带保存了这可爱的猫咪表情包，一套开场白毫无犹豫。</p><p>诗雨兵法第一步：乐趣进攻。</p><p>爱静的苏打：夏沫，你平常不学习的时候会做些什么</p><p>是不是有点太直接了，苏瑾转念一想…..</p><p>夏沫略微抬头，眼眸微微闪动，看书，画画，听歌，好像是这些，如果可以，加上个下厨。</p><p>简单的夏沫：看书，画画，听歌，下厨。</p><p>爱静的苏瑾：全能！画画可上得厅堂，下厨可下得厨房，可以借画一观看吗？</p><p>前半句给夏沫夸得嘴角微微上扬，后半句则是令其方寸大乱，夏沫感觉自己好像被发现了，找到压在最下面的那一叠画纸，第一张便是树下少年素描，像是老鼠偷吃了大米一样，夏沫一股羞耻感席卷全身，连拿手机的手都微微发抖，一边颤抖着手指用最后的理智打字，一边把那张素描从第一张的位置换到最后一张。</p><p>简单的夏末：我画的不好。</p><p>爱静的苏打：没事，以后有机会再欣赏一下</p><p>夏沫将画的画放的远远的，眼不见心如镜。</p><p>夏沫心想，这样也太被动了，必须要主动出击。</p><p>不愧是年级第一的觉悟，即使没听闻诗雨兵法，却可自悟一套夏沫兵法。</p><p>简单的夏末：你呢，会做些什么？</p><p>朴实无华的反击！</p><p>爱静的苏打：我啊，我也喜欢听歌，有时候会弹弹吉他，不过弹得挺一般的，</p><p>也有时候会写作，就当放松一下了</p><p>简单的夏末：嗯</p><p>苏瑾再次陷入语塞的沼泽无法脱离，百般想要询问，又无从口出，看来第二次聊天也要结束了吗？</p><p>呼吸灯突然一亮，一条信息弹了出来，</p><p>另一旁的夏沫看着输入框内打出的字，面红耳赤，有些难为情，不过还是点下了发送的按钮。</p><p>​                           </p><p>简单的夏末：那个，你说的“处朋友”是？</p><p>苏瑾对这个问题有些困惑，自己那个意思应该是想和她单纯处个朋友的，了解她，不过现在好像有点变味了，似乎是诞生了一种莫名的情感。</p><p>爱静的苏打：之前上学的时候对你知之甚少，现在 ……想和你交个朋友</p><p>爱静的苏打：你应该也是这样想的，对吧，夏沫</p><p>夏沫双手捂着小脸，脸颊已是通红，似乎是清晨的朝露在脸上散开，细腻的光线洒在周围，温暖的舞动着，砰砰作响的心跳声在脑海里回荡。</p><p>叮咚</p><p>苏瑾看着那头久久不作声，抬起手发问，</p><p>爱静的苏打：有什么事情要忙吗？夏沫</p><p>简单的夏末：没有没有</p><p>爱静的苏打：交朋友很简单的，我想多了解你一些，之前没好好认识一下，有点遗憾</p><p>爱静的苏打：所以我们算是朋友了吗</p><p>简单的夏沫：嗯，是的</p><p>夏沫的逻辑经过一番疏导，终于舒畅起来，刚刚一直发软的身体也停止了震颤，原来处朋友是这样的，果然是自己想复杂了。</p><p>房间里的风扇咿呀咿呀转着，窗外是黑暗的世界，偶尔吹进一些凉风，窗帘轻轻摆动，夏沫拿着手机缓步走到窗前，愈是黑暗的世界，月亮与星星就愈是美丽，星星如钻石般璀璨，如精灵般舞动，融入银行的汪洋，织就了独属于夏日夜色景的美妙画卷。</p><p>少女眼中闪着喜悦的微光，拿起相机记录下了此刻的图景。</p><p>犹豫了一番，夏沫还是抑制不住分享的冲动，将刚刚拍摄下的图片发给发给了苏瑾。</p><p>爱静的苏打：这是你拍的吗，好美的夜景</p><p>“猫咪竖起大拇指的表情包“</p><p>简单的夏末：嗯，我刚刚拍的</p><p>苏瑾绕过躺在地上的格格米，拉开房间的窗帘，映入眼帘的是，漫天星辰点缀着黑幕，如果将宇宙比作诗篇，那么星辰便是一句一句诗句，以微弱但可见的光芒为天空增辉。</p><p>月光洒在苏瑾脸上，苏瑾将手机稳稳地举起，对准空中一轮弯月，角度绝佳，卡擦一声，记录下了此刻。</p><p>来而不往非礼也，苏瑾将图片也发了过去</p><p>爱静的苏打：嘿嘿，我拍的不赖吧，多亏了你，不然就错过了这样的景色</p><p>简单的夏末：拍的很好看</p><p>夏沫点开图片，长按保存了下来，想着苏瑾就在几墙之隔的那端拍下这张照片，夏沫不由得小脸一红。</p><p>简单的夏末：我先睡觉了，有点晚了，拜拜</p><p>爱静的苏打：嗯，好梦</p><p>配上一个猫猫挥手的表情包。</p><p>苏瑾看向手机左上角，10点05分，看来她很早睡呢，苏瑾如果是读书时候，差不多10点半睡觉，他从不习惯打夜战，学习这东西，该认真的时候认真就是了，而放假时候，一般会将时间延长半小时，11点才去睡觉。</p><p>一旁的夏沫则是在月光下呢喃着处个朋友进入了梦乡，梦里：醉后不知天在水，满船清梦压星河…… </p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第十五章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第十五章-求助"><a href="#第十五章-求助" class="headerlink" title="第十五章.求助"></a>第十五章.求助</h1><p>傍晚，夕阳现身，房间内苏瑾持着吉他，心绪却飘到另外一边。</p><p>苏瑾将周杰伦《最伟大的作品》吉它曲上传到哔哩哔哩，他隐约觉得对夏沫有种不一样的感觉，在他和其他女生交流时从未有过，但又感觉还谈不上喜欢，好奇怪的感觉，比数学最后一道压轴题还难以解开，苏瑾脑袋已经乱成了一团浆糊。</p><p>这时候，苏瑾猛地想起来那个便宜姐姐苏诗雨，比苏瑾大了四岁，小时候没少欺负苏瑾，从小决心成为一名律师的她，如愿考上中山大学并选择法学，估摸着再过十天天就要回来了，现在接近1点，她应该还没上课，苏瑾决定询问一下她。</p><p>苏瑾打开微信，找到备注“大姐”，进入聊天框，</p><p>“姐，最近怎么样啊，什么时候回来啊”</p><p>大约过了几十秒，叮咚一声，手机呼吸灯一亮，</p><p>“多久没给姐姐发信息了，你小子，笑脸，笑脸”<br>“我应该一周后回来，目前在备战期末，老忙了”</p><p>“我有一个朋友，你知道的，许穆清，他不知道怎么和女生聊天，向我请教，但我什么人姐你是知道的，我怎么能知道怎么和女生聊，这不就想来请教一下无所不能的大姐”</p><p>苏瑾感觉这波掩饰及其粗拙，可能要被发现并拆穿了。</p><p>“他跑来问一个没谈过恋爱的，哈哈哈”</p><p>不愧是大智若愚的大姐，没发现，苏瑾暗自窃喜。</p><p>“所以这个任务只能交给你了”</p><p>“虽然我没有谈过恋爱，不过女生一般很少主动发起聊天，所以如果要聊天的话男生可以主动发起聊天”<br>“嗯，有道理”</p><p>“一些兴趣之类的也可以谈一下，可以幽默一点就更好了”</p><p>“说的对”苏瑾汗颜，幽默自己可不太拿手啊。</p><p>“少说一点那种问完后对方回答后就没有话说得问题，除非你有很多这种问题，不然很容易像是在查户口，这就很，你懂的”</p><p>“是这样”苏瑾越发感觉这个便宜大姐在家里安装了监控，越说越像他自己。</p><p>“真诚才是必杀技，真心就好了，嗯，就是这样”<br>“如果能弄清她需要什么，再合理帮助她，可能比较好”<br>“还有，现实肯定比虚拟要来的好，不要老是微信聊天会更好一些”<br>“大概就这些，我同学叫我了，把我说的去告诉你朋友吧”</p><p>“好嘞”<br>苏瑾感觉便宜姐姐讲的还是可以的，决定重新尝试尝试。<br>“真诚是吗”苏瑾喃喃自语道。</p><p>另一旁的夏沫，在卧室插着耳机播放着富有夏日气息的纯音乐，拿着铅笔，想象着大槐树下少年躺着听歌的样子进行素描，当然，夏沫告诉自己这只是为了画格格米，那个少年是附带的。</p><p>画画是她在忙完所有事情之后才会进行的一项爱好，也是除了听歌外的最大爱好，而且虽然没有买一些画画的工具，但一支铅笔，一个橡皮，在少女手里即可创造出一副副图画。</p><p>夏沫已经初步完成了轮廓的塑造，到了关键的细节描写，夏沫眼神微微紧缩，尽量减少颤动，将铅笔小心翼翼地放在纸上。她细腻地描绘出少年的眼睛，慢慢的勾画，轻轻地涂上阴影，虽是素描，却使眼睛透露出神彩和光芒。</p><p>她拿起一支细小的擦除笔，仔细修正着一些细微的瑕疵。她的手指轻柔地在纸上移动，犹如舞动着极细的笔触。少女聚焦于每一个细节，一丝一毫地调整和完善。</p><p>随着修正的完成，夏沫轻轻的吹了一口气，将纸上的浮粉吹走，然后缓缓放下笔，脸色有些许红润，嘴角微微上扬，拿起画作，认真的看着，只是看着：</p><p>树下，少年，白猫，还有沿着那条小道缓缓走来的少女……</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第十四章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第十四章-微信初聊"><a href="#第十四章-微信初聊" class="headerlink" title="第十四章.微信初聊"></a>第十四章.微信初聊</h1><p>午后时分，苏瑾正在房间里忙活着今天要弹什么曲子上传哔哩哔哩，这个爱好从苏瑾六年级那个暑假开始，苏瑾那时便喜欢听歌，于是用奖学金和老爸协商而得的一部分私房钱，买了人生第一把吉他。苏瑾如获至宝，便开始捣鼓，一开始只是简单的乱按，发出毫无节奏的音符，扰的全家不宁。后来在老父亲苏晨的推荐下，买了一本吉他入门手册，并给苏瑾推荐了哔哩哔哩这一应用，于是少年一发不可收拾，潜心练习，也算小有所成。</p><p>初二时候一时兴起，将弹奏的一首杰伦的稻香的吉他上传到网上，获得了一些关注量，看到有人在评论区请求up主坚持做下去，苏瑾也决心继续进行视频的录制与上传，而老爸老妈只知道儿子会记录下弹琴时候的样子，却并不知道苏瑾已经将视频传到了网上，并收获了一批忠实粉丝和一小笔收入。</p><p>除了吉他，苏瑾也热衷于阅读，书架上摆满了各式各样的书籍，平常也会经常进行一些写作和记录，可以说涉猎颇为广泛了。</p><p>生活过的很充实，这样平实而稳定的生活才是苏瑾所向往的吧。</p><p>叮咚</p><p>系统信息：简单的夏末已经通过你的好友申请，现在我们可以开始聊天了。</p><p>苏瑾看到消息的瞬间，心情激动了一下，紧接着开始打字：</p><p>爱静的苏打：“下午好</p><p>再配上一个猫咪躺着的表情包。<br>这也是苏瑾聊天的独特风格，他一贯喜欢发一句话配上一个表情包，有时候话都不说，就在那发表情包，让人一头雾水。</p><p>另一旁的夏末趴在桌子上，手指放在手指上漫无目的的划着，大眼睛紧张兮兮的看着微信窗口，想发点什么却又不知道从何处发起，只剩下眼里微光闪动。</p><p>叮咚</p><p>夏沫看着聊天窗口弹出的问候，连忙打字回应</p><p>简单的夏末：下午好</p><p>女生总是对猫咪表情包没有抵抗能力，夏沫也是如此，顺手长按收藏了这个表情包。</p><p>苏瑾看着这一来一回，真是书到用时方恨少，竟然不知道说些什么，要不问一下她志愿的事情，说问就问。</p><p>爱静的苏打：夏沫，你志愿打算报哪里,你的成绩应该可以去省重点中学了</p><p>简单的夏末：我应该会选江南中学，离家近</p><p>夏沫关于志愿其实之前就有想过，她更喜欢在本地读，还可以照顾父亲夏皓，而本地最好的高中就是江南中学，自然很快就确定下来了。</p><p>爱静的苏打：嗯</p><p>爱静的苏打：我们大概率会在同一所高中，如果分数允许。</p><p>简单的夏末：嗯</p><p>爱静的苏打：嗯<br>爱静的苏打：我有点事，先下了<br>爱静的苏打：拜拜，待会再聊<br>紧接着是一个猫猫挥手的表情包</p><p>简单的夏末：拜拜</p><p>苏瑾意识到气氛陷入了尴尬，聊天沉默了下来，但又不知道如何缓解，急中生智，于是以事情为由匆匆跑路，聊天就此作罢。</p><p>苏瑾的腼腆，夏沫的害羞以及比苏瑾更逊一筹的聊天，让第一次会话拉下帷幕。</p><p>夏沫呆呆的看着屏幕，不对啊，还没问他这个处朋友是什么意思，想再发送过去问他他又有事，真是太不巧了，夏沫轻轻的捶打着沙发，宣泄着郁闷和懊恼。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第十三章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第十三章-微信好友"><a href="#第十三章-微信好友" class="headerlink" title="第十三章.微信好友"></a>第十三章.微信好友</h1><p>夏季的雨总是来得措不及防，明明上一秒还是阳光直射，下一秒便有雨水天降。</p><p>雨淅淅沥沥，打在地上，鸟儿莺莺鸣鸣，青草随风漂流，夏沫哼着小曲，在窗前<br>刷着碗。</p><p>夏沫的父亲夏皓忙于工作，午饭一般都在厂里解决。</p><p>夏皓自从妻子陈清惠去世后变得沉默寡言，但他始终记着妻子临终前说的话“我只是提前去给你们准备下辈子的东西了，不要挂念我，带着对女儿的爱生活下去”。他没有被生活击垮，而是携带着妻子那一份，尽力给女儿最好的生活。</p><p>叮咚。</p><p>放在客厅桌上的手机屏幕一亮，那是一款崭新的红米手机，是在夏沫中考后买的，估摸着价格在1000块钱左右，夏皓本想给女儿买一个更好一点的手机，但奈何夏沫怎么都不肯，她知道爸爸搬家所承受的压力，不想让他支出过多，最后双方协商才挑了这样一部手机。</p><p>夏沫没有多想，仍然哼着小曲，听着雨滴敲打屋檐发出的声响，交错，融合，节奏变幻，带来迷人的韵律。</p><p>夏沫刷完最后一个碗，拿起抹擦干洗碗盆的水，再把碗放进消毒箱内，随即用清水洗了洗小手，用毛巾擦干手里的水，这才走到桌前拿起那部手机。<br>夏沫略带好奇的看了眼亮起的屏幕，“你有一条未读的微信通知”，</p><p>夏沫手掌撑着侧脸，划了划屏幕，点进微信，上面十分整洁，只有通讯录有一个红点。</p><p>“喜静的苏打”请求添加你为好友，<br>备注：</p><p>“处个朋友吗，夏沫，我是苏瑾”。</p><p>夏沫呆呆的看着这条备注，指尖停留在同意按钮之上，一时间不知道是要点下去还是不点下去，双脚蜷缩着坐在长沙发上，缩成一团，低着头，柔嫩而洁白的耳根已经快要熟透，绯红的侧脸也可以印证此刻的心跳速度。</p><p>处个朋友是什么意思嘛，怎么就突然要处朋友了，这是不是太快了，只是见了几面而已啊？青春期的少女总容易浮想联翩，执着于那一字一句的深层含义，却没有想到这一字一句却了无内涵，有的只是字面意思和少年的随想随做。</p><p>夏沫点开苏瑾的微信头像，少年手拿书本，躺在一望无际的大草原上，身旁一只白猫躺在少年旁休息。</p><p>他的微信头像和他看起来一样阳光呢，夏沫蛮喜欢这个头像的，于是长按保存了下来。</p><p>点开更多信息，个人签名“欲买桂花同载酒，终不似，少年游”。</p><p>夏沫想点进朋友圈访问一下，却被挡在门外，陌生人只能观察最近三天的朋友圈，然而朋友圈干干净净，她一张也看不了。</p><p>夏沫看的很慢，反反复复的看了苏瑾微信的所有相关信息，就连她也不知道自己为什么会有这种反应，只是觉得想多了解一下这个三年内未曾触及的同学，最终，好奇战胜了所谓的羞耻，夏沫同意了好友邀请。</p><p>夏沫一只手摸着发烫的小脸，另一只手快速将手机摆在桌面，点开朋友圈，没有想象中的生活特写，有的是毕业后的一条毕业相关的动态，江南中学直通教学楼的小道，小道两旁四季常有的香樟树，最后加上一张九年级十六班的合照，配上一句简单的“珍重，九年级16班”。</p><p>夏沫端详着那张照片，一个一个面孔，曾经的点点滴滴涌上心头，此刻却如此亲切。</p><p>或许当初那些情景并不能令我们感动，但当故事走到结尾，书页翻到最后，我们重新回温，那些平凡的时光总能温暖人心。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第十二章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第十二章-做个朋友"><a href="#第十二章-做个朋友" class="headerlink" title="第十二章.做个朋友"></a>第十二章.做个朋友</h1><p>十六七岁的少年总是发着光的，可惜这个被放养的少年不会做饭。</p><p>苏瑾熟练的拿起手机，打开微信，老爸的留言赫然在目：</p><p>和你妈说我不回去吃饭了，你们陈主任打算请我们去吃一顿，我就不发给她了，这个任务就交给你了。</p><p>“还是一如既往的害怕老妈呢”苏瑾扑哧一笑，打算给雪玲芳女士发出消息时，一条信息弹了出来。</p><p>“儿子，我要和你舅妈出去外面，顺便把午饭吃了，你和你爸的午饭自己承包”</p><p>苏瑾表情从玩味转为震惊，随即就是瘫倒在沙发上，最后自然受伤的只有他自己。</p><p>“不是一家人，不进一家门啊”苏瑾长叹，前脚还在嘲笑老爸，后脚自己就是成为小丑。</p><p>眼下如何准备一顿午饭成了莫大的难题。</p><p>苏瑾生无可恋的走到厨房，打开冰箱，一番仔细挑选后还是决定煮个朴实无华的清汤面，拿起冰箱的火腿，鸡蛋和几根青菜，再从箱子里掏出两包面条，一场浩大的工程即将开始。</p><p>只要开头成功了，那不就成功了一半，苏瑾安慰自己，先给叠一波护甲。</p><p>未曾设想的道路是就在苏瑾开火，蒸干清水，放油后，煤气的火就跟开玩笑一样主动熄灭了。</p><p>“不会吧，该不会是没有煤气了”苏瑾呆呆站在原地，就连那颗下到一半的鸡蛋都好似在发出嘲讽的意味。</p><p>苏瑾瘫倒在沙发上，一脸的疲惫，唯一一手还算过得去的面也被终止了，看来只能点个外卖了。</p><p>塞翁失马焉知非福，因为很久没有登录饿了么，苏瑾获得了老朋友奖励，一波挑选，直接三块钱拿下招牌牛肉面。</p><p>这波必须发给许穆清炫耀炫耀，苏瑾把付款截图发给许穆清，配上一个戴眼镜的猫的表情包，一切尽在不言之中。</p><p>对于苏瑾，一个人的快乐远非快乐，不过当它传播出去的时候，快乐就会指数暴涨</p><p>“你小子行啊”</p><p>你的好友许穆清拍了拍你并大喊一声：父亲。</p><p>“你这个拍了拍什么时候去换一个，太不当人子了”</p><p>“过阵子我就换”</p><p>一只大熊猫抽烟眺望天空的表情包弹了出来，大熊猫一贯作为二人聊天必备的表情包来源之一。</p><p>“对了，你对我们班的夏沫了解多少”</p><p>苏瑾不自觉的想更多的了解这个邻居，</p><p>“怎么突然说起这个”</p><p>“没什么，前阵子兴致来了翻毕业照突然看到她”</p><p>“我应该没和她说过几句话，之前我想着把班级群里的人微信都加了，也加了她，我打了声招呼，她也打了声招呼，然后就没有再聊过了”</p><p>“我知道了”</p><p>“老苏，你该不会铁树开花了吧，奸笑，奸笑”许穆清半开玩笑的打趣道，</p><p>“我不太懂这个”苏瑾持续装傻，决定先不把夏沫成了邻居这件事公之于众。</p><p>“过阵子中考成绩要出来了，你想去哪里”许穆清也没在这个话题深入，转眼就跳到另一个话题。</p><p>“依然江南中学吧，这里离家近，而且估计大家十有八九都会在这里”</p><p>“我也这样打算，不知道叶扬他们怎么想”</p><p>“他们也有可能，我觉得我们这群人看来会在次聚首”</p><p>“让世人感受一下何为江南六大才子”</p><p>许穆清开始中二模式，“且看这天地，我们洋洋洒洒，红袖添香心不乱，坐怀不乱读书高”。</p><p>“很有精神”苏瑾拿起独属于他的话术，一波精神，解决百分之九十的聊天不知道回答什么的难题。</p><p>“吃饭去了，下了”苏瑾接到外卖通知，匆匆打字。</p><p>“这牛肉面，果然牛肉不多，都是面，还好比康师傅那个微观牛肉要好得多”，还是蛮不错，起码有饭吃，乐天派达人苏瑾一贯看的很开。</p><p>苏瑾翻找着微信群聊的列表，找到“九年级十六班”，消息还停留在上周的“解放了，诸位好好玩”来自于老班陈建斌，也就是年级主任，请苏瑾老爸吃饭的那一位。</p><p>往下则是对于老师的回应，诸如感谢之类的话语。</p><p>苏瑾打开列表，找到那个头像是简单的卡通猫咪的人，点了进去：</p><p>昵称：简单的夏末，</p><p>更多信息</p><p>我和她的共有群聊一个</p><p>个性签名：晚风</p><p>要不要加她好友呢，苏瑾手指停留在加好友的选项上，一番思量，还是点了下去。</p><p>“处个朋友吗，夏沫，我是苏瑾”</p><p>故事的升温，指尖之下，一念之间……</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第十一章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第十一章．一起回家"><a href="#第十一章．一起回家" class="headerlink" title="第十一章．一起回家"></a>第十一章．一起回家</h1><p>时间已经接近正午，火辣辣的太阳烘烤着大地，即使是槐树也无法抵御这种诱惑，周围的空气弥漫着一股热气，连起初觉得清爽的微风也夹杂着一股热气。</p><p>苏瑾有些扛不住了，“树下也开始变热了，我们回去吧，电应该来了”。</p><p>“嗯，好”，夏沫拔下耳机，交给苏瑾，“谢谢，歌很好听”，随即莞尔一笑，宛如水中荷花绽放。</p><p>“哈，下次接着听”苏瑾撩了撩头发，轻轻拍了怕熟睡中格格米的额头。</p><p>“喵呜哇”格格米猛的跳起，精准的跳到了夏沫的怀里。</p><p>“啊”夏沫一声惊吓，用力甩手，想摆脱莫名跳到身上的雪白软状物体。</p><p>“不要怕，是格格米”苏瑾连忙解释。</p><p>冷静下来的夏沫盯着怀里那甩不掉的白猫，白猫轻轻低下头，用毛茸茸的脑袋轻轻擦着夏沫的胸前，论起讨人欢心还得是格格米大将军。</p><p>“好可爱”冷静下来的夏沫长出了一口气，随即开始轻轻揉着猫咪略微拱起的小背。</p><p>​                               </p><p>“它果然很喜欢你”苏瑾有些诧异，格格米像自带导航一样，瞄准她的怀里就跳进去了，看来很享受她的怀抱，那会是什么感觉呢？</p><p>不对不对，这是一个正人君子该想的吗？我怎么这么龌龊，去掉这个想法，去掉这个想法。</p><p>看到一旁紧闭双眼的苏瑾，夏沫有些疑惑，想去拿放在树下的那把浅蓝色雨伞，却因抱着怀里的猫咪而无法触及。</p><p>“苏瑾，能帮我拿一下雨伞吗”，夏沫的脸再一次泛起红晕，似乎是很少询问别人问题的缘故，这一问便有种麻烦别人的不好意思的感觉。</p><p>“交给我”苏瑾意识到抽不开身的夏沫，走过去拿起树下的雨伞，走到夏沫跟前，打开雨伞。</p><p>“走吧，我们回家”苏瑾走在夏沫身前，一只手拿着雨伞，一只手高高举起，示意夏沫过来。</p><p>“好”夏沫甜甜的回了一字，像小白兔一样乖巧的走过来，不过心理活动却有些异常汹涌：这话听起来怎么那么像老夫老妻，不对不对，肯定是我想多了，我最近怎么变得这么奇怪，老是想这种东西，只是回家而已，又不是回同一个家，对对对，就是这样。</p><p>心里虽然这样已经建设好了，但夏沫不仅是清秀的小脸有些发红，连身体都有些微微的发抖，像一只煮熟的大螃蟹。</p><p>苏瑾走在前面，时不时回头看着低着头，散落着些许发梢的夏沫，素锦若有所思，在她身上还有着哪些故事呢，好奇感竟越发强烈。</p><p>不知不觉走到了小巷子的末尾的两处人家，夏沫将格格米慢慢放下，</p><p>“苏瑾，那我进去了”夏沫轻轻朝苏瑾挥手。</p><p>“那个，是不是还有伞”苏瑾带着笑容微微颔首，将伞递了过去。</p><p>“抱歉”夏沫脸上红晕一朵未落，一朵又起，接过雨伞，一溜烟就小跑进家门了。</p><p>“有点可爱是怎么回事，似乎就是这点很可爱，总之就是可爱”苏瑾嘴角扬起，抱起地上的格格米，走进了小家。</p><p>人间骄阳正好，风过树梢，彼时他们，正当年少。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第十章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%8D%81%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第十章．树下闲谈"><a href="#第十章．树下闲谈" class="headerlink" title="第十章．树下闲谈"></a>第十章．树下闲谈</h1><p>“夏沫，你原本老家住在哪里，之前没在这附近看到过你”，苏瑾决定主动打破僵局，抢占话语主动权。</p><p>“我之前住在南苑小区，最近搬过来的”</p><p>“嗯，是这样”空气又一次陷入寂静。苏瑾这才意识到自己的口才还真是有待提高，怎么就说不出几句像样的话语呢。</p><p>微风吹来，一阵慵懒袭来，苏瑾勾起了嘴角，这种慵懒还真是久违呢。</p><p>一旁的夏沫也已经很久没享受过这种什么都不想的时光，读书的时候，她总是早早起来，帮爸爸一起做完家务，煮完早饭，然后再去上学，为的是让爸爸减轻负担，安心工作，不要太担心自己。<br>然后傍晚回家的时候顺带去买菜回家，煮饭，吃饭，洗澡，学习，睡觉，日复一日，未曾真正的放松下来，如一条紧绷的弦。</p><p>不知怎的，夏沫坐在这里感觉很安心，可以静静的看着缓缓流淌的溪水，几条小鱼游过，时不时一阵微风拂动脸颊，夏日的燥热也尽数驱散。</p><p>苏瑾将一只耳机重新插上，递过另一只，“要不要听歌，很好听的，一只耳机给你”。</p><p>一贯下意识没有拒绝他人的夏沫鬼使神差就接了过来，将耳机放在耳旁。</p><p>“红雨瓢泼泛起了回忆怎么潜”<br>“你眉目如当年”<br>“流转我心间”<br>慵懒，迷梦的江南风情，青春迷茫在这首歌中得到了诠释。</p><p>“夏沫，这个音量合适吗”苏瑾习惯了戴上耳机，怕自己的习惯音量和其他人的不太一样。</p><p>“渡口边最后一面洒下了句点”<br>“与你若只如初见”<br>“何须感伤离别”<br>略显伤感的节奏，和时不时的小雨点滴滴答答的声音，把夏沫带到了一个优美迷蒙的意境之中，当然，没有听到苏瑾的话。</p><p>苏瑾看着沉浸的少女，微微一笑，耳机中的声音渐渐减弱，副歌也走到尽头，</p><p>“好听吗？”</p><p>“嗯”夏沫点了点头，“你也喜欢许嵩的歌啊”夏沫从前就特别喜欢听许嵩和JJ的音乐，悠扬的旋律总能驱散心中的阴霾。</p><p>“他很有才华，歌词写的如诗如画，看来你也是嵩鼠，哈哈”，</p><p>“嗯”</p><p>“那请问这位歌迷朋友想听什么呢”<br>苏瑾打趣道，</p><p>夏沫微微思考，“那《如约而至》，可以吗？”</p><p>“当然”。</p><p>“如果早知道那天是我们最后一面”<br>“我绝不会和你谈论琐事浪费时间”<br>……<br>“等到秋叶终于金黄，等到华发悄然苍苍”<br>“我们相约老地方”<br>……<br>槐树下，两人一猫，听歌赏景，时有言语，却别具风味……</p><p>附上《如约而至》语录：<br>我越来越相信<br>用爱来连接着的人<br>一定会重逢<br>在某个时刻<br>某个地点<br>某个现在的我无法想象的形式<br>又或许在彼此的脑海<br>和广袤的银河星海里<br>我们早已经无数次电波冲撞<br>无数次<br>喜悦相逢。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第九章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%B9%9D%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%B9%9D%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第九章．树下相遇"><a href="#第九章．树下相遇" class="headerlink" title="第九章．树下相遇"></a>第九章．树下相遇</h1><p>呼呼山风从窗户吹过，摇晃的风铃很是清脆。</p><p>夏沫透过窗户：碧绿色的草地依偎着清澈的溪水，令人神往。</p><p>于是乎，她拿着一把浅蓝色的雨伞，决心暂时逃离因停电而倍感燥热的房间。</p><p>道路上有些许花香，夏沫举着雨伞，漫步到槐树下，却发现已经被苏瑾和格格米捷足先登。</p><p>苏瑾并没有意识到不速之客的到来，仍然闭着眼睛，嘴角时不时出现笑意，似乎是歌词格外有趣，又似乎是难得的停电时光的惬意闲适。</p><p>夏沫仔细端详着苏瑾，一袭白衣衬衫，看起来自信阳光，浑身散发着的好像是夏日橘子汽水的味道，干净而不失少年感。</p><p>夏沫忍不住向前走近，想要更近距离地端详那张脸。</p><p>“喵呜，喵呜”,格格米不合时宜的叫声将苏瑾从歌曲拉了回来，睁开眼睛，不是想象中的蓝天白云共一色，而是夏沫那张略微涨红的小脸。</p><p>夏沫连连后退几步，“我……不是你想的那样”，夏沫想解释什么，但又不知道解释什么，总不能说想看看他的脸吧。</p><p>苏瑾眼神中略显疑惑，歪了歪头，摘下耳机“我想我什么都没想”，</p><p>“话说，夏沫，天气热，一起坐树下乘凉吧”</p><p>“站着被阳光晒不太好哦”，苏瑾从地上翻起，主动挪出一个空位。</p><p>“格格米好像很喜欢你，看到你就很欢呢，要不你坐格格米旁边”苏瑾细心用手指梳理着格格米的毛发。</p><p>夏沫这才意识到自己刚刚一退就退到了树荫笼罩之外的地方，接近正午的日光烤着少女的柔嫩肌肤，略微有些发疼。</p><p>“好”夏沫迟疑了一会，还是选择坐在格格米的旁边。</p><p>一男一女一猫，彼此无言，空气中弥漫着一股尴尬。</p><p>我是不是该说些什么，苏瑾内心有点小纠结，那要说些什么呢。</p><p>苏瑾全身心思都在想要不要说话，要说什么比较好那里，不过手上撸猫却停不下来。</p><p>“喵呜呜，喵呜”</p><p>他会不会说些什么，刚刚的事他应该还不清楚吧，如果他问起来我要怎么回答，一连串没有答案的问题接连浮现在夏沫脑海里。</p><p> 我们或许可以预测彗星下一次撞击地球的时间，但我们却无法预测就坐在身边的人此时此刻此情此景想着什么，这句话就很有道理。</p><p>夏沫犹豫再三，还是选择打算把手放在白猫上面，她偷偷把手伸过去，不过不是意料中柔顺的猫毛，摸起来呢，就像是男生的手一样，就像她老爸一样，不过要稚嫩一些，还有点软，对，好像就是这种感觉。</p><p>欸，不对，不对，猫的毛摸起来不是这张感觉。</p><p>夏沫感受到肩膀有些许触动，“夏沫，话说…….你应该想摸的是格格米吧”，苏瑾用手戳了戳夏沫的肩膀，略显尴尬的挪了挪被夏沫的小手压着的一双手。</p><p>夏沫望向格格米，下面一层哪里是雪白的猫毛，分明是苏瑾的手。</p><p>“没有没有”夏沫火速抽回手臂，下意识选择否定。</p><p>那我想摸的不成他手臂了吗，那也有问题啊，身为年级第一的夏沫转念一想。</p><p>“不对不对”急忙开口再次辩解，脸上的滚烫感愈发强烈，已经有了一层红晕。</p><p>“我知道了”苏瑾将手从格格米身上抽开，他确实知道夏沫的意思，应该就是那个意思，他觉得说这句话夏沫应该知道他的意思，总之呢，不知道说什么，于是先说这句话意思意思。</p><p>你知道什么你就知道，夏沫暗暗吐槽，夏沫略微嘟起嘴巴，一种从来没有过的羞耻感也猛的袭来。</p><p>苏瑾打量着夏沫那绯红的侧脸，怎么就那么红呢，难道这是女生和男生说话必经的步骤，还真是奇怪呢。</p><p>不过少女的脸红作为炎炎夏日的另一番图景还真不错呢，苏瑾由衷觉得。</p><p>可惜格格米不会说话，不然它一定跳起来给诸位叫一声：这奇怪而热烈的青春哪！</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第八章</title>
      <link href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%85%AB%E7%AB%A0/"/>
      <url>/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%85%AB%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第八章．停电了"><a href="#第八章．停电了" class="headerlink" title="第八章．停电了"></a>第八章．停电了</h1><p>“苏瑾，快来打团，那波线不要了，想要成大事怎么能看着那点兵线’</p><p>许穆清开着游戏麦，指尖不断滑动，一手高渐离出神入化，一手开大闪现炸裂进场，不是你死就是我亡，120秒帅一次还是很值得的。</p><p>“看我怎么拿捏他们”陈凡也开始放狠话，“are you ready”，一手蹩脚的英语发音，随即拖动大招，苍穹一按，马克波罗晕眩大招扎入人堆，火花四射。</p><p>苏瑾也不甘示弱，吕布一技能迅速附魔后，直接运用草里大奥义，魔神天降。</p><p>不消5秒，对面五人便人间蒸发，三人和其余两个路人队友一路高歌猛进，一路连胜。</p><p>早上10点，吃完早饭后便是熟悉的王者时间，三人势必会共同游戏，浴血奋战。</p><p>“滴”冰箱突然发出声响，风扇也缓缓停止转动，一股燥热猛地袭来，苏瑾手机屏幕上也出现加载信号，“正在等待连接，请稍后”。</p><p>“真不走运，游戏刚开始，竟然停电了，让穆清和陈凡自求多福罢”苏瑾暗暗笑道。</p><p>他一贯不太在意游戏的胜负，对他而言更多的快乐来自于与朋友一起玩耍，一起畅所欲言，与这些相比，输家与赢家不再是那么重要。</p><p>现在家里除了苏瑾以外没有别人了，老爸苏晨清晨接到主任的电话去学校还没回来，老妈去舅舅家做客了。</p><p>当然，不要忘了，还有万能的阿猫格格米。</p><p>“喵呜，喵呜”一下子燥热的房间让格格米顿感不适，急忙迈着小步向苏瑾奔来。</p><p>苏瑾将白猫抱起，摸了摸毛茸茸的额头，“这里太热了，格格米，我们去那颗大树乘凉吹风”苏瑾拿起放在桌子上的MP3和蓝牙耳机，插上耳机，抱起格格米，悠哉游哉走出家门。</p><p>目的地嘛，自然是离苏瑾家不远处的溪边一颗大槐树。</p><p>自苏瑾记事开始，这颗大槐树便在那里，旁边有一处草坪，临近河水，独处一方，坐于树下，淡看云卷云舒，与蔚蓝天空共舞，时有蝉鸣不止，时有鸟儿停留，人至而不去。</p><p>一少年一白猫，漫步在那条巷道，缓缓走向树荫下。</p><p>树叶在微风中沙沙作响，为苏瑾带来一丝凉意，格格米倒是惬意，最懂得享受了，一来就找到树下的一处靠背的地方，直接盘起，准备睡觉。</p><p>草地的草也不磕人，无死角的太阳光被槐树的遮挡也只剩下点点日光洒落。</p><p>苏瑾在格格米旁坐下，靠在树上，慢慢插上耳机，闭上眼睛，开始今日份听歌。</p><p>“爱情好像流沙”</p><p>“我不挣扎”</p><p>……</p><p>“我一直都想对你说’’</p><p>“你给我想不到的’’</p><p>……</p><p>白衣少年苏瑾闲坐树下听歌，殊不知邻家少女撑着雨伞正在往树下缓步走来……</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷刷题9</title>
      <link href="/2024/02/09/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%989/"/>
      <url>/2024/02/09/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%989/</url>
      
        <content type="html"><![CDATA[<h1 id="洛谷刷题9"><a href="#洛谷刷题9" class="headerlink" title="洛谷刷题9"></a>洛谷刷题9</h1><p><a href="https://oi-wiki.org/basic/binary/">二分 - OI Wiki (oi-wiki.org)</a></p><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>二分查找（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是用来在一个有序数组中查找某一元素的算法。</p><h3 id><a href="#" class="headerlink" title></a></h3><p>以在一个升序数组中查找一个数为例。</p><p>它每次考察数组当前部分的中间元素，如果中间元素刚好是要找的，就结束搜索过程；如果中间元素小于所查找的值，那么左侧的只会更小，不会有所查找的元素，只需到右侧查找；如果中间元素大于所查找的值同理，只需到左侧查找。</p><h3 id="最大值最小化"><a href="#最大值最小化" class="headerlink" title="最大值最小化"></a>最大值最小化</h3><p>注意，这里的有序是广义的有序，如果一个数组中的左侧或者右侧都满足某一种条件，而另一侧都不满足这种条件，也可以看作是一种有序（如果把满足条件看做 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="1">，不满足看做 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="0">，至少对于这个条件的这一维度是有序的）。换言之，二分搜索法可以用来查找满足某种条件的最大（最小）的值。</p><p>要求满足某种条件的最大值的最小可能情况（最大值最小化），首先的想法是从小到大枚举这个作为答案的「最大值」，然后去判断是否合法。若答案单调，就可以使用二分搜索法来更快地找到答案。因此，要想使用二分搜索法来解这种「最大值最小化」的题目，需要满足以下三个条件：</p><ol><li>答案在一个固定区间内；</li><li>可能查找一个符合条件的值不是很容易，但是要求能比较容易地判断某个值是否是符合条件的；</li><li>可行解对于区间满足一定的单调性。换言之，如果 <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="x"> 是符合条件的，那么有x+1 或者 x-1符合。</li></ol><p>当然，最小值最大化是同理的。</p><h3 id="STL-的二分查找"><a href="#STL-的二分查找" class="headerlink" title="STL 的二分查找"></a>STL 的二分查找</h3><p>C++ 标准库中实现了查找首个不小于给定值的元素的函数 <a href="https://zh.cppreference.com/w/cpp/algorithm/lower_bound"><code>std::lower_bound</code></a> 和查找首个大于给定值的元素的函数 <a href="https://zh.cppreference.com/w/cpp/algorithm/upper_bound"><code>std::upper_bound</code></a>，二者均定义于头文件 <code>&lt;algorithm&gt;</code> 中。</p><p>二者均采用二分实现，所以调用前必须保证元素有序。</p><p>题目：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M = <span class="number">10000000</span>;</span><br><span class="line"><span class="type">int</span> a[M];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r = n+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l+<span class="number">1</span>&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid]&lt;x)</span><br><span class="line">&#123;</span><br><span class="line">l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[r]==x )</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt; r&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-1&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">题解的lower_bound写法</span><br><span class="line">    <span class="type">int</span> ans=<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,x)-a;<span class="comment">//二分搜，注意-a</span></span><br><span class="line"><span class="keyword">if</span>(x!=a[ans]) <span class="built_in">printf</span>(<span class="string">&quot;-1 &quot;</span>);<span class="comment">//没有，输出-1</span></span><br><span class="line"><span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans);<span class="comment">//有，输出ans</span></span><br></pre></td></tr></table></figure><h1 id="A-B-数对"><a href="#A-B-数对" class="headerlink" title="A-B 数对"></a>A-B 数对</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>出题是一件痛苦的事情！</p><p>相同的题目看多了也会有审美疲劳，于是我舍弃了大家所熟悉的 A+B Problem，改用 A-B 了哈哈！</p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一串正整数数列以及一个正整数 C，要求计算出所有满足 A - B &#x3D; C 的数对的个数（不同位置的数字一样的数对算不同的数对）。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入共两行。</p><p>第一行，两个正整数 N,C。</p><p>第二行，N 个正整数，作为要求处理的那串数。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，表示该串正整数中包含的满足 A - B &#x3D; C 的数对的个数。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 1</span><br><span class="line">1 1 2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 75% 的数据，1 \leq N \leq 2000。</p><p>对于 100% 的数据，1 \leq N \leq 2 \times 10^5，0 \leq a_i &lt;2^{30}，1 \leq C &lt; 2^{30}。</p><p>2017&#x2F;4&#x2F;29 新添数据两组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for(int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span>  c;</span><br><span class="line">cin&gt;&gt;c;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n);</span><br><span class="line"><span class="type">int</span> l=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> r=<span class="number">0</span>;</span><br><span class="line">ll ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(a[i]&gt;a[l]-c&amp;&amp;l&lt;=n )</span><br><span class="line">    &#123;</span><br><span class="line">        l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到第一个大于或等于</span></span><br><span class="line">    <span class="keyword">while</span>(a[i]&gt;=a[r]-c&amp;&amp;r&lt;=n)</span><br><span class="line">   &#123;</span><br><span class="line">    r++;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">//找到第一个大于</span></span><br><span class="line">   <span class="keyword">if</span>(a[l]-a[i]==c)</span><br><span class="line">   &#123;</span><br><span class="line">       ans += r - l;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>题解也有映射做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line">    LL a[<span class="number">200001</span>];</span><br><span class="line">    map&lt;LL,LL&gt; m;<span class="comment">//建立一个数字到出现次数的映射 map&lt;num,times&gt;</span></span><br><span class="line">    <span class="comment">//A-B=C --&gt; A-C=B</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        LL c;</span><br><span class="line">        LL ans=<span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) &#123;</span><br><span class="line">            cin &gt;&gt; a[i];</span><br><span class="line">            m[a[i]]++;</span><br><span class="line">            a[i]-=c;    </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) ans+=m[a[i]];</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//好办法！</span></span><br></pre></td></tr></table></figure><p>也有stl做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> a[<span class="number">200001</span>];</span><br><span class="line"><span class="type">long</span> N,C,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;C;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+N+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=((<span class="built_in">upper_bound</span>(a+<span class="number">1</span>,a+N+<span class="number">1</span>,a[i]+C)-a)-(<span class="built_in">lower_bound</span>(a+<span class="number">1</span>,a+N+<span class="number">1</span>,a[i]+C)-a));</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="COCI-2011-2012-5-EKO-砍树"><a href="#COCI-2011-2012-5-EKO-砍树" class="headerlink" title="[COCI 2011&#x2F;2012 #5] EKO &#x2F; 砍树"></a>[COCI 2011&#x2F;2012 #5] EKO &#x2F; 砍树</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>伐木工人 Mirko 需要砍 M 米长的木材。对 Mirko 来说这是很简单的工作，因为他有一个漂亮的新伐木机，可以如野火一般砍伐森林。不过，Mirko 只被允许砍伐一排树。</p><p>Mirko 的伐木机工作流程如下：Mirko 设置一个高度参数 H（米），伐木机升起一个巨大的锯片到高度 H，并锯掉所有树比 H 高的部分（当然，树木不高于 H 米的部分保持不变）。Mirko 就得到树木被锯下的部分。例如，如果一排树的高度分别为 20,15,10 和 17，Mirko 把锯片升到 15 米的高度，切割后树木剩下的高度将是 15,15,10 和 15，而 Mirko 将从第 1 棵树得到 5 米，从第 4 棵树得到 2 米，共得到 7 米木材。</p><p>Mirko 非常关注生态保护，所以他不会砍掉过多的木材。这也是他尽可能高地设定伐木机锯片的原因。请帮助 Mirko 找到伐木机锯片的最大的整数高度 H，使得他能得到的木材至少为 M 米。换句话说，如果再升高 1 米，他将得不到 M 米木材。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 1 行 2 个整数 N 和 M，N 表示树木的数量，M 表示需要的木材总长度。</p><p>第 2 行 N 个整数表示每棵树的高度。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>1 个整数，表示锯片的最高高度。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 7</span><br><span class="line">20 15 10 17</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 20</span><br><span class="line">4 42 40 26 46</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">36</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>对于 100% 的测试数据，1\le N\le10^6，1\le M\le2\times10^9，树的高度 \le 4\times 10^5，所有树的高度总和 &gt;M。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100000000</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">sum += <span class="built_in">max</span>(<span class="number">0</span>, a[i] - x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (sum&gt;=m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a, a + n);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h = a[n - <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> l = <span class="number">-1</span>;</span><br><span class="line"><span class="type">int</span> r = h+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l+<span class="number">1</span>&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(mid))</span><br><span class="line">&#123;</span><br><span class="line">l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r = mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">check</span>(r))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">cout &lt;&lt; l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力究极解法</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="NOIP2001-提高组-一元三次方程求解"><a href="#NOIP2001-提高组-一元三次方程求解" class="headerlink" title="[NOIP2001 提高组] 一元三次方程求解"></a>[NOIP2001 提高组] 一元三次方程求解</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>有形如：a x^3 + b x^2 + c x + d &#x3D; 0  这样的一个一元三次方程。给出该方程中各项的系数（a,b,c,d 均为实数），并约定该方程存在三个不同实根（根的范围在 -100 至 100 之间），且根与根之差的绝对值 \ge 1。要求由小到大依次在同一行输出这三个实根(根与根之间留有空格)，并精确到小数点后 2 位。</p><p>提示：记方程 f(x) &#x3D; 0，若存在 2 个数 x_1 和 x_2，且 x_1 &lt; x_2，f(x_1) \times f(x_2) &lt; 0，则在 (x_1, x_2) 之间一定有一个根。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行，4 个实数 a, b, c, d。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，3 个实根，从小到大输出，并精确到小数点后 2 位。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 -5 -4 20</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-2.00 2.00 5.00</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p><strong>【题目来源】</strong></p><p>NOIP 2001 提高组第一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> a, b, c, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> a * x * x * x + b * x * x + c * x + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (r-l&lt;<span class="number">0.001</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, r);</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>(mid)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, mid);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>(mid)*<span class="built_in">f</span>(l)&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">find</span>(l, mid);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">find</span>(mid, r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> mark = <span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">double</span> i = <span class="number">-100</span>; i &lt;<span class="number">100</span>,mark!=<span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>(i)==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f &quot;</span>, i);</span><br><span class="line">mark++;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">f</span>(i)*<span class="built_in">f</span>(i+<span class="number">1</span>)&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">find</span>(i, i + <span class="number">1</span>);</span><br><span class="line">mark++;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//有根找根</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="烦恼的高考志愿"><a href="#烦恼的高考志愿" class="headerlink" title="烦恼的高考志愿"></a>烦恼的高考志愿</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>计算机竞赛小组的神牛 V 神终于结束了高考，然而作为班长的他还不能闲下来，班主任老 t 给了他一个艰巨的任务：帮同学找出最合理的大学填报方案。可是 v 神太忙了，身后还有一群小姑娘等着和他约会，于是他想到了同为计算机竞赛小组的你，请你帮他完成这个艰巨的任务。</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有 m 所学校，每所学校预计分数线是 a_i。有 n 位学生，估分分别为 b_i。</p><p>根据 n 位学生的估分情况，分别给每位学生推荐一所学校，要求学校的预计分数线和学生的估分相差最小（可高可低，毕竟是估分嘛），这个最小值为不满意度。求所有学生不满意度和的最小值。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行读入两个整数 m,n。m 表示学校数，n 表示学生数。</p><p>第二行共有 m 个数，表示 m 个学校的预计录取分数。第三行有 n 个数，表示 n 个学生的估分成绩。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，为最小的不满度之和。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 3</span><br><span class="line">513 598 567 689</span><br><span class="line">500 600 550</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">32</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>数据范围：</p><p>对于 30% 的数据，1\leq n,m\leq1000，估分和录取线 \leq10000；</p><p>对于 100% 的数据，1\leq n,m\leq100000，估分和录取线 \leq 1000000 且均为非负整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line">ll m, n;</span><br><span class="line">ll a[<span class="number">1001000</span>], b[<span class="number">1001000</span>];</span><br><span class="line">ll ans;</span><br><span class="line">ll sum;</span><br><span class="line">ll s;</span><br><span class="line"><span class="function">ll <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>, r = m + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l +<span class="number">1</span>&lt; r) &#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (a[mid] &lt; x)l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x &lt;= a[<span class="number">1</span>])<span class="comment">//这里需要特判断一下，不然只能得70分</span></span><br><span class="line">&#123;</span><br><span class="line">ans = a[<span class="number">1</span>] - x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"> <span class="keyword">if</span> (<span class="built_in">abs</span>(a[l] - x) &lt; <span class="built_in">abs</span>(a[l+<span class="number">1</span>] - x)) &#123;</span><br><span class="line">ans = <span class="built_in">abs</span>(a[l] - x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">ans = <span class="built_in">abs</span>(a[l+<span class="number">1</span>] - x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">cin &gt;&gt; b[j];</span><br><span class="line">s += b[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(b + <span class="number">1</span>, b + <span class="number">1</span> + n);</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + <span class="number">1</span> + m);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++) &#123;</span><br><span class="line"></span><br><span class="line">sum +=<span class="built_in">find</span>(b[k]);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2015-提高组-跳石头"><a href="#NOIP2015-提高组-跳石头" class="headerlink" title="[NOIP2015 提高组] 跳石头"></a>[NOIP2015 提高组] 跳石头</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2015 Day2T1</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>一年一度的“跳石头”比赛又要开始了！</p><p>这项比赛将在一条笔直的河道中进行，河道中分布着一些巨大岩石。组委会已经选择好了两块岩石作为比赛起点和终点。在起点和终点之间，有 N 块岩石（不含起点和终点的岩石）。在比赛过程中，选手们将从起点出发，每一步跳向相邻的岩石，直至到达终点。</p><p>为了提高比赛难度，组委会计划移走一些岩石，使得选手们在比赛过程中的最短跳跃距离尽可能长。由于预算限制，组委会至多从起点和终点之间移走 M 块岩石（不能移走起点和终点的岩石）。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含三个整数 L,N,M，分别表示起点到终点的距离，起点和终点之间的岩石数，以及组委会至多移走的岩石数。保证 L \geq 1 且 N \geq M \geq 0。</p><p>接下来 N 行，每行一个整数，第 i 行的整数 D_i,( 0 &lt; D_i &lt; L)， 表示第 i 块岩石与起点的距离。这些岩石按与起点距离从小到大的顺序给出，且不会有两个岩石出现在同一个位置。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，即最短跳跃距离的最大值。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">25 5 2 </span><br><span class="line">2</span><br><span class="line">11</span><br><span class="line">14</span><br><span class="line">17 </span><br><span class="line">21</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><h3 id="输入输出样例-1-说明"><a href="#输入输出样例-1-说明" class="headerlink" title="输入输出样例 1 说明"></a>输入输出样例 1 说明</h3><p>将与起点距离为 2 和 14 的两个岩石移走后，最短的跳跃距离为 4（从与起点距离 17 的岩石跳到距离 21 的岩石，或者从距离 21 的岩石跳到终点）。</p><h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于 20%的数据，0 \le M \le N \le 10。<br>对于 50% 的数据，0 \le M \le N \le 100。<br>对于 100% 的数据，0 \le M \le N \le 50000,1 \le L<br> \le 10^9。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">int</span> length, n, m, a[<span class="number">500005</span>], l, r, now, before = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; length &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; now;</span><br><span class="line">a[i] = now - before;</span><br><span class="line">before = now;</span><br><span class="line">&#125;</span><br><span class="line">a[n] = length - before;</span><br><span class="line">l = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (n == m)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; length;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">r = length / (n - m);</span><br><span class="line"><span class="keyword">while</span> (l &lt;= r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>, tmp,count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">tmp = a[i];</span><br><span class="line"><span class="keyword">while</span> (tmp &lt; mid &amp;&amp; i &lt; n)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line">tmp += a[i];</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (count &gt; m)</span><br><span class="line">&#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; r;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="TJOI2007-路标设置"><a href="#TJOI2007-路标设置" class="headerlink" title="[TJOI2007] 路标设置"></a>[TJOI2007] 路标设置</h1><h2 id="题目背景-3"><a href="#题目背景-3" class="headerlink" title="题目背景"></a>题目背景</h2><p>B 市和 T 市之间有一条长长的高速公路，这条公路的某些地方设有路标，但是大家都感觉路标设得太少了，相邻两个路标之间往往隔着相当长的一段距离。为了便于研究这个问题，我们把公路上相邻路标的最大距离定义为该公路的“空旷指数”。</p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在政府决定在公路上增设一些路标，使得公路的“空旷指数”最小。他们请求你设计一个程序计算能达到的最小值是多少。请注意，公路的起点和终点保证已设有路标，公路的长度为整数，并且原有路标和新设路标都必须距起点整数个单位距离。</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 1 行包括三个数 L,N,K，分别表示公路的长度，原有路标的数量，以及最多可增设的路标数量。</p><p>第 2 行包括递增排列的 N 个整数，分别表示原有的 N 个路标的位置。路标的位置用距起点的距离表示，且一定位于区间 [0,L] 内。</p><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 1 行，包含一个整数，表示增设路标后能达到的最小“空旷指数”值。</p><h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">101 2 1</span><br><span class="line">0 101</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">51</span><br></pre></td></tr></table></figure><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>公路原来只在起点和终点处有两个路标，现在允许新增一个路标，应该把新路标设在距起点 50 或 51 个单位距离处，这样能达到最小的空旷指数 51。</p><p>50% 的数据中，2 \leq N \leq 100，0 \leq K \leq 100。</p><p>100% 的数据中，2 \leq N \leq 100000, 0 \leq K \leq100000。</p><p>100% 的数据中，0 &lt; L \leq 10000000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> length, n, k, a[<span class="number">10000005</span>], now, before = <span class="number">0</span>, r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; length &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; now;</span><br><span class="line">a[i] = now - before;</span><br><span class="line">before = now;</span><br><span class="line"><span class="keyword">if</span> (r&lt;a[i])</span><br><span class="line">&#123;</span><br><span class="line">r = a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">a[n] = length - before;</span><br><span class="line"><span class="keyword">if</span> (r&lt;a[n])</span><br><span class="line">&#123;</span><br><span class="line">r = a[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">100000000</span>;</span><br><span class="line"><span class="keyword">if</span> (k==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; r;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> mid = (l + r) / <span class="number">2</span>, count = <span class="number">0</span>, tep;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">tep = a[i];</span><br><span class="line"><span class="keyword">while</span> (tep&gt;mid)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">tep -= mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (count&lt;=k)</span><br><span class="line">&#123;</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数列分段-Section-II"><a href="#数列分段-Section-II" class="headerlink" title="数列分段 Section II"></a>数列分段 Section II</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>对于给定的一个长度为N的正整数数列 A_{1\sim N}，现要将其分成 M（M\leq N）段，并要求每段连续，且每段和的最大值最小。</p><p>关于最大值最小：</p><p>例如一数列 4\ 2\ 4\ 5\ 1 要分成 3 段。</p><p>将其如下分段：</p><p>[4\ 2][4\ 5][1]</p><p>第一段和为 6，第 2 段和为 9，第 3 段和为 1，和最大值为 9。</p><p>将其如下分段：</p><p>[4][2\ 4][5\ 1]</p><p>第一段和为 4，第 2 段和为 6，第 3 段和为 6，和最大值为 6。</p><p>并且无论如何分段，最大值不会小于 6。</p><p>所以可以得到要将数列 4\ 2\ 4\ 5\ 1 要分成 3 段，每段和的最大值最小为 6。</p><h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 1 行包含两个正整数 N,M。  </p><p>第 2 行包含 N 个空格隔开的非负整数 A_i，含义如题目所述。</p><h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个正整数，即每段和最大值最小为多少。</p><h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">4 2 4 5 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p>对于 20% 的数据，N\leq 10。</p><p>对于 40% 的数据，N\leq 1000。</p><p>对于 100% 的数据，1\leq N\leq 10^5，M\leq N，A_i &lt; 10^8， 答案不超过 10^9。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n)  for(int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e6</span>+<span class="number">100</span>;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(ans+a[i]&gt;x)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line">ans=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">ans+=a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> cnt&gt;m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">sum += a[i];</span><br><span class="line">l=<span class="built_in">max</span>(l,a[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> r=sum;</span><br><span class="line"><span class="type">int</span> mid;</span><br><span class="line"><span class="keyword">while</span>(l+<span class="number">1</span>&lt;r)</span><br><span class="line">&#123;</span><br><span class="line"> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">&#123;</span><br><span class="line">l=mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(!<span class="built_in">check</span>(l))</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;r;</span><br><span class="line">&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="银行贷款"><a href="#银行贷款" class="headerlink" title="银行贷款"></a>银行贷款</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>当一个人从银行贷款后，在一段时间内他（她）将不得不每月偿还固定的分期付款。这个问题要求计算出贷款者向银行支付的利率。假设利率按月累计。</p><h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>三个用空格隔开的正整数。</p><p>第一个整数表示贷款的原值 w_0，第二个整数表示每月支付的分期付款金额 w，第三个整数表示分期付款还清贷款所需的总月数 m。</p><h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个实数，表示该贷款的月利率（用百分数表示），四舍五入精确到 0.1%。</p><p>数据保证答案不超过 300.0%。</p><h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000 100 12</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.9</span><br></pre></td></tr></table></figure><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \leq w_0, w\leq 2^{31}-1，1 \leq m\leq 3000。</p><blockquote><p>月利率是指按照每个月实时本金而产生，不是按照第一次。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> loan, pay, month;</span><br><span class="line"><span class="type">double</span> l = <span class="number">0</span>, r = <span class="number">10</span> , mid, t;</span><br><span class="line">cin &gt;&gt; loan &gt;&gt; pay &gt;&gt; month;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l&lt;r)</span><br><span class="line">&#123;</span><br><span class="line">mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (r-l&lt;<span class="number">0.0001</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">t = loan;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; month; i++)</span><br><span class="line">&#123;</span><br><span class="line">t = t * (<span class="number">1</span> + mid) - pay;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (t&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>, mid*<span class="number">100</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1f&quot;</span>, mid * <span class="number">100</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="kotori的设备"><a href="#kotori的设备" class="headerlink" title="kotori的设备"></a>kotori的设备</h1><h2 id="题目背景-4"><a href="#题目背景-4" class="headerlink" title="题目背景"></a>题目背景</h2><p>kotori 有 n 个可同时使用的设备。</p><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>第 i 个设备每秒消耗 a_i 个单位能量。能量的使用是连续的，也就是说能量不是某时刻突然消耗的，而是匀速消耗。也就是说，对于任意实数，在 k 秒内消耗的能量均为 k\times a_i 单位。在开始的时候第 i 个设备里存储着 b_i 个单位能量。</p><p>同时 kotori 又有一个可以给任意一个设备充电的充电宝，每秒可以给接通的设备充能 p 个单位，充能也是连续的，不再赘述。你可以在任意时间给任意一个设备充能，从一个设备切换到另一个设备的时间忽略不计。</p><p>kotori 想把这些设备一起使用，直到其中有设备能量降为  0。所以 kotori 想知道，在充电器的作用下，她最多能将这些设备一起使用多久。</p><h2 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行给出两个整数 n,p。</p><p>接下来 n 行，每行表示一个设备，给出两个整数，分别是这个设备的 a_i 和 b_i。</p><h2 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h2><p>如果 kotori 可以无限使用这些设备，输出 -1。</p><p>否则输出 kotori 在其中一个设备能量降为 0 之前最多能使用多久。</p><p>设你的答案为 a，标准答案为 b，只有当 a,b 满足<br>\dfrac{|a-b|}{\max(1,b)} \leq 10^{-4} 的时候，你能得到本测试点的满分。</p><h2 id="样例-1-8"><a href="#样例-1-8" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-8"><a href="#样例输入-1-8" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2 1</span><br><span class="line">2 2</span><br><span class="line">2 1000</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-8"><a href="#样例输出-1-8" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2.0000000000</span><br></pre></td></tr></table></figure><h2 id="样例-2-1"><a href="#样例-2-1" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-1"><a href="#样例输入-2-1" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 100</span><br><span class="line">1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1"><a href="#样例输出-2-1" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1</span><br></pre></td></tr></table></figure><h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 5</span><br><span class="line">4 3</span><br><span class="line">5 2</span><br><span class="line">6 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0.5000000000</span><br></pre></td></tr></table></figure><h2 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h2><p>对于 100% 的数据，1\leq n\leq 100000，1\leq p\leq 100000，1\leq a_i,b_i\leq100000。</p><blockquote><p>能量的使用&#x2F;消耗是连续的，所以我可以把能量任意分配。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//很好理解()</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> p;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200000</span>;</span><br><span class="line"><span class="type">double</span> a[N],b[N];</span><br><span class="line"><span class="type">double</span> lbound=<span class="number">0</span>,rbound=<span class="number">1e10</span>;</span><br><span class="line"><span class="type">double</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">check</span><span class="params">(<span class="type">double</span> ans)</span></span>&#123;</span><br><span class="line"><span class="type">double</span> q=p*ans;</span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]*ans&lt;=b[i])&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">sum+=(a[i]*ans-b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum&lt;=q;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;p;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">cin&gt;&gt;a[i]&gt;&gt;b[i];</span><br><span class="line">sum+=a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(sum&lt;=p)&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">-1.000000</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(rbound-lbound&gt;<span class="number">1e-6</span>)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="type">double</span> mid=(lbound+rbound)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(mid))</span><br><span class="line">        &#123;</span><br><span class="line">lbound=mid;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">rbound=mid;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;lbound&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷刷题8</title>
      <link href="/2024/02/08/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%988/"/>
      <url>/2024/02/08/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%988/</url>
      
        <content type="html"><![CDATA[<h1 id="洛谷刷题8"><a href="#洛谷刷题8" class="headerlink" title="洛谷刷题8"></a>洛谷刷题8</h1><blockquote><p>贪心策略的讲解和用法</p><p>贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，算法得到的是在某种意义上的局部最优解 。</p><p>贪心算法不是对所有问题都能得到体最优解，关键是整贪心策略的选择</p><p>贪心算法一般按如下步骤进行：  </p><p>①建立数学模型来描述问题   。</p><p>②把求解的问题分成若干个子问题   。</p><p>③对每个子问题求解，得到子问题的局部最优解   。</p><p>④把子问题的解局部最优解合成原来解问题的一个解   。</p></blockquote><h1 id="【深基12-例1】部分背包问题"><a href="#【深基12-例1】部分背包问题" class="headerlink" title="【深基12.例1】部分背包问题"></a>【深基12.例1】部分背包问题</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 N(N \le 100) 堆金币，第 i 堆金币的总重量和总价值分别是 m_i,v_i(1\le m_i,v_i \le 100)。阿里巴巴有一个承重量为 T(T \le 1000) 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数 N,T。</p><p>接下来 N 行，每行两个整数 m_i,v_i。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个实数表示答案，输出两位小数</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4 50</span><br><span class="line">10 60</span><br><span class="line">20 100</span><br><span class="line">30 120</span><br><span class="line">15 45</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">240.00</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">coin</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m, v;</span><br><span class="line"></span><br><span class="line">&#125;a[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">cmp</span><span class="params">(coin x, coin y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.v * y.m &gt; x.m * y.v;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, c;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; c;</span><br><span class="line"><span class="type">float</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i].m &gt;&gt; a[i].v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(a, a + n, cmp);</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (c&lt;a[i].m)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">c -= a[i].m;</span><br><span class="line">ans += a[i].v;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">ans += <span class="number">1.0</span> * c / a[i].m * a[i].v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//贪心每次拿走性价比最高的</span></span><br></pre></td></tr></table></figure><h1 id="排队接水"><a href="#排队接水" class="headerlink" title="排队接水"></a>排队接水</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 n 个人在一个水龙头前排队接水，假如每个人接水的时间为 T_i，请编程找出这 n 个人排队的一种顺序，使得 n 个人的平均等待时间最小。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为一个整数 n。</p><p>第二行 n 个整数，第 i 个整数 T_i 表示第 i 个人的接水时间 T_i。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件有两行，第一行为一种平均时间最短的排队顺序；第二行为这种排列方案下的平均等待时间（输出结果精确到小数点后两位）。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10 </span><br><span class="line">56 12 1 99 1000 234 33 55 99 812</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 2 7 8 1 4 9 6 10 5</span><br><span class="line">291.90</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>1\le n \leq 1000，1\le t_i \leq 10^6，不保证 t_i 不重复。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> arr[<span class="number">2000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//n个人的排队时间输入</span></span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制一次数组，便于操作；</span></span><br><span class="line"><span class="type">long</span> arr1[<span class="number">2000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">arr1[i] = arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先查找，用数组记录下标后再排序；</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>; <span class="type">int</span> arr2[<span class="number">2000</span>] = &#123; <span class="number">0</span> &#125;; <span class="type">int</span> min = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//检验是否查找完毕；</span></span><br><span class="line"><span class="keyword">while</span> (min)</span><br><span class="line">&#123;</span><br><span class="line">min = <span class="number">0</span>;<span class="comment">//找是否有非负项，找完了就结束循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">min = arr[i];</span><br><span class="line">n = i;<span class="comment">//确保有下标录入；</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找并录入最小值的下标,剔出已录入的（赋一个负值，改条件）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (min &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[i] &lt; min &amp;&amp; arr[i] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">min = arr[i];</span><br><span class="line">n = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">arr2[x] = n + <span class="number">1</span>;</span><br><span class="line">arr[n] = <span class="number">-1</span>;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出查找的最小值的排序；</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= x - <span class="number">1</span>; i++)</span><br><span class="line">cout &lt;&lt; arr2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//对复制的数组arr1排序(冒泡排序）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; N - i - <span class="number">1</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr1[j + <span class="number">1</span>] &lt; arr1[j])</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = arr1[j];</span><br><span class="line">arr1[j] = arr1[j + <span class="number">1</span>];</span><br><span class="line">arr1[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算平均时间</span></span><br><span class="line"><span class="type">double</span> t = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i1 = <span class="number">0</span>; i1 &lt; i; i1++)</span><br><span class="line">&#123;</span><br><span class="line">t += arr1[i1];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> t0 = t / N;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, t0);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//自己写的，写的很抽象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//题解写的，很好理解</span></span><br><span class="line"><span class="comment">//先结构体排序，接着进行运算即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;iostream&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;cstdio&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;algorithm&quot;</span><span class="comment">//为了用sort快排</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">a</span>  </span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> b,num;<span class="comment">//定义结构体a      </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(a x,a y)</span><span class="comment">//定义“小于”运算符</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">return</span> x.b&lt;y.b;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">struct</span> <span class="title class_">a</span> a[<span class="number">1010</span>];<span class="comment">//定义结构体数组</span></span><br><span class="line"> <span class="type">int</span> n,i,j;</span><br><span class="line"> <span class="type">double</span> time=<span class="number">0</span>;</span><br><span class="line"> cin&gt;&gt;n;    </span><br><span class="line"> <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)   </span><br><span class="line">  &#123;</span><br><span class="line">   cin&gt;&gt;a[i].b;</span><br><span class="line">   a[i].num=i;<span class="comment">//序号存起来              </span></span><br><span class="line">  &#125; </span><br><span class="line"> <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>,cmp);<span class="comment">//排序</span></span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">   cout&lt;&lt;a[i].num&lt;&lt;<span class="string">&quot; &quot;</span>; <span class="comment">//先把简单的做了，输入由小到大的编号</span></span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;endl;<span class="comment">//要换行</span></span><br><span class="line">  <span class="keyword">for</span>(j=n<span class="number">-1</span>;j&gt;=<span class="number">1</span>;j--) <span class="comment">//等待人数的计数器，由n-1开始</span></span><br><span class="line">  &#123;</span><br><span class="line">   i=n-j;<span class="comment">//这是个规律，当前最少时间的人序号和要等待的人数之和=n</span></span><br><span class="line">   time+=a[i].b*j; <span class="comment">//累加                  </span></span><br><span class="line">  &#125;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>,time/n);<span class="comment">//算平均，保留两位小数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="凌乱的yyy-线段覆盖"><a href="#凌乱的yyy-线段覆盖" class="headerlink" title="凌乱的yyy &#x2F; 线段覆盖"></a>凌乱的yyy &#x2F; 线段覆盖</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>快 noip 了，yyy 很紧张！</p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在各大 oj 上有 n 个比赛，每个比赛的开始、结束的时间点是知道的。</p><p>yyy 认为，参加越多的比赛，noip 就能考的越好（假的）。</p><p>所以，他想知道他最多能参加几个比赛。</p><p>由于 yyy 是蒟蒻，如果要参加一个比赛必须善始善终，而且不能同时参加 2 个及以上的比赛。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行是一个整数 n，接下来 n 行每行是 2 个整数 a_{i},b_{i}\ (a_{i}&lt;b_{i})，表示比赛开始、结束的时间。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数最多参加的比赛数目。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">0 2</span><br><span class="line">2 4</span><br><span class="line">1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><ul><li><p>对于 20% 的数据，n \le 10；</p></li><li><p>对于 50% 的数据，n \le 10^3；</p></li><li><p>对于 70% 的数据，n \le 10^{5}；</p></li><li><p>对于 100% 的数据，1\le n \le 10^{6}，0 \le a_{i} &lt; b_{i} \le 10^6。</p></li><li><pre><code class="C++">#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;math.h&gt;#include&lt;cmath&gt;using namespace std;struct contest&#123;    int l;    int r;&#125;con[100000000];bool cmp(contest x, contest y)&#123;    return x.r &lt;= y.r;&#125;int main()&#123;    int n;    cin &gt;&gt; n;    for (int i = 0; i &lt; n; i++)    &#123;        cin &gt;&gt; con[i].l &gt;&gt; con[i].r;    &#125;    sort(con, con + n,cmp);    int ans = 0;    int finish = 0;    for (int i = 0; i &lt; n; i++)    &#123;        if (finish&lt;=con[i].l)        &#123;            ans++;            finish = con[i].r;        &#125;    &#125;    cout &lt;&lt; ans;    return 0;&#125;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># [NOIP2004 提高组] 合并果子 / [USACO06NOV] Fence Repair G</span><br><span class="line"></span><br><span class="line">## 题目描述</span><br><span class="line"></span><br><span class="line">在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。</span><br><span class="line"></span><br><span class="line">每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 n-1 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。</span><br><span class="line"></span><br><span class="line">因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。</span><br><span class="line"></span><br><span class="line">例如有 3 种果子，数目依次为 1 ， 2 ， 9 。可以先将 1 、 2 堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力 =3+12=15 。可以证明 15 为最小的体力耗费值。</span><br><span class="line"></span><br><span class="line">## 输入格式</span><br><span class="line"></span><br><span class="line">共两行。  </span><br><span class="line">第一行是一个整数 n(1\leq n\leq 10000) ，表示果子的种类数。  </span><br><span class="line"></span><br><span class="line">第二行包含 n 个整数，用空格分隔，第 i 个整数 a_i(1\leq a_i\leq 20000) 是第 i 种果子的数目。</span><br><span class="line"></span><br><span class="line">## 输出格式</span><br><span class="line"></span><br><span class="line">一个整数，也就是最小的体力耗费值。输入数据保证这个值小于 2^&#123;31&#125; 。</span><br><span class="line"></span><br><span class="line">## 样例 #1</span><br><span class="line"></span><br><span class="line">### 样例输入 #1</span><br><span class="line"></span><br></pre></td></tr></table></figure>3 1 2 9<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 样例输出 #1</span><br><span class="line"></span><br></pre></td></tr></table></figure>15<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 提示</span><br><span class="line"></span><br><span class="line">对于 30\% 的数据，保证有 n \le 1000：</span><br><span class="line"></span><br><span class="line">对于 50\% 的数据，保证有 n \le 5000；</span><br><span class="line"></span><br><span class="line">对于全部的数据，保证有 n \le 10000。</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">//单调队列</span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">const int N=1e7;</span><br><span class="line">#define rep(i,a,n) for(int i=a;i&lt;=n;i++)</span><br><span class="line">priority_queue &lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">int n,x,y;</span><br><span class="line">int ans=0;</span><br><span class="line">int cost;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">rep(i,1,n)</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    q.push(x);</span><br><span class="line">&#125;</span><br><span class="line">while(q.size()&gt;1)</span><br><span class="line">&#123;</span><br><span class="line">    x=q.top();</span><br><span class="line">q.pop();</span><br><span class="line">    y=q.top();</span><br><span class="line">q.pop();</span><br><span class="line">cost =x+y;</span><br><span class="line">q.push(cost);</span><br><span class="line">ans+=cost;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure># 小A的糖果## 题目描述小 A 有 n 个糖果盒，第 i 个盒中有 a_i 颗糖果。小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 x，至少得吃掉几颗糖。## 输入格式输入的第一行是两个用空格隔开的整数，代表糖果盒的个数 n 和给定的参数 x。第二行有 n 个用空格隔开的整数，第 i 个整数代表第 i 盒糖的糖果个数 a_i。## 输出格式输出一行一个整数，代表最少要吃掉的糖果的数量。## 样例 #1### 样例输入 #1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 3</span><br><span class="line">2 2 2</span><br></pre></td></tr></table></figure>### 样例输出 #1<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>## 样例 #2### 样例输入 #2<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 1</span><br><span class="line">1 6 1 2 0 4</span><br></pre></td></tr></table></figure>### 样例输出 #2<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure>## 样例 #3### 样例输入 #3<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 9</span><br><span class="line">3 1 4 1 5</span><br></pre></td></tr></table></figure>### 样例输出 #3<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>## 提示#### 样例输入输出 1 解释吃掉第 2 盒中的一个糖果即可。---#### 样例输入输出 2 解释第 2 盒糖吃掉 6 颗，第 4 盒吃掉 2 颗，第 6 盒吃掉 3 颗。---#### 数据规模与约定- 对于 30\% 的数据，保证 n \leq 20，a_i, x \leq 100。- 对于 70\% 的数据，保证 n \leq 10^3，a_i, x \leq 10^5。- 对于 100\% 的数据，保证 2 \leq n \leq 10^5，0 \leq a_i, x \leq 10^9。- ```C++  #include&lt;iostream&gt;  #include&lt;algorithm&gt;  using namespace std;    long long a[100000];  int main()  &#123;      long long n,x;      cin &gt;&gt; n&gt;&gt;x;      for (int i = 1; i &lt;= n; i++)      &#123;          cin &gt;&gt; a[i];      &#125;      long long sum = 0;      for (int i =1; i &lt; n; i++)      &#123;          if (a[i]+a[i+1]&gt;x)          &#123;              sum += (a[i] + a[i + 1] - x);              a[i + 1] = x - a[i];          &#125;      &#125;      cout &lt;&lt; sum      return 0;  &#125;      <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 删数问题</span><br><span class="line"></span><br><span class="line">## 题目描述</span><br><span class="line"></span><br><span class="line">键盘输入一个高精度的正整数 N（不超过 250 位），去掉其中任意 k 个数字后剩下的数字按原左右次序将组成一个新的非负整数。编程对给定的 N 和 k，寻找一种方案使得剩下的数字组成的新数最小。</span><br><span class="line"></span><br><span class="line">## 输入格式</span><br><span class="line"></span><br><span class="line">输入两行正整数。</span><br><span class="line"></span><br><span class="line">第一行输入一个高精度的正整数 n。</span><br><span class="line"></span><br><span class="line">第二行输入一个正整数 k，表示需要删除的数字个数。</span><br><span class="line"></span><br><span class="line">## 输出格式</span><br><span class="line"></span><br><span class="line">输出一个整数，最后剩下的最小数。</span><br><span class="line"></span><br><span class="line">## 样例 #1</span><br><span class="line"></span><br><span class="line">### 样例输入 #1</span><br><span class="line"></span><br></pre></td></tr></table></figure>  175438   4  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 样例输出 #1</span><br><span class="line"></span><br></pre></td></tr></table></figure>  13  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">```C++</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int b[10000];</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">string st;//字符串</span><br><span class="line">cin &gt;&gt; st;</span><br><span class="line">int n;//删除的次数</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">int len = st.length();</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">b[i] = st[i] - &#x27;0&#x27;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for (int k = 1; k&lt;=n; k++)</span><br><span class="line">&#123;</span><br><span class="line">//遍历n次，因为要删除n个</span><br><span class="line">for (int i = 0; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">if (b[i]&gt;b[i+1])</span><br><span class="line">&#123;</span><br><span class="line">for (int j = i; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line">b[j] = b[j + 1];//删除操作</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">len--;</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;//删除操作完成</span><br><span class="line">//去前导0操作来袭</span><br><span class="line">int i = 0;</span><br><span class="line">int l = 0;</span><br><span class="line">while (b[i]==0&amp;&amp;l&lt;len-1)</span><br><span class="line">&#123;</span><br><span class="line">l++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">for (int i = l; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; b[i];</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre></li></ul><h1 id="陶陶摘苹果（升级版）"><a href="#陶陶摘苹果（升级版）" class="headerlink" title="陶陶摘苹果（升级版）"></a>陶陶摘苹果（升级版）</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>又是一年秋季时，陶陶家的苹果树结了 n 个果子。陶陶又跑去摘苹果，这次他有一个 a 公分的椅子。当他手够不着时，他会站到椅子上再试试。</p><p>这次与 NOIp2005 普及组第一题不同的是：陶陶之前搬凳子，力气只剩下 s 了。当然，每次摘苹果时都要用一定的力气。陶陶想知道在 s&lt;0 之前最多能摘到多少个苹果。</p><p>现在已知 n 个苹果到达地上的高度 x_i，椅子的高度 a，陶陶手伸直的最大长度 b，陶陶所剩的力气 s，陶陶摘一个苹果需要的力气 y_i，求陶陶最多能摘到多少个苹果。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 1 行：两个数 苹果数 n，力气 s。</p><p>第 2 行：两个数 椅子的高度 a，陶陶手伸直的最大长度 b。</p><p>第 3 行~第 3+n-1 行：每行两个数 苹果高度 x_i，摘这个苹果需要的力气 y_i。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有一个整数，表示陶陶最多能摘到的苹果数。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">8 15</span><br><span class="line">20 130</span><br><span class="line">120 3</span><br><span class="line">150 2</span><br><span class="line">110 7</span><br><span class="line">180 1</span><br><span class="line">50 8</span><br><span class="line">200 0</span><br><span class="line">140 3</span><br><span class="line">120 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>对于 100% 的数据，n\leq 5000, a\leq 50, b\leq 200, s\leq 1000, x_i\leq 280, y_i\leq 100。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, s, a, b;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">app</span> &#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="type">int</span> y;</span><br><span class="line">&#125;c[<span class="number">10500</span>];</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(app j, app k)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> j.y &lt; k.y;</span><br><span class="line">    <span class="comment">//先摘取最小的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; s;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">cin &gt;&gt; c[i].x &gt;&gt; c[i].y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(c + <span class="number">1</span>, c + <span class="number">1</span> + n, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i&lt;=n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (c[i].x &lt;= a + b) &#123;</span><br><span class="line"><span class="keyword">if</span> (s-c[i].y&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">s -= c[i].y;</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; num;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2018-提高组-铺设道路"><a href="#NOIP2018-提高组-铺设道路" class="headerlink" title="[NOIP2018 提高组] 铺设道路"></a>[NOIP2018 提高组] 铺设道路</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2018 提高组 D1T1</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>春春是一名道路工程师，负责铺设一条长度为 n 的道路。 </p><p>铺设道路的主要工作是填平下陷的地表。整段道路可以看作是 n 块首尾相连的区域，一开始，第 i 块区域下陷的深度为 d_i 。 </p><p>春春每天可以选择一段连续区间 [L,R] ，填充这段区间中的每块区域，让其下陷深度减少 1。在选择区间时，需要保证，区间内的每块区域在填充前下陷深度均不为 0 。 </p><p>春春希望你能帮他设计一种方案，可以在最短的时间内将整段道路的下陷深度都变为 0 。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件包含两行，第一行包含一个整数 n，表示道路的长度。 第二行包含 n 个整数，相邻两数间用一个空格隔开，第 i 个整数为 d_i 。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件仅包含一个整数，即最少需要多少天才能完成任务。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6   </span><br><span class="line">4 3 2 5 3 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>【样例解释】</p><p>一种可行的最佳方案是，依次选择：<br>[1,6]、[1,6]、[1,2]、[1,1]、[4,6]、[4,4]、[4,4]、[6,6]、[6,6]。   </p><p>【数据规模与约定】</p><p>对于 30% 的数据，1 ≤ n ≤ 10 ；<br>对于 70% 的数据，1 ≤ n ≤ 1000 ；<br>对于 100% 的数据，1 ≤ n ≤ 100000 , 0 ≤ d_i ≤ 10000 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">100005</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)     cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)     <span class="keyword">if</span>(a[i]&gt;a[i<span class="number">-1</span>]) ans+=a[i]-a[i<span class="number">-1</span>];</span><br><span class="line">cout&lt;&lt;ans+a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="USACO1-3-混合牛奶-Mixing-Milk"><a href="#USACO1-3-混合牛奶-Mixing-Milk" class="headerlink" title="[USACO1.3] 混合牛奶 Mixing Milk"></a>[USACO1.3] 混合牛奶 Mixing Milk</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>由于乳制品产业利润很低，所以降低原材料（牛奶）价格就变得十分重要。帮助 Marry 乳业找到最优的牛奶采购方案。</p><p>Marry 乳业从一些奶农手中采购牛奶，并且每一位奶农为乳制品加工企业提供的价格可能相同。此外，就像每头奶牛每天只能挤出固定数量的奶，每位奶农每天能提供的牛奶数量是一定的。每天 Marry 乳业可以从奶农手中采购到小于或者等于奶农最大产量的整数数量的牛奶。</p><p>给出 Marry 乳业每天对牛奶的需求量，还有每位奶农提供的牛奶单价和产量。计算采购足够数量的牛奶所需的最小花费。</p><p>注：每天所有奶农的总产量大于 Marry 乳业的需求量。</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行二个整数 n,m，表示需要牛奶的总量，和提供牛奶的农民个数。</p><p>接下来 m 行，每行两个整数 p_i,a_i，表示第 i 个农民牛奶的单价，和农民 i 一天最多能卖出的牛奶量。</p><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>单独的一行包含单独的一个整数，表示 Marry 的牛奶制造公司拿到所需的牛奶所要的最小费用。</p><h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">100 5</span><br><span class="line">5 20</span><br><span class="line">9 40</span><br><span class="line">3 10</span><br><span class="line">8 80</span><br><span class="line">6 30</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">630</span><br></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>【数据范围】<br>对于 100% 的数据：<br>0 \le n,a_i \le 2 \times 10^6，0\le m \le 5000，0 \le p_i \le 1000</p><p>题目翻译来自 NOCOW。</p><p>USACO Training Section 1.3</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找价格最少即可</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">niunai</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> jiage;</span><br><span class="line"><span class="type">int</span> shuliang;</span><br><span class="line">&#125;a[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(niunai x, niunai y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x.jiage &lt; y.jiage;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i].jiage &gt;&gt; a[i].shuliang;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a, a + m, cmp);</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (n-a[i].shuliang&gt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum += a[i].jiage * a[i].shuliang;</span><br><span class="line">n -= a[i].shuliang;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sum += a[i].jiage * n;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2007-普及组-纪念品分组"><a href="#NOIP2007-普及组-纪念品分组" class="headerlink" title="[NOIP2007 普及组] 纪念品分组"></a>[NOIP2007 普及组] 纪念品分组</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2007 普及组 T2</p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>元旦快到了，校学生会让乐乐负责新年晚会的纪念品发放工作。为使得参加晚会的同学所获得 的纪念品价值相对均衡，他要把购来的纪念品根据价格进行分组，但每组最多只能包括两件纪念品， 并且每组纪念品的价格之和不能超过一个给定的整数。为了保证在尽量短的时间内发完所有纪念品，乐乐希望分组的数目最少。</p><p>你的任务是写一个程序，找出所有分组方案中分组数最少的一种，输出最少的分组数目。</p><h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>共 n+2 行：</p><p>第一行包括一个整数 w，为每组纪念品价格之和的上限。</p><p>第二行为一个整数 n，表示购来的纪念品的总件数 G。</p><p>第 3\sim n+2 行每行包含一个正整数 P_i 表示所对应纪念品的价格。</p><h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，即最少的分组数目。</p><h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">100 </span><br><span class="line">9 </span><br><span class="line">90 </span><br><span class="line">20 </span><br><span class="line">20 </span><br><span class="line">30 </span><br><span class="line">50 </span><br><span class="line">60 </span><br><span class="line">70 </span><br><span class="line">80 </span><br><span class="line">90</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>50% 的数据满足：1\le n\le15。</p><p>100% 的数据满足：1\le n\le3\times10^4，80\le w\le200，5 \le  P_i  \le  w。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找两端最大的</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100000000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> w;</span><br><span class="line">cin &gt;&gt; w;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> r = n;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (l&lt;=r)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[l]+a[r]&lt;=w)</span><br><span class="line">&#123;</span><br><span class="line">l++, r--;</span><br><span class="line">sum += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">r--;</span><br><span class="line">sum++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="跳跳！"><a href="#跳跳！" class="headerlink" title="跳跳！"></a>跳跳！</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>你是一只小跳蛙，你特别擅长在各种地方跳来跳去。</p><p>这一天，你和朋友小 F 一起出去玩耍的时候，遇到了一堆高矮不同的石头，其中第 i 块的石头高度为 h_i，地面的高度是 h_0 &#x3D; 0。你估计着，从第 i 块石头跳到第 j 块石头上耗费的体力值为 (h_i - h_j) ^ 2，从地面跳到第 i 块石头耗费的体力值是 (h_i) ^ 2。</p><p>为了给小 F 展现你超级跳的本领，你决定跳到每个石头上各一次，并最终停在任意一块石头上，并且小跳蛙想耗费<strong>尽可能多</strong>的体力值。</p><p>当然，你只是一只小跳蛙，你只会跳，不知道怎么跳才能让本领更充分地展现。</p><p>不过你有救啦！小 F 给你递来了一个写着 AK 的电脑，你可以使用计算机程序帮你解决这个问题，万能的计算机会告诉你怎么跳。</p><p>那就请你——会写代码的小跳蛙——写下这个程序，为你 NOIp AK 踏出坚实的一步吧！</p><h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行一个正整数 n，表示石头个数。</p><p>输入第二行 n 个正整数，表示第 i 块石头的高度 h_i。</p><h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个正整数，表示你可以耗费的体力值的最大值。</p><h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">2 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">6 3 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">49</span><br></pre></td></tr></table></figure><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><h4 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h4><p>两个样例按照输入给定的顺序依次跳上去就可以得到最优方案之一。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>对于 1 \leq i \leq n，有 0 &lt; h_i \leq 10 ^ 4，且保证 h_i 互不相同。</p><p>对于 10% 的数据，n \leq 3；</p><p>对于 20% 的数据，n \leq 10；</p><p>对于 50% 的数据，n \leq 20；</p><p>对于 80% 的数据，n \leq 50；</p><p>对于 100% 的数据，n \leq 300。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//差距最大反复横跳</span></span><br><span class="line">    <span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100000</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">100000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> cmax = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line"><span class="type">int</span> j;</span><br><span class="line"><span class="type">int</span> z;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> ((<span class="built_in">abs</span>(a[j] - now)) * (<span class="built_in">abs</span>(a[j] - now))&gt;cmax&amp;&amp;!b[j])</span><br><span class="line">&#123;</span><br><span class="line">cmax = <span class="built_in">abs</span>(a[j] - now) * <span class="built_in">abs</span>(a[j] - now);</span><br><span class="line">t = a[j];</span><br><span class="line">z = j;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">sum += cmax;</span><br><span class="line">cmax = <span class="number">0</span>;</span><br><span class="line">now = t;</span><br><span class="line">b[z] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AHOI2018初中组-分组"><a href="#AHOI2018初中组-分组" class="headerlink" title="[AHOI2018初中组] 分组"></a>[AHOI2018初中组] 分组</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>小可可的学校信息组总共有 n 个队员，每个人都有一个实力值 a_i。现在，一年一度的编程大赛就要到了，小可可的学校获得了若干个参赛名额，教练决定把学校信息组的 n 个队员分成若干个小组去参加这场比赛。</p><p>但是每个队员都不会愿意与实力跟自己过于悬殊的队员组队，于是要求分成的每个小组的队员实力值连续，同时，一个队不需要两个实力相同的选手。举个例子：[1, 2, 3, 4, 5] 是合法的分组方案，因为实力值连续；[1, 2, 3, 5] 不是合法的分组方案，因为实力值不连续；[0, 1, 1, 2] 同样不是合法的分组方案，因为出现了两个实力值为 1 的选手。</p><p>如果有小组内人数太少，就会因为时间不够而无法获得高分，于是小可可想让你给出一个合法的分组方案，满足所有人都恰好分到一个小组，使得人数最少的组人数最多，输出人数最少的组人数的最大值。</p><p>注意：实力值可能是负数，分组的数量没有限制。</p><h2 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入有两行：</p><p>第一行一个正整数 n，表示队员数量。<br>第二行有 n 个整数，第 i 个整数 a_i 表示第 i 个队员的实力。</p><h2 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，包括一个正整数，表示人数最少的组的人数最大值。</p><h2 id="样例-1-8"><a href="#样例-1-8" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-8"><a href="#样例输入-1-8" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">4 5 2 3 -4 -3 -5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-8"><a href="#样例输出-1-8" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>【样例解释】<br>分为 2 组，一组的队员实力值是 {4, 5, 2, 3}，一组是 {-4, -3, -5}，其中最小的组人数为 3，可以发现没有比 3 更优的分法了。</p><p>【数据范围】</p><p>对于 100% 的数据满足：1\leq n\leq 100000，|a_i|\leq10^9。</p><p>本题共 10 个测试点，编号为 1\sim10，每个测试点额外保证如下：</p><table><thead><tr><th align="center">测试点编号</th><th align="center">数据限制</th></tr></thead><tbody><tr><td align="center">1\sim2</td><td align="center">n\leq 6, 1\leq a_i \leq 100</td></tr><tr><td align="center">3\sim4</td><td align="center">n\leq 1000, 1\leq a_i\leq 10^5 且 a_i 互不相同</td></tr><tr><td align="center">5\sim6</td><td align="center">n\leq 100000, a_i 互不相同</td></tr><tr><td align="center">7\sim8</td><td align="center">n\leq 100000, 1\leq a_i \leq10^5</td></tr><tr><td align="center">9\sim 10</td><td align="center">n\leq 100000, -10^9 \leq a_i \leq 10^9</td></tr></tbody></table><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e5</span>+<span class="number">40</span>;</span><br><span class="line"><span class="type">int</span> f[N],n,ans=<span class="number">1e9</span>,siz[N],top,q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;f[i];</span><br><span class="line"><span class="built_in">sort</span>(f+<span class="number">1</span>,f+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line"><span class="type">int</span> pos=<span class="built_in">lower_bound</span>(q+<span class="number">1</span>,q+top+<span class="number">1</span>,f[i])-q; </span><br><span class="line">        <span class="comment">//查询大于或等于他的</span></span><br><span class="line"><span class="keyword">while</span>(q[pos+<span class="number">1</span>]==f[i]&amp;&amp;pos&lt;top) pos++;</span><br><span class="line">        <span class="comment">//查询最后一个等于他的</span></span><br><span class="line"><span class="keyword">if</span>(pos&gt;top||q[pos]!=f[i]) siz[++top]=<span class="number">1</span>,q[top]=f[i]+<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//不等于再开，并记录下一个要进来的（如果有）</span></span><br><span class="line"><span class="keyword">else</span> siz[pos]++,q[pos]++;</span><br><span class="line">        <span class="comment">//有就加，并更新待会要进来的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=top;i++) ans=<span class="built_in">min</span>(ans,siz[i]);  </span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2012-提高组-国王游戏"><a href="#NOIP2012-提高组-国王游戏" class="headerlink" title="[NOIP2012 提高组] 国王游戏"></a>[NOIP2012 提高组] 国王游戏</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>恰逢 H 国国庆，国王邀请 n 位大臣来玩一个有奖游戏。首先，他让每个大臣在左、右手上面分别写下一个整数，国王自己也在左、右手上各写一个整数。然后，让这 n 位大臣排成一排，国王站在队伍的最前面。排好队后，所有的大臣都会获得国王奖赏的若干金币，每位大臣获得的金币数分别是：排在该大臣前面的所有人的左手上的数的乘积除以他自己右手上的数，然后向下取整得到的结果。</p><p>国王不希望某一个大臣获得特别多的奖赏，所以他想请你帮他重新安排一下队伍的顺序，使得获得奖赏最多的大臣，所获奖赏尽可能的少。注意，国王的位置始终在队伍的最前面。</p><h2 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个整数 n，表示大臣的人数。</p><p>第二行包含两个整数 a 和 b，之间用一个空格隔开，分别表示国王左手和右手上的整数。</p><p>接下来 n 行，每行包含两个整数 a 和 b，之间用一个空格隔开，分别表示每个大臣左手和右手上的整数。</p><h2 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示重新排列后的队伍中获奖赏最多的大臣所获得的金币数。</p><h2 id="样例-1-9"><a href="#样例-1-9" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-9"><a href="#样例输入-1-9" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">3 </span><br><span class="line">1 1 </span><br><span class="line">2 3 </span><br><span class="line">7 4 </span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-9"><a href="#样例输出-1-9" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h2><p>【输入输出样例说明】</p><p>按 1、2、3 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；</p><p>按 1、3、2 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；</p><p>按 2、1、3 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；</p><p>按 2、3、1 这样排列队伍，获得奖赏最多的大臣所获得金币数为 9；</p><p>按 3、1、2 这样排列队伍，获得奖赏最多的大臣所获得金币数为 2；  </p><p>按 3、2、1 这样排列队伍，获得奖赏最多的大臣所获得金币数为 9。</p><p>因此，奖赏最多的大臣最少获得 2 个金币，答案输出 2。</p><p>【数据范围】</p><p>对于 20% 的数据，有 1≤ n≤ 10,0 &lt; a,b &lt; 8；</p><p>对于 40% 的数据，有 1≤ n≤20,0 &lt; a,b &lt; 8；</p><p>对于 60% 的数据，有 1≤ n≤100；</p><p>对于 60% 的数据，保证答案不超过 10^9；</p><p>对于 100% 的数据，有 1 ≤ n ≤1,000,0 &lt; a,b &lt; 10000。</p><p>NOIP 2012 提高组 第一天 第二题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本题的难点是排序要怎么排序？</span></span><br><span class="line"><span class="comment">//不妨想，相邻两个人，如果后者</span></span><br><span class="line">a2/b1 vs a1/b2</span><br><span class="line">要比较小的话</span><br><span class="line">    实际上就是要让乘积较小排前面，局部贪心</span><br><span class="line">整体贪心：相邻两个不会影响后面，因此不断推，就是整体。</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN=<span class="number">1010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">bign</span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BASE=<span class="number">1e4</span>;</span><br><span class="line">    <span class="type">int</span> a[MAXN&lt;&lt;<span class="number">2</span>],len;</span><br><span class="line">    <span class="built_in">bign</span>(<span class="type">int</span> len=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;len=len;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span>=(<span class="type">int</span> rhs)&#123;</span><br><span class="line">        len=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(rhs==<span class="number">0</span>)&#123;</span><br><span class="line">            len=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(rhs)&#123;</span><br><span class="line">            a[++len]=rhs%BASE;</span><br><span class="line">            rhs/=BASE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span>=(<span class="type">const</span> bign rhs)&#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(a,rhs.a,<span class="built_in">sizeof</span>(rhs.a));</span><br><span class="line">        len=rhs.len;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="keyword">operator</span>*=(<span class="type">const</span> <span class="type">int</span> rhs)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)</span><br><span class="line">            a[i]*=rhs;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;i++)&#123;</span><br><span class="line">            a[i+<span class="number">1</span>]+=a[i]/BASE;</span><br><span class="line">            a[i]%=BASE;</span><br><span class="line">            <span class="keyword">if</span>(i+<span class="number">1</span>&gt;len&amp;&amp;a[i+<span class="number">1</span>])</span><br><span class="line">                len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(len&amp;&amp;a[len]==<span class="number">0</span>)</span><br><span class="line">            len--;</span><br><span class="line">    &#125;</span><br><span class="line">    bign <span class="keyword">operator</span>/(<span class="type">const</span> <span class="type">int</span> rhs)&#123;</span><br><span class="line">        bign c;c=*<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">while</span>(c.len&amp;&amp;c.a[c.len]==<span class="number">0</span>)</span><br><span class="line">            c.len--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=c.len;i;i--)&#123;</span><br><span class="line">            c.a[i<span class="number">-1</span>]+=(c.a[i]%rhs)*BASE;</span><br><span class="line">            c.a[i]/=rhs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(c.len&amp;&amp;c.a[c.len]==<span class="number">0</span>)</span><br><span class="line">            c.len--;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(len&amp;&amp;a[len]==<span class="number">0</span>)</span><br><span class="line">            len--;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">putchar</span>(<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,a[len]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-1</span>;i;i--)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%04d&quot;</span>,a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> bign &amp;rhs)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(len!=rhs.len)</span><br><span class="line">            <span class="keyword">return</span> len&gt;rhs.len;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len;i;i--)</span><br><span class="line">            <span class="keyword">if</span>(a[i]!=rhs.a[i])</span><br><span class="line">                <span class="keyword">return</span> a[i]&gt;rhs.a[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;mul,ans;</span><br><span class="line"><span class="comment">//高精模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> node &amp;rhs)<span class="type">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a*b&lt;rhs.a*rhs.b||(a*b==rhs.a*rhs.b&amp;&amp;a&gt;rhs.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[MAXN];</span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">   cin&gt;&gt;p[i].a&gt;&gt;p[i].b;</span><br><span class="line">    <span class="built_in">sort</span>(p+<span class="number">1</span>,p+n+<span class="number">1</span>);</span><br><span class="line">    mul=p[<span class="number">0</span>].a;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        bign tmp=mul/p[i].b;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;ans)</span><br><span class="line">            ans=tmp;</span><br><span class="line">        mul*=p[i].a;</span><br><span class="line">        <span class="comment">//结果回收</span></span><br><span class="line">    &#125;</span><br><span class="line">    ans.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷刷题7</title>
      <link href="/2024/02/08/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%987/"/>
      <url>/2024/02/08/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%987/</url>
      
        <content type="html"><![CDATA[<h1 id="洛谷刷题7"><a href="#洛谷刷题7" class="headerlink" title="洛谷刷题7"></a>洛谷刷题7</h1><h1 id="【深基15-例1】询问学号"><a href="#【深基15-例1】询问学号" class="headerlink" title="【深基15.例1】询问学号"></a>【深基15.例1】询问学号</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 n(n \le 2 \times 10^6) 名同学陆陆续续进入教室。我们知道每名同学的学号（在 1 到 10^9 之间），按进教室的顺序给出。上课了，老师想知道第 i 个进入教室的同学的学号是什么（最先进入教室的同学 i&#x3D;1），询问次数不超过 10^5 次。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行 2 个整数 n 和 m，表示学生个数和询问次数。</p><p>第二行 n 个整数，表示按顺序进入教室的学号。</p><p>第三行 m 个整数，表示询问第几个进入教室的同学。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 m 个整数表示答案，用换行隔开。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">10 3</span><br><span class="line">1 9 2 60 8 17 11 4 5 14</span><br><span class="line">1 5 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">8</span><br><span class="line">5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, m ,temp;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;stu;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; temp;</span><br><span class="line">stu.<span class="built_in">push_back</span>(temp);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">cout &lt;&lt; stu[x - <span class="number">1</span>]&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="vector知识点"><a href="#vector知识点" class="headerlink" title="vector知识点"></a>vector知识点</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">1</span>) <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//定义了10个整型元素的向量（尖括号中为元素类型名，它可以是任何合法的数据类型），但没有给出初值，其值是不确定的。</span></span><br><span class="line">   （<span class="number">2</span>）<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>; <span class="comment">//定义了10个整型元素的向量,且给出每个元素的初值为1</span></span><br><span class="line">   （<span class="number">3</span>）<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">//用b向量来创建a向量，整体复制性赋值</span></span><br><span class="line">   （<span class="number">4</span>）<span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b.begin(),b.begin+<span class="number">3</span>)</span></span>; <span class="comment">//定义了a值为b中第0个到第2个（共3个）元素</span></span><br><span class="line">   （<span class="number">5</span>）<span class="type">int</span> b[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>)</span></span>; <span class="comment">//从数组中获得初值</span></span><br><span class="line">（<span class="number">1</span>）a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//b为向量，将b的0~2个元素构成的向量赋给a</span></span><br><span class="line">    （<span class="number">2</span>）a.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">2</span>); <span class="comment">//是a只含4个元素，且每个元素为2</span></span><br><span class="line">    （<span class="number">3</span>）a.<span class="built_in">back</span>(); <span class="comment">//返回a的最后一个元素</span></span><br><span class="line">    （<span class="number">4</span>）a.<span class="built_in">front</span>(); <span class="comment">//返回a的第一个元素</span></span><br><span class="line">    （<span class="number">5</span>）a[i]; <span class="comment">//返回a的第i个元素，当且仅当a[i]存在2013-12-07</span></span><br><span class="line">    （<span class="number">6</span>）a.<span class="built_in">clear</span>(); <span class="comment">//清空a中的元素</span></span><br><span class="line">    （<span class="number">7</span>）a.<span class="built_in">empty</span>(); <span class="comment">//判断a是否为空，空则返回ture,不空则返回false</span></span><br><span class="line">    （<span class="number">8</span>）a.<span class="built_in">pop_back</span>(); <span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">    （<span class="number">9</span>）a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+         3（不包括它）</span></span><br><span class="line">    （<span class="number">10</span>）a.<span class="built_in">push_back</span>(<span class="number">5</span>); <span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">    （<span class="number">11</span>）a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4</span></span><br><span class="line">    （<span class="number">12</span>）a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</span></span><br><span class="line">    （<span class="number">13</span>）a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>); <span class="comment">//b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8         ，插入元素后为1,4,5,9,2,3,4,5,9,8</span></span><br><span class="line">    （<span class="number">14</span>）a.<span class="built_in">size</span>(); <span class="comment">//返回a中元素的个数；</span></span><br><span class="line">    （<span class="number">15</span>）a.<span class="built_in">capacity</span>(); <span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">    （<span class="number">16</span>）a.<span class="built_in">resize</span>(<span class="number">10</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值随机</span></span><br><span class="line">    （<span class="number">17</span>）a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值为2</span></span><br><span class="line">    （<span class="number">18</span>）a.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">//将a的容量（capacity）扩充至100，也就是说现在测试a.capacity();的时候返回值是100.这种操作只有在需要给a添加大量数据的时候才         显得有意义，因为这将避免内存多次容量扩充操作（当a的容量不足时电脑会自动扩容，当然这必然降低性能） </span></span><br><span class="line">    （<span class="number">19</span>）a.<span class="built_in">swap</span>(b); <span class="comment">//b为向量，将a中的元素和b中的元素进行整体性交换</span></span><br><span class="line">    （<span class="number">20</span>）a==b; <span class="comment">//b为向量，向量的比较操作还有!=,&gt;=,&lt;=,&gt;,&lt;</span></span><br><span class="line">（<span class="number">1</span>）<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span></span><br><span class="line">（<span class="number">2</span>）<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span></span><br><span class="line">（<span class="number">3</span>）<span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),b.<span class="built_in">begin</span>()+<span class="number">1</span>); <span class="comment">//把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开        始复制，覆盖掉原有元素</span></span><br><span class="line">（<span class="number">4</span>）<span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>); <span class="comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span></span><br><span class="line"><span class="comment">//链接：</span></span><br><span class="line">https:<span class="comment">//blog.csdn.net/wkq0825/article/details/82255984</span></span><br></pre></td></tr></table></figure><p>错误地方</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    a[i]=i;</span><br></pre></td></tr></table></figure><h1 id="【深基15-例2】寄包柜"><a href="#【深基15-例2】寄包柜" class="headerlink" title="【深基15.例2】寄包柜"></a>【深基15.例2】寄包柜</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>超市里有 n(1\le n\le10^5) 个寄包柜。每个寄包柜格子数量不一，第 i 个寄包柜有 a_i(1\le a_i\le10^5) 个格子，不过我们并不知道各个 a_i 的值。对于每个寄包柜，格子编号从 1 开始，一直到 a_i。现在有 q(1 \le q\le10^5) 次操作：</p><ul><li><code>1 i j k</code>：在第 i 个柜子的第 j 个格子存入物品 k(0\le k\le 10^9)。当 k&#x3D;0 时说明清空该格子。</li><li><code>2 i j</code>：查询第 i 个柜子的第 j 个格子中的物品是什么，保证查询的柜子有存过东西。</li></ul><p>已知超市里共计不会超过 10^7 个寄包格子，a_i 是确定然而未知的，但是保证一定不小于该柜子存物品请求的格子编号的最大值。当然也有可能某些寄包柜中一个格子都没有。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行 2 个整数 n 和 q，寄包柜个数和询问次数。</p><p>接下来 q 个整数，表示一次操作。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于查询操作时，输出答案，以换行隔开。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 4</span><br><span class="line">1 3 10000 118014</span><br><span class="line">1 1 1 1</span><br><span class="line">2 3 10000</span><br><span class="line">2 1 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">118014</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>\text{upd 2022.7.26}：新增加一组 Hack 数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;a;</span><br><span class="line"><span class="type">int</span> opt;</span><br><span class="line"><span class="type">int</span> i, j, k, n, q;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">a.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">0</span>; x &lt; q; x++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; opt;</span><br><span class="line"><span class="keyword">if</span> (opt==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; i &gt;&gt; j &gt;&gt; k;</span><br><span class="line"><span class="keyword">if</span> (a[i].<span class="built_in">size</span>()&lt;j+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i].<span class="built_in">resize</span>(j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">a[i][j] = k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; i &gt;&gt; j;</span><br><span class="line">cout &lt;&lt; a[i][j] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>所谓后缀表达式是指这样的一个表达式：式中不再引用括号，运算符号放在两个运算对象之后，所有计算按运算符号出现的顺序，严格地由左而右新进行（不用考虑运算符的优先级）。</p><p>本题中运算符仅包含 \texttt{+-*&#x2F;}。保证对于 \texttt{&#x2F;} 运算除数不为 0。特别地，其中 \texttt{&#x2F;} 运算的结果需要<strong>向 0 取整</strong>（即与 C++ <code>/</code> 运算的规则一致）。</p><p>如：\texttt{3*(5-2)+7} 对应的后缀表达式为：\texttt{3.5.2.-*7.+@}。在该式中，<code>@</code> 为表达式的结束符号。<code>.</code> 为操作数的结束符号。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行一个字符串 s，表示后缀表达式。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示表达式的值。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3.5.2.-*7.+@</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">16</span><br></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.28.30./*7.-@</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-7</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \leq |s| \leq 50，答案和计算过程中的每一个值的绝对值不超过 10^9。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">stack &lt; <span class="type">int</span> &gt; n;</span><br><span class="line"><span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> ch;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">ch = <span class="built_in">getchar</span>();</span><br><span class="line"><span class="keyword">if</span> (ch&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;ch&lt;=<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">s = s * <span class="number">10</span> + ch - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ch==<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">n.<span class="built_in">push</span>(s);</span><br><span class="line">s = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(ch!=<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">x = n.<span class="built_in">top</span>();</span><br><span class="line">n.<span class="built_in">pop</span>();</span><br><span class="line">y = n.<span class="built_in">top</span>();</span><br><span class="line">n.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">switch</span> (ch)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:n.<span class="built_in">push</span>(x + y); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:n.<span class="built_in">push</span>(y - x); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:n.<span class="built_in">push</span>(x * y); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>:n.<span class="built_in">push</span>(y/x); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> (ch!=<span class="string">&#x27;@&#x27;</span>);</span><br><span class="line">    cout&lt;&lt; n.<span class="built_in">top</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈知识点"><a href="#栈知识点" class="headerlink" title="栈知识点"></a>栈知识点</h1><blockquote><p>栈是一个先入后出的有序列表<br>栈中元素的插入和删除只能在线性表的同一端进行的一种特殊线性表。允许插入和删除的一端，为变化的一端，称为栈顶(Top),另一端为固定的一端，称为栈底(Bottom)<br>根据栈的定义可知，最先放入栈中元素在栈底，最后放入的元素在栈顶，而删除元素刚好相反，最后放入的元素最先删除，最先放入的元素最后删除</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">st.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;st.<span class="built_in">top</span>()&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="number">3.</span> stack常用函数实例解析</span><br><span class="line">(<span class="number">1</span>). <span class="built_in">push</span>(x) 将x入栈</span><br><span class="line">(<span class="number">2</span>). <span class="built_in">top</span>() 获得栈顶元素</span><br><span class="line">(<span class="number">3</span>). <span class="built_in">pop</span>() 用以弹出栈顶元素</span><br><span class="line">(<span class="number">4</span>). <span class="built_in">empty</span>() 可以检测stack内是否为空，返回<span class="literal">true</span>为空，返回<span class="literal">false</span>为非空</span><br><span class="line">(<span class="number">5</span>). <span class="built_in">size</span>() 返回stack内元素的个数</span><br></pre></td></tr></table></figure><h1 id="约瑟夫问题"><a href="#约瑟夫问题" class="headerlink" title="约瑟夫问题"></a>约瑟夫问题</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>n 个人围成一圈，从第一个人开始报数,数到 m 的人出列，再由下一个人重新从 1 开始报数，数到 m 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。</p><p><strong>注意：本题和《深入浅出-基础篇》上例题的表述稍有不同。书上表述是给出淘汰 n-1 名小朋友，而该题是全部出圈。</strong></p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入两个整数 n,m。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行 n 个整数，按顺序输出每个出圈人的编号。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 6 9 2 7 1 8 5 10 4</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>1 \le m, n \le 100</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">queue &lt; <span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i =<span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>()!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; k; i++)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(q.<span class="built_in">front</span>());</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; q.<span class="built_in">front</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>queue队列详解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">C++队列Queue类成员函数如下:</span><br><span class="line"></span><br><span class="line"><span class="built_in">back</span>()返回最后一个元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">empty</span>()如果队列空则返回真</span><br><span class="line"></span><br><span class="line"><span class="built_in">front</span>()返回第一个元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">pop</span>()删除第一个元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">push</span>()在末尾加入一个元素</span><br><span class="line"></span><br><span class="line"><span class="built_in">size</span>()返回队列中元素的个数</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="队列安排"><a href="#队列安排" class="headerlink" title="队列安排"></a>队列安排</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个学校里老师要将班上 N 个同学排成一列，同学被编号为 1\sim N，他采取如下的方法：</p><ol><li><p>先将 1 号同学安排进队列，这时队列中只有他一个人；</p></li><li><p>2\sim N 号同学依次入列，编号为 i 的同学入列方式为：老师指定编号为 i 的同学站在编号为 1\sim(i-1) 中某位同学（即之前已经入列的同学）的左边或右边；</p></li><li><p>从队列中去掉 M 个同学，其他同学位置顺序不变。</p></li></ol><p>在所有同学按照上述方法队列排列完毕后，老师想知道从左到右所有同学的编号。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 N，表示了有 N 个同学。</p><p>第 2\sim N 行，第 i 行包含两个整数 k,p，其中 k 为小于 i 的正整数，p 为 0 或者 1。若 p 为 0，则表示将 i 号同学插入到 k 号同学的左边，p 为 1 则表示插入到右边。</p><p>第 N+1 行为一个整数 M，表示去掉的同学数目。</p><p>接下来 M 行，每行一个正整数 x，表示将 x 号同学从队列中移去，如果 x 号同学已经不在队列中则忽略这一条指令。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，包含最多 N 个空格隔开的整数，表示了队列从左到右所有同学的编号。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 0</span><br><span class="line">2 1</span><br><span class="line">1 0</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 4 1</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p><strong>【样例解释】</strong></p><p>将同学 2 插入至同学 1 左边，此时队列为：</p><p><code>2 1</code></p><p>将同学 3 插入至同学 2 右边，此时队列为：</p><p><code>2 3 1</code>  </p><p>将同学 4 插入至同学 1 左边，此时队列为：</p><p><code>2 3 4 1</code>  </p><p>将同学 3 从队列中移出，此时队列为：</p><p><code>2 4 1</code>  </p><p>同学 3 已经不在队列中，忽略最后一条指令</p><p>最终队列：</p><p><code>2 4 1</code>  </p><p><strong>【数据范围】</strong></p><p>对于 20% 的数据，1\leq N\leq 10。</p><p>对于 40% 的数据，1\leq N\leq 1000。</p><p>对于 100% 的数据，1&lt;M\leq N\leq 10^5。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题解第一篇大佬的，</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mx=<span class="number">1e5</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">T</span>&#123;</span><br><span class="line">    <span class="type">int</span> l,r;        <span class="comment">//每个同学的“左右手” </span></span><br><span class="line"><span class="type">int</span> d;          <span class="comment">//表示同学是否输出 </span></span><br><span class="line">&#125;t[mx]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> k,<span class="type">int</span> f)</span>       <span class="comment">//新增同学 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(f==<span class="number">1</span>)         <span class="comment">//左 </span></span><br><span class="line">    &#123;</span><br><span class="line">        t[k].r=t[i].r;</span><br><span class="line">        t[k].l=i; </span><br><span class="line">        t[i].r=k;</span><br><span class="line">        t[t[k].r].l=k;</span><br><span class="line">        <span class="comment">//一个双向链表的移动过程</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>             <span class="comment">//右 </span></span><br><span class="line">    &#123;</span><br><span class="line">        t[k].r=i;</span><br><span class="line">        t[k].l=t[i].l;</span><br><span class="line">        t[i].l=k;</span><br><span class="line">        t[t[k].l].r=k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,k,f;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    t[<span class="number">0</span>].r=<span class="number">0</span>,t[<span class="number">0</span>].l=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">add</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;f;</span><br><span class="line">        <span class="built_in">add</span>(x,i,f);</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;x;</span><br><span class="line">        t[x].d=<span class="number">1</span>;         <span class="comment">//将该同学标记为不输出 </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=t[<span class="number">0</span>].r;i;i=t[i].r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i].d==<span class="number">0</span>)    <span class="comment">//输出未标记的 </span></span><br><span class="line">          cout&lt;&lt;i&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2010-提高组-机器翻译"><a href="#NOIP2010-提高组-机器翻译" class="headerlink" title="[NOIP2010 提高组] 机器翻译"></a>[NOIP2010 提高组] 机器翻译</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2010 提高组 T1</p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。</p><p>这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。</p><p>假设内存中有 M 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 M-1，软件会将新单词存入一个未使用的内存单元；若内存中已存入 M 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。</p><p>假设一篇英语文章的长度为 N 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>共 2 行。每行中两个数之间用一个空格隔开。</p><p>第一行为两个正整数 M,N，代表内存容量和文章的长度。</p><p>第二行为 N 个非负整数，按照文章的顺序，每个数（大小不超过 1000）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。</p><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，为软件需要查词典的次数。</p><h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 7</span><br><span class="line">1 2 1 5 4 4 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><h3 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h3><p>整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：</p><ol><li><code>1</code>：查找单词 1 并调入内存。</li><li><code>1 2</code>：查找单词 2 并调入内存。</li><li><code>1 2</code>：在内存中找到单词 1。</li><li><code>1 2 5</code>：查找单词 5 并调入内存。</li><li><code>2 5 4</code>：查找单词 4 并调入内存替代单词 1。</li><li><code>2 5 4</code>：在内存中找到单词 4。</li><li><code>5 4 1</code>：查找单词 1 并调入内存替代单词 2。</li></ol><p>共计查了 5 次词典。</p><h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><ul><li>对于 10% 的数据有 M&#x3D;1，N \leq 5；</li><li>对于 100% 的数据有 1 \leq M \leq 100，1 \leq N \leq 1000。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, ans;</span><br><span class="line"><span class="type">int</span> mark[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> t;</span><br><span class="line">queue &lt;<span class="type">int</span>&gt;q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line"><span class="keyword">if</span> (mark[t]==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (q.<span class="built_in">size</span>()&lt;m)</span><br><span class="line">&#123;</span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line">mark[t] = <span class="number">1</span>;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">mark[q.<span class="built_in">front</span>()] = <span class="number">0</span>;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line">mark[t] = <span class="number">1</span>;</span><br><span class="line">ans ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//哈希存储，队列弹出</span></span><br></pre></td></tr></table></figure><h1 id="NOIP2016-普及组-海港"><a href="#NOIP2016-普及组-海港" class="headerlink" title="[NOIP2016 普及组] 海港"></a>[NOIP2016 普及组] 海港</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2016 普及组 T3</p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 K 是一个海港的海关工作人员，每天都有许多船只到达海港，船上通常有很多来自不同国家的乘客。</p><p>小 K 对这些到达海港的船只非常感兴趣，他按照时间记录下了到达海港的每一艘船只情况；对于第 i 艘到达的船，他记录了这艘船到达的时间 t_i (单位：秒)，船上的乘客数 k_i，以及每名乘客的国籍 x_{i,1}, x_{i,2},\dots,x_{i,k}。</p><p>小K统计了 n 艘船的信息，希望你帮忙计算出以每一艘船到达时间为止的 24 小时（24 小时 &#x3D;86400 秒）内所有乘船到达的乘客来自多少个不同的国家。</p><p>形式化地讲，你需要计算 n 条信息。对于输出的第 i 条信息，你需要统计满足 t_i-86400&lt;t_p \le t_i 的船只 p，在所有的 x_{p,j} 中，总共有多少个不同的数。</p><h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 n，表示小 K 统计了 n 艘船的信息。</p><p>接下来 n 行，每行描述一艘船的信息：前两个整数 t_i 和 k_i 分别表示这艘船到达海港的时间和船上的乘客数量，接下来 k_i 个整数 x_{i,j} 表示船上乘客的国籍。</p><p>保证输入的 t_i 是递增的，单位是秒；表示从小K第一次上班开始计时，这艘船在第 t_i 秒到达海港。</p><p>保证 1 \le n \le 10^5，\sum{k_i} \le 3\times 10^5  ，1\le x_{i,j} \le 10^5， 1 \le t_{i-1}\le  t_i    \le  10^9。</p><p>其中 \sum{k_i} 表示所有的 k_i 的和。</p><h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 n 行，第 i 行输出一个整数表示第 i 艘船到达后的统计信息。</p><h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 4 4 1 2 2</span><br><span class="line">2 2 2 3</span><br><span class="line">10 1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="样例-2-1"><a href="#样例-2-1" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-1"><a href="#样例输入-2-1" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 4 1 2 2 3</span><br><span class="line">3 2 2 3</span><br><span class="line">86401 2 3 4</span><br><span class="line">86402 1 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1"><a href="#样例输出-2-1" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>【样例解释 1】</p><p>第一艘船在第 1 秒到达海港，最近 24 小时到达的船是第一艘船，共有 4 个乘客，分别是来自国家 4,1,2,2，共来自 3 个不同的国家；</p><p>第二艘船在第 2 秒到达海港，最近 24 小时到达的船是第一艘船和第二艘船，共有 4 + 2 &#x3D; 6 个乘客，分别是来自国家 4,1,2,2,2,3，共来自 4 个不同的国家；</p><p>第三艘船在第 10 秒到达海港，最近 24 小时到达的船是第一艘船、第二艘船和第三艘船，共有 4+2+1&#x3D;7 个乘客，分别是来自国家 4,1,2,2,2,3,3，共来自 4 个不同的国家。</p><p>【样例解释 2】</p><p>第一艘船在第 1 秒到达海港，最近 24 小时到达的船是第一艘船，共有 4 个乘客，分别是来自国家 1,2,2,3，共来自 3 个不同的国家。</p><p>第二艘船在第 3 秒到达海港，最近 24 小时到达的船是第一艘船和第二艘船，共有 4+2&#x3D;6 个乘客，分别是来自国家 1,2,2,3,2,3，共来自 3 个不同的国家。</p><p>第三艘船在第 86401 秒到达海港，最近 24 小时到达的船是第二艘船和第三艘船，共有 2+2&#x3D;4 个乘客，分别是来自国家 2,3,3,4，共来自 3 个不同的国家。</p><p>第四艘船在第 86402 秒到达海港，最近 24 小时到达的船是第二艘船、第三艘船和第四艘船，共有 2+2+1&#x3D;5 个乘客，分别是来自国家 2,3,3,4,5，共来自 4个 不同的国家。</p><p>【数据范围】</p><ul><li><p>对于 10% 的测试点，n&#x3D;1,\sum k_i \leq 10,1 \leq x_{i,j} \leq 10, 1 \leq t_i \leq 10。</p></li><li><p>对于 20% 的测试点，1 \leq n \leq 10, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 32767。</p></li><li><p>对于 40% 的测试点，1 \leq n \leq 100, \sum k_i \leq 100,1 \leq x_{i,j} \leq 100,1 \leq t_i \leq 86400。</p></li><li><p>对于 70% 的测试点，1 \leq n \leq 1000, \sum k_i \leq 3000,1 \leq x_{i,j} \leq 1000,1 \leq t_i \leq 10^9。</p></li><li><p>对于 100% 的测试点，1 \leq n \leq 10^5,\sum k_i \leq 3\times 10^5, 1 \leq x_{i,j} \leq 10^5,1\leq t_i \leq 10^9。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;  </span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">people</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t, x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//放入时间和国家</span></span><br><span class="line"><span class="type">int</span> ct[<span class="number">1000000</span>];</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line"><span class="type">int</span> n, t, k, tep;</span><br><span class="line">queue&lt;people&gt;q;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">people p;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; t &gt;&gt; k;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; k; j++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; tep;</span><br><span class="line"><span class="keyword">if</span> (ct[tep]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">ct[tep]++;</span><br><span class="line">q.<span class="built_in">push</span>(&#123; t,tep &#125;);</span><br><span class="line">&#125;</span><br><span class="line">p = q.<span class="built_in">front</span>();</span><br><span class="line"><span class="keyword">while</span> (t-p.t&gt;=<span class="number">86400</span>)</span><br><span class="line">            <span class="comment">//表示过了一天，人要走了</span></span><br><span class="line">&#123;</span><br><span class="line">ct[p.x]--;</span><br><span class="line"><span class="keyword">if</span> (ct[p.x]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans--;</span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">p = q.<span class="built_in">front</span>();</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="括号序列"><a href="#括号序列" class="headerlink" title="括号序列"></a>括号序列</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>定义如下规则：</p><ol><li>空串是「平衡括号序列」</li><li>若字符串 S 是「平衡括号序列」，那么 \texttt{[}S\texttt] 和 \texttt{(}S\texttt) 也都是「平衡括号序列」</li><li>若字符串 A 和 B 都是「平衡括号序列」，那么 AB（两字符串拼接起来）也是「平衡括号序列」。</li></ol><p>例如，下面的字符串都是平衡括号序列：</p><ul><li><code>()</code>，<code>[]</code>，<code>(())</code>，<code>([])</code>，<code>()[]</code>，<code>()[()]</code></li></ul><p>而以下几个则不是：</p><ul><li><code>(</code>，<code>[</code>，<code>]</code>，<code>)(</code>，<code>())</code>，<code>([()</code></li></ul><p>现在，给定一个仅由 <code>(</code>，<code>)</code>，<code>[</code>，<code>]</code>构成的字符串 s，请你按照如下的方式给字符串中每个字符配对：</p><ol><li>从左到右扫描整个字符串。</li><li>对于当前的字符，如果它是一个右括号，考察它与它左侧离它<strong>最近</strong>的<strong>未匹配</strong>的的左括号。如果该括号与之对应（即小括号匹配小括号，中括号匹配中括号），则将二者配对。如果左侧未匹配的左括号不存在或与之不对应，则其配对失败。</li></ol><p>配对结束后，对于 s 中全部未配对的括号，请你在其旁边添加一个字符，使得该括号和新加的括号匹配。</p><h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行一个字符串，表示 s。</p><h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个字符串表示你的答案。</p><h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([()</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()[]()</span><br></pre></td></tr></table></figure><h2 id="样例-2-2"><a href="#样例-2-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-2"><a href="#样例输入-2-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">([)</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2"><a href="#样例输出-2-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">()[]()</span><br></pre></td></tr></table></figure><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于全部的测试点，保证 s 的长度不超过 100，且只含  <code>(</code>，<code>)</code>，<code>[</code>，<code>]</code> 四种字符。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line"><span class="type">int</span> pos;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">bool</span> mark[<span class="number">105</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string s;</span><br><span class="line">stack&lt;point&gt;p_s;</span><br><span class="line">cin &gt;&gt;s;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">p_s.<span class="built_in">push</span>(&#123; s[i], i &#125;);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p_s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">point p = p_s.<span class="built_in">top</span>();</span><br><span class="line"><span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; p.c == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; p.c == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">mark[i] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//标记自己</span></span><br><span class="line">mark[p.pos] = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//标记离自己最近的那个点</span></span><br><span class="line">p_s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (mark[i]==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; s[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[i]==<span class="string">&#x27;(&#x27;</span>||s[i]==<span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;()&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基15-习9】验证栈序列"><a href="#【深基15-习9】验证栈序列" class="headerlink" title="【深基15.习9】验证栈序列"></a>【深基15.习9】验证栈序列</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出两个序列 pushed 和 poped 两个序列，其取值从 1 到 n(n\le100000)。已知入栈序列是 pushed，如果出栈序列有可能是 poped，则输出 <code>Yes</code>，否则输出 <code>No</code>。为了防止骗分，每个测试点有多组数据。</p><h2 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 q，询问次数。</p><p>接下来 q 个询问，对于每个询问：</p><p>第一行一个整数 n 表示序列长度；</p><p>第二行 n 个整数表示入栈序列；</p><p>第三行 n 个整数表示出栈序列；</p><h2 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每个询问输出答案。</p><h2 id="样例-1-8"><a href="#样例-1-8" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-8"><a href="#样例输入-1-8" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">1 2 3 4 5</span><br><span class="line">5 4 3 2 1</span><br><span class="line">4</span><br><span class="line">1 2 3 4</span><br><span class="line">2 4 1 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-8"><a href="#样例输出-1-8" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000000</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">1000000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt;s;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> now=<span class="number">0</span>;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; b[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (s.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">push</span>(a[now++ ]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (b[i]!=s.<span class="built_in">top</span>()&amp;&amp;now&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">push</span>(a[now++]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//缩减代码量</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//不等于你就加，等于你就不加</span></span><br><span class="line">        <span class="comment">//因为符合栈的规律，你肯定有一个节点相同的，然后不断这样</span></span><br><span class="line"><span class="keyword">if</span> (b[i]==s.<span class="built_in">top</span>())</span><br><span class="line">&#123;</span><br><span class="line">s.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Yes&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"><span class="keyword">while</span> (q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="HNOI2002-营业额统计"><a href="#HNOI2002-营业额统计" class="headerlink" title="[HNOI2002] 营业额统计"></a>[HNOI2002] 营业额统计</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>Tiger 最近被公司升任为营业部经理，他上任后接受公司交给的第一项任务便是统计并分析公司成立以来的营业情况。</p><p>Tiger 拿出了公司的账本，账本上记录了公司成立以来每天的营业额。分析营业情况是一项相当复杂的工作。由于节假日，大减价或者是其他情况的时候，营业额会出现一定的波动，当然一定的波动是能够接受的，但是在某些时候营业额突变得很高或是很低，这就证明公司此时的经营状况出现了问题。经济管理学上定义了一种最小波动值来衡量这种情况：当最小波动值越大时，就说明营业情况越不稳定。</p><p>而分析整个公司的从成立到现在营业情况是否稳定，只需要把每一天的最小波动值加起来就可以了。你的任务就是编写一个程序帮助 Tiger 来计算这一个值。</p><p>我们定义，一天的最小波动值 &#x3D; \min{|\text{该天以前某一天的营业额}-\text{该天营业额}|}。</p><p>特别地，第一天的最小波动值为第一天的营业额。</p><h2 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为正整数 n（n \leq 32767） ，表示该公司从成立一直到现在的天数，接下来的 n 行每行有一个整数 a_i（|a_i| \leq 10^6) ，表示第 i 天公司的营业额，可能存在负数。</p><h2 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个正整数，即每一天最小波动值的和，保证结果小于 2^{31}。</p><h2 id="样例-1-9"><a href="#样例-1-9" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-9"><a href="#样例输入-1-9" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">5</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-9"><a href="#样例输出-1-9" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>结果说明：5+|1-5|+|2-1|+|5-5|+|4-5|+|6-5|&#x3D;5+4+1+0+1+1&#x3D;12</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>, x, n, l, r;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="type">int</span>&gt;q;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator lit, rit;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; ans;</span><br><span class="line">q.<span class="built_in">insert</span>(ans);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">rit = q.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">lit = --q.<span class="built_in">lower_bound</span>(x);</span><br><span class="line">l = *lit;</span><br><span class="line">r = *rit;</span><br><span class="line"><span class="keyword">if</span> (rit==q.<span class="built_in">begin</span>())</span><br><span class="line">&#123;</span><br><span class="line">ans+=<span class="built_in">abs</span>(r - x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (rit==q.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">ans += <span class="built_in">abs</span>(l - x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">ans+=<span class="built_in">min</span>(<span class="built_in">abs</span>(l - x), <span class="built_in">abs</span>(r - x));</span><br><span class="line">&#125;</span><br><span class="line">q.<span class="built_in">insert</span>(x);</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第七章</title>
      <link href="/2024/02/07/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%B8%83%E7%AB%A0/"/>
      <url>/2024/02/07/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%B8%83%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第七章．昔日"><a href="#第七章．昔日" class="headerlink" title="第七章．昔日"></a>第七章．昔日</h1><p>苏瑾在卧室里翻找着，从书桌上一本本书拿出,终于找到一本方册同学录,中间夹着一张崭新毕业照.</p><p>那是中考前几个周的夏日拍的,在某个傍晚的最后一节课时拿到的,那时苏瑾只是草草看了几眼,还未细细端详就被拉去打篮球了,之后就在此封存起来了。</p><p>“这是一个流行离别的世界,我们都不擅长告别”,这句话刻在同学录首页，竟在此刻意外真实.</p><p>仔细想想，似乎从未和身边的人好好道别，哪怕知道可能与他们再也不会相见，就如刚刚的夏沫一样，走着走着就散了，而会不会天各一方，谁也不知。</p><p>苏瑾突然想看看那张毕业照,那个同学录,曾经的同学,兄弟，和刚刚的少女留下了哪些痕迹。</p><p>脑海里，</p><p>“初三16班,全体学生都有,站为四排,两排男,两排女”体育老师拉着东北嗓子大声喊着。</p><p>苏瑾站在第三排的左上角,想露出一个微笑但属于是还没露出来,似笑非笑,不过却恰恰拍出了他的阳光.</p><p>叶扬仍然是一副书生模样,标志性的眼睛平视前方,脸上没有笑容,熟悉他的人知道这只是他不太擅长笑,所以果断不笑了.</p><p>许穆清头发刚好被风吹起,这个飘柔,那个飞扬,仔细一看,搞怪成分居多。</p><p>顾千羽,则是非常爱笑,这种时候,也是给这张毕业照留下了最真实的自己,露出一个恰如其分的微笑.</p><p>洛云初,一个酷爱衬衫的人,一身校服十分合身,平视镜头,有些憨厚可爱.</p><p>再看叶凡,站在班级C位,作为体育课代表,浅浅微笑,闪着青春光彩.</p><p>最后,苏瑾,看到了夏沫,她站在苏瑾的左下侧,微微笑着,露出两个小酒窝,像一朵下雨过后悄然绽放的睡莲。</p><p>苏瑾轻轻放下这张毕业照,翻开了那本同学录,一个个名字鲜活跳动,一句句寄语真情流露:</p><p>“愿前程似锦,过尽千帆仍有梦,眉眼清扬是少年”,</p><p>–叶扬</p><p>学霸叶扬起笔,非同凡响.</p><p>“毕业的风怎么会吹散一对父子呢,你说呢，憨笑,憨笑”</p><p>–许穆清</p><p>许穆清这家伙,不当人子。</p><p>“希望在高中时候,身旁的风,耳旁的声音仍是你们，下一个盛夏的故事仍属于我们“</p><p>–顾千羽</p><p>临近毕业，顾千羽正经了一回,不容易。</p><p>“盛夏还未结束,有你的篮球永不散场”</p><p>–洛云初</p><p>洛云初啊，洛云初，此言不虚，昨天还一起打球.青春哪有这么容易散场,要散也不是在当下.</p><p>“我一定要减肥,你也别那么瘦了，考虑考虑增重，期待下次重逢”</p><p>-陈凡</p><p>陈凡还是这样真性情和直率,高中肯定还会再见的，那一天不会很远。</p><p>”祝愿前程似锦，苏瑾”</p><p>–夏沫</p><p>没想到会在这里再次重逢,这次可要重新认识一下你。</p><p>还有很多很多,有以诗句为愿,</p><p>“莫愁前路无知己,天下谁人不识君”</p><p>“我觉君非池中物，咫尺蛟龙云雨”</p><p>也有”前途似海,来日方长”的劝慰.</p><p>……</p><p>书页不断翻动,一页接着一页，三年很漫长,漫长到三天三夜也说不完,但三年又很短,短到短短十分钟便翻完了.</p><p>故事的开头总是盛夏,猝不及防,我们相遇.</p><p>故事的结尾总是盛夏,天各一方,我们离别.</p><p>同学录结尾，苏瑾亲笔：</p><p>书上虽说,天下无不散的宴席,但不要忘了,书上还说了,人生无处不相逢.</p><p>苏瑾将夹着毕业照的同学录抱在胸前,眼眶已在不知觉间湿润.</p><p>阳光驱散阴霾,空气自由清新,风也窃窃私语,美好的稻香翻滚着,少年的心尽是温存.</p><p>“每个名字,每一句话都意义非凡,前行路上,感谢诸君”.</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷刷题6</title>
      <link href="/2024/02/07/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%986/"/>
      <url>/2024/02/07/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%986/</url>
      
        <content type="html"><![CDATA[<h1 id="洛谷刷题6"><a href="#洛谷刷题6" class="headerlink" title="洛谷刷题6"></a>洛谷刷题6</h1><h1 id="【深基7-例1】距离函数"><a href="#【深基7-例1】距离函数" class="headerlink" title="【深基7.例1】距离函数"></a>【深基7.例1】距离函数</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出平面坐标上不在一条直线上三个点坐标 (x_1,y_1),(x_2,y_2),(x_3,y_3)，坐标值是实数，且绝对值不超过 100.00，求围成的三角形周长。保留两位小数。</p><p>对于平面上的两个点 (x_1,y_1),(x_2,y_2)，则这两个点之间的距离 dis&#x3D;\sqrt{(x_2-x_1)^2+(y_2-y_1)^2}</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入三行，第 i 行表示坐标 (x_i,y_i)，以一个空格隔开。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个两位小数，表示由这三个坐标围成的三角形的周长。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 0</span><br><span class="line">0 3</span><br><span class="line">4 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12.00</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>数据保证，坐标均为实数且绝对值不超过 100，小数点后最多仅有 3 位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">double</span> x1, y1, x2, y2, x3, y3;</span><br><span class="line">cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; x2 &gt;&gt; y2 &gt;&gt; x3 &gt;&gt; y3;</span><br><span class="line"><span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">ans += <span class="built_in">sqrt</span>((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));</span><br><span class="line">ans += <span class="built_in">sqrt</span>((x3 - x1) * (x3 - x1) + (y3 - y1) * (y3 - y1));</span><br><span class="line">ans += <span class="built_in">sqrt</span>((x2 - x3) * (x2 - x3) + (y2 - y3) * (y2 - y3));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基7-例2】质数筛"><a href="#【深基7-例2】质数筛" class="headerlink" title="【深基7.例2】质数筛"></a>【深基7.例2】质数筛</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入 n 个不大于 10^5 的正整数。要求全部储存在数组中，去除掉不是质数的数字，依次输出剩余的质数。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 n，表示整数个数。</p><p>第二行输入 n 个正整数 a_i，以空格隔开。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，依次输出 a_i 中剩余的质数，以空格隔开。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 5 6 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 5 7</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1\le n\le100，1 \leq a_i \leq 10^5。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">is</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x&lt;=<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i*i &lt;=x ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (x%i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">is</span>(x))</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基7-例3】闰年展示"><a href="#【深基7-例3】闰年展示" class="headerlink" title="【深基7.例3】闰年展示"></a>【深基7.例3】闰年展示</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入 x,y，输出 [x,y] 区间中闰年个数，并在下一行输出所有闰年年份数字，使用空格隔开。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入两个正整数 x,y，以空格隔开。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行输出一个正整数，表示 [x,y] 区间中闰年个数。</p><p>第二行输出若干个正整数，按照年份单调递增的顺序输出所有闰年年份数字。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1989 2001</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1992 1996 2000</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1582\le x &lt; y \le 3000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ans[<span class="number">1500</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> begin,end;</span><br><span class="line">cin&gt;&gt;begin&gt;&gt;end;</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=begin;i&lt;=end;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>((i%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;i%<span class="number">100</span>!=<span class="number">0</span>)||i%<span class="number">400</span>==<span class="number">0</span>)&#123;</span><br><span class="line">ans[cnt++]=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;cnt&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;cnt;i++)&#123;</span><br><span class="line">cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基7-例4】歌唱比赛"><a href="#【深基7-例4】歌唱比赛" class="headerlink" title="【深基7.例4】歌唱比赛"></a>【深基7.例4】歌唱比赛</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>n(n\le 100) 名同学参加歌唱比赛，并接受 m(m\le 20) 名评委的评分，评分范围是 0 到 10 分。这名同学的得分就是这些评委给分中去掉一个最高分，去掉一个最低分，剩下 m-2 个评分的平均数。请问得分最高的同学分数是多少？评分保留 2 位小数。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行两个整数 n,m。<br>接下来 n 行，每行各 m 个整数，表示得分。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出分数最高的同学的分数，保留两位小数。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">7 6</span><br><span class="line">4 7 2 6 10 7</span><br><span class="line">0 5 0 10 3 10</span><br><span class="line">2 6 8 4 3 6</span><br><span class="line">6 3 6 7 5 8</span><br><span class="line">5 9 3 3 8 1</span><br><span class="line">5 9 9 3 2 0</span><br><span class="line">5 8 0 4 1 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.00</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="type">int</span> a[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span>  n, m;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="type">int</span> cmax;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[j];</span><br><span class="line">sum += a[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(a, a + m);</span><br><span class="line">sum = sum - a[<span class="number">0</span>] - a[m - <span class="number">1</span>];</span><br><span class="line">cmax = <span class="built_in">max</span>(sum, cmax);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> ans = cmax / (m - <span class="number">2.0</span>)*<span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;+</span><br></pre></td></tr></table></figure><h1 id="【深基7-例7】计算阶乘"><a href="#【深基7-例7】计算阶乘" class="headerlink" title="【深基7.例7】计算阶乘"></a>【深基7.例7】计算阶乘</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>求 n!，也就是 1\times2\times3\dots\times n。</p><p>挑战：尝试不使用循环语句（for、while）完成这个任务。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 n。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个正整数，表示 n!。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \leq n\le12。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">jiechen</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=x ; i++)</span><br><span class="line">&#123;</span><br><span class="line">res *= i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cout &lt;&lt; <span class="built_in">jiechen</span>(n);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="赦免战俘"><a href="#赦免战俘" class="headerlink" title="赦免战俘"></a>赦免战俘</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>借助反作弊系统，一些在月赛有抄袭作弊行为的选手被抓出来了！</p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有 2^n\times 2^n (n\le10) 名作弊者站成一个正方形方阵等候 kkksc03 的发落。kkksc03 决定赦免一些作弊者。他将正方形矩阵均分为 4 个更小的正方形矩阵，每个更小的矩阵的边长是原矩阵的一半。其中左上角那一个矩阵的所有作弊者都将得到赦免，剩下 3 个小矩阵中，每一个矩阵继续分为 4 个更小的矩阵，然后通过同样的方式赦免作弊者……直到矩阵无法再分下去为止。所有没有被赦免的作弊者都将被处以棕名处罚。</p><p>给出 n，请输出每名作弊者的命运，其中 0 代表被赦免，1 代表不被赦免。</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>一个整数 n。</p><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>2^n \times 2^n 的 01 矩阵，代表每个人是否被赦免。数字之间有一个空格。</p><h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 0 0 1</span><br><span class="line">0 0 0 0 0 0 1 1</span><br><span class="line">0 0 0 0 0 1 0 1</span><br><span class="line">0 0 0 0 1 1 1 1</span><br><span class="line">0 0 0 1 0 0 0 1</span><br><span class="line">0 0 1 1 0 0 1 1</span><br><span class="line">0 1 0 1 0 1 0 1</span><br><span class="line">1 1 1 1 1 1 1 1</span><br></pre></td></tr></table></figure><h1 id="【深基7-例9】最厉害的学生"><a href="#【深基7-例9】最厉害的学生" class="headerlink" title="【深基7.例9】最厉害的学生"></a>【深基7.例9】最厉害的学生</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有 N 名同学参加了期末考试，并且获得了每名同学的信息：姓名（不超过 8 个字符的仅有英文小写字母的字符串）、语文、数学、英语成绩（均为不超过 150 的自然数）。总分最高的学生就是最厉害的，请输出最厉害的学生各项信息（姓名、各科成绩）。如果有多个总分相同的学生，输出靠前的那位。</p><h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 N，表示学生个数。</p><p>第二行开始，往下 N 行，对于每一行首先先输入一个字符串表示学生姓名，再输入三个自然数表示语文、数学、英语的成绩。均用空格相隔。</p><h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出最厉害的学生。</p><h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">senpai 114 51 4</span><br><span class="line">lxl 114 10 23</span><br><span class="line">fafa 51 42 60</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">senpai 114 51 4</span><br></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \leq N \leq 1000，姓名为长度不超过 8 的字符串，语文、数学、英语成绩均为不超过 150 的自然数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">student</span> &#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> chinese, english, math;</span><br><span class="line">&#125;num[<span class="number">1010</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">1010</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; num[i].name &gt;&gt; num[i].chinese &gt;&gt; num[i].english &gt;&gt; num[i].math;</span><br><span class="line">sum[i] += num[i].chinese + num[i].english + num[i].math;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (temp &lt; sum[i]) </span><br><span class="line">        &#123;</span><br><span class="line">temp = sum[i];</span><br><span class="line">a = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; num[a].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num[a].chinese &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num[a].english &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; num[a].math &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="【深基7-例10】旗鼓相当的对手-加强版"><a href="#【深基7-例10】旗鼓相当的对手-加强版" class="headerlink" title="【深基7.例10】旗鼓相当的对手 - 加强版"></a>【深基7.例10】旗鼓相当的对手 - 加强版</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有 N(N\le 1000) 名同学参加了期末考试，并且获得了每名同学的信息：姓名（不超过 8 个字符的字符串，没有空格）、语文、数学、英语成绩（均为不超过 150 的自然数）。如果某对学生 \text{&lt;}i,j\text{&gt;} 的每一科成绩的分差都不大于 5，且总分分差不大于 10，那么这对学生就是“旗鼓相当的对手”。现在我们想知道这些同学中，哪些是“旗鼓相当的对手”？请输出他们的姓名。</p><p>所有人的姓名是按照字典序给出的，输出时也应该按照字典序输出所有对手组合。也就是说，这对组合的第一个名字的字典序应该小于第二个；如果两个组合中第一个名字不一样，则第一个名字字典序小的先输出；如果两个组合的第一个名字一样但第二个名字不同，则第二个名字字典序小的先输出。</p><h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 N，表示学生个数。</p><p>第二行开始，往下 N 行，对于每一行首先先输入一个字符串表示学生姓名，再输入三个自然数表示语文、数学、英语的成绩。均用空格相隔。</p><h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出若干行，每行两个以空格隔开的字符串，表示一组旗鼓相当的对手。注意题目描述中的输出格式。</p><h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">fafa 90 90 90</span><br><span class="line">lxl 95 85 90</span><br><span class="line">senpai 100 80 91</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fafa lxl</span><br><span class="line">lxl senpai</span><br></pre></td></tr></table></figure><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \leq N \leq 1000，姓名为长度不超过 8 的字符串，语文、数学、英语成绩均为不超过 150 的自然数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">xuehsneg</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> yuwen;</span><br><span class="line"><span class="type">int</span> shuxue;</span><br><span class="line"><span class="type">int</span> yingyu;</span><br><span class="line"><span class="type">int</span> zongfen;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">&#125;a[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i].name &gt;&gt; a[i].yuwen &gt;&gt; a[i].shuxue &gt;&gt; a[i].yingyu;</span><br><span class="line">a[i].zongfen = a[i].yuwen + a[i].shuxue + a[i].yingyu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(a[i].yuwen-a[j].yuwen)&lt;=<span class="number">5</span>&amp;&amp;<span class="built_in">abs</span>(a[i].shuxue-a[j].shuxue)&lt;=<span class="number">5</span>&amp;&amp;<span class="built_in">abs</span>(a[i].yingyu-a[j].yingyu)&lt;=<span class="number">5</span>&amp;&amp;<span class="built_in">abs</span>(a[i].zongfen-a[j].zongfen)&lt;=<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[j].name &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基7-例11】评等级"><a href="#【深基7-例11】评等级" class="headerlink" title="【深基7.例11】评等级"></a>【深基7.例11】评等级</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有 N 名同学，每名同学需要设计一个结构体记录以下信息：学号、学业成绩和素质拓展成绩、综合分数（实数）。每行读入同学的学号、学业成绩和素质拓展成绩，并且计算综合分数（分别按照 70% 和 30% 权重累加），存入结构体中。还需要在结构体中定义一个成员函数，返回该结构体对象的学业成绩和素质拓展成绩的总分。</p><p>然后需要设计一个函数，其参数是一个学生结构体对象，判断该学生是否“优秀”。优秀的定义是学业和素质拓展成绩总分<strong>大于</strong> 140 分，且综合分数<strong>不小于</strong> 80 分。</p><blockquote><p>当然通过本题很容易啦，本题只是为了帮助你训练结构体的使用方法。</p></blockquote><p>本题存在精度误差问题，请将 <code>a * 0.7 + b * 0.3</code> 与 80 比较 转化为 <code>a * 7 + b * 3</code> 与 800 比较。</p><h2 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 N。</p><p>接下来 N 行，每行 3 个整数，依次代表学号、学业成绩和素质拓展成绩。</p><h2 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h2><p>N 行，如果第 i 名学生是优秀的，输出 <code>Excellent</code>，否则输出 <code>Not excellent</code>。</p><h2 id="样例-1-8"><a href="#样例-1-8" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-8"><a href="#样例输入-1-8" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1223 95 59</span><br><span class="line">1224 50 7</span><br><span class="line">1473 32 45</span><br><span class="line">1556 86 99</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-8"><a href="#样例输出-1-8" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Excellent</span><br><span class="line">Not excellent</span><br><span class="line">Not excellent</span><br><span class="line">Excellent</span><br></pre></td></tr></table></figure><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \le N\le 1000，学号为不超过 100000 的正整数，学业成绩和素质拓展成绩为 0 \sim 100 之间的正整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">xuehsneg</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> yuwen;</span><br><span class="line"><span class="type">int</span> shuxue;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> zongfen;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;a[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i].num &gt;&gt; a[i].yuwen &gt;&gt; a[i].shuxue;</span><br><span class="line">a[i].zongfen = a[i].yuwen * <span class="number">7</span> + a[i].shuxue * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i].zongfen &gt;= <span class="number">800</span>&amp;&amp;a[i].yuwen+a[i].shuxue&gt;<span class="number">140</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Excellent&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Not excellent&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2012-普及组-质因数分解"><a href="#NOIP2012-普及组-质因数分解" class="headerlink" title="[NOIP2012 普及组] 质因数分解"></a>[NOIP2012 普及组] 质因数分解</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知正整数 n 是两个不同的质数的乘积，试求出两者中较大的那个质数。</p><h2 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个正整数 n。</p><h2 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个正整数 p，即较大的那个质数。</p><h2 id="样例-1-9"><a href="#样例-1-9" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-9"><a href="#样例输入-1-9" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-9"><a href="#样例输出-1-9" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>1 \le n\le 2\times 10^9</p><p>NOIP 2012 普及组 第一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;<span class="built_in">sqrt</span>(n); i++) <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123; </span><br><span class="line">        cout &lt;&lt; n/i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哥德巴赫猜想"><a href="#哥德巴赫猜想" class="headerlink" title="哥德巴赫猜想"></a>哥德巴赫猜想</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个偶数 N，验证 4\sim N 所有偶数是否符合哥德巴赫猜想：任一大于 2 的偶数都可写成两个质数之和。如果一个数不止一种分法，则输出第一个加数相比其他分法最小的方案。例如 10，10&#x3D;3+7&#x3D;5+5，则 10&#x3D;5+5 是错误答案。</p><h2 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正偶数 N</p><h2 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 \dfrac{N-2}{2} 行。对于第 i 行：</p><p>首先先输出正偶数 2i+2，然后输出等号，再输出加和为 2i+2 且第一个加数最小的两个质数，以加号隔开。</p><h2 id="样例-1-10"><a href="#样例-1-10" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-10"><a href="#样例输入-1-10" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-10"><a href="#样例输出-1-10" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">4=2+2</span><br><span class="line">6=3+3</span><br><span class="line">8=3+5</span><br><span class="line">10=3+7</span><br></pre></td></tr></table></figure><h2 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h2><p>数据保证， 4 \leq N\leq10000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ss</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i*i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">num</span><span class="params">(<span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d=&quot;</span>, n);</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; n; i++)<span class="comment">//穷举加数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">ss</span>(i) == <span class="number">0</span> &amp;&amp; <span class="built_in">ss</span>(n - i) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d+%d\n&quot;</span>, i, n - i);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">4</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">num</span>(i);<span class="comment">//调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="USACO1-5-回文质数-Prime-Palindromes"><a href="#USACO1-5-回文质数-Prime-Palindromes" class="headerlink" title="[USACO1.5] 回文质数 Prime Palindromes"></a>[USACO1.5] 回文质数 Prime Palindromes</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>因为 151 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 151 是回文质数。</p><p>写一个程序来找出范围 [a,b] (5 \le a &lt; b \le 100,000,000)（一亿）间的所有回文质数。</p><h2 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入两个正整数 a 和 b。</p><h2 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个回文质数的列表，一行一个。</p><h2 id="样例-1-11"><a href="#样例-1-11" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-11"><a href="#样例输入-1-11" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 500</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-11"><a href="#样例输出-1-11" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">7</span><br><span class="line">11</span><br><span class="line">101</span><br><span class="line">131</span><br><span class="line">151</span><br><span class="line">181</span><br><span class="line">191</span><br><span class="line">313</span><br><span class="line">353</span><br><span class="line">373</span><br><span class="line">383</span><br></pre></td></tr></table></figure><h2 id="提示-9"><a href="#提示-9" class="headerlink" title="提示"></a>提示</h2><p>Hint 1: Generate the palindromes and see if they are prime.</p><p>提示 1: 找出所有的回文数再判断它们是不是质数（素数）.</p><p>Hint 2: Generate palindromes by combining digits properly. You might need more than one of the loops like below.</p><p>提示 2: 要产生正确的回文数，你可能需要几个像下面这样的循环。</p><p>题目翻译来自NOCOW。</p><p>USACO Training Section 1.5</p><p>产生长度为 5 的回文数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (d1 = <span class="number">1</span>; d1 &lt;= <span class="number">9</span>; d1+=<span class="number">2</span>) &#123;    <span class="comment">// 只有奇数才会是素数</span></span><br><span class="line">     <span class="keyword">for</span> (d2 = <span class="number">0</span>; d2 &lt;= <span class="number">9</span>; d2++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (d3 = <span class="number">0</span>; d3 &lt;= <span class="number">9</span>; d3++) &#123;</span><br><span class="line">           palindrome = <span class="number">10000</span>*d1 + <span class="number">1000</span>*d2 +<span class="number">100</span>*d3 + <span class="number">10</span>*d2 + d1;<span class="comment">//(处理回文数...)</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> d1, d2, i, y, q;</span><br><span class="line"><span class="type">int</span> a1, a2;</span><br><span class="line">cin &gt;&gt; a1 &gt;&gt; a2;</span><br><span class="line"><span class="keyword">for</span> (i = a1; i &lt;= a2; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">d2 = <span class="number">0</span>;</span><br><span class="line">d1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">2</span>; x * x &lt;= i; x++)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (i % x == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">d1 = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">y = i;</span><br><span class="line"><span class="type">int</span> a3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (y != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">q = y % <span class="number">10</span>;</span><br><span class="line">a3 = a3 * <span class="number">10</span> + q;</span><br><span class="line">y = y / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a3 != i) &#123; d2 = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d1 + d2 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="集合求和"><a href="#集合求和" class="headerlink" title="集合求和"></a>集合求和</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个集合 s（集合元素数量 \le 30），求出此集合所有子集元素之和。</p><h2 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h2><p>集合中的元素（元素 \le 1000）</p><h2 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h2><p>s 所有子集元素之和。</p><h2 id="样例-1-12"><a href="#样例-1-12" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-12"><a href="#样例输入-1-12" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-12"><a href="#样例输出-1-12" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="提示-10"><a href="#提示-10" class="headerlink" title="提示"></a>提示</h2><p><strong>【样例解释】</strong></p><p>子集为：\varnothing, { 2 }, { 3 }, { 2, 3 }，和为 2 + 3 + 2 + 3 &#x3D; 10。</p><hr><p><strong>【数据范围】</strong></p><p>对于 100 % 的数据，1 \le \lvert s \rvert \le 30，1 \le s_i \le 1000，s 所有子集元素之和 \le {10}^{18}。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>,i,a;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a)!=EOF)</span><br><span class="line">    ans+=a,n++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;n;i++)ans*=<span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基7-习8】猴子吃桃"><a href="#【深基7-习8】猴子吃桃" class="headerlink" title="【深基7.习8】猴子吃桃"></a>【深基7.习8】猴子吃桃</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只小猴买了若干个桃子。第一天他刚好吃了这些桃子的一半，又贪嘴多吃了一个；接下来的每一天它都会吃剩余的桃子的一半外加一个。第 n 天早上起来一看，只剩下 1 个桃子了。请问小猴买了几个桃子？</p><h2 id="输入格式-13"><a href="#输入格式-13" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个正整数 n，表示天数。</p><h2 id="输出格式-13"><a href="#输出格式-13" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出小猴买了多少个桃子。</p><h2 id="样例-1-13"><a href="#样例-1-13" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-13"><a href="#样例输入-1-13" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-13"><a href="#样例输出-1-13" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">22</span><br></pre></td></tr></table></figure><h2 id="提示-11"><a href="#提示-11" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1\le n\le20。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,ans=<span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">ans+=<span class="number">1</span>;</span><br><span class="line">ans*=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基7-习9】培训"><a href="#【深基7-习9】培训" class="headerlink" title="【深基7.习9】培训"></a>【深基7.习9】培训</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>某培训机构的学员有如下信息：</p><ul><li>姓名（字符串）</li><li>年龄（周岁，整数）</li><li>去年 NOIP 成绩（整数，且保证是 5 的倍数）</li></ul><p>经过为期一年的培训，所有同学的成绩都有所提高，提升了 20%（当然 NOIP 满分是 600 分，不能超过这个得分）。</p><p>输入学员信息，请设计一个结构体储存这些学生信息，并设计一个函数模拟培训过程，其参数是这样的结构体类型，返回同样的结构体类型，并输出学员信息。</p><h2 id="输入格式-14"><a href="#输入格式-14" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 n，表示学员个数。</p><p>第二行开始往下 n 行。每行首先是一个字符串表示学员姓名，再是一个整数表示学员年龄，再是一个整数为去年 NOIP 成绩。</p><h2 id="输出格式-14"><a href="#输出格式-14" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 n 行，每行首先输出一个字符串表示学生姓名，再往后两个整数，表示经过一年的培训后学员的年龄和他们今年的 NOIP 成绩。以空格隔开。</p><h2 id="样例-1-14"><a href="#样例-1-14" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-14"><a href="#样例输入-1-14" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">kkksc03 24 0</span><br><span class="line">chen_zhe 14 400</span><br><span class="line">nzhtl1477 18 590</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-14"><a href="#样例输出-1-14" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kkksc03 25 0</span><br><span class="line">chen_zhe 15 480</span><br><span class="line">nzhtl1477 19 600</span><br></pre></td></tr></table></figure><h2 id="提示-12"><a href="#提示-12" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \leq n \leq 5。年龄为 0 \sim 100（含 0 与 100）的整数。成绩为 0 \sim 600（含 0 与 600）的 5 的整倍数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line"><span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;a[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i].name &gt;&gt; a[i].age &gt;&gt; a[i].result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i].result*<span class="number">1.2</span>&gt;<span class="number">600</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i].result = <span class="number">600</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">a[i].result *= <span class="number">1.2</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; a[i].name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i].age + <span class="number">1</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i].result;</span><br><span class="line"><span class="keyword">if</span> (i!=n<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷刷题5</title>
      <link href="/2024/02/07/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%985/"/>
      <url>/2024/02/07/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%985/</url>
      
        <content type="html"><![CDATA[<h1 id="洛谷刷题五"><a href="#洛谷刷题五" class="headerlink" title="洛谷刷题五"></a>洛谷刷题五</h1><h1 id="【深基6-例1】自动修正"><a href="#【深基6-例1】自动修正" class="headerlink" title="【深基6.例1】自动修正"></a>【深基6.例1】自动修正</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>大家都知道一些办公软件有自动将字母转换为大写的功能。输入一个长度不超过 100 且不包括空格的字符串。要求将该字符串中的所有小写字母变成大写字母并输出。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行，一个字符串。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个字符串，即将原字符串中的所有小写字母转化为大写字母。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Luogu4!</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LUOGU4!</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[N];</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;a[i]&lt;=<span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i] -= <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小书童——凯撒密码"><a href="#小书童——凯撒密码" class="headerlink" title="小书童——凯撒密码"></a>小书童——凯撒密码</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>某蒟蒻迷上了 “小书童”，有一天登陆时忘记密码了（他没绑定邮箱 or 手机），于是便把问题抛给了神犇你。</p><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>蒟蒻虽然忘记密码，但他还记得密码是由一个字符串组成。密码是由原文字符串（由不超过 50 个小写字母组成）中每个字母向后移动 n 位形成的。<code>z</code> 的下一个字母是 <code>a</code>，如此循环。他现在找到了移动前的原文字符串及 n，请你求出密码。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行：n。第二行：未移动前的一串字母。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，是此蒟蒻的密码。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">qwe</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rxf</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>字符串长度 \le 50，1 \leq n \leq 26。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">string a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">char</span>((a[i] - <span class="string">&#x27;a&#x27;</span> + n) % <span class="number">26</span> + <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2008-提高组-笨小猴"><a href="#NOIP2008-提高组-笨小猴" class="headerlink" title="[NOIP2008 提高组] 笨小猴"></a>[NOIP2008 提高组] 笨小猴</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>笨小猴的词汇量很小，所以每次做英语选择题的时候都很头疼。但是他找到了一种方法，经试验证明，用这种方法去选择选项的时候选对的几率非常大！</p><p>这种方法的具体描述如下：假设 \text{maxn} 是单词中出现次数最多的字母的出现次数，\text{minn} 是单词中出现次数最少的字母的出现次数，如果 \text{maxn}-\text{minn} 是一个质数，那么笨小猴就认为这是个 Lucky Word，这样的单词很可能就是正确的答案。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>一个单词，其中只可能出现小写字母，并且长度小于 100。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>共两行，第一行是一个字符串，假设输入的的单词是 Lucky Word，那么输出 <code>Lucky Word</code>，否则输出 <code>No Answer</code>；</p><p>第二行是一个整数，如果输入单词是 <code>Lucky Word</code>，输出 \text{maxn}-\text{minn} 的值，否则输出 0。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lucky Word</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">olympic</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">No Answer</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>【输入输出样例 1 解释】</p><p>单词 <code>error</code> 中出现最多的字母 \texttt r 出现了 3 次，出现次数最少的字母出现了 1 次，3-1&#x3D;2，2 是质数。</p><p>【输入输出样例 2 解释】</p><p>单词 <code>olympic</code> 中出现最多的字母 \texttt i 出现了 1 次，出现次数最少的字母出现了 1 次，1-1&#x3D;0，0 不是质数。</p><p>（本处原题面错误已经修正）</p><p>noip2008 提高第一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string arr;</span><br><span class="line"><span class="type">int</span> b[<span class="number">150</span>];</span><br><span class="line"><span class="type">int</span> word[<span class="number">26</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= <span class="number">1</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">2</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (x % i == <span class="number">0</span>)<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> min = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> n ;</span><br><span class="line">cin &gt;&gt; arr;</span><br><span class="line">n = arr.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) </span><br><span class="line">    &#123;</span><br><span class="line">b[arr[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) </span><br><span class="line">    &#123;</span><br><span class="line"><span class="keyword">if</span> (max &lt; b[j]) </span><br><span class="line">        &#123;</span><br><span class="line">max = b[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (min &gt; b[j]&amp;&amp;b[j]!=<span class="number">0</span>) &#123;</span><br><span class="line">min = b[j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> delta = max - min;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isprime</span>(delta)) &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Lucky Word&quot;</span>&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout &lt;&lt; delta;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;No Answer&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="口算练习题"><a href="#口算练习题" class="headerlink" title="口算练习题"></a>口算练习题</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>王老师正在教简单算术运算。细心的王老师收集了 i 道学生经常做错的口算题，并且想整理编写成一份练习。 编排这些题目是一件繁琐的事情，为此他想用计算机程序来提高工作效率。王老师希望尽量减少输入的工作量，比如 \texttt{5+8} 的算式最好只要输入 \texttt 5 和 \texttt 8，输出的结果要尽量详细以方便后期排版的使用，比如对于上述输入进行处理后输出 \texttt{5+8&#x3D;13} 以及该算式的总长度 6。王老师把这个光荣的任务交给你，请你帮他编程实现以上功能。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个整数 i。</p><p>接着的 i 行为需要输入的算式，每行可能有三个数据或两个数据。</p><p>若该行为三个数据则第一个数据表示运算类型，\texttt a 表示加法运算，\texttt b 表示减法运算，\texttt c 表示乘法运算，接着的两个数据表示参加运算的运算数。</p><p>若该行为两个数据，则表示本题的运算类型与上一题的运算类型相同，而这两个数据为运算数。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 2\times i 行。对于每个输入的算式，输出完整的运算式及结果，第二行输出该运算式的总长度。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">a 64 46</span><br><span class="line">275 125</span><br><span class="line">c 11 99</span><br><span class="line">b 46 64</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">64+46=110</span><br><span class="line">9</span><br><span class="line">275+125=400</span><br><span class="line">11</span><br><span class="line">11*99=1089</span><br><span class="line">10</span><br><span class="line">46-64=-18</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><h3 id="【数据规模与约定】"><a href="#【数据规模与约定】" class="headerlink" title="【数据规模与约定】"></a>【数据规模与约定】</h3><p>对于 50% 的数据，输入的算式都有三个数据，第一个算式一定有三个数据。</p><p>对于所有数据，0&lt;i\leq 50，运算数为非负整数且小于 10000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> s[<span class="number">1000</span>], b[<span class="number">10</span>];</span><br><span class="line"><span class="type">char</span> a;</span><br><span class="line"><span class="type">int</span> n, c, d;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">cin &gt;&gt; b;</span><br><span class="line"><span class="keyword">if</span> (b[<span class="number">0</span>] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; b[<span class="number">0</span>] &lt;= <span class="string">&#x27;z&#x27;</span>) </span><br><span class="line">        &#123;</span><br><span class="line">a = b[<span class="number">0</span>];</span><br><span class="line">cin &gt;&gt; c &gt;&gt; d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">sscanf</span>(b, <span class="string">&quot;%d&quot;</span>, &amp;c);</span><br><span class="line">cin &gt;&gt; d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%d+%d=%d&quot;</span>, c, d, c + d);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%d-%d=%d&quot;</span>, c, d, c - d);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a == <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line"><span class="built_in">sprintf</span>(s, <span class="string">&quot;%d*%d=%d&quot;</span>, c, d, c * d);</span><br><span class="line">cout &lt;&lt; s &lt;&lt; <span class="string">&#x27;\n&#x27;</span> &lt;&lt;<span class="built_in">strlen</span>(s) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2018-普及组-标题统计"><a href="#NOIP2018-普及组-标题统计" class="headerlink" title="[NOIP2018 普及组] 标题统计"></a>[NOIP2018 普及组] 标题统计</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2018 普及组 T1</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>凯凯刚写了一篇美妙的作文，请问这篇作文的标题中有多少个字符？ 注意：标题中可能包含大、小写英文字母、数字字符、空格和换行符。统计标题字符数时，空格和换行符不计算在内。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入文件只有一行，一个字符串 s。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出文件只有一行，包含一个整数，即作文标题的字符数（不含空格和换行符）。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">234</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-2-1"><a href="#样例-2-1" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-1"><a href="#样例输入-2-1" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ca 45</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1"><a href="#样例输出-2-1" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p><strong>样例 1 说明</strong>   </p><p>标题中共有 3 个字符，这 3 个字符都是数字字符。   </p><p><strong>样例 2 说明</strong></p><p>标题中共有  5 个字符，包括 1 个大写英文字母， 1 个小写英文字母和 2 个数字字符， 还有 1 个空格。由于空格不计入结果中，故标题的有效字符数为 4 个。 </p><p><strong>数据规模与约定</strong></p><p>规定 |s| 表示字符串 s 的长度（即字符串中的字符和空格数）。<br>对于 40% 的数据，1 ≤ |s| ≤ 5，保证输入为数字字符及行末换行符。<br>对于 80% 的数据，1 ≤ |s| ≤ 5，输入只可能包含大、小写英文字母、数字字符及行末换行符。<br>对于 100% 的数据，1 ≤ |s| ≤ 5，输入可能包含大、小写英文字母、数字字符、空格和行末换行符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (cin&gt;&gt;s)</span><br><span class="line">&#123;</span><br><span class="line">sum += s.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="手机"><a href="#手机" class="headerlink" title="手机"></a>手机</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>一般的手机的键盘是这样的：</p><p><img src="/2024/02/07/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%985/Totoro.trip\blog-demo\source\images\yq2orii6.png"></p><p>要按出英文字母就必须要按数字键多下。例如要按出 \tt x 就得按 9 两下，第一下会出 \tt w，而第二下会把 \tt w 变成 \tt x。0 键按一下会出一个空格。</p><p>你的任务是读取若干句只包含英文小写字母和空格的句子，求出要在手机上打出这个句子至少需要按多少下键盘。</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行句子，只包含英文小写字母和空格，且不超过 200 个字符。</p><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个整数，表示按键盘的总次数。</p><h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i have a dream</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23</span><br></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>NOI 导刊 2010 普及（10）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ans;</span><br><span class="line">string a;</span><br><span class="line"><span class="type">int</span> num[<span class="number">26</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;      </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">getline</span>(cin,a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">length</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;a[i]&lt;=<span class="string">&#x27;z&#x27;</span>) ans+=num[a[i]-<span class="string">&#x27;a&#x27;</span>];       </span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="string">&#x27; &#x27;</span>) ans++;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="honoka的键盘"><a href="#honoka的键盘" class="headerlink" title="honoka的键盘"></a>honoka的键盘</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>honoka 有一个只有两个键的键盘。</p><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>一天，她打出了一个只有这两个字符的字符串。当这个字符串里含有 <code>VK</code> 这个字符串的时候，honoka 就特别喜欢这个字符串。所以，她想改变至多一个字符（或者不做任何改变）来最大化这个字符串内 <code>VK</code> 出现的次数。给出原来的字符串，请计算她最多能使这个字符串内出现多少次 <code>VK</code>（只有当 <code>V</code> 和 <code>K</code> 正好相邻时，我们认为出现了 <code>VK</code>。）</p><h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行给出一个数字 n，代表字符串的长度。</p><p>第二行给出一个字符串 s。</p><h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行输出一个整数代表所求答案。</p><h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">VK</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-2"><a href="#样例-2-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-2"><a href="#样例输入-2-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">VV</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2"><a href="#样例输出-2-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">V</span><br></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-4"><a href="#样例-4" class="headerlink" title="样例 #4"></a>样例 #4</h2><h3 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入 #4"></a>样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">20</span><br><span class="line">VKKKKKKKKKVVVVVVVVVK</span><br></pre></td></tr></table></figure><h3 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出 #4"></a>样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="样例-5"><a href="#样例-5" class="headerlink" title="样例 #5"></a>样例 #5</h2><h3 id="样例输入-5"><a href="#样例输入-5" class="headerlink" title="样例输入 #5"></a>样例输入 #5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">KVKV</span><br></pre></td></tr></table></figure><h3 id="样例输出-5"><a href="#样例输出-5" class="headerlink" title="样例输出 #5"></a>样例输出 #5</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>对于 100% 的数据，1\le n\le 100。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string a;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>() - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="string">&#x27;V&#x27;</span> &amp;&amp; a[i + <span class="number">1</span>] == <span class="string">&#x27;K&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            a[i] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            a[i + <span class="number">1</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">length</span>()<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="string">&#x27;X&#x27;</span> &amp;&amp; a[i] == a[i + <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ans += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="单词覆盖还原"><a href="#单词覆盖还原" class="headerlink" title="单词覆盖还原"></a>单词覆盖还原</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个长度为 l 的字符串中被反复贴有 <code>boy</code> 和 <code>girl</code> 两单词，后贴上的可能覆盖已贴上的单词（没有被覆盖的用句点表示），最终每个单词至少有一个字符没有被覆盖。问贴有几个 <code>boy</code> 几个 <code>girl</code>？</p><h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行被反复贴有 <code>boy</code> 和 <code>girl</code> 两单词的字符串。</p><h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>两行，两个整数。第一行为 <code>boy</code> 的个数，第二行为 <code>girl</code> 的个数。</p><h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......boyogirlyy......girl.......</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p>数据保证，3\le l\le255，字符串仅仅包含如下字符：\texttt{.bgilory}。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> boy, girl, len;    </span><br><span class="line">string st;   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; st;   </span><br><span class="line">    len = st.<span class="built_in">size</span>();    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) <span class="comment">//</span></span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="string">&#x27;b&#x27;</span> || st[i + <span class="number">1</span>] == <span class="string">&#x27;o&#x27;</span> || st[i + <span class="number">2</span>] == <span class="string">&#x27;y&#x27;</span>)boy++;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">3</span>; i++) <span class="comment">//枚举开始点，注意len-3，不然会越界，因为下面要i+3</span></span><br><span class="line">        <span class="keyword">if</span> (st[i] == <span class="string">&#x27;g&#x27;</span> || st[i + <span class="number">1</span>] == <span class="string">&#x27;i&#x27;</span> || st[i + <span class="number">2</span>] == <span class="string">&#x27;r&#x27;</span> || st[i + <span class="number">3</span>] == <span class="string">&#x27;l&#x27;</span>)girl++;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; boy &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; girl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数字反转（升级版）"><a href="#数字反转（升级版）" class="headerlink" title="数字反转（升级版）"></a>数字反转（升级版）</h1><h2 id="题目背景-3"><a href="#题目背景-3" class="headerlink" title="题目背景"></a>题目背景</h2><p><strong>以下为原题面，仅供参考:</strong></p><p>给定一个数，请将该数各个位上数字反转得到一个新数。</p><p>这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。整数反转是将所有数位对调；小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分；分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母；百分数的分子一定是整数，百分数只改变数字部分。整数新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零；小数新数的末尾不为 0（除非小数部分除了 0 没有别的数，那么只保留1个 0）；分数不约分，分子和分母都不是小数（约分滴童鞋抱歉了，不能过哦。输入数据保证分母不为 0），本次没有负数。</p><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数，请将该数各个位上数字反转得到一个新数。</p><p>这次与 NOIp2011 普及组第一题不同的是：这个数可以是小数，分数，百分数，整数。</p><ul><li><p>整数反转是将所有数位对调。</p></li><li><p>小数反转是把整数部分的数反转，再将小数部分的数反转，不交换整数部分与小数部分。</p></li><li><p>分数反转是把分母的数反转，再把分子的数反转，不交换分子与分母。</p></li><li><p>百分数的分子一定是整数，百分数只改变数字部分。</p></li></ul><h2 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h2><p>一个实数 s</p><h2 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个实数，即 s 的反转数</p><h2 id="样例-1-8"><a href="#样例-1-8" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-8"><a href="#样例输入-1-8" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5087462</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-8"><a href="#样例输出-1-8" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2647805</span><br></pre></td></tr></table></figure><h2 id="样例-2-3"><a href="#样例-2-3" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-3"><a href="#样例输入-2-3" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">600.084</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3"><a href="#样例输出-2-3" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.48</span><br></pre></td></tr></table></figure><h2 id="样例-3-1"><a href="#样例-3-1" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3-1"><a href="#样例输入-3-1" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">700/27</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-1"><a href="#样例输出-3-1" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7/72</span><br></pre></td></tr></table></figure><h2 id="样例-4-1"><a href="#样例-4-1" class="headerlink" title="样例 #4"></a>样例 #4</h2><h3 id="样例输入-4-1"><a href="#样例输入-4-1" class="headerlink" title="样例输入 #4"></a>样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8670%</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-1"><a href="#样例输出-4-1" class="headerlink" title="样例输出 #4"></a>样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">768%</span><br></pre></td></tr></table></figure><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p><strong>【数据范围】</strong></p><ul><li>对于 25% 的数据，s 是整数，不大于 20 位；</li><li>对于 25% 的数据，s 是小数，整数部分和小数部分均不大于 10 位；</li><li>对于 25% 的数据，s 是分数，分子和分母均不大于 10 位；</li><li>对于 25% 的数据，s 是百分数，分子不大于 19 位。</li></ul><p><strong>【数据保证】</strong></p><ul><li><p>对于整数翻转而言，整数原数和整数新数满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数和原来的数字的最高位数字不应为零。</p></li><li><p>对于小数翻转而言，其小数点前面部分同上，小数点后面部分的形式，保证满足小数的常见形式，也就是末尾没有多余的 0（小数部分除了 0 没有别的数，那么只保留 1 个 0。若反转之后末尾数字出现 0，请省略多余的 0）</p></li><li><p>对于分数翻转而言，分数不约分，分子和分母都不是小数。输入的分母不为 0。与整数翻转相关规定见上。</p></li><li><p>对于百分数翻转而言，见与整数翻转相关内容。</p></li></ul><p>数据不存在负数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    <span class="type">char</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>) cnt++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = s[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x = cnt;</span><br><span class="line">    cnt -= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[cnt] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; cnt &gt; <span class="number">0</span>) cnt--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cnt; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        cout &lt;&lt; s[i];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="string">&#x27;%&#x27;</span>) &#123; cout &lt;&lt; p; <span class="keyword">return</span> <span class="number">0</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; p;</span><br><span class="line">    <span class="type">int</span> m = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (s[x + <span class="number">1</span>] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; x &lt; m - <span class="number">1</span>) x++;</span><br><span class="line">    <span class="keyword">while</span> (s[m] == <span class="string">&#x27;0&#x27;</span> &amp;&amp; m &gt; x + <span class="number">1</span>) m--;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = m; i &gt; x; i--)</span><br><span class="line">        cout &lt;&lt; s[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="斯诺登的密码"><a href="#斯诺登的密码" class="headerlink" title="斯诺登的密码"></a>斯诺登的密码</h1><h2 id="题目背景-4"><a href="#题目背景-4" class="headerlink" title="题目背景"></a>题目背景</h2><p>根据斯诺登事件出的一道水题</p><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>2013 年 X 月 X 日，俄罗斯办理了斯诺登的护照，于是他混迹于一架开往委内瑞拉的飞机。但是，这件事情太不周密了，因为 FBI 的间谍早已获悉他的具体位置——但这不是最重要的——最重要的是如果要去委内瑞拉，那么就要经过古巴，而经过古巴的路在美国的掌控之中。</p><p>丧心病狂的奥巴马迫降斯诺登的飞机，搜查时却发现，斯诺登杳无踪迹。但是，在据说是斯诺登的座位上，发现了一张纸条。纸条由纯英文构成：<code>Obama is a two five zero.</code>（以 <code>.</code> 结束输出，只有 6 个单词+一个句号，句子开头如没有大写亦为合法）这句话虽然有点无厘头，但是警官陈珺骛发现这是一条极其重要的线索。他在斯诺登截获的一台笔记本中找到了一个 C++ 程序，输入这条句子后立马给出了相对应的密码。陈珺鹜高兴得晕了过去，身为警官的你把字条和程序带上了飞机，准备飞往曼哈顿国际机场，但是在飞机上检查的时候发现——程序被粉碎了！飞机抵达华盛顿只剩 5 分钟，你必须在这 5 分钟内编写（杜撰）一个程序，免受上司的 10000000000 \bmod 10 大板。破译密码的步骤如下：</p><p>（1）找出句子中所有用英文表示的数字 (\leq 20)，列举在下：</p><p>正规：<code>one two three four five six seven eight nine ten eleven twelve</code><br>           <code>thirteen fourteen fifteen sixteen seventeen eighteen nineteen             twenty</code></p><p>非正规：<code>a both another first second third</code>。为避免造成歧义，<code>another</code> 算作 1 处理。</p><p>（2）将这些数字平方后对 100 取模，如 00,05,11,19,86,99。</p><p>（3）把这些两位数按数位排成一行，组成一个新数，如果开头为 0，就去 0。</p><p>（4）找出所有排列方法中最小的一个数，即为密码。</p><p>&#x2F;&#x2F; 数据已经修正 By absi2011 如果还有问题请联系我</p><h2 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h2><p>一个含有 6 个单词的句子。</p><h2 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整型变量（密码）。如果没有符合要求的数字出现，则输出 0。</p><h2 id="样例-1-9"><a href="#样例-1-9" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-9"><a href="#样例输入-1-9" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Black Obama is two five zero .</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-9"><a href="#样例输出-1-9" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">425</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mx = <span class="number">66</span>;</span><br><span class="line"><span class="type">int</span> top;</span><br><span class="line"><span class="type">int</span> st[mx];</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    q[<span class="string">&quot;one&quot;</span>] = <span class="number">1</span>; q[<span class="string">&quot;two&quot;</span>] = <span class="number">2</span>; q[<span class="string">&quot;three&quot;</span>] = <span class="number">3</span>; q[<span class="string">&quot;four&quot;</span>] = <span class="number">4</span>; q[<span class="string">&quot;five&quot;</span>] = <span class="number">5</span>; q[<span class="string">&quot;six&quot;</span>] = <span class="number">6</span>; q[<span class="string">&quot;seven&quot;</span>] = <span class="number">7</span>; q[<span class="string">&quot;eight&quot;</span>] = <span class="number">8</span>; q[<span class="string">&quot;nine&quot;</span>] = <span class="number">9</span>; q[<span class="string">&quot;ten&quot;</span>] = <span class="number">10</span>;</span><br><span class="line">        q[<span class="string">&quot;eleven&quot;</span>] = <span class="number">11</span>; q[<span class="string">&quot;twelve&quot;</span>] = <span class="number">12</span>; q[<span class="string">&quot;thirteen&quot;</span>] = <span class="number">13</span>; q[<span class="string">&quot;fourteen&quot;</span>] = <span class="number">14</span>; q[<span class="string">&quot;fifteen&quot;</span>] = <span class="number">15</span>; q[<span class="string">&quot;sixteen&quot;</span>] = <span class="number">16</span>; q[<span class="string">&quot;seventeen&quot;</span>] = <span class="number">17</span>; q[<span class="string">&quot;eighteen&quot;</span>] = <span class="number">18</span>; q[<span class="string">&quot;nineteen&quot;</span>] = <span class="number">19</span>; q[<span class="string">&quot;twenty&quot;</span>] = <span class="number">20</span>;</span><br><span class="line">    q[<span class="string">&quot;a&quot;</span>] = <span class="number">1</span>; q[<span class="string">&quot;both&quot;</span>] = <span class="number">2</span>; q[<span class="string">&quot;another&quot;</span>] = <span class="number">1</span>; q[<span class="string">&quot;first&quot;</span>] = <span class="number">1</span>; q[<span class="string">&quot;second&quot;</span>] = <span class="number">2</span>; q[<span class="string">&quot;third&quot;</span>] = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++) &#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span> (q[s]) &#123;</span><br><span class="line">            <span class="type">int</span> k = q[s] * q[s] % <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>)<span class="keyword">continue</span>;</span><br><span class="line">            st[++top] = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(st + <span class="number">1</span>, st + top + <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; st[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= top; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (st[i] &lt; <span class="number">10</span>)cout &lt;&lt; <span class="number">0</span>;</span><br><span class="line">        cout &lt;&lt; st[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="USACO1-1-你的飞碟在这儿-Your-Ride-Is-Here"><a href="#USACO1-1-你的飞碟在这儿-Your-Ride-Is-Here" class="headerlink" title="[USACO1.1] 你的飞碟在这儿 Your Ride Is Here"></a>[USACO1.1] 你的飞碟在这儿 Your Ride Is Here</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>众所周知，在每一个彗星后都有一只 UFO。这些 UFO 时常来收集地球上的忠诚支持者。不幸的是，他们的飞碟每次出行都只能带上一组支持者。因此，他们要用一种聪明的方案让这些小组提前知道谁会被彗星带走。他们为每个彗星起了一个名字，通过这些名字来决定这个小组是不是被带走的那个特定的小组（你认为是谁给这些彗星取的名字呢？）。关于如何搭配的细节会在下面告诉你；你的任务是写一个程序，通过小组名和彗星名来决定这个小组是否能被那颗彗星后面的 UFO 带走。</p><p>小组名和彗星名都以下列方式转换成一个数字：最终的数字就是名字中所有字母的积，其中 \texttt A 是 1，\texttt Z 是 26。例如，\texttt{USACO} 小组就是 21 \times 19 \times 1 \times 3 \times 15&#x3D;17955。如果小组的数字 \bmod 47 等于彗星的数字 \bmod 47,你就得告诉这个小组需要准备好被带走！（记住“a \bmod b”是 a 除以 b 的余数，例如 34 \bmod 10 等于 4）</p><p>写出一个程序，读入彗星名和小组名并算出用上面的方案能否将两个名字搭配起来，如果能搭配，就输出 <code>GO</code>，否则输出 <code>STAY</code>。小组名和彗星名均是没有空格或标点的一串大写字母（不超过 6 个字母）。</p><h2 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h2><p>第1行：一个长度为 1 到 6 的大写字母串，表示彗星的名字。</p><p>第2行：一个长度为 1 到 6 的大写字母串，表示队伍的名字。</p><h2 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h2><h2 id="样例-1-10"><a href="#样例-1-10" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-10"><a href="#样例输入-1-10" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMETQ</span><br><span class="line">HVNGAT</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-10"><a href="#样例输出-1-10" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GO</span><br></pre></td></tr></table></figure><h2 id="样例-2-4"><a href="#样例-2-4" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-4"><a href="#样例输入-2-4" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ABSTAR</span><br><span class="line">USACO</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4"><a href="#样例输出-2-4" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STAY</span><br></pre></td></tr></table></figure><h2 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h2><p>题目翻译来自 NOCOW。</p><p>USACO Training Section 1.1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">  <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> std ;</span><br><span class="line">  </span><br><span class="line">  string a , b ;</span><br><span class="line">  <span class="type">int</span> ans = <span class="number">1</span> , num = <span class="number">1</span> ; </span><br><span class="line">  <span class="built_in">main</span>()&#123;</span><br><span class="line">      cin &gt;&gt; a &gt;&gt; b ; </span><br><span class="line">      <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; a.<span class="built_in">length</span>() ; i ++ ) ans *= a[i] - <span class="number">64</span>; </span><br><span class="line">     </span><br><span class="line">      <span class="keyword">for</span>( <span class="type">int</span> i = <span class="number">0</span> ; i &lt; b.<span class="built_in">length</span>() ; i ++ ) num *= b[i] - <span class="number">64</span> ; </span><br><span class="line">      </span><br><span class="line">      ans %= <span class="number">47</span> , num %= <span class="number">47</span> ; </span><br><span class="line">      <span class="keyword">if</span>( ans == num ) cout &lt;&lt; <span class="string">&quot;GO&quot;</span> ; </span><br><span class="line">      <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;STAY&quot;</span> ; </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="语句解析"><a href="#语句解析" class="headerlink" title="语句解析"></a>语句解析</h1><h2 id="题目背景-5"><a href="#题目背景-5" class="headerlink" title="题目背景"></a>题目背景</h2><p>木有背景……</p><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>一串长度不超过 255 的 PASCAL 语言代码，只有 a,b,c 三个变量，而且只有赋值语句，赋值只能是一个一位的数字或一个变量，每条赋值语句的格式是 <code>[变量]:=[变量或一位整数];</code>。未赋值的变量值为 0 输出 a,b,c 的值。</p><h2 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h2><p>一串符合语法的 PASCAL 语言，只有 a,b,c 三个变量，而且只有赋值语句，赋值只能是一个一位的数字或一个变量，未赋值的变量值为 0。</p><h2 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出 a,b,c 最终的值。</p><h2 id="样例-1-11"><a href="#样例-1-11" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-11"><a href="#样例输入-1-11" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:=3;b:=4;c:=5;</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-11"><a href="#样例输出-1-11" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5</span><br></pre></td></tr></table></figure><h2 id="提示-9"><a href="#提示-9" class="headerlink" title="提示"></a>提示</h2><p>输入的 PASCAL 语言长度不超过 255。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> s[<span class="number">256</span>];</span><br><span class="line"><span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,s);</span><br><span class="line"><span class="type">int</span> n=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">5</span>)&#123;</span><br><span class="line"><span class="keyword">switch</span>(s[i])&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: &#123;</span><br><span class="line"><span class="keyword">switch</span>(s[i+<span class="number">3</span>])&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: a=a;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: a=b;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: a=c;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: a=s[i+<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: &#123;</span><br><span class="line"><span class="keyword">switch</span>(s[i+<span class="number">3</span>])&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: b=a;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: b=b;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: b=c;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: b=s[i+<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: &#123;</span><br><span class="line"><span class="keyword">switch</span>(s[i+<span class="number">3</span>])&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>: c=a;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;b&#x27;</span>: c=b;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">&#x27;c&#x27;</span>: c=c;<span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>: c=s[i+<span class="number">3</span>]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>,a,b,c);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="垂直柱状图"><a href="#垂直柱状图" class="headerlink" title="垂直柱状图"></a>垂直柱状图</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>写一个程序从输入文件中去读取四行大写字母（全都是大写的，每行不超过 100 个字符），然后用柱状图输出每个字符在输入文件中出现的次数。严格地按照输出样例来安排你的输出格式。</p><h2 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h2><p>四行字符，由大写字母组成，每行不超过 100 个字符</p><h2 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h2><p>由若干行组成，前几行由空格和星号组成，最后一行则是由空格和字母组成的。在任何一行末尾不要打印不需要的多余空格。不要打印任何空行。</p><h2 id="样例-1-12"><a href="#样例-1-12" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-12"><a href="#样例输入-1-12" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG.</span><br><span class="line">THIS IS AN EXAMPLE TO TEST FOR YOUR</span><br><span class="line">HISTOGRAM PROGRAM.</span><br><span class="line">HELLO!</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-12"><a href="#样例输出-1-12" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line">                            *</span><br><span class="line">        *                   *</span><br><span class="line">        *                   *     *   *</span><br><span class="line">        *                   *     *   *</span><br><span class="line">*       *     *             *     *   *</span><br><span class="line">*       *     * *     * *   *     * * *</span><br><span class="line">*       *   * * *     * *   * *   * * * *</span><br><span class="line">*     * * * * * *     * * * * *   * * * *     * *</span><br><span class="line">* * * * * * * * * * * * * * * * * * * * * * * * * *</span><br><span class="line">A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</span><br></pre></td></tr></table></figure><h2 id="提示-10"><a href="#提示-10" class="headerlink" title="提示"></a>提示</h2><p>每行输出后面不允许出现多余的空格。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> ff[<span class="number">26</span>];<span class="comment">//定义计数数组</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j, n, maxn = <span class="number">0</span>; string a;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin, a);</span><br><span class="line">        n = a.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)<span class="keyword">if</span> (a[j] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; a[j] &lt;= <span class="string">&#x27;Z&#x27;</span>)ff[a[j] - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)maxn = <span class="built_in">max</span>(maxn, ff[i]);</span><br><span class="line">    <span class="keyword">for</span> (i = maxn; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span><br><span class="line">            <span class="keyword">if</span> (ff[j] &gt;= i)<span class="built_in">printf</span>(<span class="string">&quot;* &quot;</span>); <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)<span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, i + <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷刷题4</title>
      <link href="/2024/02/07/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%984/"/>
      <url>/2024/02/07/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%984/</url>
      
        <content type="html"><![CDATA[<h1 id="洛谷刷题三"><a href="#洛谷刷题三" class="headerlink" title="洛谷刷题三"></a>洛谷刷题三</h1><h1 id="小鱼比可爱"><a href="#小鱼比可爱" class="headerlink" title="小鱼比可爱"></a>小鱼比可爱</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>人比人，气死人；鱼比鱼，难死鱼。小鱼最近参加了一个“比可爱”比赛，比的是每只鱼的可爱程度。参赛的鱼被从左到右排成一排，头都朝向左边，然后每只鱼会得到一个整数数值，表示这只鱼的可爱程度，很显然整数越大，表示这只鱼越可爱，而且任意两只鱼的可爱程度<strong>可能一样</strong>。由于所有的鱼头都朝向左边，所以每只鱼只能看见在它左边的鱼的可爱程度，它们心里都在计算，在自己的眼力范围内有多少只鱼不如自己可爱呢。请你帮这些可爱但是鱼脑不够用的小鱼们计算一下。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 n，表示鱼的数目。</p><p>第二行内输入 n 个正整数，用空格间隔，依次表示从左到右每只小鱼的可爱程度 a_i。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，输出 n 个整数，用空格间隔，依次表示每只小鱼眼中有多少只鱼不如自己可爱。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">4 3 0 5 1 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 3 1 2</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 100% 的数据，1 \leq n\leq 100，0 \leq a_i \leq 10。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; <span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i<span class="number">-1</span>; j &gt;=<span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[j]&lt;a[i])</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ans = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小鱼的数字游戏"><a href="#小鱼的数字游戏" class="headerlink" title="小鱼的数字游戏"></a>小鱼的数字游戏</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>小鱼最近被要求参加一个数字游戏，要求它把看到的一串数字 a_i（长度不一定，以 0 结束），记住了然后反着念出来（表示结束的数字 0 就不要念出来了）。这对小鱼的那点记忆力来说实在是太难了，你也不想想小鱼的整个脑袋才多大，其中一部分还是好吃的肉！所以请你帮小鱼编程解决这个问题。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行内输入一串整数，以 0 结束，以空格间隔。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行内倒着输出这一串整数，以空格间隔。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 65 23 5 34 1 30 0</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 1 34 5 23 65 3</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 100% 的数据，保证 0 \leq a_i \leq 2^{31} - 1，数字个数不超过 100。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">cin &gt;&gt; b;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[i] =b;</span><br><span class="line">cin &gt;&gt; b;</span><br><span class="line">cnt++;</span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = cnt<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基5-例3】冰雹猜想"><a href="#【深基5-例3】冰雹猜想" class="headerlink" title="【深基5.例3】冰雹猜想"></a>【深基5.例3】冰雹猜想</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个正整数 n，然后对这个数字一直进行下面的操作：如果这个数字是奇数，那么将其乘 3 再加 1，否则除以 2。经过若干次循环后，最终都会回到 1。经过验证很大的数字（7\times10^{11}）都可以按照这样的方式比变成 1，所以被称为“冰雹猜想”。例如当 n 是 20，变化的过程是 20\to 10\to 5\to 16\to 8\to 4\to 2\to 1。</p><p>根据给定的数字，验证这个猜想，并从最后的 1 开始，倒序输出整个变化序列。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个正整数 n。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出若干个由空格隔开的正整数，表示从最后的 1 开始倒序的变化数列。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 8 16 5 10 20</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \le n\le 100。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 100</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;</span><br><span class="line">a[<span class="number">0</span>] = n;</span><br><span class="line"><span class="keyword">while</span> (n != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n%<span class="number">2</span>==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">n = n * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">n /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">a[i] = n;</span><br><span class="line">i++;</span><br><span class="line">ans = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = ans<span class="number">-1</span>; i &gt;=<span class="number">0</span> ; i--)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i];</span><br><span class="line"><span class="keyword">if</span> (i!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2005-普及组-校门外的树"><a href="#NOIP2005-普及组-校门外的树" class="headerlink" title="[NOIP2005 普及组] 校门外的树"></a>[NOIP2005 普及组] 校门外的树</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>某校大门外长度为 l 的马路上有一排树，每两棵相邻的树之间的间隔都是 1 米。我们可以把马路看成一个数轴，马路的一端在数轴 0 的位置，另一端在 l 的位置；数轴上的每个整数点，即 0,1,2,\dots,l，都种有一棵树。</p><p>由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个整数，分别表示马路的长度 l 和区域的数目 m。</p><p>接下来 m 行，每行两个整数 u, v，表示一个区域的起始点和终止点的坐标。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">500 3</span><br><span class="line">150 300</span><br><span class="line">100 200</span><br><span class="line">470 471</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">298</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p><strong>【数据范围】</strong></p><ul><li>对于 20% 的数据，保证区域之间没有重合的部分。</li><li>对于 100% 的数据，保证 1 \leq l \leq 10^4，1 \leq m \leq 100，0 \leq u \leq v \leq l。</li></ul><p><strong>【题目来源】</strong></p><p>NOIP 2005 普及组第二题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> l;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;=y ; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;=l ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i]==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基5-例5】旗鼓相当的对手"><a href="#【深基5-例5】旗鼓相当的对手" class="headerlink" title="【深基5.例5】旗鼓相当的对手"></a>【深基5.例5】旗鼓相当的对手</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有 N 名同学参加了期末考试，并且获得了每名同学的信息：语文、数学、英语成绩（均为不超过 150 的自然数）。如果某对学生 \lang i,j\rang 的每一科成绩的分差都不大于 5，且总分分差不大于 10，那么这对学生就是“旗鼓相当的对手”。现在想知道这些同学中，有几对“旗鼓相当的对手”？同样一个人可能会和其他好几名同学结对。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数 N。</p><p>接下来 N 行，每行三个整数，其中第 i 行表示第 i 名同学的语文、数学、英语成绩。最先读入的同学编号为 1。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示“旗鼓相当的对手”的对数。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">90 90 90</span><br><span class="line">85 95 90</span><br><span class="line">80 100 91</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>数据保证，2 \le N\le 1000 且每科成绩为不超过 150 的自然数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> a[<span class="number">10000</span>][<span class="number">5</span>], z[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,d=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i][<span class="number">0</span>] &gt;&gt; a[i][<span class="number">1</span>] &gt;&gt; a[i][<span class="number">2</span>];</span><br><span class="line">        z[i] = a[i][<span class="number">1</span>] + a[i][<span class="number">2</span>] + a[i][<span class="number">0</span>];   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> f=<span class="number">1</span>; f&lt;=n; f++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> y =f+<span class="number">1</span>; y&lt;=n; y++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">abs</span>(a[f][<span class="number">0</span>] - a[y][<span class="number">0</span>]) &lt;= <span class="number">5</span></span><br><span class="line">                &amp;&amp; <span class="built_in">abs</span>(a[f][<span class="number">1</span>] - a[y][<span class="number">1</span>]) &lt;= <span class="number">5</span></span><br><span class="line">                &amp;&amp; <span class="built_in">abs</span>(a[f][<span class="number">2</span>] - a[y][<span class="number">2</span>]) &lt;= <span class="number">5</span></span><br><span class="line">                &amp;&amp; <span class="built_in">abs</span>(z[f] - z[y]) &lt;= <span class="number">10</span>)d++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基5-例7】工艺品制作"><a href="#【深基5-例7】工艺品制作" class="headerlink" title="【深基5.例7】工艺品制作"></a>【深基5.例7】工艺品制作</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有一个长宽高分别为 w,x,h 组成的实心玻璃立方体，可以认为是由 1\times1\times1 的数个小方块组成的，每个小方块都有一个坐标  ( i,j,k ) 。现在需要进行 q 次切割。每次切割给出 (x_1,y_1,z_1),(x_2,y_2,z_2) 这 6 个参数，保证 x_1\le x_2，y_1\le y_2，z_1\le z_2；每次切割时，使用激光工具切出一个立方体空洞，空洞的壁平行于立方体的面，空洞的对角点就是给出的切割参数的两个点。</p><p>换句话说，所有满足  x_1\le i\le x_2，y_1\le j \le y_2 ，z_1\le k\le z_2 的小方块 (i,j,k) 的点都会被激光蒸发。例如有一个  4\times4\times 4 的大方块，其体积为 64；给出参数 (1,1,1),(2,2,2) 时，中间的 8 块小方块就会被蒸发，剩下 56 个小方块。现在想知道经过所有切割操作后，剩下的工艺品还剩下多少格小方块的体积？</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行三个正整数 w,x,h。</p><p>第二行一个正整数 q。</p><p>接下来 q 行，每行六个整数 (x_1,y_1,z_1),(x_2,y_2,z_2)。</p><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数表示答案。</p><h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 4 4</span><br><span class="line">1</span><br><span class="line">1 1 1 2 2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">56</span><br></pre></td></tr></table></figure><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1\le w,x,h\le 20，1 \leq q\le 100。1 \leq x_1 \leq x_2 \leq w，1 \leq y_1\leq y_2 \leq x，1 \leq z_1 \leq z_2 \leq h。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">22</span>][<span class="number">22</span>][<span class="number">22</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> w, x, h;</span><br><span class="line">cin &gt;&gt; w &gt;&gt; x &gt;&gt; h;</span><br><span class="line"><span class="type">int</span> q;</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"><span class="keyword">while</span> (q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x1, y1, z1, x2 ,y2, z2;</span><br><span class="line">cin &gt;&gt; x1 &gt;&gt; y1 &gt;&gt; z1 &gt;&gt; x2 &gt;&gt; y2&gt;&gt; z2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x1; i &lt;=x2 ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c= y1; c &lt;=y2 ; c++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = z1; j &lt;=z2 ; j++)</span><br><span class="line">&#123;</span><br><span class="line">a[i][c][j] =<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= w; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">1</span>; c &lt;= x; c++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= h; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i][c][j] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; w * x * h - ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="AHOI2001-彩票摇奖"><a href="#AHOI2001-彩票摇奖" class="headerlink" title="[AHOI2001] 彩票摇奖"></a>[AHOI2001] 彩票摇奖</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>为了丰富人民群众的生活、支持某些社会公益事业，北塔市设置了一项彩票。该彩票的规则是：</p><ol><li>每张彩票上印有 7 个各不相同的号码，且这些号码的取值范围为 1\sim33。</li><li>每次在兑奖前都会公布一个由七个各不相同的号码构成的中奖号码。</li><li>共设置 7 个奖项，特等奖和一等奖至六等奖。</li></ol><p>兑奖规则如下：</p><ul><li>特等奖：要求彩票上 7 个号码都出现在中奖号码中。</li><li>一等奖：要求彩票上有 6 个号码出现在中奖号码中。</li><li>二等奖：要求彩票上有 5 个号码出现在中奖号码中。</li><li>三等奖：要求彩票上有 4 个号码出现在中奖号码中。</li><li>四等奖：要求彩票上有 3 个号码出现在中奖号码中。</li><li>五等奖：要求彩票上有 2 个号码出现在中奖号码中。</li><li>六等奖：要求彩票上有 1 个号码出现在中奖号码中。</li></ul><p>注：兑奖时并不考虑彩票上的号码和中奖号码中的各个号码出现的位置。例如，中奖号码为 23\ 31\ 1\ 14\ 19\ 17\ 18，则彩票 12\ 8\ 9\ 23\ 1\ 16\ 7 由于其中有两个号码（23 和 1）出现在中奖号码中，所以该彩票中了五等奖。</p><p>现已知中奖号码和小明买的若干张彩票的号码，请你写一个程序帮助小明判断他买的彩票的中奖情况。</p><h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入的第一行只有一个自然数 n，表示小明买的彩票张数；</p><p>第二行存放了 7 个介于 1 和 33 之间的自然数，表示中奖号码；</p><p>在随后的 n 行中每行都有 7 个介于 1 和 33 之间的自然数，分别表示小明所买的 n 张彩票。</p><h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>依次输出小明所买的彩票的中奖情况（中奖的张数），首先输出特等奖的中奖张数，然后依次输出一等奖至六等奖的中奖张数。</p><h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">23 31 1 14 19 17 18</span><br><span class="line">12 8 9 23 1 16 7</span><br><span class="line">11 7 10 21 2 9 31</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0 0 1 1</span><br></pre></td></tr></table></figure><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 100% 的数据，保证 1 \leq n\lt1000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> x[<span class="number">6</span>] ;</span><br><span class="line"><span class="type">int</span> Counter[<span class="number">6</span>] ;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i1 = <span class="number">0</span>;i1 &lt;= <span class="number">6</span>;i1++)<span class="comment">//输入今日中奖号</span></span><br><span class="line">cin &gt;&gt; x[i1];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i++)<span class="comment">//对n张彩票进行判断</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i2 = <span class="number">1</span>;i2 &lt;= <span class="number">7</span>;i2++)<span class="comment">//判断第n张彩票对上号的数目</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i3 = <span class="number">0</span>;i3 &lt;= <span class="number">6</span>;i3++) <span class="comment">//遍历寻找</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a == x[i3])</span><br><span class="line">counter++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Counter[<span class="number">7</span>-counter]++;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//展示统计结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i5 = <span class="number">0</span>;i5 &lt;= <span class="number">6</span>;i5++)</span><br><span class="line">cout &lt;&lt; Counter[i5] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2015-提高组-神奇的幻方"><a href="#NOIP2015-提高组-神奇的幻方" class="headerlink" title="[NOIP2015 提高组] 神奇的幻方"></a>[NOIP2015 提高组] 神奇的幻方</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIp2015 提高组 Day1T1</p><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>幻方是一种很神奇的 N\times N 矩阵：它由数字 1,2,3,\cdots \cdots ,N \times N 构成，且每行、每列及两条对角线上的数字之和都相同。</p><p>当 N 为奇数时，我们可以通过下方法构建一个幻方：</p><p>首先将 1 写在第一行的中间。</p><p>之后，按如下方式从小到大依次填写每个数 K \ (K&#x3D;2,3,\cdots,N \times N) ：</p><ol><li>若 (K-1) 在第一行但不在最后一列，则将 K 填在最后一行， (K-1) 所在列的右一列；</li><li>若 (K-1) 在最后一列但不在第一行，则将 K 填在第一列， (K-1) 所在行的上一行；</li><li>若 (K-1) 在第一行最后一列，则将 K 填在 (K-1) 的正下方；</li><li>若 (K-1) 既不在第一行，也不在最后一列，如果 (K-1) 的右上方还未填数，则将 K 填在 (K-1) 的右上方，否则将 K 填在 (K-1) 的正下方。</li></ol><p>现给定 N ，请按上述方法构造 N \times N 的幻方。</p><h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>一个正整数 N，即幻方的大小。</p><h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>共 N 行，每行 N 个整数，即按上述方法构造出的 N \times N 的幻方，相邻两个整数之间用单空格隔开。</p><h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8 1 6</span><br><span class="line">3 5 7</span><br><span class="line">4 9 2</span><br></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">25</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">327 354 381 408 435 462 489 516 543 570 597 624 1 28 55 82 109 136 163 190 217 244 271 298 325</span><br><span class="line">353 380 407 434 461 488 515 542 569 596 623 25 27 54 81 108 135 162 189 216 243 270 297 324 326</span><br><span class="line">379 406 433 460 487 514 541 568 595 622 24 26 53 80 107 134 161 188 215 242 269 296 323 350 352</span><br><span class="line">405 432 459 486 513 540 567 594 621 23 50 52 79 106 133 160 187 214 241 268 295 322 349 351 378</span><br><span class="line">431 458 485 512 539 566 593 620 22 49 51 78 105 132 159 186 213 240 267 294 321 348 375 377 404</span><br><span class="line">457 484 511 538 565 592 619 21 48 75 77 104 131 158 185 212 239 266 293 320 347 374 376 403 430</span><br><span class="line">483 510 537 564 591 618 20 47 74 76 103 130 157 184 211 238 265 292 319 346 373 400 402 429 456</span><br><span class="line">509 536 563 590 617 19 46 73 100 102 129 156 183 210 237 264 291 318 345 372 399 401 428 455 482</span><br><span class="line">535 562 589 616 18 45 72 99 101 128 155 182 209 236 263 290 317 344 371 398 425 427 454 481 508</span><br><span class="line">561 588 615 17 44 71 98 125 127 154 181 208 235 262 289 316 343 370 397 424 426 453 480 507 534</span><br><span class="line">587 614 16 43 70 97 124 126 153 180 207 234 261 288 315 342 369 396 423 450 452 479 506 533 560</span><br><span class="line">613 15 42 69 96 123 150 152 179 206 233 260 287 314 341 368 395 422 449 451 478 505 532 559 586</span><br><span class="line">14 41 68 95 122 149 151 178 205 232 259 286 313 340 367 394 421 448 475 477 504 531 558 585 612</span><br><span class="line">40 67 94 121 148 175 177 204 231 258 285 312 339 366 393 420 447 474 476 503 530 557 584 611 13</span><br><span class="line">66 93 120 147 174 176 203 230 257 284 311 338 365 392 419 446 473 500 502 529 556 583 610 12 39</span><br><span class="line">92 119 146 173 200 202 229 256 283 310 337 364 391 418 445 472 499 501 528 555 582 609 11 38 65</span><br><span class="line">118 145 172 199 201 228 255 282 309 336 363 390 417 444 471 498 525 527 554 581 608 10 37 64 91</span><br><span class="line">144 171 198 225 227 254 281 308 335 362 389 416 443 470 497 524 526 553 580 607 9 36 63 90 117</span><br><span class="line">170 197 224 226 253 280 307 334 361 388 415 442 469 496 523 550 552 579 606 8 35 62 89 116 143</span><br><span class="line">196 223 250 252 279 306 333 360 387 414 441 468 495 522 549 551 578 605 7 34 61 88 115 142 169</span><br><span class="line">222 249 251 278 305 332 359 386 413 440 467 494 521 548 575 577 604 6 33 60 87 114 141 168 195</span><br><span class="line">248 275 277 304 331 358 385 412 439 466 493 520 547 574 576 603 5 32 59 86 113 140 167 194 221</span><br><span class="line">274 276 303 330 357 384 411 438 465 492 519 546 573 600 602 4 31 58 85 112 139 166 193 220 247</span><br><span class="line">300 302 329 356 383 410 437 464 491 518 545 572 599 601 3 30 57 84 111 138 165 192 219 246 273</span><br><span class="line">301 328 355 382 409 436 463 490 517 544 571 598 625 2 29 56 83 110 137 164 191 218 245 272 299</span><br></pre></td></tr></table></figure><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>对于 100% 的数据，对于全部数据， 1 \leq N \leq 39 且 N 为奇数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span>  f = n / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">a[<span class="number">1</span>][n / <span class="number">2</span> + <span class="number">1</span>] = i;</span><br><span class="line"><span class="keyword">while</span> (i!=n*n+<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (t==<span class="number">1</span>&amp;&amp;f!=n)</span><br><span class="line">&#123;</span><br><span class="line">a[n][f + <span class="number">1</span>] = i;</span><br><span class="line">t = n;</span><br><span class="line">f = f + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (t!=<span class="number">1</span>&amp;&amp;f==n)</span><br><span class="line">&#123;</span><br><span class="line">a[t - <span class="number">1</span>][<span class="number">1</span>] = i;</span><br><span class="line">t = t - <span class="number">1</span>;</span><br><span class="line">f = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(t==<span class="number">1</span>&amp;&amp;f==n)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">2</span>][f] = i;</span><br><span class="line">t = <span class="number">2</span>;</span><br><span class="line">f = f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (t != <span class="number">1</span> &amp;&amp; f != n &amp;&amp; a[t - <span class="number">1</span>][f + <span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">a[t - <span class="number">1</span>][f + <span class="number">1</span>] = i;</span><br><span class="line">t = t - <span class="number">1</span>;</span><br><span class="line">f = f + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">a[t + <span class="number">1</span>][f] = i;</span><br><span class="line">t = t + <span class="number">1</span>;</span><br><span class="line">f = f;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;=n ; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i][j] &lt;&lt; (j == n ? <span class="string">&quot;\n&quot;</span> : <span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按要求模拟即可</span></span><br></pre></td></tr></table></figure><h1 id="【深基5-例10】显示屏"><a href="#【深基5-例10】显示屏" class="headerlink" title="【深基5.例10】显示屏"></a>【深基5.例10】显示屏</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>液晶屏上，每个阿拉伯数字都是可以显示成 3\times5 的点阵的（其中 <code>X</code> 表示亮点，<code>.</code> 表示暗点）。现在给出数字位数（不超过 100）和一串数字，要求输出这些数字在显示屏上的效果。数字的显示方式如同样例输出，注意每个数字之间都有一列间隔。</p><h2 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 n，表示数字的位数。</p><p>第二行输入一个长度为 n 的自然数。</p><h2 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出五行，表示显示屏上的数字。</p><h2 id="样例-1-8"><a href="#样例-1-8" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-8"><a href="#样例输入-1-8" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">0123456789</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-8"><a href="#样例输出-1-8" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">XXX...X.XXX.XXX.X.X.XXX.XXX.XXX.XXX.XXX</span><br><span class="line">X.X...X...X...X.X.X.X...X.....X.X.X.X.X</span><br><span class="line">X.X...X.XXX.XXX.XXX.XXX.XXX...X.XXX.XXX</span><br><span class="line">X.X...X.X.....X...X...X.X.X...X.X.X...X</span><br><span class="line">XXX...X.XXX.XXX...X.XXX.XXX...X.XXX.XXX</span><br></pre></td></tr></table></figure><h2 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \leq n \leq 100。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> a[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">string ans[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">ans[<span class="number">1</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">2</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">3</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">4</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">5</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans[<span class="number">1</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">2</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">3</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">4</span>]+=<span class="string">&quot;X...&quot;</span>;</span><br><span class="line">ans[<span class="number">5</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans[<span class="number">1</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">2</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">3</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">4</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">5</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans[<span class="number">1</span>]+=<span class="string">&quot;X.X.&quot;</span>;</span><br><span class="line">ans[<span class="number">2</span>]+=<span class="string">&quot;X.X.&quot;</span>;</span><br><span class="line">ans[<span class="number">3</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">4</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">5</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans[<span class="number">1</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">2</span>]+=<span class="string">&quot;X...&quot;</span>;</span><br><span class="line">ans[<span class="number">3</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">4</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">5</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans[<span class="number">1</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">2</span>]+=<span class="string">&quot;X...&quot;</span>;</span><br><span class="line">ans[<span class="number">3</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">4</span>]+=<span class="string">&quot;X.X.&quot;</span>;</span><br><span class="line">ans[<span class="number">5</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans[<span class="number">1</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">2</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">3</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">4</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">5</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans[<span class="number">1</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">2</span>]+=<span class="string">&quot;X.X.&quot;</span>;</span><br><span class="line">ans[<span class="number">3</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">4</span>]+=<span class="string">&quot;X.X.&quot;</span>;</span><br><span class="line">ans[<span class="number">5</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans[<span class="number">1</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">2</span>]+=<span class="string">&quot;X.X.&quot;</span>;</span><br><span class="line">ans[<span class="number">3</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">4</span>]+=<span class="string">&quot;..X.&quot;</span>;</span><br><span class="line">ans[<span class="number">5</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">ans[<span class="number">1</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">ans[<span class="number">2</span>]+=<span class="string">&quot;X.X.&quot;</span>;</span><br><span class="line">ans[<span class="number">3</span>]+=<span class="string">&quot;X.X.&quot;</span>;</span><br><span class="line">ans[<span class="number">4</span>]+=<span class="string">&quot;X.X.&quot;</span>;</span><br><span class="line">ans[<span class="number">5</span>]+=<span class="string">&quot;XXX.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">ans[i]=ans[i].<span class="built_in">substr</span>(<span class="number">0</span>,ans[i].<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line"><span class="comment">//复制函数，但复制少一位</span></span><br><span class="line">cout&lt;&lt;ans[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="梦中的统计"><a href="#梦中的统计" class="headerlink" title="梦中的统计"></a>梦中的统计</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>Bessie 处于半梦半醒的状态。过了一会儿，她意识到她在数数，不能入睡。</p><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>Bessie 的大脑反应灵敏，仿佛真实地看到了她数过的一个又一个数。她开始注意每一个数码（0 \ldots 9）：每一个数码在计数的过程中出现过多少次？</p><p>给出两个整数 M 和 N，求在序列 [M, M + 1, M + 2, \ldots, N - 1, N] 中每一个数码出现了多少次。</p><h2 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h2><p>第 1 行: 两个用空格分开的整数 M 和 N。</p><h2 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h2><p>第 1 行: 十个用空格分开的整数，分别表示数码 0 \ldots 9 在序列中出现的次数。</p><h2 id="样例-1-9"><a href="#样例-1-9" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-9"><a href="#样例输入-1-9" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">129 137</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-9"><a href="#样例输出-1-9" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 10 2 9 1 1 1 1 0 1</span><br></pre></td></tr></table></figure><h2 id="提示-9"><a href="#提示-9" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \leq M \leq N \leq 2 \times 10^9，N-M \leq 5 \times 10^5。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> js[<span class="number">11</span>],n,m;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;=m;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> tmp=i;tmp;tmp/=<span class="number">10</span>)</span><br><span class="line">js[tmp%<span class="number">10</span>]++; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">9</span>;i++)cout&lt;&lt;js[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2014-普及组-珠心算测验"><a href="#NOIP2014-普及组-珠心算测验" class="headerlink" title="[NOIP2014 普及组] 珠心算测验"></a>[NOIP2014 普及组] 珠心算测验</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2014 普及 T1</p><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>珠心算是一种通过在脑中模拟算盘变化来完成快速运算的一种计算技术。珠心算训练，既能够开发智力，又能够为日常生活带来很多便利，因而在很多学校得到普及。</p><p>某学校的珠心算老师采用一种快速考察珠心算加法能力的测验方法。他随机生成一个正整数集合，集合中的数各不相同，然后要求学生回答：其中有多少个数，恰好等于集合中另外两个（不同的）数之和？</p><p>最近老师出了一些测验题，请你帮忙求出答案。</p><h2 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h2><p>共两行，第一行包含一个整数 n，表示测试题中给出的正整数个数。</p><p>第二行有 n 个正整数，每两个正整数之间用一个空格隔开，表示测试题中给出的正整数。</p><h2 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示测验题答案。</p><h2 id="样例-1-10"><a href="#样例-1-10" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-10"><a href="#样例输入-1-10" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1 2 3 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-10"><a href="#样例输出-1-10" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-10"><a href="#提示-10" class="headerlink" title="提示"></a>提示</h2><p>【样例说明】</p><p>由 1+2&#x3D;3,1+3&#x3D;4，故满足测试要求的答案为 2。  </p><p>注意，加数和被加数必须是集合中的两个不同的数。</p><p>【数据说明】</p><p>对于 100% 的数据，3 \leq n \leq 100，测验题给出的正整数大小不超过 10,000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t[<span class="number">200005</span>],g[<span class="number">200005</span>];</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">105</span>],ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        g[a[i]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            t[a[i]+a[j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">200002</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (t[i]&gt;<span class="number">0</span>&amp;&amp;g[i]) ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="爱与愁的心痛"><a href="#爱与愁的心痛" class="headerlink" title="爱与愁的心痛"></a>爱与愁的心痛</h1><h2 id="题目背景-3"><a href="#题目背景-3" class="headerlink" title="题目背景"></a>题目背景</h2><p>（本道题目隐藏了两首歌名，找找看哪~~~）</p><p>《爱与愁的故事第一弹·heartache》第一章。</p><p>《我为歌狂》当中伍思凯神曲《舞月光》居然没赢给萨顶顶，爱与愁大神心痛啊~~~而且最近还有一些令人伤心的事情，都让人心痛（最近真的很烦哈)……</p><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>最近有 n 个不爽的事，每句话都有一个正整数刺痛值（心理承受力极差）。爱与愁大神想知道连续 m 个刺痛值的和的最小值是多少，但是由于业务繁忙，爱与愁大神只好请你编个程序告诉他。</p><h2 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有两个用空格隔开的整数，分别代表 n 和 m。</p><p>第 2 到第 (n + 1) 行，每行一个整数，第 (i + 1) 行的整数 a_i 代表第 i 件事的刺痛值 a_i。</p><h2 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数，表示连续 m 个刺痛值的和的最小值是多少。</p><h2 id="样例-1-11"><a href="#样例-1-11" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-11"><a href="#样例输入-1-11" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-11"><a href="#样例输出-1-11" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="提示-11"><a href="#提示-11" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定-2"><a href="#数据规模与约定-2" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><ul><li>对于 30% 的数据，保证 n \leq 20。</li><li>对于 60% 的数据，保证 n \leq 100。</li><li>对于 90% 的数据，保证 n \leq 10^3。</li><li>对于 100% 的数据，保证 0 \leq m \leq n \leq 3 \times 10^3，1 \leq a_i \leq 100。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前缀和</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="type">int</span> n,m,In,Sum[<span class="number">3002</span>],Ans=<span class="number">1e9</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Min</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;<span class="keyword">return</span> a&lt;b?a:b;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,In;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;In);</span><br><span class="line">        Sum[i]=Sum[i<span class="number">-1</span>]+In;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=m;i&lt;=n;i++) Ans=<span class="built_in">Min</span>(Ans,Sum[i]-Sum[i-m]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,Ans);</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="USACO08OCT-Bovine-Bones-G"><a href="#USACO08OCT-Bovine-Bones-G" class="headerlink" title="[USACO08OCT] Bovine Bones G"></a>[USACO08OCT] Bovine Bones G</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>贝茜喜欢玩棋盘游戏和角色扮演游戏，所以她说服了约翰开车带她去小商店.在那里她买了三个骰子。这三个不同的骰子的面数分别为 s_1,s_2,s_3。</p><p>对于一个有 S 个面的骰子每个面上的数字是 1,2,3,\ldots,S。每个面（上的数字）出现的概率均等。贝茜希望找出在所有“三个面上的数字的和”中，哪个和的值出现的概率最大。</p><p>现在给出每个骰子的面数，需要求出哪个所有“三个面上的数字的和”出现得最频繁。如果有很多个和出现的概率相同，那么只需要输出最小的那个。</p><p>数据范围： 2\le s_1\leq 20，2 \leq s_2\leq 20，2 \leq s_3\leq 40。</p><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>Bessie loves board games and role-playing games so she persuaded Farmer John to drive her to the hobby shop where she purchased three dice for rolling. These fair dice have S1, S2, and S3 sides</p><p>respectively (2 &lt;&#x3D; S1 &lt;&#x3D; 20; 2 &lt;&#x3D; S2 &lt;&#x3D; 20; 2 &lt;&#x3D; S3 &lt;&#x3D; 40). </p><p>Bessie rolls and rolls and rolls trying to figure out which three-dice sum appears most often.</p><p>Given the number of sides on each of the three dice, determine which three-dice sum appears most frequently. If more than one sum can appear most frequently, report the smallest such sum.</p><p>POINTS: 70</p><h2 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h2><p>* Line 1: Three space-separated integers: S1, S2, and S3</p><h2 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h2><p>* Line 1: The smallest integer sum that appears most frequently when the dice are rolled in every possible combination.</p><h2 id="样例-1-12"><a href="#样例-1-12" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-12"><a href="#样例输入-1-12" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-12"><a href="#样例输出-1-12" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示-12"><a href="#提示-12" class="headerlink" title="提示"></a>提示</h2><p>Here are all the possible outcomes.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1 1 1 -&gt; 3  </span><br><span class="line">1 2 1 -&gt; 4  </span><br><span class="line">2 1 1 -&gt; 4  </span><br><span class="line">2 2 1 -&gt; 5  </span><br><span class="line">3 1 1 -&gt; 5  </span><br><span class="line">3 2 1 -&gt; 6 </span><br><span class="line">1 1 2 -&gt; 4  </span><br><span class="line">1 2 2 -&gt; 5  </span><br><span class="line">2 1 2 -&gt; 5  </span><br><span class="line">2 2 2 -&gt; 6  </span><br><span class="line">3 1 2 -&gt; 6  </span><br><span class="line">3 2 2 -&gt; 7 </span><br><span class="line">1 1 3 -&gt; 5  </span><br><span class="line">1 2 3 -&gt; 6  </span><br><span class="line">2 1 3 -&gt; 6  </span><br><span class="line">2 2 3 -&gt; 7  </span><br><span class="line">3 1 3 -&gt; 7  </span><br><span class="line">3 2 3 -&gt; 8</span><br></pre></td></tr></table></figure><p>Both 5 and 6 appear most frequently (five times each), so 5 is the answer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> f[<span class="number">100001</span>],maxx;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i,j,k,s1,s2,s3;</span><br><span class="line">cin&gt;&gt;s1&gt;&gt;s2&gt;&gt;s3;</span><br><span class="line">   </span><br><span class="line">     </span><br><span class="line">   </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=s1;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=s2;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=s3;k++)</span><br><span class="line">&#123;</span><br><span class="line">f[i+j+k]++;</span><br><span class="line">maxx=<span class="built_in">max</span>(maxx,i+j+k);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> maxl=<span class="number">0</span>,c;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=maxx;i++)</span><br><span class="line">&#123;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span>(f[i]&gt;maxl)</span><br><span class="line">&#123;</span><br><span class="line">maxl=f[i];</span><br><span class="line">c=i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;c&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开灯"><a href="#开灯" class="headerlink" title="开灯"></a>开灯</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一条无限长的路上，有一排无限长的路灯，编号为 1,2,3,4,\dots。</p><p>每一盏灯只有两种可能的状态，开或者关。如果按一下某一盏灯的开关，那么这盏灯的状态将发生改变。如果原来是开，将变成关。如果原来是关，将变成开。</p><p>在刚开始的时候，所有的灯都是关的。小明每次可以进行如下的操作：</p><p>指定两个数，a,t（a 为实数，t 为正整数）。将编号为 \lfloor a\rfloor,\lfloor 2 \times a\rfloor,\lfloor3 \times a\rfloor,\dots,\lfloor t  \times a\rfloor 的灯的开关各按一次。其中 \lfloor k \rfloor 表示实数 k 的整数部分。</p><p>在小明进行了 n 次操作后，小明突然发现，这个时候只有一盏灯是开的，小明很想知道这盏灯的编号，可是这盏灯离小明太远了，小明看不清编号是多少。</p><p>幸好，小明还记得之前的 n 次操作。于是小明找到了你，你能帮他计算出这盏开着的灯的编号吗？</p><h2 id="输入格式-13"><a href="#输入格式-13" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数 n，表示 n 次操作。</p><p>接下来有 n 行，每行两个数，a_i,t_i。其中 a_i 是实数，小数点后一定有 6 位，t_i 是正整数。</p><h2 id="输出格式-13"><a href="#输出格式-13" class="headerlink" title="输出格式"></a>输出格式</h2><p>仅一个正整数，那盏开着的灯的编号。</p><h2 id="样例-1-13"><a href="#样例-1-13" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-13"><a href="#样例输入-1-13" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1.618034 13</span><br><span class="line">2.618034 7</span><br><span class="line">1.000000 21</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-13"><a href="#样例输出-1-13" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h2 id="提示-13"><a href="#提示-13" class="headerlink" title="提示"></a>提示</h2><p>记 T&#x3D;\sum \limits_{i&#x3D;1}^n t_i &#x3D; t_1+t_2+t_3+\dots+t_n。</p><ul><li>对于 30% 的数据，满足 T \le 1000；</li><li>对于 80% 的数据，满足 T \le 200000；</li><li>对于 100% 的数据，满足 T \le 2000000；</li><li>对于 100% 的数据，满足 n \le 5000，1 \le a_i&lt;1000，1 \le t_i \le T。</li></ul><p>数据保证，在经过 n 次操作后，有且只有一盏灯是开的，不必判错。而且对于所有的 i 来说，t_i\times a_i 的最大值不超过 2000000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">2000001</span>],n;</span><br><span class="line"><span class="type">double</span> x,y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">double</span> j=<span class="number">1</span>;j&lt;=y;++j)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[<span class="built_in">int</span>(j*x)]==<span class="number">0</span>) a[<span class="built_in">int</span>(j*x)]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> a[<span class="built_in">int</span>(j*x)]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(a[i]==<span class="number">1</span>)&#123;</span><br><span class="line">cout&lt;&lt;i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="【深基5-习6】蛇形方阵"><a href="#【深基5-习6】蛇形方阵" class="headerlink" title="【深基5.习6】蛇形方阵"></a>【深基5.习6】蛇形方阵</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个不大于 9 的正整数 n，输出 n\times n<br>的蛇形方阵。</p><p>从左上角填上 1 开始，顺时针方向依次填入数字，如同样例所示。注意每个数字有都会占用 3 个字符，前面使用空格补齐。</p><h2 id="输入格式-14"><a href="#输入格式-14" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个正整数 n，含义如题所述。</p><h2 id="输出格式-14"><a href="#输出格式-14" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出符合题目要求的蛇形矩阵。</p><h2 id="样例-1-14"><a href="#样例-1-14" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-14"><a href="#样例输入-1-14" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-14"><a href="#样例输出-1-14" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1  2  3  4</span><br><span class="line"> 12 13 14  5</span><br><span class="line"> 11 16 15  6</span><br><span class="line"> 10  9  8  7</span><br></pre></td></tr></table></figure><h2 id="提示-14"><a href="#提示-14" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \leq n \leq 9。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,k=<span class="number">1</span>,x=<span class="number">1</span>,y=<span class="number">0</span>;;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">while</span> (k&lt;=n*n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span>(y&lt;n&amp;&amp;!a[x][y+<span class="number">1</span>])a[x][++y]=k++;</span><br><span class="line"><span class="keyword">while</span>(x&lt;n&amp;&amp;!a[x+<span class="number">1</span>][y])a[++x][y]=k++;</span><br><span class="line"><span class="keyword">while</span>(y&gt;<span class="number">1</span>&amp;&amp;!a[x][y<span class="number">-1</span>])a[x][--y]=k++;</span><br><span class="line"><span class="keyword">while</span>(x&gt;<span class="number">1</span>&amp;&amp;!a[x<span class="number">-1</span>][y])a[--x][y]=k++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++) cout&lt;&lt;a[i][j]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基5-习7】杨辉三角"><a href="#【深基5-习7】杨辉三角" class="headerlink" title="【深基5.习7】杨辉三角"></a>【深基5.习7】杨辉三角</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出 n(n\le20)，输出杨辉三角的前 n 行。</p><p>如果你不知道什么是杨辉三角，可以观察样例找找规律。</p><h2 id="输入格式-15"><a href="#输入格式-15" class="headerlink" title="输入格式"></a>输入格式</h2><h2 id="输出格式-15"><a href="#输出格式-15" class="headerlink" title="输出格式"></a>输出格式</h2><h2 id="样例-1-15"><a href="#样例-1-15" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-15"><a href="#样例输入-1-15" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-15"><a href="#样例输出-1-15" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1 1</span><br><span class="line">1 2 1</span><br><span class="line">1 3 3 1</span><br><span class="line">1 4 6 4 1</span><br><span class="line">1 5 10 10 5 1</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">a[i][<span class="number">1</span>]=a[i][i]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;i;j++)</span><br><span class="line">a[i][j]=a[i<span class="number">-1</span>][j]+a[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=i;j++)</span><br><span class="line">cout&lt;&lt;a[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【Mc生存】插火把"><a href="#【Mc生存】插火把" class="headerlink" title="【Mc生存】插火把"></a>【Mc生存】插火把</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>话说有一天 linyorson 在“我的世界”开了一个 n \times n 的方阵，现在他有 m 个火把和 k 个萤石，分别放在 (x_1, y_1) \sim (x_m, y_m) 和 (o_1, p_1) \sim (o_k, p_k) 的位置，没有光并且没放东西的地方会生成怪物。请问在这个方阵中有几个点会生成怪物？</p><p>P.S. 火把的照亮范围是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|暗|暗| 光 |暗|暗|</span><br><span class="line">|暗|光| 光 |光|暗|</span><br><span class="line">|光|光|火把|光|光|</span><br><span class="line">|暗|光| 光 |光|暗|</span><br><span class="line">|暗|暗| 光 |暗|暗|</span><br></pre></td></tr></table></figure><p>萤石：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|光|光| 光 |光|光|</span><br><span class="line">|光|光| 光 |光|光|</span><br><span class="line">|光|光|萤石|光|光|</span><br><span class="line">|光|光| 光 |光|光|</span><br><span class="line">|光|光| 光 |光|光|</span><br></pre></td></tr></table></figure><h2 id="输入格式-16"><a href="#输入格式-16" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入共 m + k + 1 行。<br>第一行为 n, m, k。<br>第 2 到第 m + 1 行分别是火把的位置 x_i, y_i。<br>第 m + 2 到第 m + k + 1 行分别是萤石的位置 o_i, p_i。</p><p>注：可能没有萤石，但一定有火把。</p><h2 id="输出格式-16"><a href="#输出格式-16" class="headerlink" title="输出格式"></a>输出格式</h2><p>有几个点会生出怪物。</p><h2 id="样例-1-16"><a href="#样例-1-16" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-16"><a href="#样例输入-1-16" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 1 0</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-16"><a href="#样例输出-1-16" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="提示-15"><a href="#提示-15" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \le n \le 100，1 \leq m+k \leq 25，1 \leq m \leq 25，0 \leq k \leq 5。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,m,k,x,y,o,p,ans=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> dx1[<span class="number">13</span>]=&#123;<span class="number">2</span>,<span class="number">0</span>,<span class="number">-2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;,</span><br><span class="line">    dy1[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">-2</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line"><span class="type">int</span> dx2[<span class="number">25</span>]=&#123;<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;,</span><br><span class="line">    dy2[<span class="number">25</span>]=&#123;<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        </span><br><span class="line">    <span class="type">int</span> a[<span class="number">120</span>][<span class="number">120</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">13</span>;j++)</span><br><span class="line">        a[x+dx1[j]][y+dy1[j]]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">&#123;</span><br><span class="line">        cin&gt;&gt;o&gt;&gt;p;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">25</span>;j++)</span><br><span class="line">        a[o+dx2[j]][p+dy2[j]]=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">    <span class="keyword">if</span>(a[i][j]==<span class="number">0</span>)</span><br><span class="line">ans++;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//纯哈希</span></span><br></pre></td></tr></table></figure><h1 id="压缩技术"><a href="#压缩技术" class="headerlink" title="压缩技术"></a>压缩技术</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>设某汉字由 N \times N 的 \texttt 0 和 \texttt 1 的点阵图案组成。</p><p>我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个 \texttt 0，第二个数表示接下来连续有几个 \texttt 1，第三个数再接下来连续有几个 \texttt 0，第四个数接着连续几个 \texttt 1，以此类推……</p><p>例如: 以下汉字点阵图案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">0001111</span><br><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">1111111</span><br></pre></td></tr></table></figure><p>对应的压缩码是： \texttt {7 3 1 6 1 6 4 3 1 6 1 6 1 3 7} （第一个数是 N ,其余各位表示交替表示0和1 的个数，压缩码保证 N \times N&#x3D; 交替的各位数之和）</p><h2 id="输入格式-17"><a href="#输入格式-17" class="headerlink" title="输入格式"></a>输入格式</h2><p>数据输入一行，由空格隔开的若干个整数，表示压缩码。</p><p>其中，压缩码的第一个数字就是 N，表示这个点阵应当是 N\times N 的大小。</p><p>接下来的若干个数字，含义如题目描述所述。</p><h2 id="输出格式-17"><a href="#输出格式-17" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个 N\times N 的 01 矩阵，表示最后的汉字点阵图（点阵符号之间不留空格）。</p><h2 id="样例-1-17"><a href="#样例-1-17" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-17"><a href="#样例输入-1-17" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 3 1 6 1 6 4 3 1 6 1 6 1 3 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-17"><a href="#样例输出-1-17" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">0001111</span><br><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">1111111</span><br></pre></td></tr></table></figure><h2 id="提示-16"><a href="#提示-16" class="headerlink" title="提示"></a>提示</h2><h2 id="样例解释"><a href="#样例解释" class="headerlink" title="样例解释"></a>样例解释</h2><p><img src="/2024/02/07/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%984/Totoro.trip\blog-demo\source\images\rsx9qytk.png"></p><h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>数据保证，3\leq N\leq 200。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">1000000</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> N;</span><br><span class="line">cin &gt;&gt; N;</span><br><span class="line"><span class="type">int</span> x = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> t; </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; x &lt; N * N; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; t;</span><br><span class="line">arr[i] = t;</span><br><span class="line">x += t;</span><br><span class="line">n = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> b = <span class="number">0</span>; <span class="type">int</span> c = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a = i % <span class="number">2</span>;</span><br><span class="line">b += arr[i];</span><br><span class="line"><span class="keyword">for</span> (; c &lt;= b; c++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (c % N == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; a;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="压缩技术（续集版）"><a href="#压缩技术（续集版）" class="headerlink" title="压缩技术（续集版）"></a>压缩技术（续集版）</h1><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>设某汉字由 N \times N 的 \texttt 0 和 \texttt 1 的点阵图案组成。</p><p>我们依照以下规则生成压缩码。连续一组数值：从汉字点阵图案的第一行第一个符号开始计算，按书写顺序从左到右，由上至下。第一个数表示连续有几个 \texttt 0，第二个数表示接下来连续有几个 \texttt 1，第三个数再接下来连续有几个 \texttt 0，第四个数接着连续几个 \texttt 1，以此类推……</p><p>例如: 以下汉字点阵图案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">0001111</span><br><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">1111111</span><br></pre></td></tr></table></figure><p>对应的压缩码是： \texttt {7 3 1 6 1 6 4 3 1 6 1 6 1 3 7} （第一个数是 N ,其余各位表示交替表示0和1 的个数，压缩码保证 N \times N&#x3D; 交替的各位数之和）</p><h2 id="输入格式-18"><a href="#输入格式-18" class="headerlink" title="输入格式"></a>输入格式</h2><p>汉字点阵图（点阵符号之间不留空格）。</p><h2 id="输出格式-18"><a href="#输出格式-18" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，压缩码。</p><h2 id="样例-1-18"><a href="#样例-1-18" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-18"><a href="#样例输入-1-18" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">0001111</span><br><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">0001000</span><br><span class="line">1111111</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-18"><a href="#样例输出-1-18" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7 3 1 6 1 6 4 3 1 6 1 6 1 3 7</span><br></pre></td></tr></table></figure><h2 id="提示-17"><a href="#提示-17" class="headerlink" title="提示"></a>提示</h2><p>数据保证，3\leq N\leq 200。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a,b=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="type">int</span> n,ans[<span class="number">1000001</span>],z=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">while</span>(cin&gt;&gt;a)</span><br><span class="line"> &#123;</span><br><span class="line"> n++;</span><br><span class="line"> <span class="keyword">if</span>(a==b)</span><br><span class="line"> ans[z]++;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;ans[++z]++;</span><br><span class="line"> b=a;&#125;</span><br><span class="line"> &#125;</span><br><span class="line"> cout&lt;&lt;<span class="built_in">sqrt</span>(n);</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span> ; i&lt;=z ; i++)</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="USACO1-2-方块转换-Transformations"><a href="#USACO1-2-方块转换-Transformations" class="headerlink" title="[USACO1.2] 方块转换 Transformations"></a>[USACO1.2] 方块转换 Transformations</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>一块 n \times n 正方形的黑白瓦片的图案要被转换成新的正方形图案。写一个程序来找出将原始图案按照以下列转换方法转换成新图案的最小方式：</p><ul><li><p>转 90\degree：图案按顺时针转 90\degree。</p></li><li><p>转 180\degree：图案按顺时针转 180\degree。</p></li><li><p>转 270\degree：图案按顺时针转 270\degree。</p></li><li><p>反射：图案在水平方向翻转（以中央铅垂线为中心形成原图案的镜像）。</p></li><li><p>组合：图案在水平方向翻转，然后再按照 1 \sim 3 之间的一种再次转换。</p></li><li><p>不改变：原图案不改变。</p></li><li><p>无效转换：无法用以上方法得到新图案。</p></li></ul><p>如果有多种可用的转换方法，请选择序号最小的那个。</p><p>只使用上述 7 个中的一个步骤来完成这次转换。</p><h2 id="输入格式-19"><a href="#输入格式-19" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行一个正整数 n。   </p><p>然后 n 行，每行 n 个字符，全部为 <code>@</code> 或 <code>-</code>，表示初始的正方形。</p><p>接下来 n 行，每行 n 个字符，全部为 <code>@</code> 或 <code>-</code>，表示最终的正方形。</p><h2 id="输出格式-19"><a href="#输出格式-19" class="headerlink" title="输出格式"></a>输出格式</h2><p>单独的一行包括 1 \sim 7 之间的一个数字（在上文已描述）表明需要将转换前的正方形变为转换后的正方形的转换方法。</p><h2 id="样例-1-19"><a href="#样例-1-19" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-19"><a href="#样例输入-1-19" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">@-@</span><br><span class="line">---</span><br><span class="line">@@-</span><br><span class="line">@-@</span><br><span class="line">@--</span><br><span class="line">--@</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-19"><a href="#样例输出-1-19" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-18"><a href="#提示-18" class="headerlink" title="提示"></a>提示</h2><p>【数据范围】<br>对于 100% 的数据，1\le n \le 10。</p><p>题目翻译来自 NOCOW。</p><p>USACO Training Section 1.2</p><blockquote><p>大大大模拟</p></blockquote><p>抄代码了（）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">char</span> a[<span class="number">15</span>][<span class="number">15</span>],b[<span class="number">15</span>][<span class="number">15</span>],c[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        b[j][n-i+<span class="number">1</span>]=a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">     <span class="keyword">if</span>(b[i][j]!=c[i][j])</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        b[n-i+<span class="number">1</span>][n-j+<span class="number">1</span>]=a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">     <span class="keyword">if</span>(b[i][j]!=c[i][j])</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        b[n-j+<span class="number">1</span>][i]=a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">     <span class="keyword">if</span>(b[i][j]!=c[i][j])</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work4</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        b[i][n-j+<span class="number">1</span>]=a[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">     <span class="keyword">if</span>(b[i][j]!=c[i][j])</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work5</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">work4</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">      a[i][j]=b[i][j];  </span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">work1</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">      a[i][j]=b[i][j]; </span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">work2</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">      a[i][j]=b[i][j]; </span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">work3</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work6</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">     <span class="keyword">if</span>(b[i][j]!=c[i][j])</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">work1</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">work2</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">work3</span>())</span><br><span class="line">    &#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">work4</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">4</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">work5</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">5</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">work6</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="number">6</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">     &#123;</span><br><span class="line">     cin&gt;&gt;a[i][j];</span><br><span class="line"> &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">      cin&gt;&gt;c[i][j];</span><br><span class="line">    <span class="built_in">work</span>();</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷刷题3</title>
      <link href="/2024/02/06/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%983/"/>
      <url>/2024/02/06/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%983/</url>
      
        <content type="html"><![CDATA[<h1 id="洛谷刷题四"><a href="#洛谷刷题四" class="headerlink" title="洛谷刷题四"></a>洛谷刷题四</h1><h1 id="【深基4-例2】找最小值"><a href="#【深基4-例2】找最小值" class="headerlink" title="【深基4.例2】找最小值"></a>【深基4.例2】找最小值</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出 n 和 n 个整数 a_i，求这 n 个整数中最小值是什么。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 n，表示数字个数。</p><p>第二行输入 n 个非负整数，表示 a_1,a_2 \dots a_n，以空格隔开。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个非负整数，表示这 n 个非负整数中的最小值。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">1 9 2 6 0 8 1 7</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>数据保证，n\le100 且 0\le a_i \le 1000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,a[<span class="number">10001</span>];</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];<span class="comment">//循环输入</span></span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    cout&lt;&lt;a[<span class="number">1</span>];</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基4-例3】分类平均"><a href="#【深基4-例3】分类平均" class="headerlink" title="【深基4.例3】分类平均"></a>【深基4.例3】分类平均</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 n 和 k，将从 1 到 n 之间的所有正整数可以分为两类：A 类数可以被 k 整除（也就是说是 k 的倍数），而 B 类数不能。请输出这两类数的平均数，精确到小数点后 1 位，用空格隔开。</p><p>数据保证两类数的个数都不会是 0。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入两个正整数 n 与 k。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，两个实数，分别表示 A 类数与 B 类数的平均数。精确到小数点后一位。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 16</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">56.0 50.1</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \leq n\leq 10000，1 \leq k \leq 100。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> n1 = <span class="number">0</span>, n2 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">double</span> total1, total2;</span><br><span class="line"><span class="type">double</span> avg1, avg2;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">cin &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">n &gt;= <span class="number">1</span> &amp;&amp; n &lt;= <span class="number">10000</span>, k &gt;= <span class="number">1</span> &amp;&amp; k &lt;= <span class="number">100</span>, n &gt; k;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % k == <span class="number">0</span>)</span><br><span class="line">total1 += i, n1++;</span><br><span class="line"><span class="keyword">else</span> total2 += i, n2++;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">avg1 = total1 / n1;</span><br><span class="line">avg2 = total2 / n2;</span><br><span class="line">cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">1</span>) &lt;&lt; fixed &lt;&lt; avg1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; avg2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基4-例4】一尺之棰"><a href="#【深基4-例4】一尺之棰" class="headerlink" title="【深基4.例4】一尺之棰"></a>【深基4.例4】一尺之棰</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>《庄子》中说到，“一尺之棰，日取其半，万世不竭”。第一天有一根长度为 a 的木棍，从第二天开始，每天都要将这根木棍锯掉一半（每次除 2，向下取整）。第几天的时候木棍的长度会变为 1？</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个正整数 a，表示木棍长度。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个正整数，表示要第几天的时候木棍长度会变为 1。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \le a\le 10^9。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a, ans = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span> (<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line"><span class="keyword">while</span> (a &gt; <span class="number">1</span>) &#123;</span><br><span class="line">ans++; </span><br><span class="line">a /= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; ans ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基4-例6】数字直角三角形"><a href="#【深基4-例6】数字直角三角形" class="headerlink" title="【深基4.例6】数字直角三角形"></a>【深基4.例6】数字直角三角形</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出 n，请输出一个直角边长度是 n 的数字直角三角形。所有数字都是 2 位组成的，如果没有 2 位则加上前导 0。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个正整数 n。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出如题目要求的数字直角三角形。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0102030405</span><br><span class="line">06070809</span><br><span class="line">101112</span><br><span class="line">1314</span><br><span class="line">15</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1\le n\le13。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="type">int</span> cnt=<span class="number">0</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">cnt++;</span><br><span class="line"><span class="keyword">if</span>(cnt&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,cnt);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h1 id="NOIP1998-普及组-阶乘之和"><a href="#NOIP1998-普及组-阶乘之和" class="headerlink" title="[NOIP1998 普及组] 阶乘之和"></a>[NOIP1998 普及组] 阶乘之和</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>用高精度计算出 S &#x3D; 1! + 2! + 3! + \cdots + n!（n \le 50）。</p><p>其中 <code>!</code> 表示阶乘，定义为 n!&#x3D;n\times (n-1)\times (n-2)\times \cdots \times 1。例如，5! &#x3D; 5 \times 4 \times 3 \times 2 \times 1&#x3D;120。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>一个正整数 n。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个正整数 S，表示计算结果。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p><strong>【数据范围】</strong></p><p>对于 100 % 的数据，1 \le n \le 50。</p><p><strong>【其他说明】</strong></p><p>注，《深入浅出基础篇》中使用本题作为例题，但是其数据范围只有 n \le 20，使用书中的代码无法通过本题。</p><p>如果希望通过本题，请继续学习第八章高精度的知识。</p><p>NOIP1998 普及组 第二题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本题很直观</span></span><br><span class="line"><span class="comment">//只是需要高精度</span></span><br><span class="line"><span class="comment">//前置条件，和只有100位数字</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1005</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">1005</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> i, j;</span><br><span class="line">a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">b[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">2</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line">b[j] *= i;</span><br><span class="line"><span class="comment">//每一位都进行乘法，但×的数字范围会随着i增大而缩小，模拟每个数的阶乘</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (b[j]&gt;<span class="number">9</span>)</span><br><span class="line">&#123;</span><br><span class="line">b[j + <span class="number">1</span>] += b[j] / <span class="number">10</span>;</span><br><span class="line">b[j] = b[j] % <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//对b进行高精度</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">100</span>; j++) &#123;</span><br><span class="line">a[j] += b[j];</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; <span class="number">9</span>) &#123;</span><br><span class="line">a[j + <span class="number">1</span>] += a[j] / <span class="number">10</span>;</span><br><span class="line">a[j] %= <span class="number">10</span>;</span><br><span class="line">                <span class="comment">//a记录b数组的值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">100</span>; i &gt;= <span class="number">0</span> &amp;&amp; a[i] == <span class="number">0</span>; i--);</span><br><span class="line">    <span class="comment">//去前导0</span></span><br><span class="line"><span class="keyword">for</span> ( j = i; j &gt;=<span class="number">0</span>; j--)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[j];</span><br><span class="line">        <span class="comment">//倒序输出</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2013-普及组-计数问题"><a href="#NOIP2013-普及组-计数问题" class="headerlink" title="[NOIP2013 普及组] 计数问题"></a>[NOIP2013 普及组] 计数问题</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2013 普及组 T1</p><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>试计算在区间 1 到 n 的所有整数中，数字 x（0\le x\le9）共出现了多少次？例如，在 1 到 11 中，即在 1,2,3,4,5,6,7,8,9,10,11 中，数字 1 出现了 4 次。</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>2 个整数 n,x，之间用一个空格隔开。</p><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>1 个整数，表示 x 出现的次数。</p><h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">11 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>对于 100% 的数据，1\le n\le 10^6，0\le x \le 9。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n,i,x,b,c,t=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        b=i;</span><br><span class="line">        <span class="keyword">while</span>(b!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c=b%<span class="number">10</span>;</span><br><span class="line">            b=b/<span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span>(c==x) t++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数的分解罢了</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2002-普及组-级数求和"><a href="#NOIP2002-普及组-级数求和" class="headerlink" title="[NOIP2002 普及组] 级数求和"></a>[NOIP2002 普及组] 级数求和</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知：S_n&#x3D; 1+\dfrac{1}{2}+\dfrac{1}{3}+…+\dfrac{1}{n}。显然对于任意一个整数 k，当 n 足够大的时候，S_n&gt;k。</p><p>现给出一个整数 k，要求计算出一个最小的 n，使得 S_n&gt;k。</p><h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>一个正整数 k。</p><h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个正整数 n。</p><h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p><strong>【数据范围】</strong></p><p>对于 100% 的数据，1\le k \le 15。</p><p><strong>【题目来源】</strong></p><p>NOIP 2002 普及组第一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> k,n=<span class="number">0</span>;<span class="comment">//直接定义</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> Sn=<span class="number">0</span>;Sn&lt;=k;++n,Sn+=<span class="number">1.0</span>/n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,n);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><h1 id="NOIP2015-普及组-金币"><a href="#NOIP2015-普及组-金币" class="headerlink" title="[NOIP2015 普及组] 金币"></a>[NOIP2015 普及组] 金币</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2015 普及组 T1</p><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>国王将金币作为工资，发放给忠诚的骑士。第一天，骑士收到一枚金币；之后两天（第二天和第三天），每天收到两枚金币；之后三天（第四、五、六天），每天收到三枚金币；之后四天（第七、八、九、十天），每天收到四枚金币……；这种工资发放模式会一直这样延续下去：当连续 n 天每天收到 n 枚金币后，骑士会在之后的连续 n+1 天里，每天收到 n+1 枚金币。</p><p>请计算在前 k 天里，骑士一共获得了多少金币。</p><h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>一个正整数 k，表示发放金币的天数。</p><h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个正整数，即骑士收到的金币数。</p><h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1000</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">29820</span><br></pre></td></tr></table></figure><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p><strong>【样例 1 说明】</strong></p><p>骑士第一天收到一枚金币；第二天和第三天，每天收到两枚金币；第四、五、六天，每天收到三枚金币。因此一共收到 1+2+2+3+3+3&#x3D;14 枚金币。</p><p>对于 100% 的数据，1\le k\le 10^4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> k,coins = <span class="number">0</span>,days=<span class="number">0</span>;</span><br><span class="line">    cin &gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= k;i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;j &lt;= i;j++)</span><br><span class="line">        &#123;           </span><br><span class="line">            coins += i;</span><br><span class="line">            <span class="comment">//-----------</span></span><br><span class="line">            days++;</span><br><span class="line">            <span class="comment">//-----------</span></span><br><span class="line">            <span class="comment">//神来之笔！！！</span></span><br><span class="line">            <span class="keyword">if</span> ( days == k) </span><br><span class="line">            &#123;   </span><br><span class="line">                cout&lt;&lt;coins;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基4-例11】数列求和"><a href="#【深基4-例11】数列求和" class="headerlink" title="【深基4.例11】数列求和"></a>【深基4.例11】数列求和</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>计算 1+2+3+\cdots+(n-1)+n 的值，其中正整数 n 不大于 100。由于你没有高斯聪明，所以你不被允许使用等差数列求和公式直接求出答案。</p><h2 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个正整数 n。</p><h2 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个正整数，表示最后求和的答案。</p><h2 id="样例-1-8"><a href="#样例-1-8" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-8"><a href="#样例输入-1-8" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-8"><a href="#样例输出-1-8" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5050</span><br></pre></td></tr></table></figure><h2 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \leq n \leq 100。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,n;</span><br><span class="line">    cin&gt;&gt;n;<span class="comment">//输入</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    a+=i;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;a;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,x;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">isprime</span><span class="params">(<span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i*i&lt;=y; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(y%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">if</span>(n&lt;<span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;2\n1\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;i!=<span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(sum+i&gt;n) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,x);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">isprime</span>(i)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">sum+=i;</span><br><span class="line">x++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="USACO1-5-回文质数-Prime-Palindromes"><a href="#USACO1-5-回文质数-Prime-Palindromes" class="headerlink" title="[USACO1.5] 回文质数 Prime Palindromes"></a>[USACO1.5] 回文质数 Prime Palindromes</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>因为 151 既是一个质数又是一个回文数（从左到右和从右到左是看一样的），所以 151 是回文质数。</p><p>写一个程序来找出范围 [a,b] (5 \le a &lt; b \le 100,000,000)（一亿）间的所有回文质数。</p><h2 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入两个正整数 a 和 b。</p><h2 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个回文质数的列表，一行一个。</p><h2 id="样例-1-9"><a href="#样例-1-9" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-9"><a href="#样例输入-1-9" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 500</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-9"><a href="#样例输出-1-9" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">7</span><br><span class="line">11</span><br><span class="line">101</span><br><span class="line">131</span><br><span class="line">151</span><br><span class="line">181</span><br><span class="line">191</span><br><span class="line">313</span><br><span class="line">353</span><br><span class="line">373</span><br><span class="line">383</span><br></pre></td></tr></table></figure><h2 id="提示-9"><a href="#提示-9" class="headerlink" title="提示"></a>提示</h2><p>Hint 1: Generate the palindromes and see if they are prime.</p><p>提示 1: 找出所有的回文数再判断它们是不是质数（素数）.</p><p>Hint 2: Generate palindromes by combining digits properly. You might need more than one of the loops like below.</p><p>提示 2: 要产生正确的回文数，你可能需要几个像下面这样的循环。</p><p>题目翻译来自NOCOW。</p><p>USACO Training Section 1.5</p><p>产生长度为 5 的回文数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (d1 = <span class="number">1</span>; d1 &lt;= <span class="number">9</span>; d1+=<span class="number">2</span>) &#123;    <span class="comment">// 只有奇数才会是素数</span></span><br><span class="line">     <span class="keyword">for</span> (d2 = <span class="number">0</span>; d2 &lt;= <span class="number">9</span>; d2++) &#123;</span><br><span class="line">         <span class="keyword">for</span> (d3 = <span class="number">0</span>; d3 &lt;= <span class="number">9</span>; d3++) &#123;</span><br><span class="line">           palindrome = <span class="number">10000</span>*d1 + <span class="number">1000</span>*d2 +<span class="number">100</span>*d3 + <span class="number">10</span>*d2 + d1;<span class="comment">//(处理回文数...)</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"><span class="type">int</span> d1, d2, i, y, q;</span><br><span class="line"><span class="type">int</span> a1, a2;</span><br><span class="line">cin &gt;&gt; a1 &gt;&gt; a2;</span><br><span class="line"><span class="keyword">for</span> (i = a1; i &lt;= a2; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i%<span class="number">2</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">       <span class="keyword">if</span>(i%<span class="number">3</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">5</span>==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">d2 = <span class="number">0</span>;</span><br><span class="line">d1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> x = <span class="number">2</span>; x * x &lt;= i; x++)</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">if</span> (i % x == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">d1 = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">y = i;</span><br><span class="line"><span class="type">int</span> a3 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (y != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">q = y % <span class="number">10</span>;</span><br><span class="line">a3 = a3 * <span class="number">10</span> + q;</span><br><span class="line">y = y / <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a3 != i) &#123; d2 = <span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (d1 + d2 == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//质数和回文</span></span><br></pre></td></tr></table></figure><h1 id="小玉在游泳"><a href="#小玉在游泳" class="headerlink" title="小玉在游泳"></a>小玉在游泳</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>小玉开心的在游泳，可是她很快难过的发现，自己的力气不够，游泳好累哦。已知小玉第一步能游 2 米，可是随着越来越累，力气越来越小，她接下来的每一步都只能游出上一步距离的 98%。现在小玉想知道，如果要游到距离 s 米的地方，她需要游多少步呢。请你编程解决这个问题。</p><h2 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个实数 s（单位：米），表示要游的目标距离。</p><h2 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示小玉一共需要游多少步。</p><h2 id="样例-1-10"><a href="#样例-1-10" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-10"><a href="#样例输入-1-10" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-10"><a href="#样例输出-1-10" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-10"><a href="#提示-10" class="headerlink" title="提示"></a>提示</h2><p>数据保证，0 \leq s &lt; 100，且 s 小数点后最多只有一位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">double</span> x;  cin&gt;&gt;x;  </span><br><span class="line">  <span class="type">double</span> sum=<span class="number">0</span>;   </span><br><span class="line">  <span class="type">int</span> ans=<span class="number">0</span>;             </span><br><span class="line">  <span class="type">double</span> tmp=<span class="number">2</span>;    </span><br><span class="line">  <span class="keyword">while</span>(sum&lt;=x) </span><br><span class="line">  &#123; </span><br><span class="line">    sum=sum+tmp; </span><br><span class="line">    tmp=tmp*<span class="number">0.98</span>; </span><br><span class="line">    ans++;          </span><br><span class="line">  &#125;</span><br><span class="line">  cout&lt;&lt;ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2011-普及组-数字反转"><a href="#NOIP2011-普及组-数字反转" class="headerlink" title="[NOIP2011 普及组] 数字反转"></a>[NOIP2011 普及组] 数字反转</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数 N，请将该数各个位上数字反转得到一个新数。新数也应满足整数的常见形式，即除非给定的原数为零，否则反转后得到的新数的最高位数字不应为零（参见样例 2）。</p><h2 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h2><p>一个整数 N。</p><h2 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示反转后的新数。</p><h2 id="样例-1-11"><a href="#样例-1-11" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-11"><a href="#样例输入-1-11" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-11"><a href="#样例输出-1-11" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">321</span><br></pre></td></tr></table></figure><h2 id="样例-2-1"><a href="#样例-2-1" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-1"><a href="#样例输入-2-1" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-380</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1"><a href="#样例输出-2-1" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-83</span><br></pre></td></tr></table></figure><h2 id="提示-11"><a href="#提示-11" class="headerlink" title="提示"></a>提示</h2><p><strong>【数据范围】</strong></p><p>-1,000,000,000\leq N\leq 1,000,000,000 。</p><p>noip2011 普及组第一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,s=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">while</span>(n) s=s*<span class="number">10</span>+n%<span class="number">10</span>,n/=<span class="number">10</span>;</span><br><span class="line">    <span class="comment">//分解</span></span><br><span class="line">    cout&lt;&lt;s;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="月落乌啼算钱（斐波那契数列）"><a href="#月落乌啼算钱（斐波那契数列）" class="headerlink" title="月落乌啼算钱（斐波那契数列）"></a>月落乌啼算钱（斐波那契数列）</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>（本道题目木有隐藏歌曲……不用猜了……）</p><p>《爱与愁的故事第一弹·heartache》最终章。</p><p>吃完 pizza，月落乌啼知道超出自己的预算了。为了不在爱与愁大神面前献丑，只好还是硬着头皮去算钱……</p><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>算完钱后，月落乌啼想着：“你坑我！”于是当爱与愁大神问多少钱时，月落乌啼说了一堆乱码。爱与愁大神说：“算了算了，我只问第 n 样菜价格多少？”月落乌啼写出了：</p><p>F_n&#x3D;\dfrac{\left(\frac{1+\sqrt{5}}{2}\right)^n-\left(\frac{1-\sqrt{5}}{2}\right)^n}{\sqrt{5}}</p><p>由于爱与愁大神学过编程，于是就用 1 分钟的时间求出了 F_n 的结果。月落乌啼为此大吃一惊。你能学学爱与愁大神求出 F_n 的值吗？</p><h2 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行一个自然数 n。</p><h2 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h2><p>只有 1 行一个实数 F_n，保留两位小数。</p><h2 id="样例-1-12"><a href="#样例-1-12" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-12"><a href="#样例输入-1-12" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-12"><a href="#样例输出-1-12" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">8.00</span><br></pre></td></tr></table></figure><h2 id="提示-12"><a href="#提示-12" class="headerlink" title="提示"></a>提示</h2><p>对于所有数据：0 \leq n\leq 48。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[<span class="number">50</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        f[i] = f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>];<span class="comment">//按照斐波那契的公式算。</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; f[n] &lt;&lt; <span class="string">&quot;.00&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基4-习5】求极差-最大跨度值"><a href="#【深基4-习5】求极差-最大跨度值" class="headerlink" title="【深基4.习5】求极差 &#x2F; 最大跨度值"></a>【深基4.习5】求极差 &#x2F; 最大跨度值</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出 n 和 n 个整数 a_i，求这 n 个整数中的极差是什么。极差的意思是一组数中的最大值减去最小值的差。</p><h2 id="输入格式-13"><a href="#输入格式-13" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 n，表示整数个数。</p><p>第二行输入 n 个整数 a_1,a_2 \dots a_n，以空格隔开。</p><h2 id="输出格式-13"><a href="#输出格式-13" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示这 n 个整数的极差。</p><h2 id="样例-1-13"><a href="#样例-1-13" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-13"><a href="#样例输入-1-13" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">4 1 5 1 4 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-13"><a href="#样例输出-1-13" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h2 id="提示-13"><a href="#提示-13" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1 \leq n\leq 100，0\le a_i \le 1000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">cout&lt;&lt;a[n]-a[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="最长连号"><a href="#最长连号" class="headerlink" title="最长连号"></a>最长连号</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入长度为 n 的一个正整数序列，要求输出序列中最长连号的长度。</p><p>连号指在序列中，从小到大的连续自然数。</p><h2 id="输入格式-14"><a href="#输入格式-14" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，一个整数 n。</p><p>第二行，n 个整数 a_i，之间用空格隔开。</p><h2 id="输出格式-14"><a href="#输出格式-14" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数，最长连号的个数。</p><h2 id="样例-1-14"><a href="#样例-1-14" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-14"><a href="#样例输入-1-14" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">1 5 6 2 3 4 5 6 8 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-14"><a href="#样例输出-1-14" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示-14"><a href="#提示-14" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于 100% 的数据，保证 1 \leq n \leq 10^4，1 \leq a_i \leq 10^9。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, n0, t = <span class="number">1</span>, b = <span class="number">1</span>, ni;<span class="comment">//n与ni交替</span></span><br><span class="line">cin &gt;&gt; n &gt;&gt; n0;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; ni;</span><br><span class="line"><span class="keyword">if</span> (n0 + <span class="number">1</span> == ni) &#123; t++; &#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">b = <span class="built_in">max</span>(b, t);</span><br><span class="line"> t = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">n0 = ni;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="NOIP2012-普及组-质因数分解"><a href="#NOIP2012-普及组-质因数分解" class="headerlink" title="[NOIP2012 普及组] 质因数分解"></a>[NOIP2012 普及组] 质因数分解</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>已知正整数 n 是两个不同的质数的乘积，试求出两者中较大的那个质数。</p><h2 id="输入格式-15"><a href="#输入格式-15" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个正整数 n。</p><h2 id="输出格式-15"><a href="#输出格式-15" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个正整数 p，即较大的那个质数。</p><h2 id="样例-1-15"><a href="#样例-1-15" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-15"><a href="#样例输入-1-15" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-15"><a href="#样例输出-1-15" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure><h2 id="提示-15"><a href="#提示-15" class="headerlink" title="提示"></a>提示</h2><p>1 \le n\le 2\times 10^9</p><p>NOIP 2012 普及组 第一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;<span class="built_in">sqrt</span>(n); i++) <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123; </span><br><span class="line">        cout &lt;&lt; n/i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基4-习8】求三角形"><a href="#【深基4-习8】求三角形" class="headerlink" title="【深基4.习8】求三角形"></a>【深基4.习8】求三角形</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>模仿例题，打印出不同方向的正方形，然后打印三角形矩阵。中间有个空行。</p><h2 id="输入格式-16"><a href="#输入格式-16" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入矩阵的规模，不超过 9。</p><h2 id="输出格式-16"><a href="#输出格式-16" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出矩形和正方形</p><h2 id="样例-1-16"><a href="#样例-1-16" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-16"><a href="#样例输入-1-16" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-16"><a href="#样例输出-1-16" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">01020304</span><br><span class="line">05060708</span><br><span class="line">09101112</span><br><span class="line">13141516</span><br><span class="line"></span><br><span class="line">      01</span><br><span class="line">    0203</span><br><span class="line">  040506</span><br><span class="line">07080910</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> n; </span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * n; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">10</span>)</span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;0%d&quot;</span>, i); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, i); &#125;</span><br><span class="line">    <span class="keyword">if</span>(i % n == <span class="number">0</span>) </span><br><span class="line">    &#123; <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  <span class="type">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n - i; j ++) &#123; <span class="built_in">printf</span>(<span class="string">&quot;  &quot;</span>); &#125;</span><br><span class="line">    <span class="keyword">while</span>(cnt &lt;= i * (i + <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span>(cnt &lt; <span class="number">10</span>) &#123; <span class="built_in">printf</span>(<span class="string">&quot;0%d&quot;</span>, cnt); &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, cnt); &#125;</span><br><span class="line">      cnt ++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//模拟即可</span></span><br></pre></td></tr></table></figure><h1 id="【深基4-习9】打分"><a href="#【深基4-习9】打分" class="headerlink" title="【深基4.习9】打分"></a>【深基4.习9】打分</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在有 n(n \le 1000) 位评委给选手打分，分值从 0 到 10。需要去掉一个最高分，去掉一个最低分（如果有多个最高或者最低分，也只需要去掉一个），剩下的评分的平均数就是这位选手的得分。现在输入评委人数和他们的打分，请输出选手的最后得分，精确到 2 位小数。</p><h2 id="输入格式-17"><a href="#输入格式-17" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入一个正整数 n，表示有 n 个评委。</p><p>第二行输入 n 个正整数，第 i 个正整数表示第 i 个评委打出的分值。</p><h2 id="输出格式-17"><a href="#输出格式-17" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个两位小数，表示选手的最后得分。</p><h2 id="样例-1-17"><a href="#样例-1-17" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-17"><a href="#样例输入-1-17" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">9 5 6 8 9</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-17"><a href="#样例输出-1-17" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7.67</span><br></pre></td></tr></table></figure><h2 id="提示-16"><a href="#提示-16" class="headerlink" title="提示"></a>提示</h2><p>数据保证，3 \leq n \leq 1000，每个评委打出的分值为为 0 到 10（含 0 与 10）之间的整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">10001</span>];</span><br><span class="line"><span class="type">double</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) cin&gt;&gt;a[i];</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n<span class="number">-1</span>;i++) ans+=a[i];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.2f&quot;</span>,ans/(n<span class="number">-2</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="COCI2017-2018-6-Davor"><a href="#COCI2017-2018-6-Davor" class="headerlink" title="[COCI2017-2018#6] Davor"></a>[COCI2017-2018#6] Davor</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>在征服南极之后，Davor 开始了一项新的挑战。下一步是在西伯利亚、格林兰、挪威的北极圈远征。他将在 2018 年 12 月 31 日开始出发，在这之前需要一共筹集 n 元钱。他打算在每个星期一筹集 x 元，星期二筹集 x+k 元，……，星期日筹集 x+6k 元，并连续筹集 52 个星期。其中 x,k 为正整数，并且满足 1 \le x \le 100。</p><p>现在请你帮忙计算 x,k 为多少时，能刚好筹集 n 元。</p><p>如果有多个答案，输出 x 尽可能大，k 尽可能小的。注意 k 必须大于 0。</p><h2 id="题目描述-18"><a href="#题目描述-18" class="headerlink" title="题目描述"></a>题目描述</h2><p>After successfully conquering the South Pole, Davor is preparing for new challenges. Next up is the Arctic expedition to Siberia, Greenland and Norway. He begins his travels on 31 December 2018, and needs to collect N kunas (Croatian currency) by then. In order to do this, he has decided to put away X (X ≤ 100) kunas every Monday to his travel fund, X + K kunas every Tuesday, X + 2* K every Wednesday, and so on until Sunday, when he will put away X + 6* K kunas. This way, he will collect money for 52 weeks, starting with 1 January 2018 (Monday) until 30 December 2018 (Sunday).</p><p>If we know the amount of money N, output the values X and K so that it is possible to collect the <strong>exact</strong> money amount in the given timespan. The solution will always exist, and if there are multiple, output the one with the greatest X  and smallest K .</p><h2 id="输入格式-18"><a href="#输入格式-18" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line of input contains the integer N (1456 ≤ N ≤ 145600), the number from the task.</p><h2 id="输出格式-18"><a href="#输出格式-18" class="headerlink" title="输出格式"></a>输出格式</h2><p>The first line of output must contain the value of X (0 &lt; X ≤ 100 ), and the second the value of<br>K (K &gt; 0 ).</p><h2 id="样例-1-18"><a href="#样例-1-18" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-18"><a href="#样例输入-1-18" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1456</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-18"><a href="#样例输出-1-18" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-2-2"><a href="#样例-2-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-2"><a href="#样例输入-2-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6188</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2"><a href="#样例输出-2-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">14</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">40404</span><br></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">99</span><br><span class="line">4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> x,k=<span class="number">1</span>,n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(x=<span class="number">100</span>;x&gt;=<span class="number">1</span>;x--)</span><br><span class="line">&#123;<span class="keyword">if</span>((<span class="number">7</span>*x+<span class="number">21</span>*k)*<span class="number">52</span>==n)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;x&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">cout&lt;&lt;k;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2004-提高组-津津的储蓄计划"><a href="#NOIP2004-提高组-津津的储蓄计划" class="headerlink" title="[NOIP2004 提高组] 津津的储蓄计划"></a>[NOIP2004 提高组] 津津的储蓄计划</h1><h2 id="题目描述-19"><a href="#题目描述-19" class="headerlink" title="题目描述"></a>题目描述</h2><p>津津的零花钱一直都是自己管理。每个月的月初妈妈给津津 300 元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。</p><p>为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上 20% 还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于 100 元或恰好 100 元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。</p><p>例如 11月初津津手中还有 83 元，妈妈给了津津 300 元。津津预计11月的花销是 180 元，那么她就会在妈妈那里存 200 元，自己留下 183 元。到了 11 月月末，津津手中会剩下 3 元钱。</p><p>津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。</p><p>现在请你根据 2004 年 1 月到 12 月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到 2004 年年末，妈妈将津津平常存的钱加上 20% 还给津津之后，津津手中会有多少钱。</p><h2 id="输入格式-19"><a href="#输入格式-19" class="headerlink" title="输入格式"></a>输入格式</h2><p>12 行数据，每行包含一个小于 350 的非负整数，分别表示 1 月到 12 月津津的预算。</p><h2 id="输出格式-19"><a href="#输出格式-19" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出 -X，X 表示出现这种情况的第一个月；否则输出到 2004 年年末津津手中会有多少钱。</p><p>注意，洛谷不需要进行文件输入输出，而是标准输入输出。</p><h2 id="样例-1-19"><a href="#样例-1-19" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-19"><a href="#样例输入-1-19" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">290</span><br><span class="line">230</span><br><span class="line">280</span><br><span class="line">200</span><br><span class="line">300</span><br><span class="line">170</span><br><span class="line">340</span><br><span class="line">50 </span><br><span class="line">90 </span><br><span class="line">80 </span><br><span class="line">200</span><br><span class="line">60</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-19"><a href="#样例输出-1-19" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-7</span><br></pre></td></tr></table></figure><h2 id="样例-2-3"><a href="#样例-2-3" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-3"><a href="#样例输入-2-3" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">290 </span><br><span class="line">230 </span><br><span class="line">280 </span><br><span class="line">200 </span><br><span class="line">300 </span><br><span class="line">170 </span><br><span class="line">330 </span><br><span class="line">50 </span><br><span class="line">90 </span><br><span class="line">80 </span><br><span class="line">200 </span><br><span class="line">60</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3"><a href="#样例输出-2-3" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1580</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> c,s=<span class="number">0</span>,h=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">12</span>;i++)         </span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;c);                </span><br><span class="line">                s-=c<span class="number">-300</span>;   <span class="comment">//当前还有钱吗                      </span></span><br><span class="line">                <span class="keyword">if</span>(s&lt;<span class="number">0</span>)                             </span><br><span class="line">                &#123;</span><br><span class="line">                        <span class="built_in">printf</span>(<span class="string">&quot;-%d&quot;</span>,i);              </span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;                        </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> h+=s/<span class="number">100</span>,s%=<span class="number">100</span>;    <span class="comment">//记录 </span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,<span class="number">120</span>*h+s);                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷刷题2</title>
      <link href="/2024/02/06/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%982/"/>
      <url>/2024/02/06/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%982/</url>
      
        <content type="html"><![CDATA[<h1 id="洛谷刷题第二讲"><a href="#洛谷刷题第二讲" class="headerlink" title="洛谷刷题第二讲"></a>洛谷刷题第二讲</h1><h1 id="【深基1-2】小学数学-N-合一"><a href="#【深基1-2】小学数学-N-合一" class="headerlink" title="【深基1-2】小学数学 N 合一"></a>【深基1-2】小学数学 N 合一</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题 1"></a>问题 1</h3><p>请输出 <code>I love Luogu!</code></p><h3 id="问题-2"><a href="#问题-2" class="headerlink" title="问题 2"></a>问题 2</h3><p>这里有 10 个苹果，小 A 拿走了 2 个，Uim 拿走了 4 个，八尾勇拿走剩下的所有的苹果。我们想知道：</p><ol><li>小A 和 Uim 两个人一共拿走多少苹果？</li><li>八尾勇能拿走多少苹果？</li></ol><p>现在需要编写一个程序，输出两个数字作为答案，中间使用空格分开。</p><h3 id="问题-3"><a href="#问题-3" class="headerlink" title="问题 3"></a>问题 3</h3><p>现在有 14 个苹果。要均分给 4 名同学，分不掉的苹果放回冰箱。请问：</p><ol><li><p>每位同学能分得几个苹果？</p></li><li><p>一共分出去多少苹果？</p></li><li><p>把几个苹果放回冰箱？</p><p>  现在需要编写一个程序，输出三个数字作为答案，每个数字一行。</p></li></ol><h3 id="问题-4"><a href="#问题-4" class="headerlink" title="问题 4"></a>问题 4</h3><p>现在有 500 毫升的肥宅快乐水，要均分给 3 名同学，每位同学可以分到多少毫升？请输出一个数字作为输出。保留 6 位有效数字，且不使用科学计数法。</p><h3 id="问题-5"><a href="#问题-5" class="headerlink" title="问题 5"></a>问题 5</h3><p>甲列火车长 260 米，每秒行 12 米；乙列火车长 220 米，每秒行 20 米，两车相向而行，从两车车头相遇时开始计时，多长时间后两车车尾相离？已知答案是整数。</p><h3 id="问题-6"><a href="#问题-6" class="headerlink" title="问题 6"></a>问题 6</h3><p>一个长方形长宽分别是 6 \text{ cm}、9 \text{ cm}，求它的对角线长度（\text{cm}）。直接使用 <code>cout</code> 输出。</p><h3 id="问题-7"><a href="#问题-7" class="headerlink" title="问题 7"></a>问题 7</h3><p>Uim 银行账户里面有 100 元。经过了下面的操作：</p><ol><li><p>往里面存了 10 元；</p></li><li><p>购物花掉了 20 元；</p></li><li><p>把里面的钱全部取出。</p><p>  请在每次操作后输出账户余额，并使用换行符隔开。</p></li></ol><h3 id="问题-8"><a href="#问题-8" class="headerlink" title="问题 8"></a>问题 8</h3><p>当半径为 r&#x3D;5，请输出圆的周长、面积和球体积。取 \pi&#x3D;3.141593。请直接使用 <code>cout</code> 输出答案，每行一个数字。</p><h3 id="问题-9"><a href="#问题-9" class="headerlink" title="问题 9"></a>问题 9</h3><p>一只小猴买了若干个桃子。第一天他刚好吃了这些桃子的一半，又贪嘴多吃了一个；第二天他也刚好吃了剩余桃子的一半，贪嘴多吃了一个；第三天他又刚好吃了剩下的桃子的一半，并贪嘴多吃了一个。第四天起来一看，发现桃子只剩下一个了。请问小猴买了几个桃子？</p><h3 id="问题-10"><a href="#问题-10" class="headerlink" title="问题 10"></a>问题 10</h3><p>洛谷的评测任务是单位时间内均匀增加的。8 台评测机 30 分钟可以刚好把评测队列中的程序评测完毕，10 台评测机 6 分钟可以刚好把评测队列中的程序评测完毕，请问几台评测机可以在 10 分钟时刚好把评测队列中的程序评测完毕？</p><h3 id="问题-11"><a href="#问题-11" class="headerlink" title="问题 11"></a>问题 11</h3><p>小 A 跑步速度 5 \text{ m&#x2F;s}，八尾勇跑步速度 8 \text{ m&#x2F;s}，八尾勇在小 A 后面 100 \text{ m}，他们同时起跑，请问需要多长时间八尾勇可以追上小 A？输出一个数字表示答案，使用 <code>cout</code> 直接输出。</p><h3 id="问题-12"><a href="#问题-12" class="headerlink" title="问题 12"></a>问题 12</h3><p>大家都知道有 26 个英文字母，其中 A 是第一个字母。现在请编程求出：</p><ol><li>M 是字母表中的第几个字母？</li><li>第 18 个字母是什么？</li></ol><p>输出一个数字和一个字母，使用换行隔开。</p><h3 id="问题-13"><a href="#问题-13" class="headerlink" title="问题 13"></a>问题 13</h3><p>小 A 有两块球形橡皮泥，一个半径是 4，一个半径是 10。他想把这两块橡皮泥揉在一起，然后塑造成一个正方体，请问这个正方体的棱长是多少？如果结果不是整数，则舍去小数点之后的数字。取 \pi &#x3D; 3.141593。</p><h3 id="问题-14"><a href="#问题-14" class="headerlink" title="问题 14"></a>问题 14</h3><p>根据咕咕网校的预测，当课程定价为 110 元时，会有 10 人报名。如果课程价格每降低 1 元，就会多 1 名报名者（反之亦然）。如果希望总共能收到 3500 元学费的话，那么应该定价多少呢？已知本题有两个答案符合要求，则取较小的那一个。如果这个答案不是整数，则需四舍五入精确到整数。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个正整数，表示第几个问题。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>根据所输入的问题编号，输出对应问题的答案。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 4</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>请解决以下小学数学题。你可以提交答案，也可以写一个程序。</p><p>对于本题来说，如果你不知道怎么输入，也可以这么抄：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">// 填上你觉得需要的其他头文件</span><br><span class="line">using namespace std;</span><br><span class="line">int main() &#123;</span><br><span class="line">    int T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    if (T == 1) &#123;</span><br><span class="line">        // 粘贴问题 1 的主函数代码，除了 return 0</span><br><span class="line">        cout &lt;&lt; &quot;I love Luogu!&quot;;</span><br><span class="line">    &#125; else if (T == 2) &#123;</span><br><span class="line">        // 粘贴问题 2 的主函数代码，除了 return 0</span><br><span class="line">        cout &lt;&lt; 2 + 4 &lt;&lt; &quot; &quot; &lt;&lt; 10 - 2 - 4;</span><br><span class="line">    &#125; else if (T == 3) &#123;</span><br><span class="line">        // 请自行完成问题 3 的代码</span><br><span class="line">    &#125; else if (T == 4) &#123;</span><br><span class="line">        // 请自行完成问题 4 的代码</span><br><span class="line">    &#125; else if (T == 5) &#123;</span><br><span class="line">        // 请自行完成问题 5 的代码</span><br><span class="line">    &#125; else if (T == 6) &#123;</span><br><span class="line">        // 请自行完成问题 6 的代码</span><br><span class="line">    &#125; else if (T == 7) &#123;</span><br><span class="line">        // 请自行完成问题 7 的代码</span><br><span class="line">    &#125; else if (T == 8) &#123;</span><br><span class="line">        // 请自行完成问题 8 的代码</span><br><span class="line">    &#125; else if (T == 9) &#123;</span><br><span class="line">        // 请自行完成问题 9 的代码</span><br><span class="line">    &#125; else if (T == 10) &#123;</span><br><span class="line">        // 请自行完成问题 10 的代码</span><br><span class="line">    &#125; else if (T == 11) &#123;</span><br><span class="line">        // 请自行完成问题 11 的代码</span><br><span class="line">    &#125; else if (T == 12) &#123;</span><br><span class="line">        // 请自行完成问题 12 的代码</span><br><span class="line">    &#125; else if (T == 13) &#123;</span><br><span class="line">        // 请自行完成问题 13 的代码</span><br><span class="line">    &#125; else if (T == 14) &#123;</span><br><span class="line">        // 请自行完成问题 14 的代码</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">if</span> (T == <span class="number">1</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I love Luogu!&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T == <span class="number">2</span>) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">2</span> + <span class="number">4</span> &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="number">10</span> - <span class="number">2</span> - <span class="number">4</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T == <span class="number">3</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">3</span>&lt;&lt;endl&lt;&lt;<span class="number">12</span>&lt;&lt;endl&lt;&lt;<span class="number">2</span>&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n&quot;</span>,<span class="number">500.0</span>/<span class="number">3.0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T == <span class="number">5</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">15</span>&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T == <span class="number">6</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sqrt</span>(<span class="number">6</span>*<span class="number">6</span>+<span class="number">9</span>*<span class="number">9</span>)&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T == <span class="number">7</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">110</span>&lt;&lt;endl&lt;&lt;<span class="number">90</span>&lt;&lt;endl&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T == <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="type">double</span> <span class="type">const</span> pi=<span class="number">3.141593</span>;</span><br><span class="line">    <span class="type">double</span> <span class="type">const</span> r=<span class="number">5</span>;</span><br><span class="line">    cout&lt;&lt;pi*r*<span class="number">2</span>&lt;&lt;endl&lt;&lt;pi*r*r&lt;&lt;endl&lt;&lt;<span class="number">4.0</span>/<span class="number">3</span>*pi*r*r*r&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T == <span class="number">9</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">22</span>&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T == <span class="number">10</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">9</span>&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T == <span class="number">11</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">100.0</span>/(<span class="number">8</span><span class="number">-5</span>)&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T == <span class="number">12</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">13</span>&lt;&lt;endl&lt;&lt;<span class="string">&quot;R&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T == <span class="number">13</span>) &#123;</span><br><span class="line">    <span class="type">double</span> <span class="type">const</span> pi=<span class="number">3.141593</span>;</span><br><span class="line">    <span class="type">double</span> V=pi*<span class="number">4</span>*<span class="number">4</span>*<span class="number">4</span>*<span class="number">4</span>/<span class="number">3</span>+pi*<span class="number">10</span>*<span class="number">10</span>*<span class="number">10</span>*<span class="number">4</span>/<span class="number">3</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">floor</span>(<span class="built_in">pow</span>(V,<span class="number">1.0</span>/<span class="number">3</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (T == <span class="number">14</span>) &#123;</span><br><span class="line">    cout&lt;&lt;<span class="number">50</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基2-习6】Apples-Prologue-苹果和虫子"><a href="#【深基2-习6】Apples-Prologue-苹果和虫子" class="headerlink" title="【深基2.习6】Apples Prologue &#x2F; 苹果和虫子"></a>【深基2.习6】Apples Prologue &#x2F; 苹果和虫子</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>八尾勇喜欢吃苹果。她现在有 m（1 \le m \le 100）个苹果，吃完一个苹果需要花费 t（0 \le t \le 100）分钟，吃完一个后立刻开始吃下一个。现在时间过去了 s（1 \le s \le 10000）分钟，请问她还有几个完整的苹果？</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入三个<strong>非负整数</strong>表示 m, t, s。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数表示答案。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50 10 200</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>如果你出现了 RE，不如检查一下被零除？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"><span class="keyword">if</span> (b==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">ceil</span>(<span class="number">1.0</span>*c/b)&gt;=a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a - <span class="built_in">ceil</span>(<span class="number">1.0</span>*c / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基3-例2】数的性质"><a href="#【深基3-例2】数的性质" class="headerlink" title="【深基3.例2】数的性质"></a>【深基3.例2】数的性质</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>一些整数可能拥有以下的性质：</p><ul><li>性质 1：是偶数；</li><li>性质 2：大于 4 且不大于 12。</li></ul><p>小 A 喜欢这两个性质同时成立的整数；Uim 喜欢这至少符合其中一种性质的整数；八尾勇喜欢刚好有符合其中一个性质的整数；正妹喜欢不符合这两个性质的整数。现在给出一个整数 x，请问他们是否喜欢这个整数？</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个整数 x(0\le x \le 1000)</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出这 4 个人是否喜欢这个数字，如果喜欢则输出 <code>1</code>，否则输出 <code>0</code>，用空格分隔。输出顺序为：小 A、Uim、八尾勇、正妹。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 1 0 0</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>,d=<span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>&amp;&amp;(n&gt;<span class="number">4</span>&amp;&amp;n&lt;=<span class="number">12</span>))a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>||(n&gt;<span class="number">4</span>&amp;&amp;n&lt;=<span class="number">12</span>))b=<span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>^(n&gt;<span class="number">4</span>&amp;&amp;n&lt;=<span class="number">12</span>))c=<span class="number">1</span>;   </span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>!=<span class="number">0</span>&amp;&amp;(n&lt;=<span class="number">4</span>||n&gt;<span class="number">12</span>))d=<span class="number">1</span>;  </span><br><span class="line">    cout&lt;&lt;a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;c&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;d&lt;&lt;endl;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基3-例3】闰年判断"><a href="#【深基3-例3】闰年判断" class="headerlink" title="【深基3.例3】闰年判断"></a>【深基3.例3】闰年判断</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个年份，判断这一年是否是闰年，如果是输出 1，否则输出 0。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个正整数 n，表示年份。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行。如果输入的年份是闰年则输出 1，否则输出 0。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1926</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1900</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h2 id="样例-3"><a href="#样例-3" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3"><a href="#样例输入-3" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2000</span><br></pre></td></tr></table></figure><h3 id="样例输出-3"><a href="#样例输出-3" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="样例-4"><a href="#样例-4" class="headerlink" title="样例 #4"></a>样例 #4</h2><h3 id="样例输入-4"><a href="#样例输入-4" class="headerlink" title="样例输入 #4"></a>样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1996</span><br></pre></td></tr></table></figure><h3 id="样例输出-4"><a href="#样例输出-4" class="headerlink" title="样例输出 #4"></a>样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1582 \leq n \leq 2020 且年份为自然数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">    <span class="comment">//闰年性质</span></span><br><span class="line">    </span><br><span class="line">cout&lt;&lt;((n%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;n%<span class="number">100</span>!=<span class="number">0</span>)||(n%<span class="number">400</span>==<span class="number">0</span>))?<span class="number">1</span>:<span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="【深基3-例4】Apples"><a href="#【深基3-例4】Apples" class="headerlink" title="【深基3.例4】Apples"></a>【深基3.例4】Apples</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>八尾勇喜欢吃苹果。她今天吃掉了 x 个苹果。英语课上学到了 apple 这个词语，想用它来造句。如果她吃了 1 个苹果，就输出 <code>Today, I ate 1 apple.</code>；如果她没有吃，那么就把 1 换成 0；如果她吃了不止一个苹果，别忘了 <code>apple</code> 这个单词后面要加上代表复数的 <code>s</code>。你能帮她完成这个句子吗？</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一行一个自然数 x，表示吃掉的苹果数。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>根据题目要求输出。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Today, I ate 1 apple.</span><br></pre></td></tr></table></figure><h2 id="样例-2-1"><a href="#样例-2-1" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-1"><a href="#样例输入-2-1" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1"><a href="#样例输出-2-1" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Today, I ate 3 apples.</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>对于所有数据，0\le x \le 100。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0</span> || x == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Today, I ate &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; apple.&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Today, I ate &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; apples.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基3-例5】洛谷团队系统"><a href="#【深基3-例5】洛谷团队系统" class="headerlink" title="【深基3.例5】洛谷团队系统"></a>【深基3.例5】洛谷团队系统</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>在洛谷上使用团队系统非常方便的添加自己的题目。如果在自己的电脑上配置题目和测试数据，每题需要花费时间 5 分钟；而在洛谷团队中上传私有题目，每题只需要花费 3 分钟，但是上传题目之前还需要一次性花费 11 分钟创建与配置团队。现在要配置 n 道题目，如果本地配置花费的总时间短，请输出 <code>Local</code>，否则输出 <code>Luogu</code>。</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个正整数 n，表示需要配置的题目量。</p><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，一个字符串。如果本地配置花费的总时间短，请输出 <code>Local</code>，否则输出 <code>Luogu</code>。</p><h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Local</span><br></pre></td></tr></table></figure><h2 id="样例-2-2"><a href="#样例-2-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-2"><a href="#样例输入-2-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2"><a href="#样例输出-2-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Luogu</span><br></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>数据保证 1 \leq n\leq 100。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">5</span>*n&lt;<span class="number">3</span>*n+<span class="number">11</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Local&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Luogu&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基3-例7】肥胖问题"><a href="#【深基3-例7】肥胖问题" class="headerlink" title="【深基3.例7】肥胖问题"></a>【深基3.例7】肥胖问题</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>BMI 指数是国际上常用的衡量人体胖瘦程度的一个标准，其算法是 \dfrac{m}{h^2}，其中 m 是指体重（千克），h 是指身高（米）。不同体型范围与判定结果如下：</p><ul><li>小于 18.5：体重过轻，输出 <code>Underweight</code>；</li><li>大于等于 18.5 且小于 24：正常体重，输出 <code>Normal</code>；</li><li>大于等于 24：肥胖，不仅要输出 BMI 值（使用 <code>cout</code> 的默认精度），然后换行，还要输出 <code>Overweight</code>；</li></ul><p>现在给出体重和身高数据，需要根据 BMI 指数判断体型状态并输出对应的判断。</p><p>对于非 C++ 语言，在输出时，请四舍五入保留六位<strong>有效数字</strong>输出，如果小数部分存在后缀 0，不要输出后缀 0。</p><p>请注意，保留六位<strong>有效数字</strong>不是保留六位小数。例如 123.4567 应该输出为 123.457，5432.10 应该输出为 5432.1。</p><h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>共一行。</p><p>第一行，共 2 个浮点数，m, h，分别表示体重（单位为 kg），身高（单位为 m）。</p><h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个字符串，表示根据 BMI 的对应判断。特别地，对于 <code>Overweight</code> 情况的特别处理请参照题目所述。</p><h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70 1.72</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Normal</span><br></pre></td></tr></table></figure><h2 id="样例-2-3"><a href="#样例-2-3" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-3"><a href="#样例输入-2-3" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 1.68</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-3"><a href="#样例输出-2-3" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">35.4308</span><br><span class="line">Overweight</span><br></pre></td></tr></table></figure><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>对于所有数据，40\le m \le 120，1.4 \le h \le 2.0。m 和 h 的小数点后不超过三位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> m, h, bmi;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; m &gt;&gt; h;</span><br><span class="line">bmi = m / (h * h); </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bmi &lt; <span class="number">18.5</span>) cout &lt;&lt; <span class="string">&quot;Underweight&quot;</span> &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (bmi &gt;= <span class="number">18.5</span> &amp;&amp; bmi &lt; <span class="number">24</span>)</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Normal&quot;</span>;</span><br><span class="line"><span class="keyword">if</span> (bmi &gt;= <span class="number">24</span>)</span><br><span class="line">cout &lt;&lt; bmi &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; <span class="string">&quot;Overweight&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基3-例8】三位数排序"><a href="#【深基3-例8】三位数排序" class="headerlink" title="【深基3.例8】三位数排序"></a>【深基3.例8】三位数排序</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出三个整数 a,b,c(0\le a,b,c \le 100)，要求把这三位整数从小到大排序。</p><h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入三个整数 a,b,c，以空格隔开。</p><h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，三个整数，表示从小到大排序后的结果。</p><h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 14 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 5 14</span><br></pre></td></tr></table></figure><h2 id="样例-2-4"><a href="#样例-2-4" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-4"><a href="#样例输入-2-4" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 2 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-4"><a href="#样例输出-2-4" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 2 2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a[<span class="number">1</span>]&gt;&gt;a[<span class="number">2</span>]&gt;&gt;a[<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">4</span>);</span><br><span class="line">    cout&lt;&lt;a[<span class="number">1</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;a[<span class="number">2</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;a[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基3-例9】月份天数"><a href="#【深基3-例9】月份天数" class="headerlink" title="【深基3.例9】月份天数"></a>【深基3.例9】月份天数</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入年份和月份，输出这一年的这一月有多少天。需要考虑闰年。</p><h2 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入两个正整数，分别表示年份 y 和月数 m，以空格隔开。</p><h2 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个正整数，表示这个月有多少天。</p><h2 id="样例-1-8"><a href="#样例-1-8" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-8"><a href="#样例输入-1-8" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1926 8</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-8"><a href="#样例输出-1-8" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">31</span><br></pre></td></tr></table></figure><h2 id="样例-2-5"><a href="#样例-2-5" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-5"><a href="#样例输入-2-5" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2000 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-5"><a href="#样例输出-2-5" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">29</span><br></pre></td></tr></table></figure><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p>数据保证 1583 \leq y \leq 2020，1 \leq m \leq 12。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> year, month;</span><br><span class="line">cin &gt;&gt; year &gt;&gt; month;</span><br><span class="line"><span class="type">int</span> a[<span class="number">13</span>] = &#123; <span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (year % <span class="number">4</span> == <span class="number">0</span> &amp;&amp; year % <span class="number">100</span> != <span class="number">0</span> || year % <span class="number">400</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; a[month];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="NOIP2004-普及组-不高兴的津津"><a href="#NOIP2004-普及组-不高兴的津津" class="headerlink" title="[NOIP2004 普及组] 不高兴的津津"></a>[NOIP2004 普及组] 不高兴的津津</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。</p><h2 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包括 7 行数据，分别表示周一到周日的日程安排。每行包括两个小于 10 的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。</p><h2 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个数字。如果不会不高兴则输出 0，如果会则输出最不高兴的是周几（用 1, 2, 3, 4, 5, 6, 7 分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。</p><h2 id="样例-1-9"><a href="#样例-1-9" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-9"><a href="#样例输入-1-9" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br><span class="line">6 2</span><br><span class="line">7 2</span><br><span class="line">5 3</span><br><span class="line">5 4</span><br><span class="line">0 4</span><br><span class="line">0 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-9"><a href="#样例输出-1-9" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>NOIP2004 普及组第 1 题</p><ul><li>2021-10-27：增加一组 hack 数据</li><li>2022-06-05：又增加一组 hack 数据</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;   </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,t,max=<span class="number">0</span>,i,day=<span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">1</span>;i&lt;<span class="number">8</span>;i++)  &#123;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;   </span><br><span class="line">        t=a+b;  </span><br><span class="line">        <span class="keyword">if</span> ((t&gt;max)&amp;&amp;(t&gt;<span class="number">8</span>)) max=t,day=i;  </span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    cout&lt;&lt;day; </span><br><span class="line">         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2016-普及组-买铅笔"><a href="#NOIP2016-普及组-买铅笔" class="headerlink" title="[NOIP2016 普及组] 买铅笔"></a>[NOIP2016 普及组] 买铅笔</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2016 普及组 T1</p><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>P 老师需要去商店买 n 支铅笔作为小朋友们参加 NOIP 的礼物。她发现商店一共有 3 种包装的铅笔，不同包装内的铅笔数量有可能不同，价格也有可能不同。为了公平起 见，P 老师决定只买同一种包装的铅笔。</p><p>商店不允许将铅笔的包装拆开，因此 P 老师可能需要购买超过 n 支铅笔才够给小朋友们发礼物。</p><p>现在 P 老师想知道，在商店每种包装的数量都足够的情况下，要买够至少 n 支铅笔最少需要花费多少钱。</p><h2 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含一个正整数 n，表示需要的铅笔数量。</p><p>接下来三行，每行用 2 个正整数描述一种包装的铅笔：其中第 1 个整数表示这种包装内铅笔的数量，第 2 个整数表示这种包装的价格。</p><p>保证所有的 7 个数都是不超过 10000 的正整数。</p><h2 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h2><p>1 个整数，表示 P 老师最少需要花费的钱。</p><h2 id="样例-1-10"><a href="#样例-1-10" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-10"><a href="#样例输入-1-10" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">57</span><br><span class="line">2 2</span><br><span class="line">50 30</span><br><span class="line">30 27</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-10"><a href="#样例输出-1-10" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">54</span><br></pre></td></tr></table></figure><h2 id="样例-2-6"><a href="#样例-2-6" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-6"><a href="#样例输入-2-6" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">9998</span><br><span class="line">128 233</span><br><span class="line">128 2333</span><br><span class="line">128 666</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-6"><a href="#样例输出-2-6" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18407</span><br></pre></td></tr></table></figure><h2 id="样例-3-1"><a href="#样例-3-1" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3-1"><a href="#样例输入-3-1" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">9999</span><br><span class="line">101 1111</span><br><span class="line">1 9999</span><br><span class="line">1111 9999</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-1"><a href="#样例输出-3-1" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">89991</span><br></pre></td></tr></table></figure><h2 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h2><p>铅笔的三种包装分别是：</p><ul><li>2 支装，价格为 2;</li><li>50 支装，价格为 30;</li><li>30 支装，价格为 27。</li></ul><p>P 老师需要购买至少 57 支铅笔。</p><p>如果她选择购买第一种包装，那么她需要购买 29 份，共计 2 \times 29 &#x3D; 58 支，需要花费的钱为 2 \times 29 &#x3D; 58。</p><p>实际上，P 老师会选择购买第三种包装，这样需要买 2 份。虽然最后买到的铅笔数量更多了，为 30 \times 2 &#x3D; 60 支，但花费却减少为 27 \times 2 &#x3D; 54，比第一种少。</p><p>对于第二种包装，虽然每支铅笔的价格是最低的，但要够发必须买 2 份，实际的花费达到了 30  \times 2 &#x3D; 60，因此 P 老师也不会选择。</p><p>所以最后输出的答案是 54。</p><p><strong>数据范围</strong></p><p>保证所有的 7 个数都是不超过 10000 的正整数。</p><p><strong>子任务</strong></p><p>子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。</p><p>每个测试点的数据规模及特点如下表：</p><p><img src="/2024/02/06/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%982/Totoro.trip\blog-demo\source\images\dlgsz3h4.png"></p><p>上表中“整倍数”的意义为：若为 K，表示对应数据所需要的铅笔数量 n —定是每种包装铅笔数量的整倍数（这意味着一定可以不用多买铅笔）。</p><p>于 2022 年 12 月 23 日新加 Hack 数据三组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,a,b,c,ans=<span class="number">2100000000</span>,x,i;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span> (;i&lt;<span class="number">3</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">      cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        x=<span class="built_in">ceil</span>(n*<span class="number">1.0</span>/a)*b;</span><br><span class="line">        ans=<span class="built_in">min</span>(x,ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//很容易，枚举循环就可以（差点背包</span></span><br></pre></td></tr></table></figure><h1 id="【深基3-习8】三角形分类"><a href="#【深基3-习8】三角形分类" class="headerlink" title="【深基3.习8】三角形分类"></a>【深基3.习8】三角形分类</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出三条线段 a,b,c 的长度，均是不大于 10000 的正整数。打算把这三条线段拼成一个三角形，它可以是什么三角形呢？</p><ul><li>如果三条线段不能组成一个三角形，输出<code>Not triangle</code>；</li><li>如果是直角三角形，输出<code>Right triangle</code>；</li><li>如果是锐角三角形，输出<code>Acute triangle</code>；</li><li>如果是钝角三角形，输出<code>Obtuse triangle</code>；</li><li>如果是等腰三角形，输出<code>Isosceles triangle</code>；</li><li>如果是等边三角形，输出<code>Equilateral triangle</code>。</li></ul><p>如果这个三角形符合以上多个条件，请按以上顺序分别输出，并用换行符隔开。</p><h2 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入 3 个整数 a、b 和 c。</p><h2 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出若干行判定字符串。</p><h2 id="样例-1-11"><a href="#样例-1-11" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-11"><a href="#样例输入-1-11" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 3 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-11"><a href="#样例输出-1-11" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Acute triangle</span><br><span class="line">Isosceles triangle</span><br><span class="line">Equilateral triangle</span><br></pre></td></tr></table></figure><h2 id="样例-2-7"><a href="#样例-2-7" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-7"><a href="#样例输入-2-7" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-7"><a href="#样例输出-2-7" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Right triangle</span><br></pre></td></tr></table></figure><h2 id="样例-3-2"><a href="#样例-3-2" class="headerlink" title="样例 #3"></a>样例 #3</h2><h3 id="样例输入-3-2"><a href="#样例输入-3-2" class="headerlink" title="样例输入 #3"></a>样例输入 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 10 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-3-2"><a href="#样例输出-3-2" class="headerlink" title="样例输出 #3"></a>样例输出 #3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Obtuse triangle</span><br><span class="line">Isosceles triangle</span><br></pre></td></tr></table></figure><h2 id="样例-4-1"><a href="#样例-4-1" class="headerlink" title="样例 #4"></a>样例 #4</h2><h3 id="样例输入-4-1"><a href="#样例输入-4-1" class="headerlink" title="样例输入 #4"></a>样例输入 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 14 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-4-1"><a href="#样例输出-4-1" class="headerlink" title="样例输出 #4"></a>样例输出 #4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Not triangle</span><br></pre></td></tr></table></figure><h2 id="提示-9"><a href="#提示-9" class="headerlink" title="提示"></a>提示</h2><p>当两短边的平方和大于一长边的平方，说明是锐角三角形。</p><p>当两短边的平方和等于一长边的平方，说明是直角三角形。</p><p>当两短边的平方和小于一长边的平方，说明是钝角三角形。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a&gt;c)<span class="built_in">swap</span>(a,c);</span><br><span class="line"><span class="keyword">if</span>(b&gt;c)<span class="built_in">swap</span>(b,c);</span><br><span class="line"><span class="keyword">if</span>(a&gt;c)<span class="built_in">swap</span>(a,c);</span><br><span class="line"><span class="keyword">if</span>(b&gt;c)<span class="built_in">swap</span>(b,c);</span><br><span class="line">    <span class="comment">//排序</span></span><br><span class="line"><span class="keyword">if</span>(a+b&lt;=c)&#123;cout&lt;&lt;<span class="string">&quot;Not triangle&quot;</span>;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(a*a+b*b==c*c)cout&lt;&lt;<span class="string">&quot;Right triangle&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(a*a+b*b&gt;c*c)cout&lt;&lt;<span class="string">&quot;Acute triangle&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">pow</span>(a,<span class="number">2</span>)+<span class="built_in">pow</span>(b,<span class="number">2</span>)&lt;<span class="built_in">pow</span>(c,<span class="number">2</span>))cout&lt;&lt;<span class="string">&quot;Obtuse triangle&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(a==b||a==c||b==c)cout&lt;&lt;<span class="string">&quot;Isosceles triangle&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">if</span>(a==b&amp;&amp;b==c)cout&lt;&lt;<span class="string">&quot;Equilateral triangle&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小玉家的电费"><a href="#小玉家的电费" class="headerlink" title="小玉家的电费"></a>小玉家的电费</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>夏天到了，各家各户的用电量都增加了许多，相应的电费也交的更多了。小玉家今天收到了一份电费通知单。小玉看到上面写：据闽价电 [2006]27 号规定，月用电量在 150 千瓦时及以下部分按每千瓦时 0.4463 元执行，月用电量在 151\sim 400 千瓦时的部分按每千瓦时 0.4663 元执行，月用电量在 401 千瓦时及以上部分按每千瓦时 0.5663 元执行;小玉想自己验证一下，电费通知单上应交电费的数目到底是否正确呢。请编写一个程序，已知用电总计，根据电价规定，计算出应交的电费应该是多少。</p><h2 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个正整数，表示用电总计（单位以千瓦时计），不超过 10000。</p><h2 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个数，保留到小数点后 1 位（单位以元计，保留到小数点后 1 位）。</p><h2 id="样例-1-12"><a href="#样例-1-12" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-12"><a href="#样例输入-1-12" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">267</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-12"><a href="#样例输出-1-12" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">121.5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>,&amp;a);</span><br><span class="line">    <span class="keyword">if</span> (a&lt;=<span class="number">150</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,a*<span class="number">0.4463</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a&gt;=<span class="number">151</span> &amp;&amp; a&lt;=<span class="number">400</span>)&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,<span class="number">150</span>*<span class="number">0.4463</span>+(a<span class="number">-150</span>)*<span class="number">0.4663</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,<span class="number">150</span>*<span class="number">0.4463</span>+<span class="number">250</span>*<span class="number">0.4663</span>+(a<span class="number">-400</span>)*<span class="number">0.5663</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="小鱼的航程（改进版）"><a href="#小鱼的航程（改进版）" class="headerlink" title="小鱼的航程（改进版）"></a>小鱼的航程（改进版）</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一只小鱼，它平日每天游泳 250 公里，周末休息（实行双休日)，假设从周 x 开始算起，过了 n 天以后，小鱼一共累计游泳了多少公里呢？</p><h2 id="输入格式-13"><a href="#输入格式-13" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入两个正整数 x,n，表示从周 x 算起，经过 n 天。</p><h2 id="输出格式-13"><a href="#输出格式-13" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个整数，表示小鱼累计游泳了多少公里。</p><h2 id="样例-1-13"><a href="#样例-1-13" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-13"><a href="#样例输入-1-13" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-13"><a href="#样例输出-1-13" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2000</span><br></pre></td></tr></table></figure><h2 id="提示-10"><a href="#提示-10" class="headerlink" title="提示"></a>提示</h2><p>数据保证，1\le x \le 7，1 \le n\le 10^6。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,k,s=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;n,&amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n!=<span class="number">6</span> &amp;&amp; n!=<span class="number">7</span>) s+=<span class="number">250</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">7</span>) n=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,s);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一组勾股数 a,b,c（a\neq b\neq c），用分数格式输出其较小锐角的正弦值。（要求约分。）</p><h2 id="输入格式-14"><a href="#输入格式-14" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行，包含三个正整数，即勾股数 a,b,c（无大小顺序）。</p><h2 id="输出格式-14"><a href="#输出格式-14" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，包含一个分数，即较小锐角的正弦值</p><h2 id="样例-1-14"><a href="#样例-1-14" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-14"><a href="#样例输入-1-14" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 5 4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-14"><a href="#样例输出-1-14" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3/5</span><br></pre></td></tr></table></figure><h2 id="提示-11"><a href="#提示-11" class="headerlink" title="提示"></a>提示</h2><p>数据保证：a,b,c 为正整数且 \in [1,10^9]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> num[<span class="number">3</span>],gce;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++)cin&gt;&gt;num[i];</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(num,num+<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(gce=num[<span class="number">0</span>];gce&gt;<span class="number">1</span>;gce--)<span class="keyword">if</span>(num[<span class="number">0</span>]%gce==<span class="number">0</span>&amp;&amp;num[<span class="number">2</span>]%gce==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;num[<span class="number">0</span>]/gce&lt;&lt;<span class="string">&quot;/&quot;</span>&lt;&lt;num[<span class="number">2</span>]/gce;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找最大公因数的过程</span></span><br></pre></td></tr></table></figure><h1 id="NOIP2005-普及组-陶陶摘苹果"><a href="#NOIP2005-普及组-陶陶摘苹果" class="headerlink" title="[NOIP2005 普及组] 陶陶摘苹果"></a>[NOIP2005 普及组] 陶陶摘苹果</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>陶陶家的院子里有一棵苹果树，每到秋天树上就会结出 10 个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个 30 厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。</p><p>现在已知 10 个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。</p><h2 id="输入格式-15"><a href="#输入格式-15" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入包括两行数据。第一行包含 10 个 100 到 200 之间（包括 100 和 200 ）的整数（以厘米为单位）分别表示 10 个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个 100 到 120 之间（包含 100 和 120 ）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。</p><h2 id="输出格式-15"><a href="#输出格式-15" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。</p><h2 id="样例-1-15"><a href="#样例-1-15" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-15"><a href="#样例输入-1-15" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">100 200 150 140 129 134 167 198 200 111</span><br><span class="line">110</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-15"><a href="#样例输出-1-15" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示-12"><a href="#提示-12" class="headerlink" title="提示"></a>提示</h2><p><strong>【题目来源】</strong></p><p>NOIP 2005 普及组第一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> height[<span class="number">20</span>],H,s;<span class="comment">//定义数组和高度，进而确认</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)cin &gt;&gt; height[i];</span><br><span class="line">    cin &gt;&gt; H;</span><br><span class="line">    H += <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)s+=!(H&lt;height[i]);</span><br><span class="line">    cout &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输入判断模拟即可</span></span><br></pre></td></tr></table></figure><h1 id="COCI2006-2007-2-ABC"><a href="#COCI2006-2007-2-ABC" class="headerlink" title="[COCI2006-2007#2] ABC"></a>[COCI2006-2007#2] ABC</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p><strong>【题目描述】</strong></p><p>三个整数分别为 A,B,C。这三个数字不会按照这样的顺序给你，但它们始终满足条件：A &lt; B &lt; C。为了看起来更加简洁明了，我们希望你可以按照给定的顺序重新排列它们。</p><p><strong>【输入格式】</strong></p><p>第一行包含三个正整数 A,B,C，不一定是按这个顺序。这三个数字都小于或等于 100。第二行包含三个大写字母 A、B 和 C（它们之间<strong>没有</strong>空格）表示所需的顺序。</p><p><strong>【输出格式】</strong></p><p>在一行中输出 A，B 和 C，用一个 <code> </code>（空格）隔开。</p><p>感谢 @smartzzh 提供的翻译</p><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>You will be given three integers A, B and C. The numbers will not be given in that exact order, but we do know that A is less than B and B less than C.<br>In order to make for a more pleasant viewing, we want to rearrange them in the given order.</p><h2 id="输入格式-16"><a href="#输入格式-16" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains three positive integers A, B and C, not necessarily in that order. All three numbers will be less than or equal to 100.<br>The second line contains three uppercase letters ‘A’, ‘B’ and ‘C’ (with no spaces between them) representing the desired order.</p><h2 id="输出格式-16"><a href="#输出格式-16" class="headerlink" title="输出格式"></a>输出格式</h2><p>Output the A, B and C in the desired order on a single line, separated by single spaces.</p><h2 id="样例-1-16"><a href="#样例-1-16" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-16"><a href="#样例输入-1-16" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 5 3</span><br><span class="line">ABC</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-16"><a href="#样例输出-1-16" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 3 5</span><br></pre></td></tr></table></figure><h2 id="样例-2-8"><a href="#样例-2-8" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-8"><a href="#样例输入-2-8" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6 4 2</span><br><span class="line">CAB</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-8"><a href="#样例输出-2-8" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 2 4</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">3</span>];</span><br><span class="line"><span class="type">char</span> A,B,C;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a[<span class="number">0</span>]&gt;&gt;a[<span class="number">1</span>]&gt;&gt;a[<span class="number">2</span>];</span><br><span class="line">    cin&gt;&gt;A&gt;&gt;B&gt;&gt;C;</span><br><span class="line">    <span class="built_in">sort</span>(a,a+<span class="number">3</span>);</span><br><span class="line">    cout&lt;&lt;a[A-<span class="string">&#x27;A&#x27;</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[B-<span class="string">&#x27;A&#x27;</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;a[C-<span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2008-普及组-ISBN-号码"><a href="#NOIP2008-普及组-ISBN-号码" class="headerlink" title="[NOIP2008 普及组] ISBN 号码"></a>[NOIP2008 普及组] ISBN 号码</h1><h2 id="题目描述-17"><a href="#题目描述-17" class="headerlink" title="题目描述"></a>题目描述</h2><p>每一本正式出版的图书都有一个 ISBN 号码与之对应，ISBN 码包括 9 位数字、1 位识别码和 3 位分隔符，其规定格式如 <code>x-xxx-xxxxx-x</code>，其中符号 <code>-</code> 就是分隔符（键盘上的减号），最后一位是识别码，例如 <code>0-670-82162-4</code>就是一个标准的 ISBN 码。ISBN 码的首位数字表示书籍的出版语言，例如 0 代表英语；第一个分隔符 <code>-</code> 之后的三位数字代表出版社，例如 670 代表维京出版社；第二个分隔符后的五位数字代表该书在该出版社的编号；最后一位为识别码。</p><p>识别码的计算方法如下：</p><p>首位数字乘以 1 加上次位数字乘以 2 ……以此类推，用所得的结果  \bmod 11，所得的余数即为识别码，如果余数为 10，则识别码为大写字母 X。例如 ISBN 号码 <code>0-670-82162-4</code> 中的识别码 4 是这样得到的：对 <code>067082162</code> 这 9 个数字，从左至右，分别乘以 1,2,\dots,9 再求和，即 0\times 1+6\times 2+……+2\times 9&#x3D;158，然后取 158 \bmod 11 的结果 4 作为识别码。</p><p>你的任务是编写程序判断输入的 ISBN 号码中识别码是否正确，如果正确，则仅输出 <code>Right</code>；如果错误，则输出你认为是正确的 ISBN 号码。</p><h2 id="输入格式-17"><a href="#输入格式-17" class="headerlink" title="输入格式"></a>输入格式</h2><p>一个字符序列，表示一本书的 ISBN 号码（保证输入符合 ISBN 号码的格式要求）。</p><h2 id="输出格式-17"><a href="#输出格式-17" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行，假如输入的 ISBN 号码的识别码正确，那么输出 <code>Right</code>，否则，按照规定的格式，输出正确的 ISBN 号码（包括分隔符 <code>-</code>）。</p><h2 id="样例-1-17"><a href="#样例-1-17" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-17"><a href="#样例输入-1-17" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0-670-82162-4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-17"><a href="#样例输出-1-17" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Right</span><br></pre></td></tr></table></figure><h2 id="样例-2-9"><a href="#样例-2-9" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-9"><a href="#样例输入-2-9" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0-670-82162-0</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-9"><a href="#样例输出-2-9" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0-670-82162-4</span><br></pre></td></tr></table></figure><h2 id="提示-13"><a href="#提示-13" class="headerlink" title="提示"></a>提示</h2><p>2008 普及组第一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a1, a2;</span><br><span class="line">    <span class="type">char</span> a[<span class="number">200</span>], b;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    <span class="comment">//0-670-82162-4</span></span><br><span class="line">    a1 = (a[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">1</span> + (a[<span class="number">2</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">2</span> + (a[<span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">3</span> + (a[<span class="number">4</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">4</span> + (a[<span class="number">6</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">5</span> + (a[<span class="number">7</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">6</span> + (a[<span class="number">8</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">7</span> + (a[<span class="number">9</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">8</span> + (a[<span class="number">10</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">9</span>;</span><br><span class="line">    <span class="comment">//记录那个数字，也就是那个答案数字</span></span><br><span class="line">    a2 = a1 % <span class="number">11</span>;<span class="comment">//取余</span></span><br><span class="line">    <span class="keyword">if</span> (a2 == <span class="number">10</span>) &#123; b = <span class="string">&#x27;X&#x27;</span>; &#125;</span><br><span class="line">    <span class="comment">//如果等于10，特判</span></span><br><span class="line">    <span class="keyword">else</span> &#123; b = a2 + <span class="string">&#x27;0&#x27;</span>; &#125;</span><br><span class="line">    <span class="comment">//记录字母</span></span><br><span class="line">    <span class="comment">//如果是，直接结束</span></span><br><span class="line">    <span class="keyword">if</span> (b == a[<span class="number">12</span>]) cout &lt;&lt; <span class="string">&quot;Right&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//输出</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i2 = <span class="number">0</span>; i2 &lt; <span class="number">12</span>; i2++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; a[i2];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷刷题1</title>
      <link href="/2024/02/06/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%981/"/>
      <url>/2024/02/06/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%981/</url>
      
        <content type="html"><![CDATA[<h1 id="洛谷刷题第一讲"><a href="#洛谷刷题第一讲" class="headerlink" title="洛谷刷题第一讲"></a>洛谷刷题第一讲</h1><blockquote><p>美赛暂且告一段落，算法已经一点不会了，在此会先对洛谷往期做题进行回归，并会在之后开启数据结构与算法章节。</p><p>—–引言</p></blockquote><p><img src="/images/image-20240206143327984.png" alt="image-20240206143327984"></p><h1 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello,World!"></a>Hello,World!</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>编写一个能够输出 <code>Hello,World!</code> 的程序。</p><p>提示：</p><ul><li>使用英文标点符号；</li><li><code>Hello,World!</code> 逗号后面<strong>没有</strong>空格。</li><li><code>H</code> 和 <code>W</code> 为<strong>大写</strong>字母。</li></ul><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">无</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello,World!</span><br></pre></td></tr></table></figure><p>梦的起点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Hello,World!&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出字符菱形"><a href="#输出字符菱形" class="headerlink" title="输出字符菱形"></a>输出字符菱形</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>用 <code>*</code> 构造一个对角线长 5 个字符，倾斜放置的菱形。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>没有输入要求。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>如样例所示。用 <code>*</code> 构成的菱形。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">*</span><br><span class="line"> ***</span><br><span class="line">*****</span><br><span class="line"> ***</span><br><span class="line">  *</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//....</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;  *\n ***\n*****\n ***\n  *&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="超级玛丽游戏"><a href="#超级玛丽游戏" class="headerlink" title="超级玛丽游戏"></a>超级玛丽游戏</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>本题是洛谷的试机题目，可以帮助了解洛谷的使用。</p><p>建议完成本题目后继续尝试 <a href="/problem/P1001">P1001</a>、<a href="/problem/P1008">P1008</a>。  </p><p>另外强烈推荐<a href="/discuss/show/241461">新用户必读贴</a></p><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>超级玛丽是一个非常经典的游戏。请你用字符画的形式输出超级玛丽中的一个场景。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">                ********</span><br><span class="line">               ************</span><br><span class="line">               ####....#.</span><br><span class="line">             #..###.....##....</span><br><span class="line">             ###.......######              ###            ###</span><br><span class="line">                ...........               #...#          #...#</span><br><span class="line">               ##*#######                 #.#.#          #.#.#</span><br><span class="line">            ####*******######             #.#.#          #.#.#</span><br><span class="line">           ...#***.****.*###....          #...#          #...#</span><br><span class="line">           ....**********##.....           ###            ###</span><br><span class="line">           ....****    *****....</span><br><span class="line">             ####        ####</span><br><span class="line">           ######        ######</span><br><span class="line">##############################################################</span><br><span class="line">#...#......#.##...#......#.##...#......#.##------------------#</span><br><span class="line">###########################################------------------#</span><br><span class="line">#..#....#....##..#....#....##..#....#....#####################</span><br><span class="line">##########################################    #----------#</span><br><span class="line">#.....#......##.....#......##.....#......#    #----------#</span><br><span class="line">##########################################    #----------#</span><br><span class="line">#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#</span><br><span class="line">##########################################    ############</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">&quot;                ********\n&quot;</span></span><br><span class="line">    <span class="string">&quot;               ************\n&quot;</span></span><br><span class="line">    <span class="string">&quot;               ####....#.\n&quot;</span></span><br><span class="line">    <span class="string">&quot;             #..###.....##....\n&quot;</span></span><br><span class="line">    <span class="string">&quot;             ###.......######              ###            ###\n&quot;</span></span><br><span class="line">    <span class="string">&quot;                ...........               #...#          #...#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;               ##*#######                 #.#.#          #.#.#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;            ####*******######             #.#.#          #.#.#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;           ...#***.****.*###....          #...#          #...#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;           ....**********##.....           ###            ###\n&quot;</span></span><br><span class="line">    <span class="string">&quot;           ....****    *****....\n&quot;</span></span><br><span class="line">    <span class="string">&quot;             ####        ####\n&quot;</span></span><br><span class="line">    <span class="string">&quot;           ######        ######\n&quot;</span></span><br><span class="line">    <span class="string">&quot;##############################################################\n&quot;</span></span><br><span class="line">    <span class="string">&quot;#...#......#.##...#......#.##...#......#.##------------------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;###########################################------------------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;#..#....#....##..#....#....##..#....#....#####################\n&quot;</span></span><br><span class="line">    <span class="string">&quot;##########################################    #----------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;#.....#......##.....#......##.....#......#    #----------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;##########################################    #----------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#\n&quot;</span></span><br><span class="line">    <span class="string">&quot;##########################################    ############\n&quot;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="A-B-Problem"><a href="#A-B-Problem" class="headerlink" title="A+B Problem"></a>A+B Problem</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>强烈推荐<a href="/discuss/show/241461">新用户必读帖</a>。</p><p><strong>不熟悉算法竞赛的选手请看这里：</strong></p><p>算法竞赛中要求的输出格式中，<strong>不能有多余的内容</strong>，<strong>这也包括了“请输入整数 \bm a 和 \bm b” 这一类的提示用户输入信息的内容</strong>。若包含了这些内容，将会被认为是 <code>Wrong Answer</code>，即洛谷上的 <code>WA</code>。在对比代码输出和标准输出时，系统将忽略每一行结尾的空格，以及最后一行之后多余的换行符。</p><p>若因此类问题出现本机似乎输出了正确的结果，但是实际提交结果为错误的现象，请勿认为是洛谷评测机出了问题，而是你的代码中可能存在多余的输出信息。用户可以参考在题目末尾提供的代码。</p><p>此外，<strong>请善用应用中的在线 IDE 功能</strong>，以避免不同平台的评测产生差异。</p><p>最后，请不要在对应的题目讨论区中发布自己的题解，请发布到题解区域中，否则将处以删除或禁言的处罚。若发现无法提交题解则表明本题题解数量过多，仍不应发布讨论。若您的做法确实与其他所有题解均不一样，请联系管理员添加题解。</p><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入两个整数 a, b，输出它们的和（|a|,|b| \le {10}^9）。</p><p>注意</p><ol><li>Pascal 使用 <code>integer</code> 会爆掉哦！</li><li>有负数哦！</li><li>C&#x2F;C++ 的 main 函数必须是 <code>int</code> 类型，而且 C 最后要 <code>return 0</code>。这不仅对洛谷其他题目有效，而且也是 NOIP&#x2F;CSP&#x2F;NOI 比赛的要求！</li></ol><p>好吧，同志们，我们就从这一题开始，向着大牛的路进发。</p><blockquote><p>任何一个伟大的思想，都有一个微不足道的开始。</p></blockquote><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><p>两个以空格分开的整数。</p><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数。</p><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20 30</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">cout &lt;&lt; a + b;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符三角形"><a href="#字符三角形" class="headerlink" title="字符三角形"></a>字符三角形</h1><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符，用它构造一个底边长 5 个字符，高 3 个字符的等腰字符三角形。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行，包含一个字符。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>该字符构成的等腰三角形，底边长 5 个字符，高 3 个字符。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  *</span><br><span class="line"> ***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 100 % 的数据，输入的字符是 ASCII 中的可见字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> c;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line"><span class="type">int</span> i, j, k;</span><br><span class="line"><span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; <span class="number">2</span>-i; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//2个空格</span></span><br><span class="line"><span class="comment">// 1个空格</span></span><br><span class="line"><span class="comment">// 没有空格</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt;(<span class="number">2</span>*i+<span class="number">1</span>) ; k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, c);</span><br><span class="line"><span class="comment">//1个字符</span></span><br><span class="line"><span class="comment">//3个字符</span></span><br><span class="line"><span class="comment">//5个字符</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基2-例5】苹果采购"><a href="#【深基2-例5】苹果采购" class="headerlink" title="【深基2.例5】苹果采购"></a>【深基2.例5】苹果采购</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在需要采购一些苹果，每名同学都可以分到固定数量的苹果，并且已经知道了同学的数量，请问需要采购多少个苹果？</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入两个不超过 10^9 正整数，分别表示每人分到的数量和同学的人数。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，表示答案。保证输入和答案都在 int 范围内的非负整数。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a, b;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">cout &lt;&lt; a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基2-例6】字母转换"><a href="#【深基2-例6】字母转换" class="headerlink" title="【深基2.例6】字母转换"></a>【深基2.例6】字母转换</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个小写字母，输出其对应的大写字母。例如输入 q[回车] 时，会输出 Q。</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">char</span> c,d;</span><br><span class="line">cin &gt;&gt; c;</span><br><span class="line">d = c - <span class="number">32</span>;</span><br><span class="line">cout &lt;&lt; d;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基2-例7】数字反转"><a href="#【深基2-例7】数字反转" class="headerlink" title="【深基2.例7】数字反转"></a>【深基2.例7】数字反转</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个不小于 100 且小于 1000，同时包括小数点后一位的一个浮点数，例如 123.4 ，要求把这个数字翻转过来，变成 4.321 并输出。</p><h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行一个浮点数</p><h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行一个浮点数</p><h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">123.4</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.321</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//面向样例编程</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> a, b, c, d,f;</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c &gt;&gt; d&gt;&gt;f;</span><br><span class="line">cout &lt;&lt; f &lt;&lt; <span class="string">&#x27;.&#x27;</span> &lt;&lt;c&lt;&lt; b &lt;&lt; a;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基2-例8】再分肥宅水"><a href="#【深基2-例8】再分肥宅水" class="headerlink" title="【深基2.例8】再分肥宅水"></a>【深基2.例8】再分肥宅水</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>现在有 t 毫升肥宅快乐水，要均分给 n 名同学。每名同学需要 2 个杯子。现在想知道每名同学可以获得多少毫升饮料（严格精确到小数点后 3 位），以及一共需要多少个杯子。</p><h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入一个实数 t 和一个正整数 n，使用空格隔开。</p><h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出两行。</p><p>第一行输出一个三位小数，表示可以获得多少毫升饮料。第二行输出一个正整数，表示一共需要多少个杯子。</p><h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">500.0 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">166.667</span><br><span class="line">6</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>对于所有数据，0\leq t\leq 10000 且小数点后不超过 3 位，1\leq n\leq 1000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> t;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">cin&gt;&gt;t&gt;&gt;n;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.3lf\n%d&quot;</span>,t/n,n*<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基2-习2】三角形面积"><a href="#【深基2-习2】三角形面积" class="headerlink" title="【深基2.习2】三角形面积"></a>【深基2.习2】三角形面积</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个三角形的三边长分别是 a、b、c，那么它的面积为 \sqrt{p(p-a)(p-b)(p-c)}，其中 p&#x3D;\frac{1}{2}(a+b+c)。输入这三个数字，计算三角形的面积，四舍五入精确到 1 位小数。</p><h2 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行输入三个实数 a,b,c，以空格隔开。</p><h2 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个实数，表示三角形面积。精确到小数点后 1 位。</p><h2 id="样例-1-8"><a href="#样例-1-8" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-8"><a href="#样例输入-1-8" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-8"><a href="#样例输出-1-8" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.0</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>数据保证能构成三角形，0\leq a,b,c\leq 1000，每个边长输入时不超过 2 位小数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">double</span> a,b,c,p,ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">p=(a+b+c)/<span class="number">2</span>;</span><br><span class="line">ans=<span class="built_in">sqrt</span>(p*(p-a)*(p-b)*(p-c));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.1lf&quot;</span>,ans);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基2-例12】上学迟到"><a href="#【深基2-例12】上学迟到" class="headerlink" title="【深基2.例12】上学迟到"></a>【深基2.例12】上学迟到</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>学校和 yyy 的家之间的距离为 s 米，而 yyy 以 v 米每分钟的速度匀速走向学校。</p><p>在上学的路上，yyy 还要额外花费 10 分钟的时间进行垃圾分类。</p><p>学校要求必须在上午 \textrm{8:00}  到达，请计算在不迟到的前提下，yyy 最晚能什么时候出门。</p><p>由于路途遥远，yyy 可能不得不提前一点出发，但是提前的时间不会超过一天。</p><h2 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行两个正整数 s,v，分别代表路程和速度。</p><h2 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一个 24 小时制下的时间，代表 yyy 最晚的出发时间。</p><p>输出格式为 \texttt{HH:MM}，分别代表该时间的时和分。必须输出两位，不足前面补 0。</p><h2 id="样例-1-9"><a href="#样例-1-9" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-9"><a href="#样例输入-1-9" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 99</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-9"><a href="#样例输出-1-9" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">07:48</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>对于 100% 的数据，1 \le s,v \le 10^4。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分类天才</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line"><span class="type">int</span> v;</span><br><span class="line">cin &gt;&gt; s &gt;&gt; v;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> t1 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">ceil</span>(<span class="number">1.0</span>*s / v) ;</span><br><span class="line"><span class="type">int</span> t2 = t1 + t;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> hh = t2 / <span class="number">60</span>;</span><br><span class="line"><span class="type">int</span> ff = t2 % <span class="number">60</span>;</span><br><span class="line"><span class="keyword">if</span> (hh&lt;<span class="number">8</span>&amp;&amp;ff==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; (<span class="number">8</span> - hh) &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="number">00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(hh&lt;<span class="number">8</span>&amp;&amp;ff&gt;<span class="number">0</span>&amp;&amp;<span class="number">60</span>-ff&gt;=<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; <span class="number">7</span> - hh &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="number">60</span> - ff;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (hh &lt; <span class="number">8</span> &amp;&amp; ff&gt;<span class="number">0</span> &amp;&amp; <span class="number">60</span> - ff &lt; <span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; <span class="number">7</span> - hh &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt; <span class="number">60</span> - ff;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (hh&gt;=<span class="number">8</span>&amp;&amp;ff==<span class="number">0</span>&amp;&amp;(<span class="number">24</span>+<span class="number">8</span>-hh)%<span class="number">24</span>&gt;=<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; (<span class="number">24</span>+<span class="number">8</span>-hh)%<span class="number">24</span>&lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="number">00</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (hh&gt;=<span class="number">8</span>&amp;&amp;ff==<span class="number">0</span>&amp;&amp;(<span class="number">24</span>+<span class="number">8</span>-hh)%<span class="number">24</span>&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt; (<span class="number">24</span> + <span class="number">8</span> - hh) % <span class="number">24</span> &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="number">00</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(hh &gt;= <span class="number">8</span>  &amp;&amp; (<span class="number">23</span> + <span class="number">8</span> - hh)%<span class="number">24</span> &lt; <span class="number">10</span>&amp;&amp;<span class="number">60</span>-ff&gt;=<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt; (<span class="number">23</span> + <span class="number">8</span> - hh) % <span class="number">24</span> &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="number">60</span> - ff;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (hh &gt;= <span class="number">8</span> &amp;&amp; (<span class="number">23</span> + <span class="number">8</span> - hh) % <span class="number">24</span> &lt; <span class="number">10</span>&amp;&amp;<span class="number">60</span>-ff&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; (<span class="number">23</span> + <span class="number">8</span> - hh) % <span class="number">24</span> &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt;<span class="string">&quot;0&quot;</span>&lt;&lt; <span class="number">60</span> - ff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (hh &gt;= <span class="number">8</span> &amp;&amp; (<span class="number">23</span> + <span class="number">8</span> - hh)%<span class="number">24</span> &gt;= <span class="number">10</span>&amp;&amp;<span class="number">60</span>-ff&gt;=<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; (<span class="number">23</span> + <span class="number">8</span> - hh)%<span class="number">24</span> &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="number">60</span>-ff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (hh &gt;= <span class="number">8</span> &amp;&amp; (<span class="number">23</span> + <span class="number">8</span> - hh) % <span class="number">24</span> &gt;= <span class="number">10</span>&amp;&amp;<span class="number">60</span>-ff&lt;<span class="number">10</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; (<span class="number">23</span> + <span class="number">8</span> - hh) % <span class="number">24</span> &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; <span class="string">&quot;0&quot;</span>&lt;&lt;<span class="number">60</span> - ff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="大象喝水"><a href="#大象喝水" class="headerlink" title="大象喝水"></a>大象喝水</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>一只大象口渴了，要喝 20 升水才能解渴，但现在只有一个深 h 厘米，底面半径为 r 厘米的小圆桶 （h 和 r 都是整数）。问大象至少要喝多少桶水才会解渴。</p><p><strong>Update：数据更新，这里我们近似地取圆周率 \pi &#x3D; 3.14。</strong></p><h2 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入有一行：包行两个整数，以一个空格分开，分别表示小圆桶的深 h 和底面半径 r，单位都是厘米。</p><h2 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行，包含一个整数，表示大象至少要喝水的桶数。</p><h2 id="样例-1-10"><a href="#样例-1-10" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-10"><a href="#样例输入-1-10" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">23 11</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-10"><a href="#样例输出-1-10" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><h3 id="数据规模与约定"><a href="#数据规模与约定" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h3><p>对于全部的测试点，保证 1 \leq h \leq 500，1 \leq r \leq 100。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h,r,a;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> t=<span class="number">3.14</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">cin&gt;&gt;h&gt;&gt;r;</span><br><span class="line"></span><br><span class="line">a=<span class="number">20000</span>/(t*r*r*h)+<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;a;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小鱼的游泳时间"><a href="#小鱼的游泳时间" class="headerlink" title="小鱼的游泳时间"></a>小鱼的游泳时间</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>伦敦奥运会要到了，小鱼在拼命练习游泳准备参加游泳比赛，可怜的小鱼并不知道鱼类是不能参加人类的奥运会的。</p><p>这一天，小鱼给自己的游泳时间做了精确的计时（本题中的计时都按 24 小时制计算），它发现自己从 a 时 b 分一直游泳到当天的 c 时 d 分，请你帮小鱼计算一下，它这天一共游了多少时间呢？</p><p>小鱼游的好辛苦呀，你可不要算错了哦。</p><h2 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h2><p>一行内输入四个整数，以空格隔开，分别表示题目中的 a, b, c, d。</p><h2 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h2><p>一行内输出两个整数 e 和 f，用空格间隔，依次表示小鱼这天一共游了多少小时多少分钟。其中表示分钟的整数 f 应该小于 60。</p><h2 id="样例-1-11"><a href="#样例-1-11" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-11"><a href="#样例输入-1-11" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 50 19 10</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-11"><a href="#样例输出-1-11" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 20</span><br></pre></td></tr></table></figure><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>对于全部测试数据，0\le a,c \le 24，0\le b,d \le 60，且结束时间一定晚于开始时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,c,d;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b&gt;&gt;c&gt;&gt;d;</span><br><span class="line">    <span class="type">int</span> x=c-a,y=d-b;</span><br><span class="line">    <span class="keyword">if</span>(y&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x--;y+=<span class="number">60</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;y;</span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="小玉买文具"><a href="#小玉买文具" class="headerlink" title="小玉买文具"></a>小玉买文具</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>班主任给小玉一个任务，到文具店里买尽量多的签字笔。已知一只签字笔的价格是 1 元 9 角，而班主任给小玉的钱是 a 元 b 角，小玉想知道，她最多能买多少只签字笔呢。</p><h2 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入只有一行两个整数，分别表示 a 和 b。</p><h2 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出一行一个整数，表示小玉最多能买多少只签字笔。</p><h2 id="样例-1-12"><a href="#样例-1-12" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-12"><a href="#样例输入-1-12" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-12"><a href="#样例输出-1-12" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><h4 id="数据规模与约定-1"><a href="#数据规模与约定-1" class="headerlink" title="数据规模与约定"></a>数据规模与约定</h4><p>对于全部的测试点，保证 0 \leq a \leq 10^4，0 \leq b \leq 9。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> a,b,m;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    m=<span class="number">10</span>*a+b;</span><br><span class="line">    cout&lt;&lt;m/<span class="number">19</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2017-普及组-成绩"><a href="#NOIP2017-普及组-成绩" class="headerlink" title="[NOIP2017 普及组] 成绩"></a>[NOIP2017 普及组] 成绩</h1><h2 id="题目背景-2"><a href="#题目背景-2" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2017 普及组 T1</p><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>牛牛最近学习了 C++ 入门课程，这门课程的总成绩计算方法是：</p><p>\text{总成绩}&#x3D;\text{作业成绩}\times 20%+\text{小测成绩}×30%+\text{期末考试成绩} \times 50%</p><p>牛牛想知道，这门课程自己最终能得到多少分。</p><h2 id="输入格式-13"><a href="#输入格式-13" class="headerlink" title="输入格式"></a>输入格式</h2><p>三个非负整数 A,B,C，分别表示牛牛的作业成绩、小测成绩和期末考试成绩。相邻两个数之间用一个空格隔开，三项成绩满分都是 100 分。</p><h2 id="输出格式-13"><a href="#输出格式-13" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，即牛牛这门课程的总成绩，满分也是 100 分。</p><h2 id="样例-1-13"><a href="#样例-1-13" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-13"><a href="#样例输入-1-13" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">100 100 80</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-13"><a href="#样例输出-1-13" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">90</span><br></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">60 90 80</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">79</span><br></pre></td></tr></table></figure><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p><strong>样例 1 说明</strong></p><p>牛牛的作业成绩是 100 分，小测成绩是 100 分，期末考试成绩是 80 分，总成绩是 100 \times 20%+100 \times 30%+80 \times 50%&#x3D;20+30+40&#x3D;90。</p><p><strong>样例 2 说明</strong></p><p>牛牛的作业成绩是 60 分，小测成绩是 90 分，期末考试成绩是 80 分，总成绩是 60 \times 20%+90 \times 30%+80 \times 50%&#x3D;12+27+40&#x3D;79。</p><p><strong>数据说明</strong></p><p>对于 30% 的数据，A&#x3D;B&#x3D;0。</p><p>对于另外 30% 的数据，A&#x3D;B&#x3D;100。</p><p>对于 100% 的数据，0≤A,B,C≤100 且 A,B,C 都是 10 的整数倍。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">double</span> a,b,c;</span><br><span class="line">    <span class="type">double</span> s;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lf%lf%lf&quot;</span>,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    s=a*<span class="number">0.2</span>+b*<span class="number">0.3</span>+c*<span class="number">0.5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.f&quot;</span>,s);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第六章</title>
      <link href="/2024/02/06/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0/"/>
      <url>/2024/02/06/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%85%AD%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第六章．少女心事"><a href="#第六章．少女心事" class="headerlink" title="第六章．少女心事"></a>第六章．少女心事</h1><p>夏沫在说完那句话后就面红耳赤的溜回家了。</p><p>谈起夏沫，她小学时候家境还算不错，父母都在厂里上班，生活平淡且美好。</p><p>但厂里突然的变故，夏沫的父母下岗了，家里一下子就没了经济来源，祸不单行，夏沫母亲也在此时重病不起，原本幸福的家庭一下子就掉进了深渊，尽管夏沫父亲积极寻找，找到一份还算体面的工作，暂时稳定住了收入，但母亲的病情日益加剧。</p><p>命运之手在这场博弈中还是取得了胜利，死神的镰刀无情挥下。</p><p>临别时母亲面含泪水，用止不住颤抖的手轻轻抚摸着夏沫的小手，临终前留下最后一句</p><p>“夏沫，对不起，妈妈没办法亲眼看着你上大学嫁人了。想妈妈的时候，去吹吹风吧，那是妈妈在抱你，用野草纪念妈妈吧，满地都是…….生生不息”</p><p>人呐，在突如其来的变故下格外无力，格外脆弱，连丝毫反抗之力都没有。或许这便是人世间所谓苦难吧。</p><p>夏沫的妈妈终究被病魔吞噬，撒手人间。</p><p>但她是带着微笑离世的，纵然有诸多遗憾，她不后悔嫁了夏沫的父亲夏皓，不后悔生下一个漂亮的公主夏沫，不后悔来人世间走一遭。</p><p>苦难后除了忍受并无他法，而忍受二字又岂是容易，对于一个年级尚小的小女孩来说，亲人的离世无异于天塌下来了，压在了那小小的肩膀上，压得喘不过气来。</p><p>夏沫哭过，撕心裂肺的哭过，那一个个夜晚，对她来说就是噩梦一般，每次从梦中惊醒，身旁找不到妈妈，泪水湿了脸庞，说着胡话，在爸爸夏皓的不断安抚下才得以重新入眠，而这一过程，每晚都要发生好几次。没人知道那段至暗时刻那个小女孩是怎么走出来的，但最后她选择成为妈妈口中的野草，火烧不尽，生生不息，坚强的活着。</p><p>夏沫不是一开始成绩就如此优秀的，就像人不是一开始就懂事一样。在那次重压下，她努力让自己懂事起来，同时也在外把自己封闭起来，慢慢变得不爱说话，性格也逐渐内向，全身心的学习，夏沫也铸就了江南学校全级第一的神话。</p><p>而所谓外人议论的高冷孤僻，不爱说话不过是一层夏沫用来保护自己的壁障罢了。</p><p>平常不善社交，心静如水的她像往常一样站在窗边吹风，她习惯了来到窗边，想象妈妈的拥抱与述说。</p><p>暑假后扎着马尾的颈后，可以看到细细的绒毛，几颗汗珠顺着她的小脸滑落下来。</p><p>不知为何，往常很快安静下来的心这次却静不下来，脑海里少年的阳光的笑容挥之不去，心也跳的厉害，耳朵竟能清晰的听到自己咚咚咚的心跳声。</p><p>夏沫开始在脑海中寻找与苏瑾有关的记忆。</p><p>一个校服永远干净，没有褶皱的少年；</p><p>一个有一群好朋友围在身边聊天，性格开朗的少年；</p><p>一个在八年级音乐会上唱了一首《晴天》和《流沙》的少年。</p><p>一个和她在九年培优课上有幸坐过一次的少年；</p><p>一个在毕业前夕递过来一张同学录的少年；</p><p>夏沫对初中同学的印象都不深，想起来都是只有某些画面，关于苏瑾的印象除了这些也就没有了。</p><p>中考后，夏沫父亲决定搬离原本的出租屋，让女儿有更好的生活环境。于是这个夏天，夏沫搬家了，本以为会连带着家的迁移，将以往那些带走，但某种引力的奇特，却让夏沫离曾经的同学更近了。</p><p>夏沫摇了摇头，决心不再想，对未来她从不奢望太多，只要生活继续这样安稳的过下去，闲暇时看看窗外的风景，其余时间照顾父亲和自己的学业，对夏沫已经是极大的满足，至于怎么和别人交往，她从没考虑过。</p><p>对她来说，人山人海，不如眼前的夏日盛景。</p><p>少女眼中：</p><p>夏日的天空湛蓝如宝石般晶莹剔透，偶尔飘过的白云像棉花糖一般轻盈可爱。</p><p>不过大概她也没想到，这个夏天，即将会被染上不一样的绚烂色彩。</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第五章</title>
      <link href="/2024/02/06/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%94%E7%AB%A0/"/>
      <url>/2024/02/06/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%94%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第五章．第二次相见"><a href="#第五章．第二次相见" class="headerlink" title="第五章．第二次相见"></a>第五章．第二次相见</h1><p>早上八点时分，东方的第一抹鱼肚白早早升起，阳光此刻不算炽热，透过薄薄的雾气，洒在地上。</p><p>苏瑾还躺着被窝的温柔乡里，老爸苏晨接到学校紧急通知一大早就去江南中学了，而老妈雪玲芳也按照日程去买一天的饭菜了。</p><p>“咚….咚….咚…”，敲门声断断续续的传来。</p><p>似乎碍于打扰这家人的休息，但又有什么不得不做的事情，才造就了这种别具一格的敲门声。</p><p>苏瑾在敲门声中从睡梦中醒来，梦里自己竟然变成了一只黑猫，还和格格米一起抢猫粮，没想到的是格格米平常那么听话可爱，梦里竟是如此狡猾，自己堂堂铲屎官，竟然还抢不过它，就在格格米的爪子扑面而来时，苏瑾猛然惊醒。</p><p>还心有余悸的苏瑾望向地上的猫窝，格格米不知所踪，“这家伙，肯定在阳台晒太阳，不过大清早的，会是谁敲门？”</p><p>苏瑾一阵疑惑，伸了个懒腰，大步走向门前。</p><p>打开门，映入眼帘的是眉清目秀的少女，标志性的瓜子脸上夹杂着几滴豆大的汗珠，怀里抱着一只白猫，白猫享受着少女温柔的抚摸，不用说，白猫自然是无所不能的阿喵格格米。</p><p>“抱歉，有只猫跑到我家来，请问是你家的吗“，苏瑾看着面前略带红晕轻轻喘着热气的少女，没想到会以这种奇怪的方式实现第二次相见，苏瑾真切的感受到那句人生唯一确定的就是不确定的人生啊。</p><p>格格米赖在少女温暖的怀里，狡黠的眼神盯着苏瑾，眼眸泛着微光，时不时眨一下。</p><p>“是我家猫，抱歉，给你添麻烦了……夏沫”</p><p>夏沫刚想说一句没事就逃之夭夭的时候，才意识到眼前她意味的陌生人竟然喊出了她的名字。</p><p>“你是……”夏沫抬起头，映入眼帘的是身高178，一袭白色衬衫的少年面带笑容在轻轻挥手，</p><p>那个，幸会，我是苏瑾，这个夏天你的新邻居 “。</p><p>半响后，少女反应过来，脸上仍带着些许红润，腼腆一笑，纯粹，美好。</p><p>“幸会，我是夏沫，这个夏天你的新邻居。“</p><p>微风拂过，云朵在天空中轻轻飘动，少年一语，少女一答，拉开了新篇章。</p><p><img src="/images/d891c499e13e919e31705c6ada0acca.png" alt="d891c499e13e919e31705c6ada0acca"></p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>评价类模型</title>
      <link href="/2024/01/31/%E8%AF%84%E4%BB%B7%E7%B1%BB%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/01/31/%E8%AF%84%E4%BB%B7%E7%B1%BB%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="评价类模型"><a href="#评价类模型" class="headerlink" title="评价类模型"></a>评价类模型</h1><h1 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h1><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><blockquote><p>层次分析法作为一种主观权重设计方法，一般不需要大量的数据，适合应用于那些比较难以用定量方法解决的问题。</p><p>是在对复杂的决策问题的本质、影响因素及其内在关系等进行深入分析的基础上，利用较少的定量信息使决策的思维过程数学化，从而为多目标、多准则或无结构特性的复杂决策问题提供简便的决策方法</p></blockquote><h2 id="层次分析法的应用"><a href="#层次分析法的应用" class="headerlink" title="层次分析法的应用"></a>层次分析法的应用</h2><p><img src="/images/7322bd6649634cf0aee14656d073dfe1.png" alt="img"></p><h2 id="Matlab-小知识"><a href="#Matlab-小知识" class="headerlink" title="Matlab 小知识"></a>Matlab 小知识</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% Matlab基本的小常识</span></span><br><span class="line"><span class="comment">% (1)在每一行的语句后面加上分号(一定要是英文的哦;中文的长这个样子；)表示不显示运行结果</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line">a = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% (2)多行注释:选中要注释的若干语句,快捷键Ctrl+R</span></span><br><span class="line"><span class="comment">% a = 3;</span></span><br><span class="line"><span class="comment">% a = 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% (3)取消注释:选中要取消注释的语句,快捷键Ctrl+T</span></span><br><span class="line"><span class="comment">% 我想要取消注释下面这行</span></span><br><span class="line"><span class="comment">% 还有这一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% clear可以清楚工作区的所有变量</span></span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line"><span class="comment">% clc可以清除命令行窗口中的所有文本,让屏幕变得干净</span></span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line"><span class="comment">% 所以大家在很多代码开头，都会见到:</span></span><br><span class="line">clear;clc   <span class="comment">% 分号也用于区分行。</span></span><br><span class="line"><span class="comment">% 这两条一起使用，起到“初始化”的作用，防止之前的结果对新脚本文件（后缀名是 .m）产生干扰。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 输出和输入函数(disp 和 input)</span></span><br><span class="line"><span class="comment">% disp函数</span></span><br><span class="line"><span class="comment">% matlab中disp()就是屏幕输出函数，类似于c语言中的printf（）函数</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;我是清风，大家好鸭~~~记得投币关注我哦&#x27;</span>)</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]    <span class="comment">%同一行中间用逗号分隔，也可以不用逗号，直接用空格</span></span><br><span class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="built_in">disp</span>(a) </span><br><span class="line"><span class="comment">% 注意，disp函数比较特殊，这里可要分号，可不要分号哦</span></span><br><span class="line"><span class="built_in">disp</span>(a);</span><br><span class="line"><span class="comment">% matlab中两个字符串的合并有两种方法</span></span><br><span class="line"><span class="comment">% （1）strcat(str1,str2……,strn) </span></span><br><span class="line"> strcat(<span class="string">&#x27;字符串1&#x27;</span>,<span class="string">&#x27;字符串2&#x27;</span>) </span><br><span class="line"><span class="comment">% （2）[str 1,str 2，……, str n]或[str1  str2  ……  strn]</span></span><br><span class="line">[<span class="string">&#x27;字符串1&#x27;</span>  <span class="string">&#x27;字符串2&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;字符串1&#x27;</span>,<span class="string">&#x27;字符串2&#x27;</span>]</span><br><span class="line"><span class="comment">% 一个有用的字符串函数：num2str  将数字转换为字符串</span></span><br><span class="line">c = <span class="number">100</span></span><br><span class="line">num2str(c)</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;c的取值为&#x27;</span> num2str(c)])</span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">&#x27;c的取值为&#x27;</span>, num2str(c)))</span><br><span class="line"></span><br><span class="line"><span class="comment">% input函数</span></span><br><span class="line"><span class="comment">% 一般我们会将输入的数、向量、矩阵、字符串等赋给一个变量，这里我们赋给A</span></span><br><span class="line">A = input(<span class="string">&#x27;请输入A：&#x27;</span>);</span><br><span class="line">B = input(<span class="string">&#x27;请输入B：&#x27;</span>)</span><br><span class="line"><span class="comment">% 注意观察工作区，并体会input后面加分号和不加分号的区别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% sum函数</span></span><br><span class="line"><span class="comment">% （1）如果是向量（无论是行向量还是列向量），都是直接求和</span></span><br><span class="line">E = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">sum(E)</span><br><span class="line">E = [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>]</span><br><span class="line">sum(E)</span><br><span class="line"><span class="comment">% （2）如果是矩阵，则需要根据行和列的方向作区分</span></span><br><span class="line">clc</span><br><span class="line">E = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>;<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">% a=sum(x); %按列求和(得到一个行向量）</span></span><br><span class="line">a = sum(E)</span><br><span class="line">a = sum(E,<span class="number">1</span>)</span><br><span class="line"><span class="comment">% a=sum(x,2); %按行求和(得到一个列向量）</span></span><br><span class="line">a = sum(E,<span class="number">2</span>)</span><br><span class="line"><span class="comment">% a=sum(x(:));%对整个矩阵求和</span></span><br><span class="line">a = sum(sum(E))</span><br><span class="line">a = sum(E(:))</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 基础：matlab中如何提取矩阵中指定位置的元素？</span></span><br><span class="line"><span class="comment">% （1）取指定行和列的一个元素（输出的是一个值）</span></span><br><span class="line">clc;A=[<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">2</span>;<span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>];</span><br><span class="line">A</span><br><span class="line">A(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">A(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">% （2）取指定的某一行的全部元素（输出的是一个行向量）</span></span><br><span class="line">clc;A</span><br><span class="line">A(<span class="number">2</span>,:)</span><br><span class="line">A(<span class="number">5</span>,:)</span><br><span class="line"><span class="comment">% （3）取指定的某一列的全部元素（输出的是一个列向量）</span></span><br><span class="line">clc;A</span><br><span class="line">A(:,<span class="number">1</span>)</span><br><span class="line">A(:,<span class="number">3</span>)</span><br><span class="line"><span class="comment">% （4）取指定的某些行的全部元素（输出的是一个矩阵）</span></span><br><span class="line">clc;A</span><br><span class="line">A([<span class="number">2</span>,<span class="number">5</span>],:)      <span class="comment">% 只取第二行和第五行（一共2行）</span></span><br><span class="line">A(<span class="number">2</span>:<span class="number">5</span>,:)        <span class="comment">% 取第二行到第五行（一共4行）</span></span><br><span class="line">A(<span class="number">2</span>:<span class="number">2</span>:<span class="number">5</span>,:)     <span class="comment">% 取第二行和第四行 （从2开始，每次递增2个单位，到5结束）</span></span><br><span class="line"><span class="number">1</span>:<span class="number">3</span>:<span class="number">10</span></span><br><span class="line"><span class="number">10</span>:<span class="number">-1</span>:<span class="number">1</span></span><br><span class="line">A(<span class="number">2</span>:<span class="keyword">end</span>,:)      <span class="comment">% 取第二行到最后一行</span></span><br><span class="line">A(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>,:)    <span class="comment">% 取第二行到倒数第二行</span></span><br><span class="line"><span class="comment">% （5）取全部元素(按列拼接的，最终输出的是一个列向量)</span></span><br><span class="line">clc;A</span><br><span class="line">A(:)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% size函数</span></span><br><span class="line">clc;</span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">size</span>(A)</span><br><span class="line"><span class="built_in">size</span>(B)</span><br><span class="line"><span class="comment">% size(A)函数是用来求矩阵A的大小的,它返回一个行向量，第一个元素是矩阵的行数，第二个元素是矩阵的列数</span></span><br><span class="line">[r,c] = <span class="built_in">size</span>(A)</span><br><span class="line"><span class="comment">% 将矩阵A的行数返回到第一个变量r，将矩阵的列数返回到第二个变量c</span></span><br><span class="line">r = <span class="built_in">size</span>(A,<span class="number">1</span>)  <span class="comment">%返回行数</span></span><br><span class="line">c = <span class="built_in">size</span>(A,<span class="number">2</span>) <span class="comment">%返回列数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% repmat函数</span></span><br><span class="line"><span class="comment">% B = repmat(A,m,n):将矩阵A复制m×n块，即把A作为B的元素，B由m×n个A平铺而成。</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">B = <span class="built_in">repmat</span>(A,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">B = <span class="built_in">repmat</span>(A,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Matlab中矩阵的运算</span></span><br><span class="line"><span class="comment">% MATLAB在矩阵的运算中，“*”号和“/”号代表矩阵之间的乘法与除法(A/B = A*inv(B))</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">A * B</span><br><span class="line">inv(B)  <span class="comment">% 求B的逆矩阵</span></span><br><span class="line">B * inv(B)</span><br><span class="line">A * inv(B)</span><br><span class="line">A / B</span><br><span class="line"></span><br><span class="line"><span class="comment">% 两个形状相同的矩阵对应元素之间的乘除法需要使用“.*”和“./”</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">A .* B</span><br><span class="line">A ./ B</span><br><span class="line"></span><br><span class="line"><span class="comment">% 每个元素同时和常数相乘或相除操作都可以使用</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">A * <span class="number">2</span></span><br><span class="line">A .* <span class="number">2</span></span><br><span class="line">A / <span class="number">2</span> </span><br><span class="line">A ./ <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 每个元素同时乘方时只能用 .^</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">A .^ <span class="number">2</span></span><br><span class="line">A ^ <span class="number">2</span> </span><br><span class="line">A * A</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Matlab中求特征值和特征向量</span></span><br><span class="line"><span class="comment">% 在Matlab中，计算矩阵A的特征值和特征向量的函数是eig(A),其中最常用的两个用法：</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> ;<span class="number">2</span> <span class="number">2</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">0</span> <span class="number">3</span>]</span><br><span class="line"><span class="comment">% （1）E=eig(A)：求矩阵A的全部特征值，构成向量E。</span></span><br><span class="line">E=eig(A)</span><br><span class="line"><span class="comment">% （2）[V,D]=eig(A)：求矩阵A的全部特征值，构成对角阵D，并求A的特征向量构成V的列向量。（V的每一列都是D中与之相同列的特征值的特征向量）</span></span><br><span class="line">[V,D]=eig(A)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% find函数的基本用法</span></span><br><span class="line"><span class="comment">% 下面例子来自博客：https://www.cnblogs.com/anzhiwu815/p/5907033.html 博客内有更加深入的探究</span></span><br><span class="line"><span class="comment">% find函数，它可以用来返回向量或者矩阵中不为0的元素的位置索引。</span></span><br><span class="line">clc;X = [<span class="number">1</span> <span class="number">0</span> <span class="number">4</span> <span class="number">-3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8</span> <span class="number">6</span>]</span><br><span class="line">ind = <span class="built_in">find</span>(X)</span><br><span class="line"><span class="comment">% 其有多种用法，比如返回前2个不为0的元素的位置：</span></span><br><span class="line">ind = <span class="built_in">find</span>(X,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%上面针对的是向量（一维），若X是一个矩阵（二维，有行和列），索引该如何返回呢？</span></span><br><span class="line">clc;X = [<span class="number">1</span> <span class="number">-3</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">8</span>;<span class="number">4</span> <span class="number">0</span> <span class="number">6</span>]</span><br><span class="line">ind = <span class="built_in">find</span>(X)</span><br><span class="line"><span class="comment">% 这是因为在Matlab在存储矩阵时，是一列一列存储的，我们可以做一下验证：</span></span><br><span class="line">X(<span class="number">4</span>)</span><br><span class="line"><span class="comment">% 假如你需要按照行列的信息输出该怎么办呢？</span></span><br><span class="line">[r,c] = <span class="built_in">find</span>(X)</span><br><span class="line">[r,c] = <span class="built_in">find</span>(X,<span class="number">1</span>) <span class="comment">%只找第一个非0元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 矩阵与常数的大小判断运算</span></span><br><span class="line"><span class="comment">% 共有三种运算符：大于&gt; ;小于&lt; ;等于 ==  （一个等号表示赋值；两个等号表示判断）</span></span><br><span class="line">clc</span><br><span class="line">X = [<span class="number">1</span> <span class="number">-3</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">8</span>;<span class="number">4</span> <span class="number">0</span> <span class="number">6</span>]</span><br><span class="line">X &gt; <span class="number">0</span></span><br><span class="line">X == <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 判断语句</span></span><br><span class="line"><span class="comment">% Matlab的判断语句，if所在的行不需要冒号，语句的最后一定要以end结尾 ；中间的语句要注意缩进。</span></span><br><span class="line">a = input(<span class="string">&#x27;请输入考试分数:&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> a &gt;= <span class="number">85</span>  </span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;成绩优秀&#x27;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a &gt;= <span class="number">60</span> </span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;成绩合格&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;成绩挂科&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>;</span><br><span class="line">    <span class="number">1</span>/<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>;</span><br><span class="line">    <span class="number">1</span>/<span class="number">4</span>,<span class="number">1</span>/<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">[V,D] = eig(A)  <span class="comment">% 求出A的特征值和特征向量</span></span><br><span class="line">A*[<span class="number">1</span>;<span class="number">1</span>/<span class="number">2</span>;<span class="number">1</span>/<span class="number">4</span>] - <span class="number">3</span>*[<span class="number">1</span>;<span class="number">1</span>/<span class="number">2</span>;<span class="number">1</span>/<span class="number">4</span>]   <span class="comment">% 验证[1;1/2;1/4]是否为特征值3对应的特征向量</span></span><br><span class="line"><span class="comment">% A X = /lamba X</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><blockquote><p>建立层次结构模型<br>简述：</p><p>将决策的目标、考虑的因素(决策准则)和决策方案，按它们之间的相互关系分为最高层、中间层和最低层，绘出层次结构图。</p><p>最高层：决策的目的、要解决的问题。</p><p>中间层：考虑的因素、决策的准则。</p><p>最低层：决策时的备选方案。</p><p>对于相邻的两层，称高层为目标层，低层为因素层。</p><p>如图：</p></blockquote><p><img src="/images/image-20240129161333080.png" alt="image-20240129161333080"></p><p><img src="/images/image-20240129161346001.png" alt="image-20240129161346001"></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><blockquote><p>构造判断矩阵<br>从层次结构模型的第2层开始，对于从属于(或影响)上一层每个因素的同一层诸因素，构造判断矩阵，直到最下层。</p><p>在确定各层次各因素之间的权重时，如果只是定性的结果，则常常不容易被别人接受，因而Saaty等人提出：一致矩阵法，即：</p><p>1.不把所有因素放在一起比较，而是两两相互比较。</p><p>2.对此时采用相对尺度，以尽可能减少性质不同的诸因素相互比较的困难，以提高准确度。</p><p>判断矩阵是表示本层所有因素针对上一层某一个因素的相对重要性的比较。判断矩阵的元素���用Saaty的1-9标度方法给出。</p><p>心理学家认为成对比较的因素不宜超过9个，即每层不要超过9个因素。</p></blockquote><p><img src="/images/image-20240129161357280.png" alt="image-20240129161357280"></p><p><img src="/images/image-20240129161419855.png" alt="image-20240129161419855"></p><p><img src="/images/image-20240129161445463.png" alt="image-20240129161445463"></p><p><img src="/images/image-20240129161505143.png" alt="image-20240129161505143"></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><blockquote><h4 id="计算单层权向量并做一致性检验"><a href="#计算单层权向量并做一致性检验" class="headerlink" title="计算单层权向量并做一致性检验"></a><strong>计算单层权向量并做一致性检验</strong></h4><p>能否确认层次单排序，需要进行一致性检验，所谓一致性检验是指对A确定不一致的<strong>允许范围</strong>。</p><p><strong>定理1：n阶一致阵的唯一非零特征根为n</strong></p><p><strong>定理2：n阶正互反阵A的最大特征根λ≥n，当且仅当λ&#x3D;n时A为一致阵</strong></p></blockquote><p><img src="/images/image-20240129161525745.png" alt="image-20240129161525745"></p><p><img src="/images/image-20240129161542137.png" alt="image-20240129161542137"></p><p><img src="/images/image-20240129161552150.png" alt="image-20240129161552150"></p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p><img src="/images/image-20240129161610809.png" alt="image-20240129161610809"></p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p><img src="/images/image-20240129161633027.png" alt="image-20240129161633027"></p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 注意：在论文写作中，应该先对判断矩阵进行一致性检验，然后再计算权重，因为只有判断矩阵通过了一致性检验，其权重才是有意义的。</span></span><br><span class="line"><span class="comment">%% 在下面的代码中，我们先计算了权重，然后再进行了一致性检验，这是为了顺应计算过程，事实上在逻辑上是说不过去的。</span></span><br><span class="line"><span class="comment">%% 因此大家自己写论文中如果用到了层次分析法，一定要先对判断矩阵进行一致性检验。</span></span><br><span class="line"><span class="comment">%% 而且要说明的是，只有非一致矩阵的判断矩阵才需要进行一致性检验。</span></span><br><span class="line"><span class="comment">%% 如果你的判断矩阵本身就是一个一致矩阵，那么就没有必要进行一致性检验。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 输入判断矩阵</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;请输入判断矩阵A： &#x27;</span>)</span><br><span class="line"><span class="comment">% A = input(&#x27;判断矩阵A=&#x27;)</span></span><br><span class="line">A =[<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;</span><br><span class="line"> <span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;</span><br><span class="line"> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">2</span>;</span><br><span class="line"> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span>;</span><br><span class="line"> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>]</span><br><span class="line"><span class="comment">% matlab矩阵有两种写法，可以直接写到一行:</span></span><br><span class="line"><span class="comment">% [1 1 4 1/3 3;1 1 4 1/3 3;1/4 1/4 1 1/3 1/2;3 3 3 1 3;1/3 1/3 2 1/3 1]</span></span><br><span class="line"><span class="comment">% 也可以写成多行:</span></span><br><span class="line">[<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;</span><br><span class="line"> <span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;</span><br><span class="line"> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">2</span>;</span><br><span class="line"> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span>;</span><br><span class="line"> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>]</span><br><span class="line"><span class="comment">% 两行之间以分号结尾（最后一行的分号可加可不加），同行元素之间以空格（或者逗号）分开。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 方法1：算术平均法求权重</span></span><br><span class="line"><span class="comment">% 第一步：将判断矩阵按照列归一化（每一个元素除以其所在列的和）</span></span><br><span class="line">Sum_A = sum(A)</span><br><span class="line"></span><br><span class="line">[n,n] = <span class="built_in">size</span>(A)  <span class="comment">% 也可以写成n = size(A,1)</span></span><br><span class="line"><span class="comment">% 因为我们的判断矩阵A是一个方阵，所以这里的r和c相同，我们可以就用同一个字母n表示</span></span><br><span class="line">SUM_A = <span class="built_in">repmat</span>(Sum_A,n,<span class="number">1</span>)   <span class="comment">%repeat matrix的缩写</span></span><br><span class="line"><span class="comment">% 另外一种替代的方法如下：</span></span><br><span class="line">    SUM_A = [];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n   <span class="comment">%循环哦，这一行后面不能加冒号（和Python不同），这里表示循环n次</span></span><br><span class="line">        SUM_A = [SUM_A; Sum_A]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">clc;A</span><br><span class="line">SUM_A</span><br><span class="line">Stand_A = A ./ SUM_A</span><br><span class="line"><span class="comment">% 这里我们直接将两个矩阵对应的元素相除即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：将归一化的各列相加(按行求和)</span></span><br><span class="line">sum(Stand_A,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 第三步：将相加后得到的向量中每个元素除以n即可得到权重向量</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;算术平均法求权重的结果为：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(sum(Stand_A,<span class="number">2</span>) / n)</span><br><span class="line"><span class="comment">% 首先对标准化后的矩阵按照行求和，得到一个列向量</span></span><br><span class="line"><span class="comment">% 然后再将这个列向量的每个元素同时除以n即可（注意这里也可以用./哦）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 方法2：几何平均法求权重</span></span><br><span class="line"><span class="comment">% 第一步：将A的元素按照行相乘得到一个新的列向量</span></span><br><span class="line">clc;A</span><br><span class="line">Prduct_A = prod(A,<span class="number">2</span>)</span><br><span class="line"><span class="comment">% prod函数和sum函数类似，一个用于乘，一个用于加  dim = 2 维度是行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：将新的向量的每个分量开n次方</span></span><br><span class="line">Prduct_n_A = Prduct_A .^ (<span class="number">1</span>/n)</span><br><span class="line"><span class="comment">% 这里对每个元素进行乘方操作，因此要加.号哦。  ^符号表示乘方哦  这里是开n次方，所以我们等价求1/n次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第三步：对该列向量进行归一化即可得到权重向量</span></span><br><span class="line"><span class="comment">% 将这个列向量中的每一个元素除以这一个向量的和即可</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;几何平均法求权重的结果为：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(Prduct_n_A ./ sum(Prduct_n_A))</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 方法3：特征值法求权重</span></span><br><span class="line"><span class="comment">% 第一步：求出矩阵A的最大特征值以及其对应的特征向量</span></span><br><span class="line">clc</span><br><span class="line">[V,D] = eig(A)    <span class="comment">%V是特征向量, D是由特征值构成的对角矩阵（除了对角线元素外，其余位置元素全为0）</span></span><br><span class="line">Max_eig = <span class="built_in">max</span>(<span class="built_in">max</span>(D)) <span class="comment">%也可以写成max(D(:))哦~</span></span><br><span class="line"><span class="comment">% 那么怎么找到最大特征值所在的位置了？ 需要用到find函数，它可以用来返回向量或者矩阵中不为0的元素的位置索引。</span></span><br><span class="line"><span class="comment">% 那么问题来了，我们要得到最大特征值的位置，就需要将包含所有特征值的这个对角矩阵D中，不等于最大特征值的位置全变为0</span></span><br><span class="line"><span class="comment">% 这时候可以用到矩阵与常数的大小判断运算</span></span><br><span class="line">D == Max_eig</span><br><span class="line">[r,c] = <span class="built_in">find</span>(D == Max_eig , <span class="number">1</span>)</span><br><span class="line"><span class="comment">% 找到D中第一个与最大特征值相等的元素的位置，记录它的行和列。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：对求出的特征向量进行归一化即可得到我们的权重</span></span><br><span class="line">V(:,c)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;特征值法求权重的结果为：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>( V(:,c) ./ sum(V(:,c)) )</span><br><span class="line"><span class="comment">% 我们先根据上面找到的最大特征值的列数c找到对应的特征向量，然后再进行标准化。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算一致性比例CR</span></span><br><span class="line">clc</span><br><span class="line">CI = (Max_eig - n) / (n<span class="number">-1</span>);</span><br><span class="line">RI=[<span class="number">0</span> <span class="number">0</span> <span class="number">0.52</span> <span class="number">0.89</span> <span class="number">1.12</span> <span class="number">1.26</span> <span class="number">1.36</span> <span class="number">1.41</span> <span class="number">1.46</span> <span class="number">1.49</span> <span class="number">1.52</span> <span class="number">1.54</span> <span class="number">1.56</span> <span class="number">1.58</span> <span class="number">1.59</span>];  <span class="comment">%注意哦，这里的RI最多支持 n = 15</span></span><br><span class="line">CR=CI/RI(n);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;一致性指标CI=&#x27;</span>);<span class="built_in">disp</span>(CI);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;一致性比例CR=&#x27;</span>);<span class="built_in">disp</span>(CR);</span><br><span class="line"><span class="keyword">if</span> CR&lt;<span class="number">0.10</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;因为CR &lt; 0.10，所以该判断矩阵A的一致性可以接受!&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;注意：CR &gt;= 0.10，因此该判断矩阵A需要进行修改!&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="例题展示"><a href="#例题展示" class="headerlink" title="例题展示"></a>例题展示</h1><p><img src="/images/5895ff6f46cf426ab481a3ba9bd50cd7.png" alt="img"></p><p><img src="/images/b1065d4eac534cccab3811ecf3e4bc27.png" alt="img"></p><p><img src="/images/2a1108a776c04bb2ada307f4b61b090e.png" alt="img"></p><p><img src="/images/52955017804f475980d96c0087f2209e.png" alt="img"></p><p><img src="/images/00d7639e39fd47cbb43747226782f852.png" alt="img"></p><p><img src="/images/c21abac314ac42289ce23bf511e8a443.png" alt="img"></p><h1 id="模糊综合评价模型"><a href="#模糊综合评价模型" class="headerlink" title="模糊综合评价模型"></a>模糊综合评价模型</h1><p>核心在于模糊的概念</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p><img src="/images/image-20240128192713567.png" alt="image-20240128192713567"></p><h2 id="数学的量的划分"><a href="#数学的量的划分" class="headerlink" title="数学的量的划分"></a>数学的量的划分</h2><p>确定性</p><p>不确定性</p><p><img src="/images/image-20240128192829255.png" alt="image-20240128192829255"></p><h2 id="模糊数学"><a href="#模糊数学" class="headerlink" title="模糊数学"></a>模糊数学</h2><p><img src="/images/image-20240128192918227.png" alt="image-20240128192918227"></p><h1 id="经典集合和模糊集合的基本概念"><a href="#经典集合和模糊集合的基本概念" class="headerlink" title="经典集合和模糊集合的基本概念"></a>经典集合和模糊集合的基本概念</h1><p>经典集合</p><p><img src="/images/image-20240128193114838.png" alt="image-20240128193114838"></p><p>  模糊集合：描述模糊性概念的集合</p><p><img src="/images/image-20240128193422098.png" alt="image-20240128193422098"></p><p>表示方法</p><p><img src="/images/image-20240128193903017.png" alt="image-20240128193903017"></p><p><img src="/images/image-20240128194009677.png" alt="image-20240128194009677"></p><h1 id="隶属函数的三种确定方法"><a href="#隶属函数的三种确定方法" class="headerlink" title="隶属函数的三种确定方法"></a>隶属函数的三种确定方法</h1><h2 id="模糊统计法"><a href="#模糊统计法" class="headerlink" title="模糊统计法"></a>模糊统计法</h2><blockquote><p>用的比较少的模糊统计法</p><p>找特别多人</p></blockquote><p><img src="/images/image-20240128194409356.png" alt="image-20240128194409356"></p><h2 id="借助已有的客观尺度"><a href="#借助已有的客观尺度" class="headerlink" title="借助已有的客观尺度"></a>借助已有的客观尺度</h2><p>合适的指标，并能收集到数据</p><p><img src="/images/image-20240128194540182.png" alt="image-20240128194540182"></p><h1 id="指派法"><a href="#指派法" class="headerlink" title="指派法"></a>指派法</h1><p>有很多分布，主要是梯形分布</p><p><img src="/images/image-20240128195038097.png" alt="image-20240128195038097"></p><p><img src="/images/image-20240128195025001.png" alt="image-20240128195025001"></p><h2 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h2><p><img src="/images/image-20240128195203066.png" alt="image-20240128195203066"></p><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><p><img src="/images/image-20240128195305070.png" alt="image-20240128195305070"></p><p>梯形分布</p><p><img src="/images/image-20240128195426402.png" alt="image-20240128195426402"></p><h1 id="应用：模糊综合评价"><a href="#应用：模糊综合评价" class="headerlink" title="应用：模糊综合评价"></a>应用：模糊综合评价</h1><p><img src="/images/image-20240128195517785.png" alt="image-20240128195517785"></p><h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><p>确定因素集：相关性之间要不太强</p><p>确定评语集：由于每个指标的评价值不同，形成不同的等级。</p><p><img src="/images/image-20240128195716703.png" alt="image-20240128195716703"></p><blockquote><p>确定权重：Delphi法，专家法。</p><p>无数据：层次分析法</p><p>有数据：熵权法</p><p>权重也需要归一化，确定的时候注意</p></blockquote><p>模糊综合判断矩阵</p><p><img src="/images/image-20240128200100963.png" alt="image-20240128200100963"><img src="/images/image-20240128200131978.png" alt="image-20240128200131978"></p><p>解释：第一列表示各个指标对于评语1的隶属度</p><p><img src="/images/image-20240128200239957.png" alt="image-20240128200239957"></p><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><p><img src="/images/image-20240128200407651.png" alt="image-20240128200407651"></p><p> 层次分析法得到权重</p><p><img src="/images/image-20240128200513147.png" alt="image-20240128200513147"></p><p><img src="/images/image-20240128200537561.png" alt="image-20240128200537561"></p><h1 id="一级模糊综合评价模型例子"><a href="#一级模糊综合评价模型例子" class="headerlink" title="一级模糊综合评价模型例子"></a>一级模糊综合评价模型例子</h1><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p><img src="/images/image-20240128200742371.png" alt="image-20240128200742371"></p><p>SO2的隶属度计算</p><p><img src="/images/image-20240128200932155.png" alt="image-20240128200932155"></p><p>同理：</p><p><img src="/images/image-20240128201002529.png" alt="image-20240128201002529"></p><p>AR&#x3D;<img src="/images/image-20240128201019735.png" alt="image-20240128201019735"></p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p> <img src="/images/image-20240128201137546.png" alt="image-20240128201137546"></p><p><img src="/images/image-20240128201342001.png" alt="image-20240128201342001"></p><p><img src="/images/image-20240128201252683.png" alt="image-20240128201252683"></p><h1 id="多级模糊综合评价模型的引入"><a href="#多级模糊综合评价模型的引入" class="headerlink" title="多级模糊综合评价模型的引入"></a>多级模糊综合评价模型的引入</h1><p><img src="/images/image-20240128202425981.png" alt="image-20240128202425981"></p><p><img src="/images/image-20240128202456942.png" alt="image-20240128202456942"></p><p><img src="/images/image-20240128202620958.png" alt="image-20240128202620958"></p><p><img src="/images/image-20240128202637622.png" alt="image-20240128202637622"></p><p>重复1的步骤2遍即可</p><h2 id="三极模糊综合评价模型"><a href="#三极模糊综合评价模型" class="headerlink" title="三极模糊综合评价模型"></a>三极模糊综合评价模型</h2><p><img src="/images/image-20240128202134589.png" alt="image-20240128202134589"></p><p>同理</p><p><img src="/images/image-20240128203040666.png" alt="image-20240128203040666"></p><p><img src="/images/image-20240128203115836.png" alt="image-20240128203115836"></p><p><img src="/images/image-20240128203122965.png" alt="image-20240128203122965"></p><h1 id="基于熵权法对Topsis模型的修正"><a href="#基于熵权法对Topsis模型的修正" class="headerlink" title="基于熵权法对Topsis模型的修正"></a>基于熵权法对Topsis模型的修正</h1><p><img src="/images/image-20240129163013762.png" alt="image-20240129163013762"></p><blockquote><h4 id="找出最优与最最差，比较程度"><a href="#找出最优与最最差，比较程度" class="headerlink" title="找出最优与最最差，比较程度"></a>找出最优与最最差，比较程度</h4><p>常用的综合<a href="https://so.csdn.net/so/search?q=%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020">评价方法</a>，充分利用原始数据</p><p>指标很多数据已知的评分问题</p><p>层次分析不适合指标太多的，都是主观的，没数据</p><p>指标的处理（正向化）</p><p>效益类</p><p>极小类</p><p>中间型</p><p>区间型</p></blockquote><h2 id="指标的处理"><a href="#指标的处理" class="headerlink" title="指标的处理"></a>指标的处理</h2><p><img src="/images/0a807263b4fe4710887d77a97cd0d0d7.png" alt="img"></p><h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><p><img src="/images/image-20240129163301619.png" alt="image-20240129163301619"></p><p><img src="/images/image-20240129163316013.png" alt="image-20240129163316013"></p><h2 id="计算距离与得分"><a href="#计算距离与得分" class="headerlink" title="计算距离与得分"></a>计算距离与得分</h2><p><img src="/images/image-20240129163340888.png" alt="image-20240129163340888"></p><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p><img src="/images/image-20240129163405891.png" alt="image-20240129163405891"></p><p><img src="/images/image-20240129163431275.png" alt="image-20240129163431275"></p><h1 id="第一步-1"><a href="#第一步-1" class="headerlink" title="第一步"></a>第一步</h1><p><img src="/images/image-20240129163513843.png" alt="image-20240129163513843"></p><p><img src="/images/image-20240129163522594.png" alt="image-20240129163522594"></p><p><img src="/images/image-20240129163529473.png" alt="image-20240129163529473"></p><p><img src="/images/image-20240129163536903.png" alt="image-20240129163536903"></p><h1 id="第二步-1"><a href="#第二步-1" class="headerlink" title="第二步"></a>第二步</h1><p><img src="/images/image-20240129163548186.png" alt="image-20240129163548186"></p><h1 id="第三步-1"><a href="#第三步-1" class="headerlink" title="第三步"></a>第三步</h1><blockquote><p><strong>计算各评价对象与最优方案的贴近程度。</strong>正其中</p><p>的取值范围为[0,1]，越接近1表明样本评分越好。</p></blockquote><p><img src="/images/image-20240129163558967.png" alt="image-20240129163558967"></p><h1 id="第四步-1"><a href="#第四步-1" class="headerlink" title="第四步"></a>第四步</h1><h2 id="进行排序即可"><a href="#进行排序即可" class="headerlink" title="进行排序即可"></a>进行排序即可</h2><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  第一步：把数据复制到工作区，并将这个矩阵命名为X</span></span><br><span class="line"><span class="comment">% （1）在工作区右键，点击新建（Ctrl+N)，输入变量名称为X</span></span><br><span class="line"><span class="comment">% （2）在Excel中复制数据，再回到Matlab中右键，点击粘贴Excel数据（Ctrl+Shift+V）</span></span><br><span class="line"><span class="comment">% （3）关掉这个窗口，点击X变量，右键另存为，保存为mat文件（下次就不用复制粘贴了，只需使用load命令即可加载数据）</span></span><br><span class="line"><span class="comment">% （4）注意，代码和数据要放在同一个目录下哦，且Matlab的当前文件夹也要是这个目录。</span></span><br><span class="line">clear;clc</span><br><span class="line">load data_water_quality.mat</span><br><span class="line"><span class="comment">%% 注意：如果提示: 错误使用 load，无法读取文件 &#x27;data_water_quality.mat&#x27;。没有此类文件或目录。</span></span><br><span class="line"><span class="comment">% 那么原因是因为你的Matlab的当前文件夹中不存在这个文件</span></span><br><span class="line"><span class="comment">% 可以使用cd函数修改Matlab的当前文件夹</span></span><br><span class="line"><span class="comment">% 比如说，我的代码和数据放在了: D:第2讲.TOPSIS法（优劣解距离法）/代码和例题数据</span></span><br><span class="line"><span class="comment">% 那么我就可以输入命令：</span></span><br><span class="line"><span class="comment">% cd &#x27;D:第2讲.TOPSIS法（优劣解距离法）/代码和例题数据&#x27;</span></span><br><span class="line"><span class="comment">% 也可以看我更新的视频：“更新9_Topsis代码为什么运行失败_得分结果怎么可视化以及权重的确定如何更加准确”，里面有介绍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  第二步：判断是否需要正向化</span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(X);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;共有&#x27;</span> num2str(n) <span class="string">&#x27;个评价对象, &#x27;</span> num2str(m) <span class="string">&#x27;个评价指标&#x27;</span>]) </span><br><span class="line">Judge = input([<span class="string">&#x27;这&#x27;</span> num2str(m) <span class="string">&#x27;个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  &#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： &#x27;</span>); <span class="comment">%[2,3,4]</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） &#x27;</span>)</span><br><span class="line">    Type = input(<span class="string">&#x27;例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  &#x27;</span>); <span class="comment">%[2,1,3]</span></span><br><span class="line">    <span class="comment">% 注意，Position和Type是两个同维度的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   回顾上一讲的知识，X(:,n)表示取第n列的全部元素</span></span><br><span class="line">    <span class="comment">% 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;正向化后的矩阵 X =  &#x27;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：对正向化后的矩阵进行标准化</span></span><br><span class="line">Z = X ./ <span class="built_in">repmat</span>(sum(X.*X) .^ <span class="number">0.5</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;标准化矩阵 Z = &#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：计算与最大值的距离和最小值的距离，并算出得分</span></span><br><span class="line">D_P = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">max</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ],<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D+ 与最大值的距离向量</span></span><br><span class="line">D_N = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">min</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ],<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D- 与最小值的距离向量</span></span><br><span class="line">S = D_N ./ (D_P+D_N);    <span class="comment">% 未归一化的得分</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最后的得分为：&#x27;</span>)</span><br><span class="line">stand_S = S / sum(S)</span><br><span class="line">[sorted_S,index] = <span class="built_in">sort</span>(stand_S ,<span class="string">&#x27;descend&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% function [输出变量] = 函数名称(输入变量）  </span></span><br><span class="line"><span class="comment">% 函数的中间部分都是函数体</span></span><br><span class="line"><span class="comment">% 函数的最后要用end结尾</span></span><br><span class="line"><span class="comment">% 输出变量和输入变量可以有多个，用逗号隔开</span></span><br><span class="line"><span class="comment">% function [a,b,c]=test(d,e,f)</span></span><br><span class="line"><span class="comment">%     a=d+e;</span></span><br><span class="line"><span class="comment">%     b=e+f;</span></span><br><span class="line"><span class="comment">%     c=f+d;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% 自定义的函数要单独放在一个m文件中，不可以直接放在主函数里面（和其他大多数语言不同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Positivization</span><span class="params">(x,type,i)</span></span></span><br><span class="line"><span class="comment">% 输入变量有三个：</span></span><br><span class="line"><span class="comment">% x：需要正向化处理的指标对应的原始列向量</span></span><br><span class="line"><span class="comment">% type： 指标的类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line"><span class="comment">% i: 正在处理的是原始矩阵中的哪一列</span></span><br><span class="line"><span class="comment">% 输出变量posit_x表示：正向化后的列向量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">1</span>  <span class="comment">%极小型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是极小型，正在正向化&#x27;</span>] )</span><br><span class="line">        posit_x = Min2Max(x);  <span class="comment">%调用Min2Max函数来正向化</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列极小型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">2</span>  <span class="comment">%中间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是中间型&#x27;</span>] )</span><br><span class="line">        best = input(<span class="string">&#x27;请输入最佳的那一个值： &#x27;</span>);</span><br><span class="line">        posit_x = Mid2Max(x,best);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列中间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">3</span>  <span class="comment">%区间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是区间型&#x27;</span>] )</span><br><span class="line">        a = input(<span class="string">&#x27;请输入区间的下界： &#x27;</span>);</span><br><span class="line">        b = input(<span class="string">&#x27;请输入区间的上界： &#x27;</span>); </span><br><span class="line">        posit_x = Inter2Max(x,a,b);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列区间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;没有这种类型的指标，请检查Type向量中是否有除了1、2、3之外的其他值&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最大值</span><br><span class="line">Intermax</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Inter2Max</span><span class="params">(x,a,b)</span></span></span><br><span class="line">    r_x = <span class="built_in">size</span>(x,<span class="number">1</span>);  <span class="comment">% row of x </span></span><br><span class="line">    M = <span class="built_in">max</span>([a-<span class="built_in">min</span>(x),<span class="built_in">max</span>(x)-b]);</span><br><span class="line">    posit_x = <span class="built_in">zeros</span>(r_x,<span class="number">1</span>);   <span class="comment">%zeros函数用法: zeros(3)  zeros(3,1)  ones(3)</span></span><br><span class="line">    <span class="comment">% 初始化posit_x全为0  初始化的目的是节省处理时间</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: r_x</span><br><span class="line">        <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; a</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(a-x(<span class="built_in">i</span>))/M;</span><br><span class="line">        <span class="keyword">elseif</span> x(<span class="built_in">i</span>) &gt; b</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(x(<span class="built_in">i</span>)-b)/M;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">MId2max</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Mid2Max</span><span class="params">(x,best)</span></span></span><br><span class="line">    M = <span class="built_in">max</span>(<span class="built_in">abs</span>(x-best));</span><br><span class="line">    posit_x = <span class="number">1</span> - <span class="built_in">abs</span>(x-best) / M;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">min2max</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Min2Max</span><span class="params">(x)</span></span></span><br><span class="line">    posit_x = <span class="built_in">max</span>(x) - x;</span><br><span class="line">     <span class="comment">%posit_x = 1 ./ x;    %如果x全部都大于0，也可以这样正向化</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><img src="/images/image-20240129164107645.png" alt="image-20240129164107645"></p><p><img src="/images/image-20240129164125974.png" alt="image-20240129164125974"></p><p><img src="/images/image-20240129164135640.png" alt="image-20240129164135640"></p><h2 id="熵权法新鲜出炉"><a href="#熵权法新鲜出炉" class="headerlink" title="熵权法新鲜出炉"></a>熵权法新鲜出炉</h2><p><img src="/images/image-20240131172123873.png" alt="image-20240131172123873"></p><p><img src="/images/image-20240131172131388.png" alt="image-20240131172131388"></p><p><img src="/images/image-20240131172140403.png" alt="image-20240131172140403"></p><p><img src="/images/image-20240131172154180.png" alt="image-20240131172154180"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  第一步：把数据复制到工作区，并将这个矩阵命名为X</span></span><br><span class="line"><span class="comment">% （1）在工作区右键，点击新建（Ctrl+N)，输入变量名称为X</span></span><br><span class="line"><span class="comment">% （2）在Excel中复制数据，再回到Matlab中右键，点击粘贴Excel数据（Ctrl+Shift+V）</span></span><br><span class="line"><span class="comment">% （3）关掉这个窗口，点击X变量，右键另存为，保存为mat文件（下次就不用复制粘贴了，只需使用load命令即可加载数据）</span></span><br><span class="line"><span class="comment">% （4）注意，代码和数据要放在同一个目录下哦。</span></span><br><span class="line">clear;clc</span><br><span class="line">load data_water_quality.mat</span><br><span class="line"></span><br><span class="line"><span class="comment">%%  第二步：判断是否需要正向化</span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(X);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;共有&#x27;</span> num2str(n) <span class="string">&#x27;个评价对象, &#x27;</span> num2str(m) <span class="string">&#x27;个评价指标&#x27;</span>]) </span><br><span class="line">Judge = input([<span class="string">&#x27;这&#x27;</span> num2str(m) <span class="string">&#x27;个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  &#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： &#x27;</span>); <span class="comment">%[2,3,4]</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） &#x27;</span>)</span><br><span class="line">    Type = input(<span class="string">&#x27;例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  &#x27;</span>); <span class="comment">%[2,1,3]</span></span><br><span class="line">    <span class="comment">% 注意，Position和Type是两个同维度的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   回顾上一讲的知识，X(:,n)表示取第n列的全部元素</span></span><br><span class="line">    <span class="comment">% 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;正向化后的矩阵 X =  &#x27;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 作业：在这里增加是否需要算加权</span></span><br><span class="line"><span class="comment">% 补充一个基础知识：m*n维的矩阵A 点乘 n维行向量B，等于这个A的每一行都点乘B</span></span><br><span class="line"><span class="comment">% （注意：2017以及之后版本的Matlab才支持，老版本Matlab会报错）</span></span><br><span class="line"><span class="comment">% % 假如原始数据为：</span></span><br><span class="line"><span class="comment">%   A=[1, 2, 3;</span></span><br><span class="line"><span class="comment">%        2, 4, 6] </span></span><br><span class="line"><span class="comment">% % 权重矩阵为：</span></span><br><span class="line"><span class="comment">%   B=[ 0.2, 0.5 ,0.3 ] </span></span><br><span class="line"><span class="comment">% % 加权后为：</span></span><br><span class="line"><span class="comment">%   C=A .* B</span></span><br><span class="line"><span class="comment">%     0.2000    1.0000    0.9000</span></span><br><span class="line"><span class="comment">%     0.4000    2.0000    1.8000</span></span><br><span class="line"><span class="comment">% 类似的，还有矩阵和向量的点除， 大家可以自己试试计算A ./ B</span></span><br><span class="line"><span class="comment">% 注意，矩阵和向量没有 .- 和 .+ 哦 ，大家可以试试，如果计算A.+B 和 A.-B会报什么错误。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 这里补充一个小插曲</span></span><br><span class="line"><span class="comment">% % 在上一讲层次分析法的代码中，我们可以优化以下的语句：</span></span><br><span class="line"><span class="comment">% % Sum_A = sum(A);</span></span><br><span class="line"><span class="comment">% % SUM_A = repmat(Sum_A,n,1);</span></span><br><span class="line"><span class="comment">% % Stand_A = A ./ SUM_A;</span></span><br><span class="line"><span class="comment">% % 事实上，我们把第三行换成：Stand_A = A ./ Sum_A; 也是可以的哦 </span></span><br><span class="line"><span class="comment">% % (再次强调，新版本的Matlab才能运行哦)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：对正向化后的矩阵进行标准化</span></span><br><span class="line">Z = X ./ <span class="built_in">repmat</span>(sum(X.*X) .^ <span class="number">0.5</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;标准化矩阵 Z = &#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(Z)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 让用户判断是否需要增加权重</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&quot;请输入是否需要增加权重向量，需要输入1，不需要输入0&quot;</span>)</span><br><span class="line">Judge = input(<span class="string">&#x27;请输入是否需要增加权重： &#x27;</span>);</span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Judge = input(<span class="string">&#x27;使用熵权法确定权重请输入1，否则输入0： &#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> sum(sum(Z&lt;<span class="number">0</span>)) &gt;<span class="number">0</span>   <span class="comment">% 如果之前标准化后的Z矩阵中存在负数，则重新对X进行标准化</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;原来标准化得到的Z矩阵中存在负数，所以需要对X重新标准化&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">                <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:m</span><br><span class="line">                    Z(<span class="built_in">i</span>,<span class="built_in">j</span>) = [X(<span class="built_in">i</span>,<span class="built_in">j</span>) - <span class="built_in">min</span>(X(:,<span class="built_in">j</span>))] / [<span class="built_in">max</span>(X(:,<span class="built_in">j</span>)) - <span class="built_in">min</span>(X(:,<span class="built_in">j</span>))];</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;X重新进行标准化得到的标准化矩阵Z为:  &#x27;</span>)</span><br><span class="line">            <span class="built_in">disp</span>(Z)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        weight = Entropy_Method(Z);</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;熵权法确定的权重为：&#x27;</span>)</span><br><span class="line">        <span class="built_in">disp</span>(weight)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;如果你有3个指标，你就需要输入3个权重，例如它们分别为0.25,0.25,0.5, 则你需要输入[0.25,0.25,0.5]&#x27;</span>]);</span><br><span class="line">        weight = input([<span class="string">&#x27;你需要输入&#x27;</span> num2str(m) <span class="string">&#x27;个权数。&#x27;</span> <span class="string">&#x27;请以行向量的形式输入这&#x27;</span> num2str(m) <span class="string">&#x27;个权重: &#x27;</span>]);</span><br><span class="line">        OK = <span class="number">0</span>;  <span class="comment">% 用来判断用户的输入格式是否正确</span></span><br><span class="line">        <span class="keyword">while</span> OK == <span class="number">0</span> </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">abs</span>(sum(weight) <span class="number">-1</span>)&lt;<span class="number">0.000001</span> &amp;&amp; <span class="built_in">size</span>(weight,<span class="number">1</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">size</span>(weight,<span class="number">2</span>) == m  <span class="comment">% 注意，Matlab中浮点数的比较要小心</span></span><br><span class="line">                OK =<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                weight = input(<span class="string">&#x27;你输入的有误，请重新输入权重行向量: &#x27;</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    weight = <span class="built_in">ones</span>(<span class="number">1</span>,m) ./ m ; <span class="comment">%如果不需要加权重就默认权重都相同，即都为1/m</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：计算与最大值的距离和最小值的距离，并算出得分</span></span><br><span class="line">D_P = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">max</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ] .* <span class="built_in">repmat</span>(weight,n,<span class="number">1</span>) ,<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D+ 与最大值的距离向量</span></span><br><span class="line">D_N = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">min</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ] .* <span class="built_in">repmat</span>(weight,n,<span class="number">1</span>) ,<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D- 与最小值的距离向量</span></span><br><span class="line">S = D_N ./ (D_P+D_N);    <span class="comment">% 未归一化的得分</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最后的得分为：&#x27;</span>)</span><br><span class="line">stand_S = S / sum(S)</span><br><span class="line">[sorted_S,index] = <span class="built_in">sort</span>(stand_S ,<span class="string">&#x27;descend&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% A = magic(5)  % 幻方矩阵</span></span><br><span class="line"><span class="comment">% M = magic(n)返回由1到n^2的整数构成并且总行数和总列数相等的n×n矩阵。阶次n必须为大于或等于3的标量。</span></span><br><span class="line"><span class="comment">% sort(A)若A是向量不管是列还是行向量，默认都是对A进行升序排列。sort(A)是默认的升序，而sort(A,&#x27;descend&#x27;)是降序排序。</span></span><br><span class="line"><span class="comment">% sort(A)若A是矩阵，默认对A的各列进行升序排列</span></span><br><span class="line"><span class="comment">% sort(A,dim)</span></span><br><span class="line"><span class="comment">% dim=1时等效sort(A)</span></span><br><span class="line"><span class="comment">% dim=2时表示对A中的各行元素升序排列</span></span><br><span class="line"><span class="comment">% A = [2,1,3,8]</span></span><br><span class="line"><span class="comment">% Matlab中给一维向量排序是使用sort函数：sort（A），排序是按升序进行的，其中A为待排序的向量；</span></span><br><span class="line"><span class="comment">% 若欲保留排列前的索引，则可用 [sA,index] = sort(A,&#x27;descend&#x27;) ，排序后，sA是排序好的向量，index是向量sA中对A的索引。</span></span><br><span class="line"><span class="comment">% sA  =  8     3     2     1</span></span><br><span class="line"><span class="comment">% index =  4     3     1     2</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="灰色关联分析（美赛不用）"><a href="#灰色关联分析（美赛不用）" class="headerlink" title="灰色关联分析（美赛不用）"></a>灰色关联分析（美赛不用）</h1><h1 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h1>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美赛假设/优缺点</title>
      <link href="/2024/01/31/%E7%BE%8E%E8%B5%9B%E5%81%87%E8%AE%BE-%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
      <url>/2024/01/31/%E7%BE%8E%E8%B5%9B%E5%81%87%E8%AE%BE-%E4%BC%98%E7%BC%BA%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="美赛假设写法"><a href="#美赛假设写法" class="headerlink" title="美赛假设写法"></a>美赛假设写法</h1><p><img src="/2024/01/31/%E7%BE%8E%E8%B5%9B%E5%81%87%E8%AE%BE-%E4%BC%98%E7%BC%BA%E7%82%B9/imageswatermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JheW1lNjI5,size_16,color_FFFFFF,t_70.png" alt="在这里插入图片描述"></p><p><img src="/2024/01/31/%E7%BE%8E%E8%B5%9B%E5%81%87%E8%AE%BE-%E4%BC%98%E7%BC%BA%E7%82%B9/imageswatermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JheW1lNjI5,size_16,color_FFFFFF,t_70-1706680795937-3.png" alt="img"></p><blockquote><p>Assumptions and Justifications </p><p>In order to simplify the given problem and modify it to be more suitable for simulating  real life conditions, we make the following basic assumptions. </p><p>⚫ Assumption: The data we collect from the online database are accurate, broad and consistent. </p><p>Justification: Since our data sources are all websites of international organizations, we  can reasonably assume the high quality of their data. For some indicators of missing data,  other available data can be used instead. Because all aspects of the food system are not  only reflected by a certain indicator. It can be the result of many factors working together. </p><p>⚫ Assumption: Environmental and socio-economic driving factors can be analyzed from the  perspective of considering the results of food system activities. </p><p>Justification: Although the model is simplified, environmental and socio-economic factors are still taken into consideration when evaluating the food system. At the same time,  the influence of environmental and socio-economic factors as driving factors will be reflected in other results. </p><p>⚫ Assumption: When analyzing the world, the country is balanced. In the analysis of specific countries, it is not balanced internally. </p><p>Justification: If we think of the world as a large food system, thus we can assume that  countries are balanced, which simplifies the calculation. And, on a global scale, different  countries are uneven, and equity still needs to be considered. </p><p>⚫ Assumption: The costs and benefits of analyzing the optimization of the food system can  be partially obtained by calculating ecosystem services.</p><p> Justification: The ecological damage caused by the food system is mainly concentrated in  the link of production. Therefore, the cost consumption and benefit acquisition generated  by optimizing the food system are mainly reflected in production.</p></blockquote><blockquote><p>假设和理由</p><p>为了简化给定的问题并使其更适合模拟实际情况，我们做出以下基本假设。</p><p>⚫ 假设：我们从在线数据库收集的数据准确、广泛且一致。<br>理由：由于我们的数据来源都是国际组织的网站，我们可以合理地假设其数据的高质量。对于某些缺失数据的指标，可以使用其他可用数据代替。因为食品系统的所有方面不仅仅通过某个指标反映，它可能是许多因素共同作用的结果。</p><p>⚫ 假设：环境和社会经济驱动因素可以从考虑食品系统活动结果的角度进行分析。<br>理由：尽管模型被简化了，但在评估食品系统时仍然考虑了环境和社会经济因素。同时，环境和社会经济因素作为驱动因素的影响将反映在其他结果中。</p><p>⚫ 假设：在分析世界时，国家是平衡的。在分析特定国家时，其内部不是平衡的。<br>理由：如果我们将世界看作一个大型食品系统，那么我们可以假设国家是平衡的，这简化了计算。而在全球范围内，不同国家是不平衡的，公平仍然需要考虑。</p><p>⚫ 假设：分析食品系统优化的成本和收益可以通过计算生态系统服务的部分获得。<br>理由：食品系统导致的生态破坏主要集中在生产环节。因此，通过优化食品系统产生的成本消耗和收益获取主要体现在生产环节。</p></blockquote><blockquote><p>Assumptions </p><p>• Developing and developed countries can not adjust their food systems in the short term. If a country is able to optimize its food system well, this change can even benefit (Ericksen PJ. 2008). Considering that the food systems of most developing and developed countries are not consistent, we assume that they can not be adjusted in the short term. </p><p>• The impact of unexpected events is unpredictable in both developing and developed countries, and measure works as a parameter in the model</p><p>. • Each country and region is considered in the best interests of its own, so the costbenefit analysis in economics applies equally to the optimization of Food Systems between countries.</p><p>• The physiological need is the most important need of human. Developed countries are not only more inclined to devote to other areas, but also willing to ensure their basic needs.</p></blockquote><blockquote><p>假设<br>• 在短期内，发展中国家和发达国家无法调整其食品系统。如果一个国家能够有效优化其食品系统，这种变化甚至可以带来利益（Ericksen PJ. 2008）。考虑到大多数发展中和发达国家的食品系统存在不一致性，我们假设它们在短期内无法进行调整。<br>• 意外事件的影响在发展中国家和发达国家都是不可预测的，而在模型中，度量被作为一个参数考虑。<br>• 每个国家和地区都被视为追求自身最大利益，因此在经济学中的成本-效益分析同样适用于各国之间的食品系统优化。<br>• 生理需求是人类最重要的需求。发达国家不仅更倾向于投入其他领域，而且愿意确保其基本需求。</p></blockquote><blockquote><p>2 Assumptions and Justifications </p><p>➢ Assumption 1: In the Food Transportation Process Model, delimit living areas to consider food transportation scenarios.</p><p> Justification: Considering that there may be tens of thousands of food transporters and  food production places in a country, it is unrealistic to model each transporter and each production place. We assume that the transportation cost of food in the same living area is 0. At the  same time, we abstract all transporters in a living area into one transporter.</p><p> ➢ Assumption 2: The market price of the same food is unchanged in the same month. </p><p>Justification: Although food prices follow the supply and demand relationship and will  be affected by demand, a too small time unit will make the model difficult to quantify and  estimate. At the same time, considering the actual life of the people, the price of the same food  in the market remains stable for a period of time, so it is reasonable to consider that the price  of food changes on a monthly time scale. </p><p>➢ Assumption 3: Assume the research data is true and reliable. </p><p>Justification: We assume that the data from national statistical offices required for model  construction and scenario simulation are real and reliable. Based on this, we can simulate more  real scenarios and establish reasonable models.</p></blockquote><blockquote><ol start="2"><li>假设与理由</li></ol><p>➢ 假设1：在食品运输过程模型中，划定居住区域以考虑食品运输场景。<br>理由：考虑到一个国家可能有成千上万的食品运输者和食品生产地点，对每个运输者和每个生产地点进行建模是不现实的。我们假设同一居住区域内的食品运输成本为零。同时，我们将一个居住区域内的所有运输者抽象为一个运输者。</p><p>➢ 假设2：相同食品在同一月份的市场价格不变。<br>理由：尽管食品价格遵循供需关系并受需求影响，但时间单位太小会使模型难以量化和估算。同时，考虑到人们实际生活，市场上同一食品的价格在一段时间内保持稳定，因此合理地认为食品价格在月度时间尺度上变化较小。</p><p>➢ 假设3：假设研究数据是真实可靠的。<br>理由：我们假设用于模型构建和场景模拟的国家统计机构提供的数据是真实可靠的。基于此，我们可以模拟更真实的场景并建立合理的模型。</p></blockquote><blockquote><p> General Assumptions</p><p> • We divide all countries into two categories: one is country with surplus food production and the other is country with deficit food production. Some of the former is blamed for overproduction and chemical abuse and some of the latter is susceptible to limited technology access. </p><p>• In production model, we choose the most classic one as a representative for countries with multiple types of climate and geographic characteristics. And we assume the labor force and population share the same growth rate. </p><p>• We assume countries with abundant food production are willing to assist the least developed countries for nothing.</p><p> • We assume most people suffering hunger come from the least developed countries. So only people from the least developed countries need assistance.</p><p>• When analyzing the production future trend, we assume every country shares the same rate of technology progress and population growth.</p></blockquote><blockquote><p>总体假设</p><p>• 我们将所有国家分为两类：一类是食品生产过剩的国家，另一类是食品生产不足的国家。前者中的一些被指责过度生产和滥用化学物质，而后者中的一些容易受到技术获取的限制。</p><p>• 在生产模型中，我们选择最经典的生产模型作为代表，以适应拥有多种气候和地理特征的国家。我们假设劳动力和人口具有相同的增长率。</p><p>• 我们假设具有丰富食品生产的国家愿意无偿协助最不发达的国家。</p><p>• 我们假设大多数饱受饥饿之苦的人来自最不发达的国家。因此，只有来自最不发达国家的人需要援助。</p><p>• 在分析生产未来趋势时，我们假设每个国家都拥有相同的技术进步和人口增长速率。</p></blockquote><blockquote><p> Assumptions</p><p> To simiplify the problem, we make the following basic assumptions, each of which is properly justified. </p><p>Assumptions 1 : We only consider calories and proteins as the basic diet need of one person. ,→Justification : For food insecure people, calories provide the sufficient energy and proteins maintain a healthy body. Thus they’re the most needed nutrition. By contrast, other nutrients like vitamins and microelement can be neglected. </p><p>Assumptions 2 : The price of the food is stable and constant. ,→Justification : As the problem says, there’re enough food to feed everyone in the world, thus the supply is more than the demand, the food producers and distributers can’t change the price of the food, it’s stable. </p><p>Assumptions 3 : The greenhouse gas emission of food transportation can be neglected. ,→Justification : According to the statistic on website Our World In Data, the greenhouse gas emission of food transportation is much smaller compared to the food production, thus we can ignore this part of emission.</p><p>Assumptions 4 : We will ignore the influence of the extreme events. ,→Justification : The tendency of development will not change as we predict the development of our modified food system. The influence of the force majeure won’t be considered. We assume our target countries are regular and stable. </p><p>Assumptions 5 : Those factors we don’t mention have few influence on the system. ,→Justification : In reality, factors that can affect food system are too plenty to be considered. Thus, this assumption is reasonable and helps avoid unnecessary troubles when building the model</p><p>Assumptions 6 : The statistic we captured from website are precise and reliable. ,→Justification : We collect most data from the authoritative websites, which we consider it trustworthy. Also, this is a premise under which our model is practical. Other specific assumption, if necessary, will be mentioned and illustrated while we’re building models</p></blockquote><blockquote><p>为了简化问题，我们提出以下基本假设，每个假设都经过适当的理由说明。</p><p>假设1：我们只考虑卡路里和蛋白质作为一个人的基本饮食需求。→ 理由：对于食物不安全的人来说，卡路里提供足够的能量，而蛋白质维持健康的身体。因此，它们是最需要的营养。相比之下，其他营养素如维生素和微量元素可以忽略不计。</p><p>假设2：食物价格是稳定且恒定的。→ 理由：正如问题所述，世界上有足够的食物来养活每个人，因此供大于求，食品生产者和分销商无法改变食物的价格，价格是稳定的。</p><p>假设3：食物运输的温室气体排放可以忽略不计。→ 理由：根据Our World In Data网站的统计数据，与食品生产相比，食品运输的温室气体排放要小得多，因此我们可以忽略这部分排放。</p><p>假设4：我们将忽略极端事件的影响。→ 理由：我们预测我们修改后的食品系统的发展趋势不会改变。不会考虑不可抗力的影响。我们假设我们的目标国家是正常和稳定的。</p><p>假设5：我们未提及的因素对系统影响很小。→ 理由：在现实中，可以影响食品系统的因素太多了以至于无法全部考虑。因此，这个假设是合理的，并有助于在构建模型时避免不必要的麻烦。</p><p>假设6：我们从网站获取的统计数据是准确可靠的。<br>→ 理由：我们从权威网站收集了大部分数据，我们认为这是可信的。此外，这是我们的模型实际可行的前提条件。<br>如果需要，我们在构建模型时将提到和说明其他具体的假设。</p></blockquote><p><img src="/2024/01/31/%E7%BE%8E%E8%B5%9B%E5%81%87%E8%AE%BE-%E4%BC%98%E7%BC%BA%E7%82%B9/imageswatermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JheW1lNjI5,size_16,color_FFFFFF,t_70-1706682792796-6.png" alt="img"></p><p><img src="/2024/01/31/%E7%BE%8E%E8%B5%9B%E5%81%87%E8%AE%BE-%E4%BC%98%E7%BC%BA%E7%82%B9/imageswatermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JheW1lNjI5,size_16,color_FFFFFF,t_70-1706682826432-9.png" alt="img"></p><blockquote><p>Assumptions and Justifications Aiming to realize the discussion of higher education system, we conduct comprehensive consideration which needs appropriate assumptions for better simplified and understood. The assumptions are as follows.</p><ol><li>The higher education in our discussion is an optional final stage of formal learning that occurs after completion of the required level of education. </li><li>Which national higher education system a person belongs to depends on the nationality of the person. For one person, different terms of higher education may be taken in different countries. But we assume that the nationality of the person is what determines his&#x2F;her education system attribution.</li><li>Expert scoring does not distinguish between the professional level of experts. In GDM, there will be several experts to score, whose skills are essentially the same as our assumption. Besides, our issues are clear and distinct without obvious inconsistency. </li><li>We assume that the development of national higher education system is continuous and slow, with no mutation. The higher education system is a huge system that has self-healing ability, which is hard to be mutant. </li><li>The data we collect is accurate. Our data is collected from United Nations Educational, Scientific and Cultural Organization, the World Bank and some other official websites and research papers.</li></ol></blockquote><blockquote><p>为了实现对高等教育制度的讨论，我们进行了全面的考虑，需要适当的假设，以便更好地简化和理解。假设如下。</p><ol><li>我们讨论的高等教育是在完成要求的教育水平之后进行的可选的正式学习的最后阶段。</li><li>一个人属于哪个国家的高等教育体系，取决于他的国籍。对于一个人来说，在不同的国家接受不同的高等教育。但我们假设，一个人的国籍决定了他&#x2F;她的教育系统归属。</li><li>专家评分不区分专家的专业水平。在GDM中，将会有几个专家进行评分，他们的技能基本上与我们的假设相同。此外，我们的问题很清楚，没有明显的矛盾。</li><li>我们假设国家高等教育体系的发展是连续的、缓慢的，没有突变。高等教育系统是一个具有自愈能力的庞大系统，难以突变。</li><li>我们收集的数据是准确的。我们的数据来源于联合国教科文组织、世界银行等一些官方网站和研究论文。</li></ol></blockquote><blockquote><p>2.2 General Assumptions</p><ol><li>No matter how well basic education is done, it cannot replace the role of higher education, and the<br>same principle applies. The academic complexity of higher education is significantly higher than that of<br>basic education, which means that the coverage of higher education is very important in the model<br>constructed in this article. </li><li>Quantity is the prerequisite for quality. The disadvantage of a country in the quality of education per<br>capita (as long as the gap between it and excellence is not too large) can be compensated by the scale<br>effect in quantity.</li><li>All sectors of society (whether public or private) can measure their investment in higher education with<br>currency.</li><li>Unfairness in higher education mainly comes from economic factors and social status.</li><li>The labor market in a market-economy-country is a buyer’s market, and the jobs are mainly provided<br>by the pillar industries of the national economy and their derivative industries. Whether the employment<br>situation, especially the gap between university degrees and other degrees, will obviously directly affect<br>the public’s enthusiasm for higher education.</li><li>The policies in our models do not include the promises of politicians participating in elections to voters<br>in elections. A strong policy should be initiated by the higher education authority or an authority in higher<br>education system, approved by the legislature, and received firm support from the executive and<br>legislature.</li><li>Without the influence of strong policies, the changes in various indicators of the health of higher<br>education are very slow. Therefore, when the data is missing, we can use adjacent years (in this article, it<br>is limited to the range of two years after the base year to two years before the base).</li><li>Higher education institutions set up by the government is more focused on justice, while private<br>institutions to focus more on efficiency.</li><li>The same indexes with different statistical calibers had similar trends over time.</li><li>External shocks such as the COVID-19 and the financial tsunami are not taken into account.</li></ol></blockquote><blockquote><p>2.2一般假设</p><ol><li>基础教育做得再好，也不能取代高等教育的作用<br>同样的原则也适用。高等教育的学术复杂性显著高于<br>基础教育，这意味着高等教育的覆盖模式是非常重要的<br>由本文构建。</li><li>数量是质量的前提。一个国家在教育质量上的劣势<br>人均(只要与优秀的差距不太大)可以用规模来补偿<br>数量上的影响。</li><li>社会所有部门(无论是公共部门还是私营部门)都可以用<br>货币。</li><li>高等教育的不公平主要来源于经济因素和社会地位因素。</li><li>市场经济国家的劳动力市场是买方市场，就业主要是提供的<br>由国民经济支柱产业及其衍生产业构成。是否就业<br>情况，特别是大学学位和其他学位之间的差距，将明显直接影响<br>公众对高等教育的热情。</li><li>我们模型中的政策不包括参与选举的政治家对选民的承诺<br>在选举。一项强有力的政策应该由高等教育主管部门或高等教育主管部门发起<br>教育体系，得到了立法机关的批准，并得到了行政和政府的坚定支持<br>立法机关。</li><li>在没有强有力政策影响的情况下，各项健康指标的变化幅度较大<br>教育是非常缓慢的。因此，当数据缺失时，我们可以使用相邻年份(在本文中)<br>(限于基准年之后两年至基准年之前两年的范围内)。</li><li>由政府设立的高等教育机构更注重正义，而私立的<br>机构更加注重效率。</li><li>不同统计口径的相同指数随时间的变化趋势相似。</li><li>没有考虑COVID-19和金融海啸等外部冲击。</li></ol></blockquote><blockquote><p>2 Assumptions and Justifications<br>To simplify our problems, we make the following basic assumptions, each of which is<br>properly justified.</p><ol><li>We assume that the environment in which the country is located is relatively stable.<br>This means that when we measure and predict the health of a country, the country we choose<br>will not undergo dramatic changes.  For example, major financial crises and global public health<br>emergencies such as the COVID-19 will not occur in the next few decades.<br>Justification: We know that global emergencies are small probability events.  Although<br>regional emergencies occur from time to time, the overall international situation is stable.<br>Small-scale incidents that happen occasionally will not have a fundamental impact on the country.  Therefore, we believe that it is reasonable to assume that the future international environment is relatively stable.</li><li>We assume that the higher education level of countries with better economic conditions can represent and reflect the development of global higher education.  This means<br>that we can select some representative countries to train our evaluation model, and the results<br>of the model can be applied to all countries.<br>Justification: The country’s economic strength is the basis for the development of higher<br>education.  Economically backward countries tend to invest more energy to deal with infrastructure construction.  According to ranking lists of higher education levels published by some<br>authoritative organizations, the top-ranked countries tend to have higher levels of economic<br>development.  Based on this, we can show that the economically developed countries have made<br>great contributions to the development of higher education, and these countries can well represent the development of global higher education.</li><li>We assume that a specific country can be regarded as a macroscopic Strategic<br>Business Unit.<br>Justification: Similar to an independent business or department, the development of a<br>specific country is relatively independent.  For certain specific undertakings, such as education,<br>environmental protection, and economics, development plans or decisions need to be made.<br>These plans or decisions can affect the country’s status and living conditions in the international<br>environment, and are related to the country’s future development.  Therefore, the status of a<br>specific country in the international environment is similar to the positioning of a company or<br>department in the market, so the country can be regarded as a macroscopic Strategic Business<br>Unit.</li><li>We assume that the health status of a country’s higher education system can be<br>comprehensively and scientifically reflected through limited and reasonably selected indicators.<br>Justification: The health of a country’s higher education system is determined by many<br>factors.  Because of the interaction between these factors, some factors can be eliminated without affecting the evaluation effect, and finally a limited number of factors that can fully reflect<br>the health status can be screened out.</li><li>We assume that when the international environment is relatively stable and there is no policy intervention, the indicators we select show regularity in the short term.  This<br>regularity can be embodied in stability, linear changes, nonlinear changes or periodic fluctuations.<br>Justification: As the international environment is relatively stable and there is no outside<br>intervention, in the short term, various indicators of a country will continue to develop along<br>with the original trend, and will not be subject to sudden changes due to disturbances within<br>and outside the system.  Therefore, the changes of these indicators over time show regularity.</li></ol></blockquote><blockquote><p>2假设和理由<br>为了简化问题，我们做了以下基本假设，每个假设都是<br>正确合理的。</p><ol><li>我们假定这个国家所处的环境相对稳定。<br>这意味着，当我们衡量和预测一个国家的健康状况时，我们选择的是哪个国家<br>不会经历剧烈的变化。例如，重大金融危机和全球公共卫生<br>像COVID-19这样的紧急情况在未来几十年内不会发生。<br>理由:我们知道全球紧急事件是小概率事件。虽然<br>地区性突发事件时有发生，国际形势总体稳定。<br>偶尔发生的小规模事件不会对国家产生根本性的影响试试。因此，我们认为有理由认为未来的国际环境是相对稳定的。</li><li>我们假设经济条件较好的国家的高等教育水平可以代表和反映全球高等教育的发展。这意味着<br>我们可以选择一些有代表性的国家来训练我们的评估模型，并得出结果<br>该模式可适用于所有国家。<br>理由:国家的经济实力是发展较高的基础<br>教育。经济落后的国家往往投入更多的精力来处理基础设施结构建设。根据一些公布的高等教育水平排名<br>权威机构认为，排名靠前的国家往往拥有更高的经济水平<br>发展。在此基础上，我们可以表明，经济发达国家已经取得了<br>对高等教育发展做出巨大贡献的国家，可以很好地代表对全球高等教育发展的不满。</li><li>我们假设一个特定的国家可以被视为一个宏观战略<br>业务单元。<br>理由:类似于一个独立的企业或部门的发展<br>具体国家相对独立。对于某些特定的事业，比如教育，<br>环境保护，经济，发展计划或决策需要做出。<br>这些计划或决定可以影响国家在国际上的地位和生活条件<br>环境，和关系到国家未来的发展。因此，a的状态<br>具体国家在国际环境中的定位是类似于一个公司的还是<br>部门在市场，所以可以看作是国家的宏观战略经营<br>单位。</li><li>我们假设一个国家的高等教育系统的健康状况可以<br>通过有限、合理的选择指标，全面、科学地体现。<br>理由:一个国家高等教育体系的健康与否取决于很多人<br>的因素。由于这些因素之间的相互作用，一些影响评价效果的因素可以通过排除，最后能够充分反映的因素数量有限<br>可以筛选出健康状态。</li><li>我们假设在国际环境相对稳定，没有政策干预的情况下，我们选择的指标在短期内表现出规律性。这<br>规律性可以表现为稳定性、线性变化、非线性变化或周期性波动。<br>理由:由于国际环境相对稳定，没有外部因素<br>干预后，在短期内，一个国家的各项指标会继续发展下去<br>具有原有的趋势，不会因内部扰动而发生突然变化<br>在体制之外。因此，这些指标随时间的变化具有规律性。</li></ol></blockquote><blockquote><p>Assumption</p><p> To simplify the given problems and modify it more appropriate for simulating reallife conditions, we make the following basic hypotheses. </p><p> Assuming that the health status of a country’s higher education is mainly affected by resource, environment, connect, achievement and sustainable, we have established a more comprehensive evaluation model.</p><p>  Assuming that if the difference between INNI of the two countries is within 0.03, the two countries are considered to have the same level of economic development. </p><p> Assuming that Italy will adopt the intervention policy we formulated for it to actively improve the health level of its higher education. This is the premise of our policy effectiveness analysis.</p><p>  Assuming that UK will not carry out a large-scale reform of its higher education system in the next 15 years, so its NHHE will not change significantly. This is the premise for us to formulate our vision with UK as the reference object.</p></blockquote><blockquote><p>2.1 假设与符号</p><p>为了简化给定问题并使其更适合模拟真实生活条件，我们提出以下基本假设。</p><ul><li>假设一个国家的高等教育健康状况主要受到资源、环境、联系、成就和可持续性的影响，我们建立了一个更全面的评估模型。</li><li>假设两个国家的国民高等教育指数（INNI）之间的差异在0.03以内，我们认为这两个国家具有相同水平的经济发展。</li><li>假设意大利将采纳我们为其制定的干预政策，积极改善其高等教育的健康水平。这是我们政策有效性分析的前提。</li><li>假设英国在未来15年内不会对其高等教育系统进行大规模改革，因此其国民高等教育指数不会发生显著变化。这是我们以英国为参考对象制定愿景的前提。</li></ul></blockquote><blockquote><p>2.1 General Assumption </p><p>In order to enable the model to accurately reflect the health status of higher education system, we analogize the health evaluation method of the medical system and make the following assumptions. </p><ol><li>Statistics we collect from the website are actual and reliable. </li><li>The overall health of higher education is only related to our evaluation indicators.</li><li>The indicators we choose possess the same distribution law as the population of higher education system, so the overall situation can be estimated through samples. </li><li>The population of the higher education system conforms to the hypothetical distribution law and can be used to measure the health status. The population does not actually exist, it is not inconsistent with the totality of all countries. </li><li>Similar to physical examination indicators, there is a specific interval that determines whether the values for indicators are healthy.  Within a certain period of time, some indicators will not be affected by the implementation of policies and can be regarded as constants. Based on the above assumptions, we have selected a reasonable data set and used corresponding processing methods to establish a comprehensive evaluation standard for the higher education system.</li></ol></blockquote><blockquote><p>2.1 一般假设</p><p>为了使模型能够准确反映高等教育系统的健康状况，我们类比了医疗系统的健康评估方法，并做出以下假设。</p><ol><li>我们从网站收集的统计数据是真实可靠的。</li><li>高等教育的整体健康仅与我们的评估指标相关。</li><li>我们选择的指标具有与高等教育系统人口相同的分布规律，因此可以通过样本估计整体状况。</li><li>高等教育系统的人口符合假设的分布规律，并可用于衡量健康状况。这个人口实际上并不存在，不与所有国家的整体状况相矛盾。</li><li>类似于体检指标，存在一个特定的区间来确定指标的值是否健康。在一定时间内，一些指标不会受到政策实施的影响，可以视为常数。基于以上假设，我们选择了一个合理的数据集，并使用相应的处理方法建立了高等教育系统的综合评估标准。</li></ol></blockquote><blockquote><p><strong>7.1 Strengths</strong></p><p>• <strong>Clear Criteria for Health and Sustainability:</strong> We have established clear criteria for health and sustainability. For each indicator, we determined a clear range of health through data analysis. The DEA-Malmquist model is used for measuring sustainability, comparing the relative efficiency of higher education in different years.</p><p>• <strong>Sufficient Indicators:</strong> Six main factors and fourteen indicators have been selected, providing a comprehensive reflection of the higher education system’s health. It also offers specific directions for policy analysis.</p><p>• <strong>Objective DEA Method:</strong> The use of DEA for efficiency analysis doesn’t require pre-specifying indicator weights. Each weight is determined solely by the data, making it a completely objective method. The DEA-Malmquist model, considering changes in productivity over time, enhances the analysis’s reasonability.</p><p>• <strong>Effective Policy Impact Prediction with Markov Chain:</strong> The Markov chain, based on the premise that the next state of the system is only related to the current state, is well-suited for analyzing the impact of policies. Governments can adjust policy directions based on the previous year’s implementation, aligning with the Markov chain’s suitability.</p><p><strong>7.2 Weaknesses</strong></p><p>• <strong>Insufficient Number of Countries:</strong> While determining the health range, we assumed that certain indicators follow a normal distribution. However, due to the limited total number of countries globally, our calculated range may deviate from the true normal distribution range.</p><p>• <strong>Lack of Consideration for Changes in Standards over Time:</strong> When analyzing the vision system, 2018 standards were followed. However, indicators of different countries may change in the future. Changes in standards have not been considered in our model.</p></blockquote><blockquote><p><strong>7.1 优势</strong></p><p>• <strong>明确的健康和可持续标准：</strong> 我们已经为健康和可持续性建立了明确的标准。对于每个指标，我们通过数据分析确定了健康的明确范围。通过比较不同年份高等教育的相对效率，我们采用了DEA-Malmquist模型来衡量可持续性。</p><p>• <strong>足够的指标：</strong> 我们选择了六个主要因素和十四个指标，可以全面反映高等教育系统的健康状况。同时，这也为我们的政策分析提供了具体方向。</p><p>• <strong>客观的DEA方法：</strong> 使用DEA进行效率分析无需事先指定各种指标的权重。每个权重完全由数据确定，这是一个完全客观的方法。考虑到随时间变化的生产率变化，我们采用了考虑时间的DEA-Malmquist模型，从而增强了分析的合理性。</p><p>• <strong>马尔可夫链对政策影响的有效预测：</strong> 马尔可夫链的前提是系统的下一个状态仅与当前状态相关，非常适合分析政策的影响。在政策实施过程中，政府会根据上一年的实施情况调整下一年的政策方向，因此马尔可夫链非常适合分析政策的影响。</p><p><strong>7.2 弱点</strong></p><p>• <strong>国家数量不足：</strong> 在确定健康范围时，我们假设某些指标服从正态分布，并通过验证确定了指标的合理范围。然而，由于全球国家总数有限，我们计算的范围可能偏离真实正态分布范围。</p><p>• <strong>未考虑随时间变化的标准变化：</strong> 在分析愿景系统时，我们遵循了2018年的标准。然而，不同国家的各种指标可能在未来发生变化。在我们的模型中，我们未考虑标准的变化。</p></blockquote><blockquote><p>General Assumption </p><ol><li>Assume that the number of higher education institutions (HEIs) in a country is relatively stable. Generally speaking, the period for preparation of setting up a new university is long, so the number of universities will not fluctuate too much in a short term;</li><li>It is assumed that there is a unified standard for defining the government’s education expenditure among countries. Due to the difference of education policies, it is inevitable that different countries will adopt different standards when calculating the government’s higher education investment. Therefore, in order to make the selected factors describe the model more accurately, it is necessary to unify the standards of different countries; </li><li>We assume that the statistics we collected from the websites and reports are reliable and accurate. The data we use in our model is mainly collected from some statistics websites such as Academic Ranking of World Universities[1] and Ranking Web of Universities[2] and reports like Project Atlas[3] .</li><li>We assume that the nations we selected to analyze have relatively stable political, social and economic environment, meaning that there will not be natural disasters like great earthquake and human disruptive events such as war, economic crisis and terrorist attacks and so on.</li></ol></blockquote><blockquote><p>一般假设</p><ol><li><p>假设一个国家的高等教育机构（HEIs）数量相对稳定。一般来说，设立新大学的准备期较长，因此大学数量在短期内不会有太大波动。</p></li><li><p>假设在各国之间存在统一的标准来定义政府的教育支出。由于教育政策的差异，不同国家在计算政府高等教育投资时可能采用不同的标准。因此，为了更准确地描述模型，有必要统一不同国家的标准。</p></li><li><p>我们假设从网站和报告中收集的统计数据是可靠准确的。我们模型中使用的数据主要来自一些统计网站，如《世界大学学术排名》[1]和《大学网络排名》[2]，以及《项目地图》[3]等报告。</p></li><li><p>我们假设我们选择分析的国家具有相对稳定的政治、社会和经济环境，意味着不会发生自然灾害，如大地震，以及人为干扰事件，如战争、经济危机和恐怖袭击等。</p></li></ol></blockquote><blockquote><p>优势与缺点</p><p> Strength and weakness of the models </p><p>8.1 Strength </p><ol><li>Inclusive</li></ol><p>Our model includes 5 independent indicators which are calculated by 13 parameters, these indicators or parameters can well represent most of the major factors determining the health and sustainability of the higher education system, and make the models relatively reliable and inclusive. </p><ol start="2"><li><p>Quantification In our model, we calculate the figures of the five indicators then obtain the scores respectively and finally get the total score of a high school education system, making the evaluation of the health and sustainability of the higher education system clearer and more intuitive. </p></li><li><p>Simple but universal The model might seems simple, however, by introducing inclusive parameters, the model can be conveniently applied to every country around the world. Therefore, our model is relatively universal. </p></li><li><p>Take advantage of comparison Score of one education system is meaningless unless the score is obtained by comparison with other systems. For example, when calculate the score of higher education system, we select 5 countries and normalize the data then obtain the final scores of each systems. The scores have relative meanings and clearly show that which nation’s higher education has room for improvement.</p><p> 8.2 Weakness </p><ol><li>Accuracy relies on statistics In our model, most of statistics are acquired from some websites and reports. The accuracy of the score calculated using our model is dependent on the data. </li><li>Subjective Some parameters using in the model are obtained subjectively. Although we have taken many government reports and development of other countries into account, the parameters seem subjective in some degree.</li><li>Disasters are not included In our model, exigence events including nature disasters and human disruptive events are not taken into consideration. Our model is not reliable when faced with destructive disasters</li></ol></li></ol><p><strong>8.1 优势</strong></p><ol><li><p><strong>包容性</strong></p><p>我们的模型包括5个独立的指标，由13个参数计算得出，这些指标或参数能够很好地代表影响高等教育系统健康和可持续性的主要因素，使模型相对可靠和全面。</p></li><li><p><strong>量化</strong></p><p>在我们的模型中，我们计算了五个指标的数值，然后分别获得了各自的得分，最终得出了高等教育系统的总体得分，使对高等教育系统健康和可持续性的评估更加清晰和直观。</p></li><li><p><strong>简单而普遍适用</strong></p><p>该模型可能看起来简单，然而，通过引入全面的参数，模型可以方便地应用于世界各国。因此，我们的模型相对具有普遍性。</p></li><li><p><strong>充分利用比较</strong></p><p>一个教育系统的得分在与其他系统进行比较之前是毫无意义的。例如，在计算高等教育系统的得分时，我们选择了5个国家，标准化数据，然后获得了每个系统的最终得分。这些分数具有相对的含义，清楚地显示了哪个国家的高等教育有改进的空间。</p></li></ol><p><strong>8.2 劣势</strong></p><ol><li><p><strong>准确性依赖于统计数据</strong></p><p>在我们的模型中，大多数统计数据都是从一些网站和报告中获取的。使用我们的模型计算的得分的准确性取决于数据的可靠性。</p></li><li><p><strong>主观性</strong></p><p>模型中使用的一些参数是主观获取的。尽管我们考虑了许多政府报告和其他国家的发展情况，但在一定程度上，这些参数似乎是主观的。</p></li><li><p><strong>不包括灾害因素</strong></p><p>在我们的模型中，紧急事件，包括自然灾害和人为干扰事件，并未考虑在内。面对破坏性灾难时，我们的模型不够可靠。</p></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美赛O奖赏析（抄录）</title>
      <link href="/2024/01/31/%E7%BE%8E%E8%B5%9BO%E5%A5%96%E8%B5%8F%E6%9E%90%EF%BC%88%E6%8A%84%E5%BD%95%EF%BC%89/"/>
      <url>/2024/01/31/%E7%BE%8E%E8%B5%9BO%E5%A5%96%E8%B5%8F%E6%9E%90%EF%BC%88%E6%8A%84%E5%BD%95%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="论文赏析（照抄）篇"><a href="#论文赏析（照抄）篇" class="headerlink" title="论文赏析（照抄）篇"></a>论文赏析（照抄）篇</h1><h1 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h1><p>关掉灯，点亮星星</p><h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><blockquote><p>光污染是⼈类活动造成的⼀种环境污染，对野⽣动物、植物和⼈类健康产⽣负⾯影 响。随着城市化、⼯业化的不断发展，光污染问题⽇益严峻。因此，光污染⻛险⽔平的评 估和改善显得尤为重要。 ⾸先，我们收集了来⾃55个地区的10个指标的数据，并将这10个指标分为三个领域： 光、社会和⾃然。然后我们结合了层次分析法, 熵权法， 和变异系数法计算这些指标的综合 权重，构建公式光污染指数（LPI），然后构建 LSN评估模型。最后，我们使⽤模糊聚类分 析将所有地点分为四类，从⽽将光污染等级分为四级。 其次，我们选择纽约市、⻉尔维尤、塞多纳和⻩⽯国家公园作为每种地点类型的代 表。使⽤LSN评估模型，他们的 LPI 计算为 35.55、41.33、76.94、84.18。由此，其光污 染等级分别为Ⅰ级、Ⅱ级、Ⅲ级、Ⅳ级。 第三，我们提出了三种⼲预策略及其具体⾏动，构建了PIA-NN模型，并研究了具体 ⾏动对光污染影响的潜在影响。三种⼲预策略是：减少⼈造光强度、加强宣传教育、扩⼤ 植被⾯积。我们结合实际情况，定量反映了三种⼲预策略对光污染效果的“潜在影响”斯 ⽪尔曼相关系数和BP神经⽹络模型。 接下来，我们选择塞多纳和纽约市两个具有代表性的地区，利⽤ PIA-NN模型和LSN 评估模型。结果表明，对于这两个地区来说，降低⼈造光强度是降低光污染⻛险⽔平最有 效的⼲预策略。 最后，我们将选择纽约市作为活动地点，并围绕其相应的最有效的⼲预策略设计精美 的传单。</p><p>关键词：LSN评估模型；LPI；PIA-NN模型；层次分析法</p></blockquote><p>由于本文要确定光污染的指标，因此自然会想到光源，社会，以及自然等因素，然后这些因素又可以进行划分，并由此得到了3个一级指标，10个二级指标，然后指标权重的确立可以像他一样使用层次分析法，熵权法，变异系数法，并综合权重，构建光污染系数。</p><p>然后系数吗，这个光污染系数自然会导致分类，什么系数算好，什么系数算中等，什么系数算差，于是这时候我们可以聚类分析出一些指标，并且给我们选择的地区划分这些指标，</p><p>接下来提出干预政策和具体行动…</p><p>简介………………………………………………………. ……………………………………………… ….3 </p><p>1.1 问题背景………………………………………………………. ……………………………………………… ……3 </p><p>1.2 我们的⼯作……………………………………………… ……………………………………………… …………………………..3 </p><p>2 假设和论证………………………………………………………. …………………………..4 </p><p>3 符号………………………………………… ……………………………………………… ……5</p><p> 4 光-社会-⾃然（LSN）评估模型………………………………………… ……5 </p><p>4.1 评价体系的建⽴……………………………………………… ………………………………………………6 </p><p>4.2 指标权重的确定………………………………………………………. …………………………..9 </p><p>4.3 LSN评价模型的建⽴………………………………………………………. ……………………12 </p><p>4.4 LSN 评价模型的应⽤………………………………………………………. ……………………13 </p><p>5 可能的⼲预策略………………………………………………………. ………………………………..16 </p><p>5.1 战略建议和具体⾏动………………………………………………………. ………………………………..16 </p><p>5.2 潜在影响分析-神经⽹络（PIA-NN）模型………………………………………… ..17 </p><p>6 哪种策略最有效？……………………………………………… ……………………19 </p><p>6.1 亚利桑那州塞多纳的结果……………………………………………….. ………………………………………………20 </p><p>6.2 纽约市纽约市的结果…………………………………. ………………………………..20 </p><p>6.3 最终结果………………………………………………………. ……………………………………………… ………………………………..21 </p><p>7 敏感性分析………………………………………………………. ………………………………………………21 </p><p>8 模型评估与进⼀步讨论………………………………………………………. ……22</p><p> 8.1 优势………………………………………… ……………………………………………… ………………….22 </p><p>8.2 弱点………………………………………… ……………………………………………… ……………….23 </p><p>8.3 进⼀步讨论………………………………………………………. ……………………………………………… ……..23 </p><p>9 结论………………………………………………………. ……………………………………………… …..23 </p><p>参考 …………………………………………. ……………………………………………… ……24</p><h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>1.1 问题背景</p><blockquote><p>光污染最早是在 20 世纪 50 年代由天⽂学家提出的。[1]随着城市化进程和经济发展的 加快，夜间照明的需求逐渐增加。同时，⼈类在夜间过度使⽤或不合理使⽤⼈造光源，破 坏了⾃然的⿊暗。根据国际暗夜协会的数据，全球80%以上的⼈⼝⽣活在受光污染影响的 地区，[2]⽽欧美约99%的城市居⺠⽆法在夜间观测银河系。[3]在全球许多⼤城市，夜间的 亮度甚⾄可以达到⽩天的⽔平。 光污染问题⽇益影响⼈们的⽇常⽣活，包括⼯作和休闲活动。它不仅破坏了美丽的夜 空景观，⽽且对⼈类健康、安全和⽣态环境产⽣负⾯影响。根据天⽂研究，没有光污染的 晴朗天空可以看到⼤约7000颗星星，⽽⼤城市只能看到20-60颗星星。夜间过多的⼈造光 会扰乱⽣物体的昼夜节律，导致睡眠质量差和失眠率升⾼。⽽且，⼈眼过度的光线照射会 损害视⽹膜和虹膜，导致视⼒急剧下降。光线充⾜的城市街道上的远光灯还会对街道对⾯ 的⾏⼈或司机造成短暂的“视觉损失”，从⽽导致交通事故的发⽣率更⾼。此外，光污染 还会改变植物的⽣⻓周期并影响野⽣动物的迁徙模式。</p><p>因此，光污染问题亟待全球关注和监管</p><p>（背景可以进行稳健查阅，要求符合文章基调）</p></blockquote><p>1.2 我们的⼯作</p><blockquote><p> ⾸先，我们提出光-社会-⾃然（LSN）评估模型，⽤于评估某个地点的光污染⻛险等 级。具体来说，该模型考虑了许多反映光污染的指标。根据这些指标，我们建⽴了⼆级评 价体系。考虑到不同⽅法都有其局限性，综合运⽤层次分析法（AHP）、熵权法（EWM） 和变异系数法（CVM）确定指标权重。我们选取全球55个有代表性的地点，根据相关数据 计算其光污染指数，并通过模糊聚类确定不同的光污染程度。 其次，我们选择了美国四个不同类型的地点，利⽤LSN评价模型计算了每个地点的光 污染指数，并结合当地实际情况分析了结果的合理性。 然后，在我们之前构建的指标中，我们在考虑其可⾏性的同时，提出了三种⼲预策 略。对于每项⼲预策略，都提供了具体的⾏动。我们还构建了 PIA-NN 模型来分析这些⾏ 为对光污染影响的潜在影响。结果将被可视化并分析其合理性。 此后，我们选择任务2中的两个地点作为研究对象，利⽤PIA-NN模型和LSN评估模型 分析三种⼲预策略对其光污染⻛险⽔平的影响，并做出相应的分析。 最后，我们将选择纽约市作为活动地点，并围绕其相应的最有效的⼲预策略设计精美 的传单。</p></blockquote><p><img src="/images/image-20240131120022411.png" alt="image-20240131120022411"></p><p>图1：我们论⽂的结构</p><h1 id="2-假设和理由"><a href="#2-假设和理由" class="headerlink" title="2 假设和理由"></a>2 假设和理由</h1><blockquote><p> 假设1：本⽂将LPI（光污染指数）定义为⼀个地区光环境的得分。LPI值越⾼，该地区的 光污染程度越低。 </p><p>理由：⼀个地区的光污染程度越低，该地区的光环境越好。根据⼈们的使⽤习惯，较 好的条件对应较⾼的分数是很常⻅的。 </p><p>假设2：相关性分析中，只保留相关性强的因素，去除相关性⼩的因素。 </p><p>理由：影响光污染的因素很复杂。如果将不太相关的因素也考虑在内，就会使研究结 果变得不那么显着，甚⾄可能产⽣误导性的结论。 </p><p>假设3：假设从互联⽹收集的数据真实可靠。 </p><p>理由：在研究光污染的过程中，我们选择了全球最典型的地区，因此保证了数据的⼴ 泛性；所有数据均来⾃官⽅⽹站，数据可靠性有保证</p><p>（收集数据所必备）</p></blockquote><p><img src="/images/image-20240131120303423.png" alt="image-20240131120303423"></p><h1 id="4-光-社会-⾃然（LSN）评估模型"><a href="#4-光-社会-⾃然（LSN）评估模型" class="headerlink" title="4 光-社会-⾃然（LSN）评估模型"></a>4 光-社会-⾃然（LSN）评估模型</h1><blockquote><p> 在本节中，我们建⽴光-社会-⾃然（LSN）评估模型来⼴泛衡量⼀个区域内某个地点 的光污染⻛险⽔平。⾸先，确定了各级指标后，建⽴了综合评价体系。[4]然后采⽤组合权 重法确定各指标的权重。最后，我们计算了光污染指数（LPI），从⽽识别某个地点的光污 染⻛险级别。 考虑到不同地点的光污染⻛险⽔平在较⼤范围内差异较⼤，因此在讨论光污染⻛险⽔ 平时，应选择尽可能⼩的地点，例如社区或住宅区，⽽不是选择⼀个区域。⼤⾯积区域， 例如国家或城市。因此，我们筛选了全球55个有代表性的站点，并将这55个站点的相关数 据作为本⽂的数据库。在此基础上，我们建⽴了光-社会-⾃然（LSN）评价模型。</p></blockquote><p>4.1 评价体系的建⽴</p><blockquote><p> 在参考⼤量前⼈研究和相关论⽂后，我们总结出反映光污染⻛险⽔平的三个关键因 素：光因素（L）、社会因素（S）和⾃然因素（N），并将其作为第⼀个因素。评价体系 中的等级指标。经过进⼀步思考和归纳，我们将指标具体化，选取了10个具体指标作为评 价体系中的⼆级指标。[5]具体评价体系如下，如图2所⽰。</p></blockquote><p><img src="/images/image-20240131120746843.png" alt="image-20240131120746843"></p><p>4.1.1 光 光因素是决定光污染⻛险等级的最重要因素。经过⼤量⽂献查阅和严格分析，我们最 终确定具体的光因素包括以下四点：</p><blockquote><p>L1</p><p>⼈造光强度 ⼈造光强度是指⼈类活动产⽣的光的亮度。在光污染研究中，⼈造光强度是⼀个重要 指标，⽤于衡量夜间⼈造光对周围环境的强度和影响。⼈造光强度通常使⽤光度计或相关 测量仪器进⾏测量，单位为坎德拉&#x2F;平⽅⽶（微cd&#x2F;⽶²),表⽰单位⾯积上光源的亮度。⼈⼯ 光强度数据可以通过光污染地图官⽹获取。</p><p>L2</p><p>⼈造光密度 ⼈造光密度是指⼀定地点的⼈造灯数量，通常⽤单位⾯积的灯数量来表⽰，如每平⽅ 公⾥的路灯数量。⾼⼈造光密度意味着⼀个区域中有更多的光。这些灯会在夜间产⽣更多的⼈造光。因此，⼈造光密度是影响因素之⼀ 影响光污染的重要因素。</p><p><img src="/images/image-20240131121053530.png" alt="image-20240131121053530"></p><p>L3 天空亮度</p><p>天空亮度是指天空某⼀区域可⻅的亮度⽔平，通常以单位⾯积的光通量来表⽰，例如每 平⽅⽶的⽉光或星光通量。这与光污染有密切关系。光污染越严重，天空亮度越⾼，会降 低夜间空⽓透明度，遮挡星光和⽉光。 天空亮度的增加会对⽣物环境和⽣态系统产⽣负⾯影响。例如，它可以影响夜⾏动物 的⾏为和迁徙，⼲扰植物⽣⻓和物种繁殖，扰乱⼈类昼夜节律和⽣理节律，甚⾄影响⼈ 类健康。 不同地区的天空亮度可以通过光污染地图⽹站获得。</p><p>L4 强光 </p><p>眩光是指极亮的光源与背景形成对⽐，导致眼睛不适并降低能⻅度的视觉状态。[6]眩 光对光污染程度有显着影响，眩光值越⾼，表明该区域光污染越严重，眩光值越低，表明 光污染程度越低。 眩光最常⻅于室外，如建筑物的玻璃幕墙，在阳光照射下会产⽣强烈的眩光，严重影 响⼈们的安全，破坏城市⽣活环境，并可能造成交通安全隐患。 根据国际通⽤眩光计算公式，并结合 了解眩光的含义后， 的值由以下公式确定：</p><p><img src="/images/image-20240131121232809.png" alt="image-20240131121232809"></p></blockquote><p>4.1.2 社会 </p><blockquote><p>社会因素是光污染的重要影响因素之⼀。社会因素包括地区⼈⼝、地区发展⽔平、教 育、宣传⼒度等诸多⽅⾯。这些因素影响⼈们对光污染的认识和态度，从⽽影响他们的⾏ 为。在建⽴光污染评价体系时，社会因素是重要的组成部分。</p><p>⼈⼝ ⼀个地区的⼈⼝是指居住在某⼀特定地区的⼈⼝数量，它与光污染密切相关。⼀⽅ ⾯，随着⼈⼝的增加，对照明的需求也随之增加。另⼀⽅⾯，⼈⼝数量也决定了光污染的 范围。⼀般来说，⼈⼝较多的地区⼈造光源⽔平较⾼密度和光污染。相反，在⼈⼝较少的地区，光污染程度可能相对较低。 不同地区的⼈⼝数据可以从各国国家统计年鉴中获得。</p><p>发展 区域发展⽔平通常是指经济、社会和环境的发展⽔平，可以⽤GDP等指标来衡量。 不同地区的GDP可以从各国国家统计年鉴中获得。 但值得注意的是，区域发展⽔平的提⾼并不⼀定会导致光污染⽔平的提⾼。发达城市 地区往往拥有更多的⼈造光源和更⾼的光强度，但也拥有更先进的技术和管理⽅法，可以 有效控制光污染问题。另⼀⽅⾯，发展⽔平较低的地区可能缺乏⾜够的技术和资⾦来控制 光污染，从⽽导致光污染程度更⾼。</p><p>宣传教育 ⼀个地区的光污染教育和宣传⽔平通常是指该地区光污染宣传教育的程度。这包括传 播有关光污染、其有害影响和预防措施的知识。加强宣传教育，可以提⾼公众对光污染的 认识，提⾼对光污染的关注，从⽽减少该地区的光污染。</p><p>为了定量地描述⼀个地区对光污染的教育和宣传的程度，我们以公众对光污染的关注 度作为衡量标准。这可以通过计算该地区⾕歌趋势上与光污染关键词相关的搜索数量来实 现。</p></blockquote><p>4.1.3 ⾃然 </p><blockquote><p>⾃然因素与光污染有着密切的关系。⾃然因素对光污染的影响主要包括区域⽓候、地 理位置、⽣物多样性等⽅⾯。建⽴光污染评价体系时，需要考虑该地区的⾃然环境特征， 量化⾃然因素对光污染的影响。</p></blockquote><p><img src="/images/image-20240131121758377.png" alt="image-20240131121758377"></p><p><img src="/images/image-20240131121812526.png" alt="image-20240131121812526"></p><p><img src="/images/image-20240131121932699.png" alt="image-20240131121932699"></p><p>4.2 指标权重的确定 </p><blockquote><p>确定指标权重的⽅法有多种。为了使我们的模型更加准确，我们决定使⽤组合赋权的 ⽅法来计算所有指标的权重。我们的组合赋权⽅法结合了主观赋权法中的层次分析法 （AHP）和客观赋权法中的熵权法（EWM）和变异系数法（CVM）。由于层次分析法的判 断较为主观，很容易受决策者的主观影响⽽发⽣变化。同时，由于数据的敏感性较⾼，可 能会因数据本⾝的原因⽽造成错误。因此，我们的组合加权⽅法综合了这些⽅法来帮助我 们减少误差并提⾼准确性。</p></blockquote><p>（这一点太妙了）</p><p>4.2.1 层次分析法 ⾸先，根据之前选择的指标构建层次结构图，如下图 3 所⽰</p><p><img src="/images/image-20240131122034950.png" alt="image-20240131122034950"></p><p>4.2.2 熵权法 </p><blockquote><p>⾸先将数据库中55个地点的指标数据进⾏聚合，形成原始矩阵X。由于指标类型不 同，我们需要对原始矩阵进⾏归⼀化处理。接下来，为了消除维数的影响，需要对归⼀化 矩阵进⾏标准化，得到矩阵Y。本⽂结合指标的归⼀化和标准化过程，具体计算公式如 下：</p></blockquote><p><img src="/images/image-20240131122104690.png" alt="image-20240131122104690"></p><p><img src="/images/image-20240131122121885.png" alt="image-20240131122121885"></p><p>4.2.3 变异系数法</p><p><img src="/images/image-20240131122144194.png" alt="image-20240131122144194"></p><p><img src="/images/image-20240131122155004.png" alt="image-20240131122155004"></p><p>4.3 LSN评估模型的建⽴ </p><blockquote><p>考虑到光、社会和⾃然对光污染的影响，我们开发了LSN评估模型。在该模型中，我 们引⼊LPI（光污染指数）来定量描述光污染的⻛险⽔平。另外，根据所选数据库，我们 通过模糊聚类分析将LPI值划分为四个区间，即将光污染⻛险等级划分为四个等级。</p></blockquote><h2 id="模型的创造性建立"><a href="#模型的创造性建立" class="headerlink" title="模型的创造性建立"></a>模型的创造性建立</h2><p><img src="/images/image-20240131122308590.png" alt="image-20240131122308590"></p><p>聚类分析</p><p><img src="/images/image-20240131122325180.png" alt="image-20240131122325180"></p><h1 id="4-4-LSN评估模型的应⽤"><a href="#4-4-LSN评估模型的应⽤" class="headerlink" title="4.4 LSN评估模型的应⽤"></a>4.4 LSN评估模型的应⽤</h1><blockquote><p>在本节中，我们根据任务2的要求，选择了美国境内四个不同类型的地点。我们收集 了相关指标数据，并应⽤建⽴的LSN模型来确定每个地点的光污染⽔平。</p></blockquote><p><img src="/images/image-20240131122405873.png" alt="image-20240131122405873"></p><h2 id="4-4-1-案例⼀："><a href="#4-4-1-案例⼀：" class="headerlink" title="4.4.1 案例⼀："></a>4.4.1 案例⼀：</h2><blockquote><p>⼀个城市社区 城市社区是⼈⼝稠密、建筑集中、基础设施完善、⼈们从事经济活动和丰富社会⽣活 的地区。我们选择纽约州纽约市作为研究地点，相关数据如下：</p></blockquote><p><img src="/images/image-20240131122430838.png" alt="image-20240131122430838"></p><blockquote><p>将上述数据代⼊LSN评估模型，则纽约市的LPI值为 35.55</p><p>属于⼀级光污染，光污染程度⾮常严重。 纽约市⼈⼝密度⾼，城市基础设施⾼。⾼⼈⼝密度意味着城市中有许多⼈造光源，包 括路灯、建筑灯和发光标志。⾼⼤的建筑物反射和散射光线，产⽣⼀种称为天空辉光的现 象，这也增加了光污染的程度。造成纽约市光污染的另⼀个因素是该市作为经济和⽂化活 动中⼼的⻆⾊。这座城市的许多企业、⽂化机构和公共场所都营业到深夜，该市的旅游业 也严重依赖光线充⾜的景点和地标。这意味着城市需要⼤量的室外照明，这可能是光污染 的重要来源。</p></blockquote><h2 id="4-4-2-案例⼆："><a href="#4-4-2-案例⼆：" class="headerlink" title="4.4.2 案例⼆："></a>4.4.2 案例⼆：</h2><blockquote><p>郊区社区 郊区社区是通常位于较⼤城市地区郊区的区域。它是住宅和商业开发的混合体。郊区 社区经常有</p><p>中低⼈⼝密度、单⼾住宅以及靠近⼤城市地区。因此，它们属于中等亮度环境的范畴。我 们选择华盛顿州⻉尔维尤作为研究地点，其相关数据如下：</p></blockquote><p><img src="/images/image-20240131122533439.png" alt="image-20240131122533439"></p><blockquote><p>将上述数据输⼊LSN评估模型，华盛顿州⻉尔维尤市的LPI值为41.33，对应⼆级。这 意味着⻉尔维尤有中等程度的光污染。</p><p> 虽然郊区距离市中⼼有⼀段距离，但对于想要远离拥挤的城市地区的⼈们来说，郊区 是最好的选择。这就导致郊区⼈⼝不断增加，室外⼈⼯照明越来越多，不可避免地造成⼀ 定程度的光污染。</p></blockquote><h2 id="4-4-3-案例三："><a href="#4-4-3-案例三：" class="headerlink" title="4.4.3 案例三："></a>4.4.3 案例三：</h2><blockquote><p>⼀个乡村社区 农村社区是城市或郊区以外的区域。它的典型特征是开阔的空间、⾃然景观和较⼩的 ⼈⼝密度，包括⼩城镇、村庄和偏远地区。农村社区获得现代基础设施和服务的机会有 限，因此属于低亮度环境区。我们选择亚利桑那州塞多纳作为研究区域，相关数据如下：</p></blockquote><p><img src="/images/image-20240131122618836.png" alt="image-20240131122618836"></p><blockquote><p>将上述数据代⼊LSN评估模型，得到LPI值 亚利桑那州塞多纳为76.94，相当于Ⅲ级。</p><p>这意味着塞多纳的光污染较少。 这是由于其距主要城市较远且⼈⼝密度较低。然⽽，随着城市的扩张和农村地区⼾外 照明需求的增加，甚⾄农村社区也开始受到光污染的影响。例如，LED 照明在农村地区的 普及导致了光污染的增加，并扰乱了⼈类和野⽣动物的⾃然睡眠模式。</p></blockquote><h2 id="4-4-4-案例四："><a href="#4-4-4-案例四：" class="headerlink" title="4.4.4 案例四："></a>4.4.4 案例四：</h2><blockquote><p>受保护的⼟地位置 在受保护的⼟地上，⼏乎没有常住⼈⼝，因此⼈造光的强度和密度较低，⼏乎不受光 污染的影响。这些是⾃然的⿊暗环境，例如国家公园和⾃然保护区。</p><p> ⻩⽯国家公园是美国西部的⼀个国家公园，主要位于怀俄明州。它成⽴于1872年，是 世界上第⼀个国家公园。⻩⽯国家公园是⼾外爱好者的天堂，也是国际暗夜公园。因此， 我们选择⻩⽯国家公园作为我们的研究地点，相关数据如下：</p></blockquote><p><img src="/images/image-20240131122704796.png" alt="image-20240131122704796"></p><blockquote><p>当我们将上述数据输⼊LSN评估模型时，我们得到的LPI值为 ⻩⽯国家公园为 84.18，该值较⾼，对应于 IV 级。这表明公园光环境良好，受光污染影响 最⼩。</p><p> 这与⻩⽯国家公园作为重点保护区，为保护夜间⾃然环境，在减少园内光污染⽅⾯做 出了很多努⼒，⽐如在夜间关闭⾮必要的灯光，⿎励游客使⽤红⾊滤光⼿电筒，这对野⽣ 动物和⼈类的⼲扰较⼩。因此，公园可以保持⾃然的夜间环境。</p></blockquote><h1 id="5-可能的⼲预策略"><a href="#5-可能的⼲预策略" class="headerlink" title="5 可能的⼲预策略"></a>5 可能的⼲预策略</h1><blockquote><p> 光污染是影响⼈们⽣产⽣活的⽇益严重的问题。光污染改变了我们对夜空的看法，对 环境产⽣影响，并影响我们的健康和安全。为了减轻光污染的负⾯影响，我们提出了三种 可能的⼲预策略并指出了它们的具体⾏动。然后，我们基于Spearman相关系数和BP神经 ⽹络模型构建了PIA-NN模型，⽤于分析这些特定⾏为对光污染效应的潜在影响。</p></blockquote><p>5.1 战略建议和具体⾏动 </p><blockquote><p>从前⽂构建的评价体系来看，影响光污染⽔平最显着的因素是“光”、“社 会”和“⾃然”，其下⼜分为⼗个具体指标。我们针对三个不同的指标并考虑它们的适⽤ 性。最后，我们提出了解决光污染问题的三种⼲预策略及其具体⾏动。</p></blockquote><p>5.1.1 策略⼀：</p><blockquote><p>减少⼈造光强度 太多的⼈造光强度会使夜间的天空变得明亮。这不仅影响⼈类的昼夜节律和健康，还 会影响野⽣动物的摄⻝和迁徙，从⽽破坏⽣态平衡。因此，降低给定区域的⼈造光强度可 以⼤⼤减轻光污染并减轻其有害影响。</p><p> 为了减少⼈造光强度，可以采取以下具体措施： </p><p>⚫ 优化照明设备：⽤⼩功率LED灯替代⼤功率照明设备；在住宅区和建筑⾛廊使⽤ 声控感应灯。 </p><p>⚫ 规范照明使⽤：将照明设备限制在必要的区域，例如室内区域和需要夜间安全的 区域；拆除郊区、农村⽆居⺠的照明设备。 </p><p>⚫ 减少夜间活动：尽量减少夜间⼤型聚会和庆祝活动，或者减少其规模和频率。 </p><p>⚫ 智慧城市规划：在城市规划中，将灯具设计为屏蔽型，仅将光引导到需要照明的 区域，⽽不将光分散到周围环境。</p></blockquote><p>5.1.2 策略⼆：加强宣传教育 </p><blockquote><p>我们可以通过教育提⾼公众对光污染的认识，并促进对其有害影响的关注。这将⿎励 公众参与光污染防治，最终缓解问题。为了加强我们的努⼒，我们可以采取以下⾏动：</p><p> ⚫ 张贴信息海报：在公共区域、社区、学校张贴海报，对公众进⾏光污染教育，提 ⾼认识。</p><p> ⚫ 举办社区活动：在社区举办讲座、研讨会、展览等宣传活动，帮助公众了解⼈造 光污染的影响和减少⽅法。 </p><p>⚫ 利⽤媒体宣传：利⽤各种媒体渠道，如电视、⼴播、报纸、杂志和互联⽹，宣传减少光污染及其有害影响的重要性。 </p><p>⚫ 加强学校教育：通过学校课程、校园公告、教学视频等⽅式向学⽣提供有关光污 染的知识和⽅法，⿎励他们成为环境保护的积极参与者和倡导者。</p><p>5.1.3 策略三：</p><p>扩⼤植被⾯积 扩⼤植被⾯积是减少光污染的有效途径，植被具有阻挡和吸收光污染的作⽤。植被可 以吸收⼀定波⻓的光污染，也可以反射和散射光，从⽽减轻光污染程度。植被的叶⾯积和 密度越⼤，对光污染的吸收和反射越强。因此，扩⼤植被⾯积可以解决光污染问题。以下 是扩⼤植被覆盖的⼀些具体⾏动：</p><p>⚫ 植树：在城乡种植各类树⽊，可以增加植被覆盖度，缓解光污染。 </p><p>⚫ 绿化建筑：在城市地区，在建筑物和道路上种植树⽊、草坪等绿⾊植被，可以增 加城市植被覆盖率，并通过植被的反射和散射减少光污染。 </p><p>⚫ 保护现有植被：保护现有的森林、草原、湿地等，防⽌过度开发和破坏，可以保 持植被缓解光污染。</p></blockquote><p>5.2 潜在影响分析-神经⽹络（PIA-NN）模型 </p><blockquote><p>⾸先，我们确定了三个直接影响因素：⼈⼯光强度、宣传教育和⽣物多样性，这三个 因素将受到三种⼲预策略的直接影响。 接下来，我们计算了三个直接影响因素与其他因素之间的Spearman相关系数，并找 出了与每个直接影响因素密切相关的间接影响因素。 要分析具体⾏动对光污染影响的潜在影响，了解这些间接影响因素的变化趋势和程度 ⾄关重要。 为了实现这⼀⽬标，我们开发了潜在影响分析-神经⽹络（PIA-NN）模型。通过构建 神经⽹络，获得间接影响因素相对于相应的直接影响因素的变化趋势和程度，并分析特定 ⾏为对光污染效果的潜在影响。</p><p>5.2.1 模型建⽴ 要考察具体⾏动对光污染效应的潜在影响，⾸先需要确定三个直接影响因素对其他光 污染因素的影响。为此，结合本⽂的数据库，我们开发了PIA-NN模型。</p><p> 为了探究因素之间的关系，我们测试了因素的正态性，发现只有天空亮度数据是正常 的。[8]因此，我们选择Spearman相关系数来衡量因素之间的相关性。[9]Spearman相关系 数的具体计算如下：</p></blockquote><p><img src="/images/image-20240131123959852.png" alt="image-20240131123959852"></p><blockquote><p>得到上述三组对应因素之间的相关性后，我们利⽤Matlab中的Neural Fitting应⽤程 序，在之前的数据库的基础上建⽴了三个神经⽹络，分别是：</p><ol><li>⼈造光强与⼈造光密度、眩光之间的神经⽹络， 天空亮度和⽣物多样性。（策略⼀） </li><li>2.宣传教育与⼈造光强度、天空之间的神经⽹络 亮度、眩光和⽣物多样性。（策略⼆） </li><li>3.⽣物多样性与天空亮度和眩光之间的神经⽹络。（策略三）通过这三个神经⽹络， 我们可以清楚地看到随着三个直接影响的变化，相应的间接影响的变化趋势和程度。</li></ol></blockquote><p>5.2.2 结果与分析 </p><blockquote><p>根据上述PIA-NN模型，我们得到了三组间接影响及其对应的直接影响的趋势，如下： （策略⼀）⼈造光密度、眩光、天空亮度和⽣物多样性随⼈造光强度的变化趋势。 （策略⼆）通过宣传教育了解⼈造光强度、天空亮度、眩光和⽣物多样性的变化趋势 （策略三）天空亮度和眩光随⽣物多样性的变化趋势。结果如 下图所⽰：</p></blockquote><p><img src="/images/image-20240131123851934.png" alt="image-20240131123851934"></p><p><img src="/images/image-20240131123841921.png" alt="image-20240131123841921"></p><p>从上图我们可以得出结论： </p><blockquote><p>从图（a）可以看出，随着⼈造光强度的降低，⼈造光密度、天空亮度和眩光均降 低，其中天空亮度降低最明显，眩光次之，⼈造光降低最弱密度，同时⽣物多样性显着增 加。这表明第⼀个策略的具体⾏动将导致夜晚更加⿊暗，进⼀步响应⽣物体的昼夜节律， 提⾼⼈们的睡眠质量，同时为野⽣动物提供更好的⽣态环境；此外，眩光将会减少，夜间 道路交通将更加安全；⽣物多样性会增加，表明该地区的⽣态环境得到改善，更加适合⼈ 类和动植物的⽣存。</p><p> 从图（b）可以看出，随着光污染意识和教育的增加，⼈造光强度、天空亮度和眩光 明显减少，⽣物多样性仍然增加。这表明第⼆个战略的具体⾏动将提⾼⼈们的意识，积极 参与光污染防治⾏动，从⽽减少⼈造光强度，还城市的夜晚和星空；减少眩光可以有效减 少⼈们眼部疾病的发⽣，从⽽对⼈们的健康产⽣积极的影响；⽣物多样性的增加可以为⼈ 类提供更好的⽣存环境。 </p><p>从图（c）可以看出，随着⽣物多样性的增加，天空亮度和眩光均出现明显的下降趋 势，且天空亮度下降的程度更为明显。这表明第三种策略的具体⾏动具有与前两种情况类 似的潜在影响，改善了⼈们对天空的印象，减少了交通事故的发⽣，给⼈们的⾝⼼健康带 来了积极的影响。</p></blockquote><h1 id="6-哪种策略最有效？"><a href="#6-哪种策略最有效？" class="headerlink" title="6 哪种策略最有效？"></a>6 哪种策略最有效？</h1><blockquote><p> 在本节中，我们研究了针对不同地区分别实施三种⼲预策略的不同效果。基于前4.4 节对四个不同区域光污染⽔平的评估，考虑不同区域⼲预策略的可⾏性，我们选择了两个 具有代表性的区域。⼀个是亚利桑那州塞多纳，光污染低的农村社区，另⼀个是纽约州纽 约市，光污染⾼的⼤城市，我们模拟在这两个地区实施三种不同的⼲预策略</p><p>本⽂提出的三种⼲预策略将分别直接影响⼈⼯光强度、宣传教育⼒度和⽣物多样性这 三个指标，并且由于这三个直接影响指标与某些其他指标之间存在相关性，因此这三个指 标的变化直接影响指标会导致相应间接影响指标的变化，我们应⽤前⽂建⽴的三个神经⽹ 络来预测每组间接影响指标的变化。</p><p> PIA-NN模型可以让我们获得战略实施和⽬标实现后该区域的指标值。最后，通过对⽐ 该策略实施前后该地区的LPI，我们可以清楚地看到该策略对该地区光污染⻛险⽔平的影 响。</p><p> 为了排除时间和强度对策略效果的影响，我们将每个策略的预定义⽬标设置为：该策 略将相应的直接影响指标增加或减少相同程度，例如增加或减少10%。以此作为策略实施 后计算该地区LPI的基础。</p></blockquote><p>6.1 亚利桑那州塞多纳的结果 </p><p>亚利桑那州塞多纳实施三种不同⼲预策略的结果如下：</p><p><img src="/images/image-20240131123606941.png" alt="image-20240131123606941"></p><blockquote><p>上图显⽰策略 I 是亚利桑那州塞多纳最有效的⼲预措施。当策略⼀的⽬标为90%时， 即当策略⼀的实施将⼈⼯光强度降低到90%时，社区的LPI显着增加。然⽽值得注意的 是，⼀旦⼈造光强度增加，例如增加到110%，该区域的LPI也会迅速下降。策略II和策略 III的LPI都有所增加，但不如策略I那么多。</p></blockquote><p>6.2 纽约州纽约市的结果 纽约州纽约市实施三种不同⼲预策略的结果如下：</p><p><img src="/images/image-20240131123706358.png" alt="image-20240131123706358"></p><blockquote><p>从上图我们可以看出，纽约州纽约市的LPI很低，属于重度光污染级别。虽然本⽂提 出的三种⼲预策略的实施将改善纽约州纽约市的LPI，但该策略的实施仍然使纽约州纽约 市处于严重光污染级别。策略⼀的LPI提升最快，预定⽬标为90%。策略⼆和策略三的实 施对该区域的LPI值影响不⼤，但相⽐之下策略⼆⽐策略三更有效。</p></blockquote><p>6.3 最终结果 </p><blockquote><p>对⽐前两张图，我们可以得出结论，实施策略⼀对于亚利桑那州塞多纳市和纽约州纽 约市的光污染减少效果最为有效，其预期⽬标相同，但不同之处在于策略⼀的影响就纽约 市⽽⾔，纽约更为明显。不同的是，策略⼀对纽约州纽约市的影响更为明显。</p><p> 策略⼀是从源头预防光污染。从前⾯的分析可以看出，⼈造光强度与⼈造光密度、眩 光、天空亮度密切相关，它们是影响光污染的主要因素，在LSN评价体系中占有较⼤的权 重，因此减少⼈造光强度对提⾼LSN评价体系中的LPI有显着效果。</p></blockquote><h1 id="7-敏感性分析"><a href="#7-敏感性分析" class="headerlink" title="7 敏感性分析"></a>7 敏感性分析</h1><blockquote><p>在构建PIA-NN模型时，我们分别验证了⼈⼯光强度、宣传教育⼒度、⽣物多样性等指 标之间的相关性，并筛选相关指标构建神经⽹络。可能是由于对问题考虑的不全⾯，导致 忽略了⼀些可能产⽣影响的⼈造光强度、宣传教育⼒度、⽣物多样性等指标。为了测试这 种可能的影响，我们重建了带有眩光、⽣物多样性和天空亮度的⼈造光强度的神经⽹络， 并通过改变⼈造光强度来观察原始模型和本模型与眩光、⽣物多样性和天空亮度的关系。 结果如下</p></blockquote><p><img src="/images/image-20240131123758844.png" alt="image-20240131123758844"></p><blockquote><p>从图中可以看出，改变⼈⼯光强度后，前后使⽤两个神经⽹络预测的三个指标的值都 ⽐较接近。结果表明，去除⼈造光密度指标对眩光、⽣物多样性和天空亮度的分析⼏乎没 有影响。这也表明未考虑的因素不会影响现有因素的分析，模型是稳健的。</p></blockquote><h1 id="8-模型评估及进⼀步讨论"><a href="#8-模型评估及进⼀步讨论" class="headerlink" title="8 模型评估及进⼀步讨论"></a>8 模型评估及进⼀步讨论</h1><p>8.1 优势 </p><blockquote><p>⚫ 为保证结果的可靠性，本⽂使⽤的数据均是官⽹提供的最准确、最新的数据。此 外，在尝试综合该问题时考虑了各种因素。因此，本⽂的研究结果具有较⾼的参 考价值。 </p><p>⚫ 我们综合考虑了光、社会、⾃然等⽅⾯的各项指标，使我们的评价模型更加全 ⾯、准确、客观。 </p><p>⚫ 本⽂结合神经⽹络模型构建了PIA-NN模型。在寻找指标之间的相关性时，神经⽹ 络通过包含⾜够神经元的隐藏层来逼近任意复杂度和任意精度的连续函数。与其 他线性模型相⽐，神经⽹络模型具有优越的性能，使其结果更加准确。 </p><p>⚫ 我们的模型的结果也符合常识和经验。</p></blockquote><p>8.2 弱点 </p><blockquote><p>⚫ 由于时间有限，本⽂仅选取了55个地区的数据作为数据库，建⽴了LNS评价体 系，通过模糊聚类分析将光污染⼤致分为四类，但尚不清楚LPI 值的范围。 </p><p>⚫ 模型中使⽤的数据不完整。由于客观原因，我们⽆法获得所需指标的全部数据， 这些数据不可避免地存在缺失值。虽然我们已经处理了缺失值，但是模型拟合的 准确性还是受到了⼀定的影响</p></blockquote><p>8.3 进⼀步讨论 </p><blockquote><p>由于本⽂的数据库只有55个区域，基于该数据库的光污染⻛险等级分类可能存在偏 差。因此，我们可以收集更多不同地区的数据，形成数据库进⾏分析，得到更准确、合理 的光污染⻛险等级划分标准。</p></blockquote><h1 id="9-结论"><a href="#9-结论" class="headerlink" title="9 结论"></a>9 结论</h1><blockquote><p>本⽂开发了⼀种⼴泛适⽤的评估模型来识别某个地点的光污染⻛险级别。我们选取了 全球55个有代表性的地点，并使⽤这些地点的相关数据作为本⽂的数据库。将所有数据带 ⼊LSN评价模型，计算各区域的LPI值，然后通过模糊聚类分析将55个区域分为四类，从⽽ 将轻污染等级分为四个等级，定义为： ⼀级：重度污染，⼆级：中度污染，三级：轻微污 染，四级：⽆污染。</p><p> 基于上述模型，我们选择纽约市、⻉尔维尤、塞多纳和⻩⽯国家公园作为每种地点类 型的代表。他们的 LPI 值计算为 35.55、41.33、76.94、84.18。由此，其光污染⻛险等级 分别为Ⅰ级、Ⅱ级、Ⅲ级、Ⅳ级。 </p><p>为了有效解决光污染问题，我们提出了三种可能的⼲预策略并指出了具体⾏动。最 后，我们构建了⼀个 PIA-NN 模型来分析这些具体⾏为对光污染效应的潜在影响。</p><p> 基于上述模型，我们选择塞多纳和纽约市作为研究对象。分别针对这两个领域模拟了 三种不同的⼲预策略。结论是，实施策略⼀对于降低这两个地区的光污染⽔平最为有效。</p></blockquote><h1 id="标题-1"><a href="#标题-1" class="headerlink" title="标题"></a>标题</h1><p>守护⿊夜，掌控光明！</p><h1 id="摘要-1"><a href="#摘要-1" class="headerlink" title="摘要"></a>摘要</h1><blockquote><p>⼈们通常会被城市灯光的“美丽”所震撼，却没有意识到这些也是污染的图像，就像欣 赏汽油在⽔中产⽣的彩虹⾊的美丽⽽没有意识到这是化学污染⼀样。在本⽂中，我们构建 了⼀个⼴泛适⽤的光污染⻛险评估模型来评估给定地点的⻛险⽔平，并提出了⼀个⼲预策 略模型来减轻不同地点的光污染影响。</p><p> 对于任务 1，我们提出光污染⻛险评估模型。该模型整合了来⾃以下⽅⾯的⻛险：四个 维度：光污染造成的⼈类、野⽣动物、植物和能源浪费。综合多项相关指标，EWM拓扑应 ⽤于解决整体⻛险评分，分为四个级别：脆弱(0-1)、较差(1-2)、⼀般(2-3)、良好(3-4)。 </p><p>对于任务 2，光污染⻛险评估模型应⽤于深圳四⼤典型区域，代表城市、郊区、农村和 保护区。在数据准备阶段，我们利⽤夜间遥感和多光谱遥感数据估算研究区域的归⼀化植 被指数（NDVI）、夜间辐射度和⼈⼝密度。保护区的⻛险评分为0.357992，⽽农村社区 的⻛险评分为1.859474，郊区社区的⻛险评分为2.114942，城市社区的⻛险评分为 3.19662。这些分数分别对应于脆弱、较差、⼀般和良好⽔平。</p><p> 对于任务 3，我们制定了三种⼲预策略，包括改善光源，降低光照强度，优化区域灯光 布局。然后我们为每个策略列出多个具体操作。基于微分⽅程的⼲预策略模型旨在量化三 种策略如何影响⻛险⽔平。 </p><p>对于任务 4，我们选择城市和郊区社区来验证三种⼲预策略的有效性。</p><p>未来50年，三⼤ 策略实施后的⻛险评分⼤约降低2%,6%， 和3% 分别。可以得出结论，第⼆种策略，降低 照明强度，旨在减少光辐射总量是城市和郊区最有效的⼲预策略。 最后，对⻛险评估模型的敏感性分析表明，单个评估指标-10%~10%的波动对最终⻛险 评分具有合理的影响，如图1所⽰。图16. 因此，该模型对于单个指标的变化具有鲁棒性。 此外，策略模型的敏感性分析如图所⽰图17 意味着我们的模型对于增⻓率来说是稳健的。</p><p> 关键词：光污染；⼲预策略；EWM-TOPSIS；微分⽅程</p></blockquote><h1 id="1-简介-1"><a href="#1-简介-1" class="headerlink" title="1 简介"></a>1 简介</h1><p> 1.1 问题背景</p><blockquote><p> 观看国际空间站拍摄的地球夜间图像，⼈们普遍被城市灯光的“美丽”所震撼，就像圣 诞树上的灯光⼀样，却没有意识到这些也是污染的图像。这就像欣赏汽油在⽔中产⽣的彩 虹⾊的美丽，却没有意识到这是化学污染。 </p><p>不恰当或过度使⽤⼈造光（称为光污染）可能会对⼈类、野⽣动物和⽓候造成严重的环 境后果。光污染的组成部分包括：</p><p> · 光侵⼊：光落在不想要或不需要的地⽅ </p><p>· 过度照明：照明强度⾼于适当的强度 · </p><p>光簇：明亮、混乱且过多的光源分组 </p><p>光污染的影响可能是深远且多样的，影响⾃然和⼈类系统。越来越多的证据表明光污染 与对⼈类健康、野⽣动物和环境的可衡量的负⾯影响有关。这些负⾯影响的⼀些例⼦包 括：</p><p> · 危害⼈类健康并影响犯罪和安全</p><p> · 破坏⽣态系统和野⽣动物</p><p> · 能源消耗增加 </p><p>· 影响天⽂观测 </p><p>重要的是要了解这些影响并采取措施减轻这些影响，以尽量减少对我们的环境、健康和 经济的负⾯影响。还有很⼤的改进空间 - 如果我们更仔细地照明，我们应该能够减少负⾯ 影响，同时仍然照亮地⾯。</p><p> 有多种⼲预策略可⽤于解决光污染问题，例如使⽤屏蔽、定向和节能照明、制定照明条 例和实施照明宵禁等。</p></blockquote><p>1.2 问题的重述</p><blockquote><p> COMAP 照明控制任务 (ICM) 要求我们提⾼⼈们对光污染影响的认识，并制定⼲预策略 以减轻负⾯影响。</p><p> 任务1：提出⼀个⼴泛适⽤的指标来衡量光污染⻛险⽔平 ⼀个地点，包含⼈类和⾮⼈类的关注点。</p><p> 任务2：应⽤我们的指标并在以下四种不同类型的位置解释其结果： 包括受保护的⼟地地点、农村社区、郊区社区和城市社区。 </p><p>任务3：概述三种可能的⼲预策略来解决光污染和 讨论为实施每项战略可采取的具体⾏动。考虑这些⾏动对光污染总体影响的潜在 影响。</p><p> 任务4：选择两个位置并应⽤之前开发的指标来确定 每个地点解决光污染最有效的⼲预策略。讨论所选⼲预策略如何影响该地点的⻛ 险⽔平。</p></blockquote><p>1.3 我们的⼯作 </p><blockquote><p>为了避免复杂的描述，直观地反映我们的⼯作流程，流程图如图2所⽰：</p></blockquote><p><img src="/images/image-20240131130756350.png" alt="image-20240131130756350"></p><h1 id="2-假设与解释"><a href="#2-假设与解释" class="headerlink" title="2 假设与解释"></a>2 假设与解释</h1><blockquote><p>考虑到实际问题总是包含许多复杂的因素，⾸先我们需要做出合理的假设来简化模型， 并且每个假设都紧接着其相应的解释：</p></blockquote><blockquote><p> 假设1：我们将市场上使⽤的照明灯具类型分为LED、 荧光灯和其他照明灯具。</p><p> 解释：LED和荧光灯的光谱和能源效率与市场上其他照明灯具有显着不 同。为了简化模型，我们将照明灯具的主要类型分为LED、荧光灯和其他 照明灯具。</p><p>假设2：我们假设我们在评估中没有选择的指标 评估模型对系统影响较⼩。</p><p> 解释：影响光污染的因素太多需要考虑，所以这个假设是合理的，有助于 避免构建模型时不必要的⿇烦。</p><p> 假设3：策略模型研究期间，变量如 不同地区和城市的⼈⼝密度、物种丰富度、植被覆盖度以及各种照明灯具 的发光效率保持相对稳定。 </p><p>解释：这些变量可能会经历⼀些波动，但为了简化模型，我们忽略这些微 ⼩的变化。 </p><p>假设4：我们假设所选的四个区域具有⾜够的代表性， 因此我们在前期研究中建⽴的评估模型的权重系数可以应⽤于全球任何地 点进⾏⻛险评估。</p><p>解释：我们选择的四个区域具有典型的城市、郊区、农 村和保护区特征。为了简化问题并使模型适⽤于任何区域，可以认为从这 四个区域获得的模型指标的权重系数是恒定的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第四章</title>
      <link href="/2024/01/31/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0/"/>
      <url>/2024/01/31/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="四章．新搬来的邻居"><a href="#四章．新搬来的邻居" class="headerlink" title="四章．新搬来的邻居"></a>四章．新搬来的邻居</h1><p>“爸，妈，我回来了”</p><p>苏瑾将车钥匙放在桌上，一只手撑着墙壁，一只手将鞋子脱下，走到阳台吹着风，想稍稍去除一场大战后的疲惫。</p><p>“怎么今天回来这么晚啊，我还以为你不回来吃饭了“，厨厅传来老妈雪玲芳的声音，</p><p>“去换一下衣服，准备吃饭了。”</p><p>“我去打球了，…….好嘞,马上到“苏瑾走进卧室，换衣服的同时顺带叫醒了还在睡觉的格格米。</p><p>“喵呜“，格格米睁开睡眼朦胧的双眼，长长打了个哈欠，如果有旁白，它一定想说，哪个人类敢打扰本喵睡觉。</p><p>“再不回来，你妈准把我臭骂一顿”旁边沙发上看着纪录片的苏晨，也就是苏瑾老爸轻笑抱怨道。</p><p>苏瑾的家庭条件还算可以，老爸苏晨在距离家不远处的江南中学教语文，爱好嘛，是钓鱼，闲暇时，时常带着苏瑾到江边垂钓。</p><p>老妈雪玲芳则酷爱时尚，热衷于服装设计，与志同道合的舅妈合开了一家服装店，可以说乐在其中了。</p><p>苏瑾很享受着这种平淡而舒适的生活，他没有什么宏大的理想，也没有什么长远的人生规划，有时会在网上上传一些弹吉他的视频，积少成多，也快收获了几十万粉丝，也有了一些小积蓄，不过这事他从没和父母提起，让它作为一个秘密，或是一个小成就埋藏于心。</p><p>对苏瑾来说，有几个交心的朋友，在该努力时努力，得到一个还算可以的成绩，考上一个还算可以的大学，将来找份喜欢的工作，娶个贤惠温柔的老婆，就蛮不错的。</p><p>厨房里，雪玲芳和苏瑾正在准备吃饭的餐具。</p><p>“苏瑾，隔壁你王阿姨今天搬走了。”</p><p>老妈雪玲芳冷不丁开口。</p><p>“这么突然，是发生了什么吗“苏瑾微微歪头，疑惑问道。</p><p>“王阿姨的老公在广州工作，升职了，买了间新房子，打算带他们一家人一起去广州生活了”，</p><p>“这样,王阿姨一家人都很善良，出去外面可以生活的更好的”</p><p>“听她说，这几天有另一家人还要搬过来，还有个和你年龄差不多的女儿，听王阿姨说也在江南中学读书，成绩听说还不错呢”。</p><p>“嗯，挺好的”苏瑾一贯对人际交往的事情不太感兴趣，扒了一口饭，草草回答。</p><p>“脑子里那个身穿绿色碎花布衫的女生的身影悄然浮现，原来她是新邻居，苏瑾的一个疑惑解开了，不过那种熟悉感又是怎么回事。</p><p>“听王阿姨说名字好像叫夏沫”</p><p>这个名字突然在苏瑾脑海里炸开，“难道是她！苏瑾突然加大音调，嘴里的饭甚至还没来得及吞下。</p><p>“什么“，苏晨微微探过头，打量着苏瑾。</p><p>没什么没什么，我只是突然想起高兴的事情“苏瑾打着马虎眼，把刚才没咽下去的饭咽下，吃完匆匆忙忙往书房赶去。</p><p>夫妻相望，一脸茫然，“这孩子”，苏晨摇摇头，不过夫妻俩也没有多想，就互相去收拾饭桌了。</p><p>苏瑾想起班级里一个记忆中不太起眼但又充满传奇的女孩夏沫，坐在教室里侧的一个角落，课间也总待坐在教室里，低头时秀发散落，微微挡住她的小脸，对于她来说，或许一个人便是一个世界吧。</p><p>苏瑾和她的交集极少，苏瑾本身也不是有一个会和女生说太多话的人，何况是和经常独来独往的夏沫。</p><p>唯一一次比较深的交集就是初三最后一次培优了，苏瑾因为值日而去晚了，到的时侯只剩一个座位，在苏穆清，顾千羽他们戏虐的眼光下，苏瑾走到角落，那里坐着一个长发及肩的女生，乌黑的头发，雪白的脖颈，低着头，那是夏沫，年级第一霸榜者。</p><p>她旁边还没有人坐，苏瑾清楚进来了再灰溜溜出去是不可能了，于是便硬着头皮上了。</p><p>“夏沫，我…能在这里坐吗？</p><p>很少与女生交流的苏瑾脸红到了极点，内心活动也激烈异常。如果被拒绝，那我去哪坐啊，如果有内心尴尬指数，现在的苏瑾肯定是百分之百，纯度那是杠杠的。</p><p>似乎被突然的声音吓了一跳，少女抬起头，似乎还没反应过来，呆了几秒，才发现有人要在这里坐，</p><p>“哦，可以“。少女说话的声音很温柔，带着些许江南女子的糯糯感。</p><p>苏瑾有种酥酥麻麻的感觉，像是跨过传入神经，直接传递到了大脑。</p><p>“这是老师刚刚发下来的试卷，给你”夏沫轻轻的把试卷推过来，纤细而柔滑的手臂又很快缩回去。</p><p>“谢谢”，苏瑾下意识的道谢，为了掩饰不知从何解释的尴尬，便将眼神对焦到黑板。不尴尬不尴尬，只是和年级第一坐一下，只是坐一下而已。</p><p>苏瑾的脸已经不像一开始那么红润，课上枯燥无味的数学题其实也没有那么无趣，他偶尔还能闻到旁边女孩飘来的淡淡香气，这似乎有种奇妙的魔力，竟有着提神醒脑的作用。</p><p>6点半，这最后一场培优结束了，落日余晖为校园染上一层金色，苏瑾向窗外望去，少女低头在整理文具，在夕阳下，苏瑾看到了那张平常很少看到的脸，余晖中，清秀的脸庞，皮肤白皙，淡雅的双眸如水一样纯净。</p><p>后来，中考后，他们未曾见过，彼此消失在茫茫人海中，似乎理应如此。</p><p>今日，新来的邻居是她，命运的邂逅与安排，竟然如此奇特。</p><p>苏瑾望向窗外，自言自语道“以后又会发生什么故事，既来之，则安之，还是先弹波吉他罢。“随即会心一笑，拿起那把陪伴多年的心爱的吉他。</p><p>天空渐渐昏暗，日落踏着晚霞而来，少年手握吉他，身旁的白猫安详的躺在怀里，享受着美妙的音符，一曲又一曲……</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美赛摘要</title>
      <link href="/2024/01/31/%E7%BE%8E%E8%B5%9B%E6%91%98%E8%A6%81/"/>
      <url>/2024/01/31/%E7%BE%8E%E8%B5%9B%E6%91%98%E8%A6%81/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要部分的写作参考"><a href="#摘要部分的写作参考" class="headerlink" title="摘要部分的写作参考"></a>摘要部分的写作参考</h1><p><img src="/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JheW1lNjI5,size_16,color_FFFFFF,t_70.png" alt="img"></p><p><img src="/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JheW1lNjI5,size_16,color_FFFFFF,t_70-1706633006728-3.png" alt="img"></p><h2 id="2021F题目为例"><a href="#2021F题目为例" class="headerlink" title="2021F题目为例"></a>2021F题目为例</h2><blockquote><p>高等教育是关键名词，那这个名词是什么？由什么指标决定？健康状况分为什么？评价指标？用什么模型？</p><p>然后权重？还有国家的评估？选取的国家？选择的研究对象？政策的实行？政策实行的效果？怎么预测效果？灰色预测？模型的优缺点？</p></blockquote><blockquote><p>在研究初期，我们需要定义高等教育系统的健康状况。因此，我们查阅了欧洲联盟、联合国教科文组织（UNESCO）、经济合作与发展组织（OECD）等国际机构的相关报告。结合一些基本的教育经济学概念，我们将健康状况分为两个方面：一是行业绩效的现状，另一是改进潜力。我们建立了两套评估体系及其相应的指标集来对应这两个方面。在许多综合评估模型中，我们选择了TOPSIS（Technique for Order Preference by Similarity to an Ideal Solution）来构建我们的评估模型。考虑到AHP在确定权重时过于依赖主管的判断的缺点，我们决定使用IEW（信息熵权重）方法来确定每个指标的权重。通过IEW-TOPSIS组合方法，我们将两套定性评估体系转化为定量评估模型。</p><p>我们从OECD的相关年度报告和在线数据库中获取了有关21个成员国2016年高等教育系统的大量数据，并将其放入两套评估模型进行评估。我们得到了这些国家在两个方面的得分并对其进行排名。在绩效现状方面，有11个国家表现良好，而在改进潜力方面，有10个国家表现良好。从21个国家中，我们选择了智利作为我们模型应用的对象，因为它具有巨大的改进潜力和相对较差的绩效状况。</p><p>我们首先分析了智利与其他国家在各种指标上的差异，然后基于其国情制定了合理而可持续的愿景。在提出政策之前，我们使用智利教育部发布的数据，通过GM（灰色模型）验证来验证采取强有力的政策改变智利高等教育行业现状的必要性。在现状和愿景之间，我们提出了适合智利高等教育系统的政策以及其实施的时间表。</p><p>我们将愿景的数据纳入模型来衡量绩效现状，发现尽管我们推荐的政策可以显著改善智利高等教育的绩效状况，但我们仍然不能称呼实现愿景的智利高等教育系统为健康。因此，我们提出的政策的有效性不够。最后，我们讨论了政策实施的影响以及本研究的优缺点。</p><p>关键词：高等教育，IEW-TOPSIS，OECD</p></blockquote><blockquote><p>一个健康、可持续的高等教育系统对国家能够带来一系列的价值。尽管世界各国的高等教育系统各有不同，但它们都或多或少存在缺陷。为了对每个国家的高等教育系统进行“体检”并提出相应的改进政策，我们开发了国家高等教育健康指数（NHHE）评估模型和其他相关模型。</p><p>为了建立国家高等教育健康指数评估模型，我们考虑了五个优越指标和23个劣势指标。我们进行了复杂但有意义的数据处理，并使用不同的方法对数据进行前进和标准化。考虑到计算权重的误差，我们综合了主观的层次分析法、客观的熵权法和变异系数法，将主观误差和数据误差最大程度上消除，通过组合权重方法使我们的模型更为准确。然后，我们使用TOPSIS综合评估方法来计算NHHE。最后，我们将40个国家纳入我们的评估模型，并对它们的计算结果进行模糊聚类分析。绘制了三条标准线，NHHE得分大于0.5被定义为超健康，得分在0.36-0.5之间被定义为亚健康，小于0.22被定义为不健康。</p><p>基于上述模型，我们引入了一个新的指标：国民收入指数（INNI）来代表一个国家的经济发展水平。我们通过回归分析分析了INNI和劣势指标，发现大多数指标与INNI之间存在强烈的相关性。在上述研究的基础上，我们估算了NHHE和INNI的曲线，并发现它们呈指数分布。基于预测曲线和所选国家的实际数据，我们定义了一个新的指标：高等教育系统国家相对健康指数（NRHHE），即考虑到国家经济发展水平后的高等教育系统健康水平。结合这两个模型，我们选择意大利作为研究对象，并选择与意大利具有相同经济发展水平的英国作为对比，制定了未来15年支持健康可持续的高等教育系统的愿景。最后，我们分别评估了意大利当前和未来愿景下的高等教育健康状况和相对健康状况。</p><p>为了支持意大利高等教育健康状况的改善，我们制定了相关政策。我们使用相关系数分析每个下属指标之间的关系，并发现许多指标之间存在强烈的相关性。为了提取主要影响因素，我们对每个指标和NHHE进行了单因素方差分析，并提取了与之最显著相关的五个指标。接下来，我们从五个方面制定干预政策并制定了一个规划进度表。干预政策将在三个阶段进行。</p><p>为了评估政策的有效性，我们考虑了政策的设计、传播、实施和反馈四个方面。其中，我们开发了干预政策与指标之间的系统动力学模型来分析它们之间的内在影响关系，并计算得出根据我们的计划，意大利可以在2035年实现我们的健康愿景。最后，我们讨论了我们的计划在意大利过渡期和达到最终状态后的影响。考虑到所有因素，我们承认变革是困难的。</p></blockquote><blockquote><p>高等教育系统是一个国家发展的重要组成部分。它直接承担国家科研任务，提供了大部分重要的研究成果。更重要的是，该系统一直在培养未来的人才，确保了国家未来的发展。每个国家都有其独特的高等教育系统，具有相应的优势和劣势。有必要全面分析和评估一个系统，发扬其优势并调整其劣势。然而，不同国家系统之间的差异使得很难为每个国家建立统一的评估标准。在本文中，我们建立了一套测量模型，评估高等教育系统的健康和可持续性。</p><p>为了衡量每个国家系统的健康状况，我们选择了五十个国家在2009年至2018年间六个主要因素和十四个指标的原始数据。然后，我们验证了数据的分布规律，并选择80%分位数作为每个指标的健康范围。此后，我们使用层次分析法（AHP）确定每个指标的权重。我们引入了总体得分增益（OPG）的概念，代表系统的总体健康状况。</p><p>我们还通过使用DEA-Malmquist模型建立了检查可持续性的方法。这是一个高度客观的模型，常用于时间序列分析。通过比较不同年份之间的相对效率，我们可以获得效率变化趋势。然后，我们可以根据趋势分析可持续性。</p><p>然后，我们选择了美国、英国、德国、日本、印度这五个国家作为分析对象，用我们的模型评估它们的健康和可持续性。我们的结论是：美国的系统是亚健康但可持续的，英国的系统是亚健康且可持续性差，德国的系统是完全健康且可持续性卓越，日本的系统虽然不健康但可持续，印度的系统不健康且不可持续。由于印度的高等教育系统有很大的改进空间，我们选择对其进行进一步分析。</p><p>首先，我们衡量了印度当前的系统。有限的资源、庞大的人口和经济压力导致低招生率和高失业率。其次，基于以上分析，我们提出了我们的三阶段愿景，包括短期、中期和长期。为了实现我们的愿景，我们提出了一些有针对性的政策。在短期政策中，我们迅速提高指标。政策包括降低贫困人口的教育成本、降低最低工资标准以及降低外国学生的入学标准。在长期政策中，我们考虑了印度的社会情况。政策包括家庭规划、经济结构转型和教育环境改善。我们还使用马尔可夫链预测未来政策的实施情况，这可以反映政策的灵活性。然后，我们评估了政策实施的实际影响和难度。</p><p>最后，我们讨论了我们模型的优点和缺点，为进一步研究留下了空间。</p></blockquote><blockquote><p>随着世界全球化的推进和科技水平的不断提高，各国之间的综合国力竞争日益激烈。高等教育系统的健康和可持续性反映了一个国家的科技水平和综合实力。一个健康和可持续的高等教育系统为国家提供人才，为社会科技发展提供智力支持，评估一个国家的高等教育系统的健康和可持续性，并学习如何使其更健康、更可持续，具有重要意义。</p><p>首先，我们建立了一个三维横向对比模型来评估一个国家的高等教育系统的健康和可持续性。这三个维度分别是成本与资本、获取与公平、学术水平。每个维度都有一个或两个用于量化的指标。这五个指标包括支出指数、性别平等指数、入学指数、研究水平和教育质量指数，由14个因素计算而得。通过对这5个指数分别评分，我们可以计算一个国家高等教育系统在一系列国家中的总相对得分。</p><p>然后，我们将该模型应用于澳大利亚、日本、瑞典、印度和英国，并得到了这些国家高等教育系统的评分。基于结果，我们选择了得分最低的印度，意味着印度的高等教育系统有最大的提升空间，并提出了四个为期五年的改进计划。这些计划旨在克服当前的不足，并根据我们提出的愿景制定了一系列政策。</p><p>我们将我们的模型修改为一个垂直对比模型，每五年测量一次印度教育系统的健康和可持续性。在实施所有四个五年计划之后，到2037年，曾经是不足之处的每个指数得分都将大幅提高，印度的高等教育系统得分将显著增加。</p><p>最后，我们讨论了政策实施的效果以及在最终状态下计划实施的实际影响。考虑到印度的社会状况和全国性问题，我们预测这些体制变革的实施将会面临困难。</p><p>关键词：高等教育系统；健康；可持续性；横向对比；垂直对比；相对得分；愿景；五年计划；政策</p></blockquote><h2 id="2021E为例"><a href="#2021E为例" class="headerlink" title="2021E为例"></a>2021E为例</h2><p><img src="/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JheW1lNjI5,size_16,color_FFFFFF,t_70-1706634023540-6.png" alt="img"></p><p><img src="/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1JheW1lNjI5,size_16,color_FFFFFF,t_70-1706634031683-9.png" alt="img"></p><blockquote><p>今天，世界的食品系统在生产和分发食品方面效率和盈利性较高，但在食品公平和可持续性方面表现不佳。具体而言，世界上仍然有相当数量的饥饿人口，对生态系统的破坏也难以忽视。因此，建立和优化一个良好的食品系统值得我们关注。</p><p>首先，我们建立了一个食品系统模型。我们将食品系统抽象为三个环节：生产、运输和销售，并分别建立了模型。在食品生产过程模型中，我们考虑了各种食品来源，并量化了食品的生产。同时，基于校正量，我们参考生产-卡路里转换量化了食物中的卡路里。在食品运输过程模型中，我们定义了生活区域的概念，并计算了运输者的利润。然后基于以利润优化驱动的运输选择算法，分配被运输的食物。在食品销售过程模型中，我们使用供需的微分方程来衡量波动的食品价格。考虑到个人收入的差异，我们根据人们食品选择算法模拟了每个个体的食品购买，并根据所购食品中含有的卡路里来确定他们的饥饿状况。</p><p>然后，我们确定了评估我们食品系统的指标。根据食品生产中引起的生态污染，我们选择了排放、土地资源使用和水资源使用这三个指标。我们使用熵方法确定权重以量化可持续性指标。</p><p>根据销售过程模型中饥饿人口的比例，我们建立了公平指标。根据食品系统中的三个模型，我们为农民和运输者的收入建立了效率指标。</p><p>为了确定食品系统如何在公平和可持续性方面进行优化，我们定义了一个非线性规划优化模型。我们使用Matlab进行模拟，并使用遗传算法找到近似最优解。</p><p>结果显示，在公平和可持续性优化的努力相同时，法国将在43个月内完成优化目标。可耕地面积将减少6.7%，饥饿人口将减少3万；而印度将在37个月内完成优化目标，可耕地面积将增加11.1%，饥饿人口将减少3910万。豆类以高卡路里为特点，其种植面积增加。同时，我们逐渐提高了优化模型中可持续性相对于公平的优先级。我们发现印度和法国的成本增加，收益减少。对于特定的优先级，与优化之前相比，印度的成本增加率和收益减少率低于法国。我们进一步将我们的模型应用于其他10个发达和发展中国家，并验证了这一结论。</p><p>最后，我们讨论了对更大的食品系统和较小的食品系统的迁移。我们认为我们的模型可以有效地应用于较小的食品系统，但其在更大的食品系统中的应用受到不同国家政策的限制。此外，我们将我们的模型移至另一个国家——索马里，并根据具体情况进行了修正。</p><p>关键词：食品系统；非线性规划；供需微分方程。</p></blockquote><blockquote><p>当前的食品系统在追求效率和盈利性的同时忽视了可持续性和公平性。这个问题主要体现在两个方面。一方面是由于过度生产和化学滥用导致的环境破坏。另一方面是饥饿和不公平问题。因此，迫切需要优化当前的食品系统。</p><p>首先，我们提出了生产模型，该模型可以估算不同生产条件下每个国家的食品产量。为了更全面地考虑模型，我们将整个食品系统分为三个子系统（种植、畜牧和渔业），并引入影响每个子系统生产的各种指标。对于可持续性问题的系统优化需要政府进行一些政策干预，我们可以通过使用生产模型评估这些干预对食品产量的影响。</p><p>其次，我们设计了一个公平分配模型来解决公平性问题，在这个模型中，食品过剩的国家将自愿资助低收入粮食缺口国家（LIFDCs）。”携手倡议”是根据在捐赠国和受益国之间最小化运输成本的原则设计的。</p><p>我们还建立了引入时间维度后的增长模型，该模型是为了应对未来的人口增长。</p><p>此外，我们在一个发达国家美国和一个发展中国家尼泊尔应用了我们的模型，评估了系统优化的成本和效益，并比较了发达国家和发展中国家之间的差异。具体来说，美国的种植业、畜牧业和渔业产值将分别下降2.1%、1.1%和1.2%，美国需要支付2055万美元的运输费用，以帮助最不发达国家海地和危地马拉。好处是美国可以体验到环境的改善。对空气、水和土地的环境损害都将得到缓解。对于尼泊尔，由于更容易获得化肥，饥饿人口数量将减少。一部分原因是来自乌克兰的捐赠，另一部分原因是由于可获得的化肥导致的食品产量增加。尼泊尔的种植业、畜牧业和渔业产值将分别增加5.4%、2.9%和1.5%。</p><p>最后，我们分析了我们模型的可扩展性和适应性，并指出了我们的优势和劣势。</p><p>关键词：食品系统；生产模型；可持续性；公平性</p></blockquote><blockquote><p>在过去的几年里，食品系统将效率和盈利性视为首要任务，忽视了环境可持续性和社会公平。由此产生的严重环境破坏和饥饿问题悬在我们头上，等待着解决。</p><p>在本文中，我们将环境因素和公平因素与经济因素结合起来，建立了一个环境-公平-经济模型（EEE模型），以重新优化当前的食品系统。EEE模型包括三个相互关联的子模型。它们是环境可持续性模型、食品分配公平模型和经济效益-成本分析模型。通过引入一些参数，可持续性和公平性被提升为优先事项，牺牲了经济利润。</p><p>第一个E：环境模型涉及三个环境指标，即食品系统的温室气体（GHG）排放、富营养化排放和食品生产用地。在检查了大量数据后，我们发现转变国民的饮食结构将显著影响上述三个指标的减少。我们使用Logistic模型预测未来情况，引入时间系数r来衡量实现环境可持续性所需的时间。动物产品税用于推动这种转变。</p><p>第二个E：公平模型基于社会上食品分配不均匀。我们的概念是通过减缓食品不安全人口的增长率来减少饥饿比例。为实现这一目标，政府可以将多余的食品送到食品短缺地区，并提供给食品不安全的人们。援助因子A用于衡量政府援助的强度。至于运费，政府可以向食品生产商和分销商征收食品公平税。</p><p>第三个E：经济模型考虑食品生产商和分销商的净利润。在我们重新优化的食品系统模型中，经济净利润不仅仅是收益和成本之间的差异。它还需要包括来自第一个E和第二个E模型的动物产品税和食品公平税。</p><p>我们选择中国和芬兰作为目标国家，并在案例研究中使用我们的模型。经过模拟，我们得出以下结果：</p><ul><li>中国的温室气体排放将减少25.79%，富营养化减少16.15%，空闲土地增加32.79%。此外，在2021年，饥饿比例将开始减少，到2029年将没有食品不安全的人。成本是食品生产的净利润减少5.14%。</li><li>芬兰的温室气体排放将减少33.22%，富营养化减少32.03%，空闲土地增加26.98%。此外，在实施计划后的第一个月，饥饿比例将开始减少，到2027年中旬将没有食品不安全的人。成本是食品生产的净利润减少9.77%。</li></ul><p>我们还讨论了我们模型的可扩展性和盈利性，确定了我们模型的优势和劣势，探讨了未来工作的可能性。</p><p>关键词：EEE模型，Logistic模型，可持续性，公平</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第三章</title>
      <link href="/2024/01/30/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/"/>
      <url>/2024/01/30/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第三章．久违的篮球"><a href="#第三章．久违的篮球" class="headerlink" title="第三章．久违的篮球"></a>第三章．久违的篮球</h1><blockquote><p>盛夏傍晚间的巷子口，老人闲坐赌博或下把象棋，孩童追赶着，打闹着，时有狗吠，时有笑语，微风徐徐。</p><p>记忆里的大槐树和合欢树依然挺立，郁郁葱葱，阳光穿过繁密的树叶，点点日光洒落地上，斑驳树影随风轻轻晃动。携着氤氲着热气的晚风，苏瑾穿过一条条小巷，来到了独属于少年的秘密基地。而兄弟们早已等候多时。</p><p>“老苏，迟到了哈”，许穆青打趣道，顺手捡起地上篮球，对准篮筐跳投出手，没有华丽的空心，而是一个三不沾。</p><p>“我这不是来了嘛，你这投篮变水了啊，穆清”，苏瑾给予还击。</p><p>说起这几位少年，那是值得大写特写，他们都来自于江南中学的尖子班，刚经历了中考的洗礼，又在熟悉的老地方重逢。</p><p>除了闷骚学霸叶扬之外，还有许穆清，身材伟岸，体格健壮，两只眼睛深邃而明亮，为人开朗俏皮，苏瑾9年之交，从小学开始便建立了强烈的羁绊。</p><p>顾千羽，洛云初，陈凡，叶扬都是初中相识。</p><p>顾千羽多行潇洒之风，走路时肩膀摇晃随意，做事一贯是想到就做，十分直爽。</p><p>洛云初身材偏廋，值得一提的是，这家伙和男生说话时可以说是金句频出，逗乐大家那是嘴到擒来，江湖人称“杰哥”，但一面对女生，不出几句，便是耳朵红透，支支吾吾，一句话也说不出来了。</p><p>再看陈凡，他身材稍胖，但请不要小看，灵活的胖子在球场上比什么都可怕，在班级上，胖子往往作为活宝，陈凡也不例外，经常能引起大家的笑声，在班里也是属于众星捧月。</p><p>很多人的青春不只是他一个人的，像苏瑾。有着他们这群朋友，这样的夏天，缓慢而美好。</p><p>“我们来分队吧“顾千羽拿着篮球走过来，这颗精灵球，正是他们去年在苏瑾生日时送的，已历经一年多的打球岁月，球上已经刻上属于他们的印记。</p><p>经过转球分队，”射手“苏瑾，”转身标杆“叶扬，”最美后仰“许穆清一队，”拉杆能手“顾千羽，”移动炮台“洛云初，”意外选手“陈凡一队。</p><p>由苏瑾开球，一个瞬步传给叶扬，叶扬二话不说，一手独属于他的甩狙，手起刀落，球应声入网，第一球正式打响。</p><p>”也只有叶扬这家伙能在这么久没打保持这种手感了，“陈凡感叹。</p><p>天色日渐昏暗，六人的衣服早已湿透，面色通红，他们已经打了一把又一把，手感已经不同于起初的生硬，也造就了独属于他们的诸多名场面。</p><p>许穆清接连投进高难度后仰，当篮球脱手而出时，你只能祈祷上帝，保佑这颗球进不去篮筐。</p><p>顾千羽在人群中任意穿梭，上篮，勾手，拉杆样样都有，灵动迅捷，攻坚利器。</p><p>洛云初，使出自创一刀流绝技，神乎其神，三分抬手就是尽显锋芒，总之，这一刻，尽显这一刻。</p><p>陈凡也不甘落后，漂移投篮绝技防不胜防，老大爷勾手更是信手拈来，颇有上世纪80年代的打法。</p><p>至于苏瑾和叶扬，作为射手，接连贡献中距离投射，空心入网如砍瓜切菜，打破僵局往往由他们来行动。作为对友，你可以放心传球给他们，而作为对手，你绝不能放他们超过两个身位，不然等待你的只有一发又一发的空心进球。</p><p>篮球悬停在球场中央，借着余晖，闪闪发光。众人坐在球场上，喝着甘甜矿泉水，彼此举瓶对视，谈论着刚刚一球接一球，不断上演的神之一手。</p><p>“走了，兄弟们，“穆清走在最前方，挥了挥手，以示告别。</p><p>汗水浸透了苏瑾的头发，苏瑾开着车，撩起头发，嘴角不自觉上扬，肆意享受着微风以及夏天的轻柔和琐碎。</p><p>苏瑾家住在小巷的末尾，这里有淳朴的乡亲和乡风，平常借点东西，路过时候打几声招呼，人情味十足，所谓“稚儿擎瓜柳棚下，细犬逐蝶窄巷中”便是如此吧。</p><p>巷尾，苏瑾家旁，住着王阿姨一家。突然，一个身穿绿色碎花布衫的女生的背影进入了苏瑾的视线，少女倚着栏杆，望着天边的火烧云，似乎在听风语人。</p><p>这条小巷里好像未曾见过这般的女生，不过看着她怎么有种难以言状的熟悉感，疑惑涌上心头，不由多想，苏瑾停车走进家中。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2023美赛e题分析</title>
      <link href="/2024/01/30/2023%E7%BE%8E%E8%B5%9Be%E9%A2%98%E5%88%86%E6%9E%90/"/>
      <url>/2024/01/30/2023%E7%BE%8E%E8%B5%9Be%E9%A2%98%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="2023-ICM"><a href="#2023-ICM" class="headerlink" title="2023 ICM"></a>2023 ICM</h1><h2 id="E题：光污染"><a href="#E题：光污染" class="headerlink" title="E题：光污染"></a>E题：<strong>光污染</strong></h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><blockquote><p>光污染是指过度使用人造光。一些我们称为光污染的现象包括光侵入、过度照明和光杂波。这些现象在大城市中最容易观察到的是太阳落山后天空中的光芒;然而，它们也可能发生在更偏远的地区。</p><p>光污染改变了我们对夜空的看法，对环境有影响，也影响了我们的健康和安全。例如，植物的成熟可能会被延迟或加速，野生动物的迁移模式也会受到影响。过多的人工光线可能会混淆我们的昼夜节律，导致睡眠质量差，也许还可能导致身心健康问题。由人工照明灯引起的眩光可能会导致一些机动车辆事故。</p><p>（眩光：过度的亮度会降低人的视觉能力。）</p><p>社区官员或当地团体可以实施干预策略，以减轻光污染的负面影响。然而，人造光既有积极的影响，也有消极的影响，对不同的地方产生不同的影响。</p><p>例如，为了避免上述光污染的负面影响，一些社区选择低光社区，这反过来可能导致犯罪率上升。(双刃剑)</p><p>光污染的影响可能取决于当地的发展水平、人口、生物多样性、地理和气候等因素。</p><p>（因素）</p><p>因此，评估任何干预策略的影响程度和潜在影响都必须针对特定的地点。</p></blockquote><h3 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h3><blockquote><p>COMAP的照明控制任务(ICM)正在努力提高人们对光污染影响的认识，并制定干预策略以减轻这些影响。为了支持ICM的工作，你们的任务是在不同地点测量和减轻光污染的影响，包括人类和非人类的问题。具体来说，你应该:</p><p>制定一个广泛适用的度量标准，以确定一个地点的光污染风险水平。</p><p>应用您的度量标准，并在以下四种不同类型的地点上解释其结果:</p><ul><li>受保护的土地</li><li>一个农村社区</li><li>郊区社区</li><li>城市社区</li></ul><p>描述了三种可能的干预策略。讨论执行每项战略的具体行动，以及这些行动对一般光污染影响的潜在影响。</p><p>选择您的两个位置，并使用您的度量来确定哪种干预策略对它们最有效。讨论所选择的干预策略如何影响该地点的风险水平。</p><p>最后，对于您确定的一个地点及其最有效的干预策略，制作一份1页的传单来推广该地点的策略。</p></blockquote><blockquote><h3 id="粗略方法"><a href="#粗略方法" class="headerlink" title="粗略方法"></a>粗略方法</h3><p>建立评价指标体系</p><p>对不同的地区进行评价</p><p>对评价结果提出干预策略</p><p>讨论策略的有效性</p><h3 id="总体方法："><a href="#总体方法：" class="headerlink" title="总体方法："></a>总体方法：</h3><p>（1）<strong>制定</strong>一个广泛适用的<strong>指标</strong>，以确定一个地点的光污染风险水平；</p><p>（2）根据不同的类型应用，度量并解释其结果</p><p>（3）描述<strong>解决</strong>光污染的三种可能的<strong>干预策略</strong>。讨论实施每项战略的具体行动，以及这些行动对光污染总体影响的潜在影响；</p><p>（4）选择您的两个地点，并使用您的度量标准来确定您的干预策略中哪一个对他们最有效。讨论所选择的干预策略如何影响所在地的风险水平；</p><p>（5）针对您确定的一个地点及其最有效的干预策略，制作一张1页<strong>传单</strong>，宣传该地点的策略。</p></blockquote><h3 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h3><blockquote><p>评价模型：首当其冲的肯定是层次分析法，接着模糊综合判定、TOPSIS等等。</p><h4 id="可以试试熵权-TOPSIS的方法"><a href="#可以试试熵权-TOPSIS的方法" class="headerlink" title="可以试试熵权-TOPSIS的方法"></a>可以试试<strong>熵权-TOPSIS</strong>的方法</h4></blockquote><h3 id="问题二"><a href="#问题二" class="headerlink" title="问题二"></a>问题二</h3><blockquote><p>侧重于<strong>结果对比分析</strong>，相对简单的方法就是先找到四种类型社区，套用问题一建立的模型。</p></blockquote><h3 id="问题三"><a href="#问题三" class="headerlink" title="问题三"></a>问题三</h3><blockquote><p>从第一问的<strong>模型公式</strong>入手，先进行推导，怎么去修改可以得到最高的评价，可以看作一个局部优化的问题，可以套用很多现有的模型，可能也相对简单一些，看作目标规划或者最优解问题。</p></blockquote><h3 id="问题四"><a href="#问题四" class="headerlink" title="问题四"></a>问题四</h3><blockquote><p>套评价模型，出图即可</p></blockquote><h2 id="论文拆解"><a href="#论文拆解" class="headerlink" title="论文拆解"></a>论文拆解</h2><h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><blockquote><p>在她的TED演讲《光污染的问题 - 以及解决它的5种极其简单的方法》中，Kelsey Johnson说：“当我看到地球的照片时，我看到的是环境灾难。那些不是珠宝，那是肿瘤。” 光是世界的基本组成部分，也是文明的支柱之一。人类文明的发展得益于人工光的发明和使用。 然而，随着人工光的年复一年的快速增长，人们对人工光的滥用和过度使用也导致了严重的后果：天文光污染导致夜空景象的退化，限制了对宇宙深处的探索[1]，生态光污染不仅污染了空气、洋流等，还使植物的成熟延迟或加速，野生动物的迁徙模式发生变化，同时包括人类在内，导致肥胖、失眠、身心健康受损等问题迅速增加。 人工光是一把双刃剑，既带来祝福，也打开了潘多拉的盒子。人类社会未来发展的一个关键问题和转折点将是通过适当的干预减轻光污染的影响。</p></blockquote><p>（这一部分需要解释我们的对象，可以适当文学性一点，一阵见血的指出问题所在）</p><h3 id="问题的重述"><a href="#问题的重述" class="headerlink" title="问题的重述"></a>问题的重述</h3><blockquote><p>管理光污染问题是一个复杂的问题，需要充分考虑各种因素。为了在不同地点测量和减轻光污染的影响，我们需要解决以下问题： </p><p>• 创建一个广泛适用的指标，允许在不同地点测量光污染的风险水平。 </p><p>• 将指标应用于四种不同类型的场地，并对发现进行逻辑分析。</p><p> • 提出三种潜在的干预选项以处理光污染，并讨论每种策略所需的精确步骤及其潜在影响。</p><p> • 将指标应用于两个位置，确定每个位置的最佳干预计划，并讨论该干预策略如何影响该位置的风险水平。</p><p> • 制作一份传单，概述指定站点中最有效的干预方法。</p></blockquote><h3 id="文献综述"><a href="#文献综述" class="headerlink" title="文献综述"></a>文献综述</h3><blockquote><p>我们使用关键词“光污染”进行文献检索，发现近年来对这一问题的研究主要可以分为三个主要部分：光污染的组成、光污染建模数据空间的确定以及光污染对生物群体的影响。以下将主要讨论提出的模型。<br>♦ 首先，就光污染的组成而言：光污染通常分为白光污染、日间污染和彩色污染，不同的是，在[2]中，刘照立等认为光污染贯穿整个白天，而绝大多数作者只研究了夜间的光污染。<br>♦ 其次，光污染建模数据空间可以分为二维和三维。刘敏等部分使用了二维数据，如图像数据和遥感数据进行建模[3]，而温政等则结合了高度和其他信息进行三维数据建模[4]。<br>♦ 最后，光污染对生物群体的影响既有宏观又有微观的维度。唐雪峰等探讨了不同光源对生物体微血管的影响[5]，而更多的作者则探讨了广泛的光污染对生物体习性和健康的宏观层面的影响。<br>⋆ 不同研究方法对光污染不同关注点的优缺点可以如图2所示可视化。</p></blockquote><p><img src="/2024/01/30/2023%E7%BE%8E%E8%B5%9Be%E9%A2%98%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240130202547609.png" alt="image-20240130202547609"></p><p>可以对自己查阅的不同文献进行对比并画图</p><h3 id="我们的工作"><a href="#我们的工作" class="headerlink" title="我们的工作"></a>我们的工作</h3><blockquote><p>实际上，这个问题需要我们量化光污染的危害，并制定合理的策略来减轻其影响。为了避免繁琐的描述，并直观地反映我们的工作过程，流程图如图3所示。</p></blockquote><p><img src="/2024/01/30/2023%E7%BE%8E%E8%B5%9Be%E9%A2%98%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240130202729518.png" alt="image-20240130202729518"></p><blockquote><p>这张图也是非常精美的</p></blockquote><h3 id="假设和解释"><a href="#假设和解释" class="headerlink" title="假设和解释"></a>假设和解释</h3><blockquote><p>考虑到实际问题通常包含许多复杂因素，首先，我们需要进行合理的假设来简化模型，每个假设都紧随其相应的解释：<br>▼ 假设1：我们使用的数据准确有效。<br>▲ 解释：本文中的数据直接来自主要在线官方数据库和已发表的文献的最新结果。</p><p>（必要解释）</p><p>▼ 假设2：夜间的光污染主要是指光污染，白天的光污染几乎可以忽略不计。<br>▲ 解释：由于白天生物习性和生态法则的长期形成，在自然光的增强下，与夜间光污染相比，白天的光污染影响微乎其微。</p><p>（白天光污染）</p><p>▼ 假设3：我们讨论的光污染中，自然光污染部分以极光污染为代表。<br>▲ 解释：大多数自然光污染只在白天影响生物和社会，基于假设2，我们认为可以忽略这部分自然光污染，因此自然光污染部分只关注极光污染以简化模型。</p><p>▼ 假设4：我们模型研究的地点的生物群体组成，如脊椎动物和无脊椎动物占生物群体的比例，相对稳定。<br>▲ 解释：”生物群体”是一个广泛的概念，生物多样性使得光污染对每个生物的影响不同，因此我们提出这个假设，以更好地关注光污染的量化和干预。<br>额外的假设用于简化对各个部分的分析。这些假设将在适当的位置进行讨论。</p><p>（必要套话）</p></blockquote><h3 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h3><blockquote><p>表1列出了本文中使用的一些重要数学符号。</p><p>表1:本文使用的注释<br>符号</p><p>𝑄𝑝𝑜𝑠𝑖𝑡𝑖𝑣𝑒 定量结果的积极的影响<br>𝑄𝑛𝑒𝑔𝑎𝑡𝑖𝑣𝑒 负面影响的定量结果<br>𝑆𝑐𝑜𝑟𝑒“x” 相关指标的分值</p><p>变量“x”的生物学比值<br>𝐿&lt;s:x区域的亮度<br>抛子运算中“x”的个数<br>𝑠“x”变化率<br>*有一些变量没有在这里列出，将在每个部分详细讨论。</p></blockquote><h3 id="模型准备"><a href="#模型准备" class="headerlink" title="模型准备"></a>模型准备</h3><h4 id="4-1光污染的构成与影响"><a href="#4-1光污染的构成与影响" class="headerlink" title="4.1光污染的构成与影响"></a>4.1光污染的构成与影响</h4><blockquote><p>光污染是一个庞大而复杂的概念，大多数研究的共识是污染源分为自然光污染和人工光污染，根据污染的构成又可分为白光污染、日间污染、有色光污染，根据污染的常见形式可分为眩光、溢光和光扰乱等…<br>光污染的构成非常复杂，但不可否认的是，无论哪种光污染都会产生巨大的影响。大多数研究将光污染的影响分类为社会经济、生态和生理三个方面，具体效应见图4。</p></blockquote><p><img src="/2024/01/30/2023%E7%BE%8E%E8%B5%9Be%E9%A2%98%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240130210105328.png" alt="image-20240130210105328"></p><h4 id="4-2数据概览"><a href="#4-2数据概览" class="headerlink" title="4.2数据概览"></a>4.2数据概览</h4><blockquote><p>4.2.1数据收集<br>问题没有直接提供给我们数据，因此在构建模型时，我们需要考虑在建模过程中收集哪些数据。通过对问题的分析，我们在表2中收集了主要数据。由于数据量太大无法一一列举，因此将数据可视化是一个很好的方法。</p><p>（数据可视化的套话）</p><p>表2：主要数据描述与来源 数据描述 数据来源 <a href="https://www.ons.gov.uk/">https://www.ons.gov.uk/</a></p><p>光污染相关指标</p><p>夜间照明</p><p><a href="https://ourworldindata.org/">https://ourworldindata.org/</a> <a href="https://hub.jncc.gov.uk/">https://hub.jncc.gov.uk/</a> <a href="https://www.earthdata.nasa.gov/">https://www.earthdata.nasa.gov/</a> <a href="https://www.nightearth.com/">https://www.nightearth.com/</a> <a href="https://www.ngdc.noaa.gov/">https://www.ngdc.noaa.gov/</a></p><p>其余提及的数据 各种相关文献</p><p>为了避免模型中更多未知因素的干扰，并简化模型的复杂性，我们主要从英国收集数据，并在考虑国内地理、风俗等小差异的情况下进行研究。</p><p>4.2.2数据筛选<br>借助各种可视化工具，我们展示了一部分数据，如图5所示。</p></blockquote><p><img src="/2024/01/30/2023%E7%BE%8E%E8%B5%9Be%E9%A2%98%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240130210329943.png" alt="image-20240130210329943"></p><p><img src="/2024/01/30/2023%E7%BE%8E%E8%B5%9Be%E9%A2%98%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240130210337170.png" alt="image-20240130210337170"></p><blockquote><p>从图5中，我们可以观察到某些地区始终保持着指标的高或低水平，这些地区将是后续模型用于案例研究的优秀选择。</p></blockquote><h3 id="5光污染评估模型（Light-Pollution-Assessment-Model）"><a href="#5光污染评估模型（Light-Pollution-Assessment-Model）" class="headerlink" title="5光污染评估模型（Light Pollution Assessment Model）"></a>5光污染评估模型（Light Pollution Assessment Model）</h3><blockquote><p>光污染是一个非常庞大的主题，基于我们的文献综述，我们选择主要对夜间光污染的宏观效应进行建模，使用主要是2维数据来简化模型的建模过程，并使用少量的3维数据来提高模型的准确性。<br>这一部分分为两个主要模型：光污染影响量化模型和光污染风险评估模型。光污染量化模型通过各种代表性数据量化光污染的影响；光污染风险评估模型根据特定的风险评估标准评估光污染的风险。</p><p>5.1光污染影响量化<br>5.1.1指标确定<br>如图4所示，光污染的影响主要可以分为对人类的影响、对社会的影响和对生态的影响。因此，我们将这三个主要方面作为一级指标。</p><p>对于人类健康影响和社会影响，我们考虑了73个官方相关指标，并结合文献最终保留了最具代表性的10个二级指标来构建我们的模型。在此基础上，我们从生态成分中补充了三个与生态环境相关的二级指标，以完善我们的定量模型。具体描述和所选指标如表3所示。</p></blockquote><p>对象指标描述<br>人类DR死亡率<br>    LE预期寿命<br>    PHS身体健康状况<br>    OOR超重和肥胖率<br>    MH心理健康<br>    AE焦虑情绪<br>    WB幸福感<br>    GPC人均国内生产总值<br>社会UR失业率<br>    CR犯罪率<br>    EP环境污染<br>生态RC资源消耗<br>    DS物种多样性</p><blockquote><p>•人类健康影响<br>  – 1. 生理健康<br>光污染的危害可能导致在长时间活动和工作的人群中正常细胞的加速老化和死亡，并可能诱发各种疾病[7]。 [8] 表明夜间人工光可以导致肥胖。基于现有数据，我们具体测量了光污染对人类生理健康的影响，使用了光污染对 “人类死亡率”(DR)、”预期寿命”(LE)、”身体健康状况”(PHS) 和 “超重和肥胖率”(OOR)的影响。</p><p>  – 2. 心理健康<br>根据[8]，光对人们的视觉、心理和情感有不同程度的影响，随着时间的推移效果逐渐增强。长时间生活在光污染环境中的居民经历强烈的心理不适。因此，我们专门使用 “心理健康”(MH)、”焦虑情绪”(AE) 和 “幸福感”(WB) 来衡量人类心理健康的状态。</p><p>•社会影响<br>  – 1. 社会发展<br>灯光的使用在一定程度上对一个地区的经济水平和发展有所贡献，因此光起到了积极的经济作用，我们通过区域 “人均国内生产总值”(GPC) 来衡量这种积极影响。<br>然而，与此同时，光的使用使工作时间显著增加，每人每天的工作负担减轻导致一些人失业，这是光的负面效应之一，我们使用 “失业率”(UR) 作为具体的衡量标准。</p><p>  – 2. 社会稳定<br>光污染使得治理法纪变得越来越困难，尤其是在人们的身体和心理健康受损、失业等负面条件下，犯罪经常发生，因此我们使用指标 “犯罪率”(CR) 来展示光污染对社会稳定的负面影响。</p></blockquote><blockquote><p>•生态影响<br>  – 1. 资源消耗<br>光污染意味着大量自然资源被不当使用。根据获得的数据，我们绘制了下面的图6，并计算了电力消耗和光污染之间的皮尔逊相关系数为0.85293，表明电力消耗和光污染之间呈现出正强相关，这意味着用于发电的资源，如煤和石油，被过度或不当地使用。</p><p><img src="/2024/01/30/2023%E7%BE%8E%E8%B5%9Be%E9%A2%98%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240130210854041.png" alt="image-20240130210854041"></p><p>假设世界上大部分地区以相同的方式使用自然资源，并且电力消耗和光的转化率稳定，我们可以用电力消耗(EC)来表示“资源消耗”(RC)。资源消耗计算如下:</p><p><img src="/2024/01/30/2023%E7%BE%8E%E8%B5%9Be%E9%A2%98%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240130211124348.png" alt="image-20240130211124348"></p><p>其中，a表示用于发电的自然资源比例，p表示发电转换率</p><ul><li><p>2。环境<br>由于光污染导致夜间能见度降低，对空气和空间环境造成污染，因此我们用天顶亮度与自然夜空亮度的比值来定义“环境污染”(environmental pollution, EP)。</p></li><li><p>3。生物学<br>我们收集了多个地区的生物多样性数据，并将光污染对生物多样性的影响因子定义为&lt;s:1&gt;。考虑到这些区域面积大、地形多等因素，生物多样性也会随之多样化，光污染对每种生物的影响也不能一概概括，因此为了保证评估的准确性，我们假设每个区域的生物平均分布.</p></li></ul></blockquote><blockquote><p>5.1.2权重计算<br>因为我们需要计算𝑄𝑝𝑜𝑠𝑖𝑡𝑖𝑣𝑒和𝑄𝑛𝑒𝑔𝑎𝑡𝑖𝑣𝑒从三个层次:人类健康、社会发生——表“性质”,与生态,基于上述分析,</p><p>在计算𝑄𝑛𝑒𝑔𝑎𝑡‑‑𝑣𝑒时，为了使模型更加合理，我们需要计算人类健康、社会和生态环境三个主要指标对应的12个次要指标的权重，得到𝑄𝑛𝑒𝑔𝑎𝑡‑‑𝑣𝑒</p><p>下面我们将主要关注各负面指标权重的计算:</p><p>在计算𝑄𝑛𝑒𝑔𝑎𝑡‑‑𝑣𝑒时，为了使模型更加合理，我们需要计算人类健康、社会和生态环境三个主要指标对应的12个次要指标的权重<br>下面我们将主要关注各负面指标权重的计算:</p><ol><li>   数据归一化<br> 我们需要对不同指标的数据进行标准化，以便在同一尺度上进行比较。对于不同类型的数据，我们使用不同的归一化方法。<br> 对于“成本属性类型”，即数据类型越小越好，我们使用以下归一化:</li></ol><p>𝑥˜𝑖𝑗</p><p>&#x3D; Max{变量}-变量𝑗<br>最大{变量}-最小{变量}</p><p>（7）</p><p>对于“利益属性类型”，即数据类型越大越好，我们使用下式进行归一化:</p><p>𝑥˜ 𝑖𝑗</p><p>&#x3D;分界𝑗−min{分界}<br>最大{变量}-最小{变量}</p><p>（8）</p><p>假设我们有𝑚组数据与𝑁𝑢𝑚𝐻𝑢𝑚𝑎𝑛&#x2F;𝑁𝑢𝑚𝑆𝑜𝑐𝑖𝑒𝑡𝑦&#x2F;𝑁𝑢𝑚𝐸𝑐𝑜𝑙𝑜𝑔𝑦在每组以上指标。表示𝑖-th组中的𝑗-数据。最大分值表示𝑖-th组中最大的数据。最小分值表示的是最小数据<br>𝑖-th组。</p><ol start="2"><li>   熵权法<br> 在对各指标进行标准化得到标准数据后，我们用下式对数据进行归一化:</li></ol><p>计算出该指标的熵值;</p><p>基于信息熵，我们将进一步计算之前定义的各个评价指标的权重𝑤&lt;e:1&gt;，计算公式如下:</p><p>我们将得到的权重组成一个向量，称其为“评估向量”，<br>指示为Φ→&#x3D;(𝜙1𝜙2 , · · · , 𝜙𝑁𝑢𝑚𝐻𝑢𝑚𝑎𝑛&#x2F;𝑁𝑢𝑚𝑆𝑜𝑐𝑖𝑒𝑡𝑦&#x2F;𝑁𝑢𝑚𝐸𝑐𝑜𝑙𝑜𝑔𝑦);通过组合一个向量<br>将得到的不同方面的影响称为“影响”</p><p>度向量”，记为𝑆→<br>最终评价值为:</p></blockquote><blockquote><p>5.1.3光污染定量结果<br>由于我们的一级指标体系分为三个维度:人类健康、社会和生态，我们对这三个维度分别应用EWM，客观地得到了各个指标的权重，如表4所示。<br>表4:各指标权重</p><p>对象指标权重对象指标权重<br>0.2404博士<br>le 0.1145社会ur 0.4498<br>小灵通0.1086 cp 0.5502<br>人类oor 0.1569, rc 0.257<br>mh 0.1789生态学ds 0.3236<br>Ae 0.1073 ep 0.4194<br>世行0.0932</p><p>为了给这三个一级指标赋予权重，从而得到最终的光污染风险评价值，我们采用层次分析法构建判断矩阵，得到三个一级指标的权重:<br>𝛿&#x3D; (0.1283,0.2764,0.5954)(13)<br>其中判断矩阵的一致性比&#x3D; 0.0053，一致性是可以接受的。<br>最终，我们的光污染风险安全评分计算如下:</p></blockquote><h3 id="5-2风险评估"><a href="#5-2风险评估" class="headerlink" title="5.2风险评估"></a>5.2风险评估</h3><blockquote><p>5.2.1风险评价准则<br>简而言之，风险就是未来一段时间内投资与收益之间的不确定性。ALARP (as low as reasonable possible)标准是风险评估的常用标准，目前仍被广泛用于选择可接受的风险和制定合理的风险控制计划[10]。<br>ALARP标准将风险分为三个区域:不可接受、合理接受和广泛接受，如图7(a)所示。</p><p>(a)退休方案标准(b)成本-风险曲线<br>图7:风险评估准则图</p><p>•如果风险处于不可接受的区域，则必须采取措施降低风险，而不管收益如何。<br>•如果风险处于广泛可接受的范围内，则风险处于非常低的水平，可以忽略。<br>•两者之间的区域是合理可接受的区域，需要在经济可行的情况下尽可能降低风险，即是否通过图7(b)中的“成本-风险”分析采取风险控制措施。</p><p>5.2.2风险因素Ω<br>在上述模型中，光污染在社会经济层面带来积极影响的同时，也带来一系列负面影响。假设未来社会经济发展将带来人类、社会和生态的进步，我们认为光污染的风险来自于光污染的积极影响和消极影响之间的相互关系。<br>我们最初将风险因素Ω定义为:</p><p>考虑到风险需要与对未来的预测和判断相结合，我们将风险评估期定为1年。由于人和生物在短期内难以发生变化，因此在负面影响中，评价期内主要是生态环境指标发生变化，环境指标的变化带动了正面影响——GPC的变化。<br>结合以上分析修正Ω的定义，得到Ω:</p><p>变化的程度𝐶𝑛𝑒𝑔𝑎𝑡𝑖𝑣𝑒生态环境指标的我们——并符合正态分布,而变异的程度𝐶𝑝𝑜𝑠𝑖𝑡𝑖𝑣𝑒GPC更稳定。因此，风险因素的实际定义为:</p><p>我们随机选取了图8(a)所示的10个区域，将它们的光强进行归一化，并进行可视化，得到图8(b)所示的折线图，并计算这两个值的pearson相关系数，得到相关系数为0.8002，大于0.8，说明两个数据之间的相关性极强，说明我们的模型能够在更大程度上有效测量光污染的影响。</p></blockquote><h3 id="5-4案例分析"><a href="#5-4案例分析" class="headerlink" title="5.4案例分析"></a>5.4案例分析</h3><blockquote><p>结合风险评价准则ALARP和风险因子Ω，我们得到以下风险评价标准[10]:</p><p>选择英国作为主要研究国家，我们在三个不同密度层中各取一个区域，并选择一个被政府或私人实体禁止开发的保护区，得到的四种不同类型的站点如表5所示。</p><p>将LPA模型应用于这四个站点，结合风险因子，安全等级评估的三个方面得到的值如图9(a)所示<br>𝑂𝑚𝑒𝑔𝑎，得出如下判断和建议如图9(b)所示。</p><p>•人类健康方面的分析<br>通过图9(a)我们可以看出，这四个地区的人类健康安全水平相差不大，我们的分析表明，城市的医疗安全状况良好，光污染对城市人类健康的影响可以通过医疗技术领先来弥补。</p><p>•社会层面分析<br>保护区和农村地区的低光照会下意识地影响犯罪率，高犯罪率导致这两个地区的社会安全水平远低于城市社区，这与社区低光照水平可能导致犯罪率上升的事实是一致的。光的积极贡献也得到肯定。<br>•生态方面分析<br>光污染的生态影响最为显著，且各区域间存在显著差异。人口密度高、商业区夜间活动频繁、人类活动频繁等因素导致城市和郊区人工光亮度过高，生态破坏严重。下面的图10清楚地显示了不同地区的天空能见度，城市地区几乎看不到星星。</p></blockquote><h3 id="6-1-1资源友好型策略"><a href="#6-1-1资源友好型策略" class="headerlink" title="6.1.1资源友好型策略"></a>6.1.1资源友好型策略</h3><blockquote><p>宵禁，是指禁止夜间活动，针对各地光污染出台光滋扰规定。这里我们将其理解为限制夜间人造光的使用时间，这将直接影响到资源的消耗。<br>首先，我们假设人们的心理健康不会受到宵禁的影响，如果实施宵禁，限制使用人造光的时间是固定的，我们将调控效率设为&lt;s:1&gt;，即资源消耗的年减少率。第一个需要的资源消耗是𝑅𝐶0，因此我们可以得到𝑡年减少的总资源消耗<br>𝑅(𝑡)&#x3D;𝑅𝐶0(1−&lt;e:1&gt;)𝑡(19)</p><p>由于光的使用减少，低亮度环境可能导致犯罪率上升，所以我们假设初始犯罪率为𝑟𝑅0，犯罪率增长率为𝑟𝑅，那么在𝑡年的犯罪率为<br>&lt;s:2&gt;(𝑡)&#x3D; &lt;s:2&gt;(𝑅0)(1 +𝑟(𝑅))(20)<br>考虑到降低犯罪率调控的不可控性，本文采用logistic回归对其进行模拟。引入政府调控后犯罪率自然下降率为&lt;s:1&gt;，犯罪减少目标量为𝑇𝐶0。</p></blockquote><h3 id="6-1-2环境友好型战略"><a href="#6-1-2环境友好型战略" class="headerlink" title="6.1.2环境友好型战略"></a>6.1.2环境友好型战略</h3><blockquote><p>由于技术发展和人类活动的限制，通过照明干预减少城市天空辉光的效果是有限的。根据文献[11]，我们了解到，由于空气污染的减少，大气气溶胶的持续减少也会降低光污染的风险。缓解空气污染的干预策略可能会降低城市内外夜空的亮度。<br>文献研究数据表明，从污染空气(≥𝑂𝐷&#x3D; 0.3)到清洁大气的变化导致夜空亮度(≥3.2倍)下降(≥≥3.2倍)，即在距离观测者1.3 km的源处，NSB下降到初始水平的30%左右。离光源越远的观测点，其所得到的二进制数据的二进制数据的二进制数据的方差降低越显著。为了简化模型，我们使用距离为1.3 km的观测点进行研究。<br>令减少空气污染对洁净大气所需要的额外资源消耗(≥𝑂𝐷&lt; 0.15)为𝑅𝑎￣𝑟，则减少空气污染所需要的额外资源消耗总量为:</p></blockquote><h3 id="6-1-3人类友好战略"><a href="#6-1-3人类友好战略" class="headerlink" title="6.1.3人类友好战略"></a>6.1.3人类友好战略</h3><blockquote><p>𝐵𝑡𝑜𝑡𝑒𝑙1<br>(1−30%)𝑡(24)</p><p>文献[12]表明，相对于谱线宽较宽的光源，谱线宽较窄的光源对生物体的影响更大;</p><p>所以在选择日常照明光源时，宜选用泛黄连续光谱较宽的光源，避免使用单一波长的光源，以减少视觉单调和频闪污染。我们建议全面禁止波长小于540𝑛𝑚的户外光，以减少褪黑激素产生减少和人类和动物昼夜节律紊乱对健康的不利影响。<br>在相同的光输出下，白光LED照明产生的道路亮度比𝐻&lt; 0.05 &lt;𝑆低6% ~ 11%，我们折中的选择8.5%作为人工光亮度的降低率，将人体健康指数的增加率设定为𝑟&lt; 0.05 &lt;𝐻𝑆，则𝑡年的人体健康指数为:</p></blockquote><h3 id="6-2系统耦合模型"><a href="#6-2系统耦合模型" class="headerlink" title="6.2系统耦合模型"></a>6.2系统耦合模型</h3><blockquote><p>(1 - 8.5%)𝑡(26)</p><p>为了得到干预方案的可行性和最终评价值，我们首先进行了耦合协调分析，将原LPA模型中的三个一阶指标与三个方案干预后的LPA模型中的一阶指标进行了比较。</p><p>6.2.1耦合协调参数<br>三个一级指标的耦合度为:</p><p>协调指标为:</p><p>定义的协调度如表6所示:</p></blockquote><p>Table 6: Defined Degree of Coordination</p><p> 表6:定义的协调度</p><table><thead><tr><th><strong>Coordination level   Degree  of coordination</strong></th><th></th></tr></thead><tbody><tr><td>1</td><td>Extreme disordered</td></tr><tr><td>2</td><td>Severe  disordered</td></tr><tr><td>3</td><td>Moderate disordered</td></tr><tr><td>4</td><td>Mild disordered</td></tr><tr><td>5</td><td>Nearly disordered</td></tr><tr><td>6</td><td>Barely  coordinated</td></tr><tr><td>7</td><td>Primary coordinated</td></tr><tr><td>8</td><td>Intermediate coordinated</td></tr><tr><td>9</td><td>Good coordinated</td></tr><tr><td>10</td><td>Quality coordinated</td></tr></tbody></table><h3 id="6-3干预结果评价"><a href="#6-3干预结果评价" class="headerlink" title="6.3干预结果评价"></a>6.3干预结果评价</h3><blockquote><p>对于Shropshire保护区，在最初干预之前，三个影响方面的协调指数均为8，我们认为不需要过多的干预。因此，我们选择协调指数为5的Rutland和协调指数为3的Westminster两个站点来研究三种干预策略的影响。</p></blockquote><h4 id="6-3-1拉特兰干预结果"><a href="#6-3-1拉特兰干预结果" class="headerlink" title="6.3.1拉特兰干预结果"></a>6.3.1拉特兰干预结果</h4><blockquote><p>干预前未加权人类安全得分为70.6022，社会安全得分为29.3440，生态环境得分为81.7827。采用3种不同干预策略后的协调指数分别为5、7、7，其中干预策略1的协调性较差。应用三种策略后的不同得分对比如图11所示。<br>•干预策略一:资源友好型策略<br>实施宵禁策略后，人类、社会和生态得分分别为70.6022、26.4082和83.5198。虽然资源消耗的减少带来了生态安全得分的提高，但由于夜间照明过少导致犯罪率上升，导致社会安全得分明显下降，再加上农村本身的资源消耗较低，宵禁策略对农村并不有效。<br>•干预策略二:环境友好型策略<br>人类、社会和生态得分分别为70.6022、29.3440和85.8223。该村的AOD为0.25，清洁空气带来的额外资源消耗不显著，获得的NBS降低幅度较大，生态安全得分有所提高。但由于原农村社区生态评分为81.7827，干预后变化较小。<br>•干预策略III:人类友好策略</p></blockquote><p><img src="/2024/01/30/2023%E7%BE%8E%E8%B5%9Be%E9%A2%98%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240130212043990.png" alt="image-20240130212043990"></p><p>图11:拉特兰三种策略的不同得分</p><blockquote><p>人类、社会和生态得分分别为78.1381、29.3440和83.0021。根据相关文献，我们定义𝑟&lt; 0.05 &lt;𝐻𝑆&gt; &#x3D; 12.84%，人体健康评分提高了10%，这是一个显著的改善，因此，切换到波长较小的光源对农村地区人体健康有显著的影响，我们对农村实施了干预策略三。</p></blockquote><h4 id="6-3-2威斯敏斯特的干预结果"><a href="#6-3-2威斯敏斯特的干预结果" class="headerlink" title="6.3.2威斯敏斯特的干预结果"></a>6.3.2威斯敏斯特的干预结果</h4><blockquote><p>干预前未加权人的安全得分分别为63.8930、95.8180、25.7414。采用三种不同干预策略后的协调指数分别为5、3和4。采用三种策略后的得分对比如图12所示:</p></blockquote><p><img src="/2024/01/30/2023%E7%BE%8E%E8%B5%9Be%E9%A2%98%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240130211910098.png" alt="image-20240130211910098"></p><p>图12:威斯敏斯特三种策略的不同得分</p><blockquote><p>•干预策略一:资源友好型策略<br>实施宵禁策略后，人类、社会和生态得分分别为63.8930、111.2475和34.7695。这一战略的干预使城市资源消耗显著减少，生态评分显著提高。此外，夜间照明是适当的，增加政府干预后，犯罪率在一定程度上有所降低。这表明，在一般环境中，迫切需要宵禁策略来控制光污染的影响。<br>•干预策略二:环境友好型策略<br>人类、社会和生态得分分别为63.8930、95.8180和25.7692。在该策略中，虽然NBS的降低使生态环境得到改善，但城市原有的0.;36的分值𝑂𝐷和更严重的空气污染，以及净化空气所需的资源消耗成本太大，使得该策略无法在城市中发挥作用。<br>•干预策略III:人类友好策略<br>人类、社会和生态得分分别为65.9782、95.8180和25.3840。根据相关文献，我们定义城市地区𝑟&lt; &lt;𝐻𝑆&gt; &#x3D; 9.65%，城市地区原本具有较高的人类健康得分，干预后人类健康安全得分有所提高，但由于基数大，变化不如策略1，因此对于城市地区，我们实施宵禁策略最有效。</p></blockquote><h3 id="7敏感性分析"><a href="#7敏感性分析" class="headerlink" title="7敏感性分析"></a>7敏感性分析</h3><blockquote><p>图13:𝑟变更后按区域划分的EP变化</p><p>我们对LPA模型进行了敏感性分析。为了验证的稳定性</p></blockquote><p><img src="/2024/01/30/2023%E7%BE%8E%E8%B5%9Be%E9%A2%98%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240130211823267.png" alt="image-20240130211823267"></p><blockquote><p>并确定模型是否会受到各种因素的干扰。我们原预设距离参数𝑟为10上下5%，将得到的6个区域的环境影响指标EP与原比较结果进行对比，如图13所示。<br>可以看出，r的变化对整体环境的影响不大，变化后的趋势与原来相同。当距离值发生小的变化时，它不符合我们对光污染环境影响的评估，其误差在可接受的范围内。因此，我们可以认为我们的模型是稳定的，可以用于解决实际问题。</p></blockquote><h3 id="8优势和进一步讨论"><a href="#8优势和进一步讨论" class="headerlink" title="8优势和进一步讨论"></a>8优势和进一步讨论</h3><h4 id="8-1优势"><a href="#8-1优势" class="headerlink" title="8.1优势"></a>8.1优势</h4><blockquote><p>•我们的模型采用官方网站和官方期刊的最新数据库，为每个指标收集了300多个数据，研究结果具有很高的参考价值，可以应用于现实生活。<br>•我们的LPA模型量化了光污染的影响，这使得模型的结果能够以高精度可视化。评价指标的选取参考了大量文献，选取的因素客观、有特色。<br>•我们的模型具有鲁棒性和可扩展性，只要提供相关数据，就可以用于模拟和预测任何国家或地区，提供更多相关指标将提高模型的准确性。<br>•我们的LPA模型在加权指标时使用AHP和EWM的组合来确定权重。该方法在一定程度上弥补了EWM下指标权重随样本变化甚至过度依赖样本的缺点，同时降低了层次分析的主观性。</p></blockquote><h4 id="8-2进一步讨论"><a href="#8-2进一步讨论" class="headerlink" title="8.2进一步讨论"></a>8.2进一步讨论</h4><blockquote><p>•我们进行干预策略评估时假设所有国家或地区都会积极配合我们提出的干预措施。实际执行时，结果可能与我们的预测有一些偏差。<br>•我们的模型将自然灾害等的突发影响转化为光污染影响的正态分布变化率，因此我们的模型偏离了现实。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美赛赛前分析</title>
      <link href="/2024/01/30/%E7%BE%8E%E8%B5%9B%E8%B5%9B%E5%89%8D%E5%88%86%E6%9E%90/"/>
      <url>/2024/01/30/%E7%BE%8E%E8%B5%9B%E8%B5%9B%E5%89%8D%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="一、竞赛时间安排"><a href="#一、竞赛时间安排" class="headerlink" title="一、竞赛时间安排"></a><strong>一、竞赛时间安排</strong></h1><p><strong>1.辅助报名截止时间：</strong>北京时间2024年2月2日00:00</p><p><strong>2.比赛时间：</strong> (北京时间：2024年2月2日，早晨6：00点，星期五) 至 (北京时间：2024年2月6 日，上午9：00，星期二)</p><p><strong>3.提交截止日期：</strong> (北京时间：2024年2月6日，上午10：00，星期二)</p><p><strong>4.比赛结果</strong>：结果将于2024年5月31 日或之前发布。</p><h1 id="问题选择"><a href="#问题选择" class="headerlink" title="问题选择"></a>问题选择</h1><p> 团队选择解决一个问题（MCM：A、B 或 C 或 ICM：D、E 或 F）并为他们选择的问题提交一个解决方案。</p><h1 id="内容限制"><a href="#内容限制" class="headerlink" title="内容限制"></a>内容限制</h1><p>MCM&#x2F;ICM 竞赛现在有 25 页的限制，且限制的25页主要指整个提交的解决方案，包括摘要表、解决方案、参考文献列表、目录、注释、附录、代码和其他具体内容。</p><p>论文必须以Adobe PDF电子文件形式提交，英文打字，可读字体至少为12号字体。论文必须在 25 页以内。</p><h1 id="比赛题目查看"><a href="#比赛题目查看" class="headerlink" title="比赛题目查看"></a>比赛题目查看</h1><p>1.比赛问题可供团队在美国东部时间 2024年2月1日星期四下午 5 点准时在比赛网站上观看。（北京时间：2024年2月2日，星期五，凌晨6点）：<a href="https://www.contest.comap.com/undergraduate/contests/index.html">&#x2F;undergraduate&#x2F;contests&#x2F;mcm</a>  </p><p>2.比赛题目也将在美国东部时间2024年2月1日，星期四，下午4:50（北京时间：2月2日凌晨5：50，星期五）准确地在以下镜像网站上发布：</p><p> <a href="http://www.comapmath.com/MCMICM/index.html">http://www.comapmath.com/MCMICM/index.html</a></p><p> <a href="http://www.comap-math.com/mcm/index.html">http://www.comap-math.com/mcm/index.html</a><br><a href="http://www.mathportals.com/mcm/index.html">http://www.mathportals.com/mcm/index.html</a><br><a href="http://www.immchallenge.org/mcm/index.html">http://www.immchallenge.org/mcm/index.html</a></p><p>****摘要页****：摘要是 MCM&#x2F;ICM 文件的重要组成部分，应作为解决方案报告的第一页显示。评委会非常重视摘要部分，并且获奖论文通常是根据摘要质量来区分于其他论文的。</p><p><strong>团队必须在美国东部时间 北京时间：2 月6日上午9 点，星期二）*<em>*<em><strong>之前完成解决方案的所有工作</strong>，</em>*并在北京时间：</em></strong>*<em>*2月6日，星期二，早上**<em><em><strong>10点之前. <strong>通过电子邮件向 COMAP 发送解决方案论文的 Adobe PDF 电子文件。</strong></strong></em>*</em>*注意：不要等到最后一分钟。完成后立即发送解决方案。***</em>*</p><ol start="2"><li>在美国东部时间 2024年2月5日晚上8 点（北京时间：2月6日，上午9点）之后，不得对团队的解决方案文件进行进一步的修改，增强，添加或改进。对解决方案的任何更改都将违反比赛规则，并可能导致取消资格。</li><li>每个团队都必须通过电子邮件向<a href="mailto:solutions@comap.com">solutions@comap.com</a>提交其解决方案的Adobe PDF 电子副本。任何团队成员或指导老师都可以提交此电子邮件。</li></ol><p>a. 您的电子 PDF 解决方案文件的电子邮件****必须****在电子邮件提交截止时间之前由COMAP 收到。</p><p>b. 在电子邮件的主题行中写下您团队的控制编号码。例如，主题：<strong>0000000</strong>。每封电子邮件限制只收一个团队解决方案文件。</p><p>c. 使用团队的控制编号作为文件附件的名称。例如：<strong>0000000.pdf****。</strong> <em>*<em>*</em>*注意：附件必须小于***</em>***<em>*<em>20*</em>*</em>* **<em>*<em>MB。请勿使用 Google 文档等云服务。您的电子邮件必须包含 Adobe PDF 附件。*</em>*</em>*</p><p>d. 团队的 PDF 电子解决方案的第1页应该是团队概要，然后是解决方案以及任何参考文献和附录。</p><p>e. 请勿在解决方案电子邮件中包含或发送代码程序、软件、数据库或其他文件，因为它们不会在评审过程中被使用。 </p><h1 id="查数据平台"><a href="#查数据平台" class="headerlink" title="查数据平台"></a>查数据平台</h1><p>美国政府公开数据，：<a href="https://link.zhihu.com/?target=https://www.usa.gov/">Official Guide to Government Information and Services | USAGov</a> ， <a href="https://link.zhihu.com/?target=https://www.data.gov/">https://www.data.gov/</a></p><p>Our World in Data 网站：<a href="https://link.zhihu.com/?target=https://ourworldindata.org/">Our World in Data</a></p><p>GitHub 上的资源：<a href="https://link.zhihu.com/?target=https://github.com/awesomedata/awesome-public-datasets">GitHub - awesomedata&#x2F;awesome-public-datasets: A topic-centric list of HQ open datasets.</a></p><p>Gapminder 网站：<a href="https://link.zhihu.com/?target=https://www.gapminder.org/about/">About | Gapminder</a></p><p><strong>2023 美国大学生数学建模竞赛（美赛）思路助攻汇总：</strong></p><p>谷歌学术镜像：<a href="https://link.zhihu.com/?target=https://so.hiqq.com.cn/">HiQQ 学术搜索</a> 或者 <a href="https://link.zhihu.com/?target=https://scholar.google.com/">https://scholar.google.com/</a></p><p>美国交通统计局 ：<a href="https://link.zhihu.com/?target=http://www.usda.gov/wps/portal/usda/usdahome">http://www.usda.gov/wps/portal/usda/usdahome</a></p><p>世界卫生组织：<a href="https://link.zhihu.com/?target=https://www.who.int/zh">世卫组织网站主页</a></p><p>知网；<a href="https://link.zhihu.com/?target=https://www.cnki.net/">中国知网</a></p><p>数学建模知识库：[数模知识库 <a href="https://link.zhihu.com/?target=https://www.shumo.com/wiki/doku.php?id=start">数模知识库]</a></p><p>国家数据：<a href="https://link.zhihu.com/?target=https://data.stats.gov.cn/">国家数据</a></p><p>数学中国论文：<a href="https://link.zhihu.com/?target=http://www.madio.net/">论坛 - 数学建模社区 - 数学中国</a></p><p>matlab 中文论坛：<a href="https://link.zhihu.com/?target=https://www.ilovematlab.cn/forum.php">页面重载开启</a></p><p>国家统计局之中国统计年鉴 ：<a href="https://link.zhihu.com/?target=http://www.stats.gov.cn/tjsj/ndsj/">国家统计局 &gt;&gt; 中国统计年鉴</a></p><p>中国气象数据网：<a href="https://link.zhihu.com/?target=http://data.cma.cn/">国家气象信息中心 - 中国气象数据网</a></p><p>俄罗斯的全球气象免费数据：<a href="https://link.zhihu.com/?target=https://rp5.ru/">Погода в 243 странах мира</a></p><p>国家冰川冻土沙漠科学数据中心：<a href="https://link.zhihu.com/?target=http://www.ncdc.ac.cn/portal/">国家冰川冻土沙漠科学数据中心</a></p><p>国家统计局：<a href="https://link.zhihu.com/?target=http://www.stats.gov.cn/tjsj/pcsj/">国家统计局 &gt;&gt; 普查数据</a></p><p>2019 新型冠状病毒信息库：<a href="https://link.zhihu.com/?target=https://www.semanticscholar.org/cord19/get-started">https://www.semanticscholar.org/cord19/get-started</a></p><p>新冠状全球数据地图：<a href="https://link.zhihu.com/?target=http://www.cn-wbst.cn/covid19/index.html">http://www.cn-wbst.cn/covid19/index.html</a></p><p>kaggle 为大量项目源码的地方：<a href="https://link.zhihu.com/?target=https://www.kaggle.com/">Kaggle: Your Machine Learning and Data Science Community</a></p><p>GIthub 也是下载代码的好地方:<a href="https://link.zhihu.com/?target=https://github.com/">GitHub: Let’s build from here</a></p><ol><li>全球免费数据库：</li></ol><p>Oaister: <a href="https://link.zhihu.com/?target=http://www.oclc.org/oaister/">http://www.oclc.org/oaister/</a></p><p>arXiv: <a href="https://link.zhihu.com/?target=http://cn.arxiv.org/">http://cn.arxiv.org</a></p><p>DOAJ: <a href="https://link.zhihu.com/?target=http://www.doaj.org/">http://www.doaj.org/</a></p><p>Open J-Gate: <a href="https://link.zhihu.com/?target=http://www.openj-gate.com/Search/QuickSearch.aspx">http://www.openj-gate.com/Search/QuickSearch.aspx</a></p><ol><li>重要的官网</li></ol><p>美国国家农业统计署 <a href="https://link.zhihu.com/?target=http://www.usda.gov/wps/portal/usda/usdahome">http://www.usda.gov/wps/portal/usda/usdahome</a></p><p>美国国家统计局 <a href="https://link.zhihu.com/?target=http://www.fedstats.gov/">http://www.fedstats.gov/</a></p><p>美国ＭＣＭ的主页 <a href="https://link.zhihu.com/?target=http://www.comap.com/">Mathematics Resources and Contests</a></p><p>美国交通统计局 <a href="https://link.zhihu.com/?target=http://www.bts.gov/">http://www.bts.gov/</a></p><p>美国劳工统计局 <a href="https://link.zhihu.com/?target=http://stats.bls.gov/">http://stats.bls.gov/</a></p><p>谷歌学术：<a href="https://link.zhihu.com/?target=http://ac.scmor.com/">http://ac.scmor.com/</a></p><p>美国人口统计局：<a href="https://link.zhihu.com/?target=http://www.census.gov/">http://www.census.gov/</a><br>美国普查局：<a href="https://link.zhihu.com/?target=http://2010.census.gov/2010census/language/chinese-simplified.php">http://2010.census.gov/2010cen</a></p><p>1、规划云，在线爬虫，地图可视化</p><p><a href="http://guihuayun.com/">http://guihuayun.com/</a></p><p>2、算法 &#x2F; 数据结构网络图在线可视化</p><p><a href="https://csacademy.com/app/graph_editor/">https://csacademy.com/app/graph_editor/</a></p><p>3、美国政府官网</p><p><a href="https://www.usa.gov/">https://www.usa.gov/</a></p><p>4、Our Worldin Data</p><p><a href="https://ourworldindata.org/">https://ourworldindata.org/</a></p><p>Google，SCI-Hub</p><p>SCI-Hub 网址：<a href="https://www.sci-hub.ren/">https://www.sci-hub.ren/</a></p><p>5、经合组织数据库</p><p><a href="https://www.oecd.org/gov/digital-government/open-government-data.htm">https://www.oecd.org/gov/digital-government/open-government-data.htm</a></p><p><strong>除此之外还有些美赛常用工具网站：</strong></p><p>英文修改：</p><p><a href="https://link.zhihu.com/?target=http://www.1checker.com/">http://www.1checker.com/</a></p><p>pdf工具</p><p><a href="https://www.ilovepdf.com/zh-cn">https://www.ilovepdf.com/zh-cn</a></p><p>上面这个需要翻墙</p><p><a href="https://tools.pdf24.org/zh/pdf-to-word">PDF转换为Word - 迅捷，在线，免费 - PDF24 Tools</a></p><p>这个不需要亲测</p><p><a href="https://www.hipdf.cn/crop-pdf">https://www.hipdf.cn/crop-pdf</a> PDF裁剪器，可以将图片导出为pdf格式，之后裁剪，避免论文模糊</p><p><a href="https://www.alltoall.net/pdf_eps/">https://www.alltoall.net/pdf_eps/</a> pdf到eps的格式转换工具，同样是避免直接插图论文变的模糊，转换为矢量格式</p><p>有道翻译</p><p><a href="https://fanyi.youdao.com/index.html#/">有道翻译_文本、文档、网页、在线即时翻译 (youdao.com)</a></p><p><a href="https://www.deepl.com/translator">https://www.deepl.com/translator</a> 一款不错的在线翻译软件</p><p><a href="https://www.fotor.com.cn/app.html#/design">https://www.fotor.com.cn/app.html#/design</a> 设计一些好看的图片</p><h1 id="选题分析"><a href="#选题分析" class="headerlink" title="选题分析"></a>选题分析</h1><h4 id="美赛赛题特点"><a href="#美赛赛题特点" class="headerlink" title="美赛赛题特点"></a>美赛赛题特点</h4><p>・对算法难度和准确度要求低于国赛<br>・综合性强，数学知识要求不高，强调创新性；<br>・英文写作水平要求较高</p><p>– E 题是<strong>环境科学题（sustainability）</strong>，大体上会集中在环境污染、资源短缺、可持续发展、生态保护等几个方面。</p><p>– F 题是<strong>政策研究题（policy）</strong>，EF 题的数据一般需要自己搜集哦。</p><p>美国大学生数学建模竞赛 ICM，Interdisciplinary Contest In Modeling，是交叉学科背景的数模赛题，<strong>用到的模型相对 MCM 题目而言更偏向评价决策、模型计算结果更具有开放性而非优化类问题较为固定的答案。</strong></p><p>ICM 一般涉及的问题较宏观和复杂，对于参赛者把握问题主线、权衡宏观与微观、整体与细节的能力要求较高。所以对于数学求解能力相对较弱的队伍，建议可以优先考虑 ICM 的赛题，保证队伍能顺利完成答题过程，同时 ICM 的题目对写作文字方面具备较大的发挥空间。</p><h3 id="02-近五年美赛-E-题特点"><a href="#02-近五年美赛-E-题特点" class="headerlink" title="02 - 近五年美赛 E 题特点"></a><strong>02 - 近五年美赛 E 题特点</strong></h3><p><strong>E 题是环境科学背景的题目，</strong>大体上会集中在环境污染、资源短缺、可持续发展、生态保护等几个方面。对问题的背景有一定的提示作用，而且范围仍然很广。如果涉及到评价问题，可以用某种或多种评估的方法对参与评价的 “对象” 进行排名分析。</p><p>在建模方法的选择上主要有：</p><blockquote><p><strong>TOPSIS 理想解法：</strong>找出理想最优解，根据样本和 “最优解” 的 “距离” 进行排名；<br><strong>模糊综合评价：</strong>适用于评价标准是等级这种模糊的评价，如人事考察等；<br><strong>数据包络分析的 cr 模型：</strong>用于对象之间的同等级比较，比较的是样本之间的相对效率；<br><strong>灰色关联度评价方法：</strong>求出每一个样本与最优解的灰色关联度即相似度进而进行排名；<br><strong>主成分分析：</strong>将原有的影响因素进行线性组合后选出主要成分再对其分析排名；<br><strong>秩和比综合评价法：</strong>可用于医疗卫生领域，工作质量的多指标综合评价。</p></blockquote><p>另外，<strong>美赛 E 题往往是评价预测类问题：</strong></p><blockquote><p>2018 年 E 题是以气候变化影响国家脆弱性为背景，属于评价和预测类问题；<br>2019 年 E 题是生态服务评估模型，加成本效益分析；<br>2020 年 E 题需要指数表征塑料污染严重程度，也属于评价类问题；<br>2021 年 E 题含有食品系统模型以及成本效益、可持续性模型。</p></blockquote><h3 id="03-近五年美赛-F-题特点"><a href="#03-近五年美赛-F-题特点" class="headerlink" title="03 - 近五年美赛 F 题特点"></a><strong>03 - 近五年美赛 F 题特点</strong></h3><p><strong>美赛 F 题通常是相对而言建模和编程难度最小的，但比较考验队伍的模型应用适配度以及写作的结果分析是否出彩，比较适合社科类的同学选择。</strong></p><p>并且 F 题主要是政策问题，会涉及到如何制定政策，制定政策需要考虑的对象，成本，限制因素，成效等一系列相关问题。题目发挥空间较大，背景与经济政策有关，适合经管专业学生当建模、写作。</p><p><strong>F 题使用的模型侧重综合评价和决策方法，也需要一些规划类问题的模型。</strong></p><p>在建模方法的选择上主要有：</p><blockquote><p><strong>层次分析法：</strong>将一个复杂的多目标决策问题作为一个系统，将目标分解为多个目标或准则，进而分解为多指标（或准则、约束）的若干层次，通过定性指标模糊量化方法算出层次单排序（权数）和总排序，以作为目标（多指标）、多方案优化决策的系统方法。如果政策中存在多种因素，即可用层次分析法来分出各种因素的重要程度；<br><strong>概率论与数理统计：</strong>若制定政策的结果中涉及到政策实行后的效果分析，则会用到动态演化模型对实行后的数据变化进行监控。可以用一些差分方程或常微分方程表示，一方面能够预测监控数据随时间的变化，另一方面能够解释一些状态；<br><strong>博弈论：</strong>主要研究公式化了的激励结构间的相互作用，是研究具有斗争或竞争性质现象的数学理论和方法。 博弈论考虑游戏中的个体的预测行为和实际行为，并研究它们的优化策略。生物学家使用博弈理论来理解和预测进化论的某些结果。</p></blockquote><p>-E 题是环境科学题（sustainability），大体上会集中在环境污染、资源短缺、可持续发展、生态保护等几个方面，评价类预测类问题居多，上手较为容易，但考验队伍的建模分析功力以及不能硬生生地套用模型。</p><p>–F 题是政策研究题（policy），经济政治的背景题目，考验数据分析能力以及结果分析的结论要有一定的深度。特别是 EF 题的数据一般需要自己搜集，大家平时多注意外网数据库的积累和收藏。</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美赛论文模板</title>
      <link href="/2024/01/30/%E7%BE%8E%E8%B5%9B%E8%AE%BA%E6%96%87%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/01/30/%E7%BE%8E%E8%B5%9B%E8%AE%BA%E6%96%87%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th><strong>Problem Chosen</strong>** **  C</th><th><strong>202X(<strong><strong>记得改年份</strong></strong>)</strong>**   MCM&#x2F;ICM   Summary Sheet**</th><th><strong>Team Control Number</strong>** **  1111111</th></tr></thead><tbody><tr><td></td><td></td><td></td></tr></tbody></table><p><strong>Your Paper’s Title</strong></p><p><strong>Summary</strong></p><p>  <strong>说明：</strong></p><p>  *<em>本</em>**<em>Word模版的版本编号是0.2版，是以美赛的标准创建的模版，也适用于其他用英文写作的数学建模比赛，例如亚太赛和小美赛。模版的使用方法可以查看下面这个视频：</em></p><p>  l   <strong>红色字体****标注的内容是对这个部分的解释，看完后请删除。</strong>  l   <strong>黄色高亮****的是需要大家修改的内容，大家修改后请取消高亮显示。</strong>                                                                             这里写美赛的摘要，美赛中摘要格外重要！！官方对于摘要的说明：  <em>The summary is an essential part of your  MCM&#x2F;ICM paper and should appear as the first page of your solution report.  The judges place considerable weight on the summary, and winning papers are  often distinguished from other papers based on the quality of the summary.</em>  翻译：摘要是美赛论文的重要组成部分，应该放在论文的第一页展示。评委们对摘要相当重视，获奖论文和其他论文的区别往往就在于摘要的好坏！  论文摘要的写法可以参考这个视频：      标题下面的Summary可要可不要，如果你觉得你摘要写的不够多，页面下方留白太大的话就加上，这样看起来稍微好看点。  注意：美赛要求英文写作，很多同学英文写作水平不够，可以先写成中文的论文，然后再进行翻译！翻译可以使用有道翻译或者谷歌翻译，翻译后一定要人工修改，机器翻译的很生硬，对专有名词的翻译也不是很准确。  </p><p><strong>Keywords:</strong> keyword1; keyword2; keyword3; keyword4</p><p>Contents最后记得更新整个目录</p><p><a href="#_Toc58786693">1  Introduction. 3</a></p><p><a href="#_Toc58786694">1.1 Problem Background. 3</a></p><p><a href="#_Toc58786695">1.2 Restatement of the Problem.. 3</a></p><p><a href="#_Toc58786696">1.3 Literature Review.. 3</a></p><p><a href="#_Toc58786697">1.4 Our Work. 4</a></p><p><a href="#_Toc58786698">2 Assumptions and  Justifications. 5</a></p><p><a href="#_Toc58786699">3 Notations. 6</a></p><p><a href="#_Toc58786700">4 The name of model 1. 6</a></p><p><a href="#_Toc58786701">4.1 Data  Description. 7</a></p><p><a href="#_Toc58786702">4.2 The  Establishment of Model 1. 7</a></p><p><a href="#_Toc58786703">4.3 The  Solution of Model 1. 7</a></p><p><a href="#_Toc58786704">5 The name of model 2. 8</a></p><p><a href="#_Toc58786705">6 The name of model 3. 8</a></p><p><a href="#_Toc58786706">7 Sensitivity Analysis. 8</a></p><p><a href="#_Toc58786707">8 Model Evaluation and  Further Discussion. 8</a></p><p><a href="#_Toc58786708">8.1 Strengths. 8</a></p><p><a href="#_Toc58786709">8.2 Weaknesses. 9</a></p><p><a href="#_Toc58786710">8.3 Further Discussion. 9</a></p><p><a href="#_Toc58786711">9 Conclusion. 9</a></p><p><a href="#_Toc58786712">References. 10</a></p><p><a href="#_Toc58786713">Appendices. 11</a></p><h1 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1 Introduction"></a>1 Introduction</h1><p>Introduction可以翻译成引言部分，大部分特等奖论文的引言部分都包含两到三个小部分。</p><p>我在下面给出了常见的四个小部分，大家可以根据自己的需要保留你要写的部分。</p><h2 id="1-1-Problem-Background"><a href="#1-1-Problem-Background" class="headerlink" title="1.1 Problem Background"></a>1.1 Problem Background</h2><p>Problem Background：这个小部分里面可以总结题目所给问题的背景，也可以加上自己查到的一些相关的资料，不要直接照搬题目；</p><p>注意，美赛的问题比国赛要更开放，大家写这个部分时可以结合你对于赛题的理解，要将这个背景介绍有侧重的往自己研究的方向去靠。例如，某个现实问题往往会涉及到经济、社会、生态、文化等各个层面，如果你的模型主要针对该问题对经济造成的影响，那么你的背景介绍就侧重于对经济层面的影响来写。</p><h2 id="1-2-Restatement-of-the-Problem"><a href="#1-2-Restatement-of-the-Problem" class="headerlink" title="1.2 Restatement of the Problem"></a>1.2 Restatement of the Problem</h2><p>Restatement of the Problem：问题重述，即用自己的话来总结下题目问我们的问题。</p><p>我下面给了一个通用的模版，大家可以改改：</p><p>Considering the background information and restricted conditions identified in the problem statement, we need to solve the following problems:</p><p>&#x3D;  Problem 1</p><p>&#x3D;  Problem 2</p><p>&#x3D;  Problem 3</p><p>注意，这个小部分也可以和问题背景合并到一起，作为第一个小部分，大家根据自己的需要调整。</p><h2 id="1-3-Literature-Review"><a href="#1-3-Literature-Review" class="headerlink" title="1.3 Literature Review"></a>1.3 Literature Review</h2><p>Literature Review：文献综述部分，这部分主要是总结以前的学者针对这个问题已经做的研究。事实上，绝大多数期刊发表的论文都会有文献综述部分。但在美赛特等奖论文中，只有不到30%的论文有这一部分，不是说这部分不重要，而是这一部分很难写。</p><p>这里给一个文献综述的定义：在对题目所涉及的研究领域的文献进行广泛阅读和理解的基础上，对该研究领域的研究现状（包括主要学术观点、前人研究成果和研究水平、争论焦点、存在的问题及可能的原因等）、新水平、新动态、新技术和新发现、发展前景等内容进行综合分析、归纳整理和评论，并提出自己的见解和研究思路而写成的一种文体。它要求作者既要对所查阅资料的主要观点进行综合整理、陈述，还要根据自己的理解和认识，对综合整理后的文献进行比较专门的、全面的、深入的、系统的论述和相应的评价，而不仅仅是相关领域学术研究的“堆砌”。</p><p>针对美赛而言，如果你以前有写过学术论文的经历，那么可以考虑加上这一部分，这一部分可以称得上是论文的一个小亮点。</p><h2 id="1-4-Our-Work"><a href="#1-4-Our-Work" class="headerlink" title="1.4 Our Work"></a>1.4 Our Work</h2><p>Our Work：对分析思路和建模的框架简要介绍，类似于国赛论文中的问题分析部分。</p><p>大家如果看特等奖论文的话，会发现很多论文在这一部分都绘制了一个图形来介绍文章的思路，大家可以模仿模仿。我给大家看两个例子：</p><p>例1：2019特等奖论文Team # 1916704</p><p>​     </p><p>例2：2020特等奖论文Team # 2017963</p><p>​     </p><h1 id="2-Assumptions-and-Justifications"><a href="#2-Assumptions-and-Justifications" class="headerlink" title="2 Assumptions and Justifications"></a>2 Assumptions and Justifications</h1><p>这一部分要写模型假设，并且要对假设的合理性进行论证，这一点比国赛的要求要高，请大家引起足够的注意。</p><p>《正确书写美国大学生数学建模论文》一书中说道：无论解答什么样的赛题，参赛小组在论文中都应该明确列出所有用到的假设条件，并解释其合理性。如果对某个假设无法给出满意的解释，则应重新考虑这个假设是否合理，并进行修改，使得修改后的假设能有满意的解释。评委不但会检查论文是否列出了在建模过程中用到的所有假设，而且还会审查这些假设是否合理，以及论文对这些假设的合理性是否给出了满意的解释。</p><p>这里给大家看两篇特等奖的范例：</p><p>例1：2020特等奖论文Team # 2022868</p><p>​     </p><p>例2：2020特等奖论文Team # 2017785</p><p>​     </p><h1 id="3-Notations"><a href="#3-Notations" class="headerlink" title="3 Notations"></a>3 Notations</h1><p>The key mathematical notations used in this paper are listed in Table 1.</p><p>Table 1: Notations used in this paper</p><table><thead><tr><th><strong>Symbol</strong></th><th><strong>Description</strong></th><th><strong>Unit</strong></th></tr></thead><tbody><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td><td></td></tr></tbody></table><p>本部分对应国赛论文中的符号（英文翻译为notation或者symbol）说明部分。</p><p>另外，少数论文有一个Deﬁnitions部分，这一部分主要是对文中出现的专有名词或者模糊的概念进行定义，这样可以帮助读者理解题目。</p><p>​     </p><p>如果你需要写这一个部分的话，可以和Notations合并在一起变成一个大部分，该部分的命名为“Deﬁnitions and Notations”，写作时再把这个大的部分分成两个小的部分（用二级标题的方式）分别写即可。</p><h1 id="4-The-name-of-model-1"><a href="#4-The-name-of-model-1" class="headerlink" title="4 The name of model 1"></a>4 The name of model 1</h1><p>这个大的部分主要介绍论文中第一个模型的建立和求解，第一个模型往往用来解决题目问的第一个问题。这个模型的标题需要结合你的题目或论文内容进行调整，我这里给的是一个通用的名称。</p><h2 id="4-1-Data-Description"><a href="#4-1-Data-Description" class="headerlink" title="4.1 Data Description"></a>4.1 Data Description</h2><p>如果自己收集了数据或者题目给了数据的话，可以先对数据进行一个描述，一般将数据可视化，然后再从图形中得到一些直观的结论。如果是美赛C题（C题一般是数据分析类型的题目），可以把这个部分单独作为一个大的部分，然后进行数据预处理和数据可视化分析。当然，这部分也不是必须的，大家根据自己的需要调整。</p><h2 id="4-2-The-Establishment-of-Model-1"><a href="#4-2-The-Establishment-of-Model-1" class="headerlink" title="4.2 The Establishment of Model 1"></a>4.2 The Establishment of Model 1</h2><p>这里可以写第一个模型的建立，模型建立是将原问题抽象成用数学语言的表达式，它一定是在先前的问题分析和模型假设的基础上得来的。因为比赛时间很紧，大多时候我们都是使用别人已经建立好的模型。这部分一定要将题目问的问题和模型紧密结合起来，切忌随意套用模型。我们还可以对已有模型的某一方面进行改进或者优化，或者建立不同的模型解决同一个问题，这样就是论文的创新和亮点。</p><p>和国赛不同，在美赛论文中，很少有论文直接用“模型建立”作为这部分的标题，一般使用模型要解决的问题作为标题。</p><p>如果需要用公式的话，可以复制下面这个隐藏的表格，并粘贴到你需要的地方，这个公式的编号会同步更新。</p><table><thead><tr><th>这里插入公式</th><th>(1)</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h2 id="4-3-The-Solution-of-Model-1"><a href="#4-3-The-Solution-of-Model-1" class="headerlink" title="4.3 The Solution of Model 1"></a>4.3 The Solution of Model 1</h2><p>这里可以写第一个模型的求解，把实际问题归结为一定的数学模型后，就要利用数学模型求解所提出的实际问题了。一般需要借助计算机软件进行求解，例如常用的软件有Matlab, Spss, Lingo, Excel, Stata, Python等。求解完成后，得到的求解结果应该规范准确并且醒目，若求解结果过长，最好编入附录里。（注意：如果使用智能优化算法或者数值计算方法求解的话，需要简要阐明算法的计算步骤）</p><p>同样的，很少有论文直接用“模型求解”作为这部分的标题，大家可以根据得到的结论来合理设计这里的标题。</p><p>另外，很多美赛论文对于模型的建立和求解没有区分开，我这里沿用的是类似于国赛的形式，这样可以让论文框架清晰点。</p><table><thead><tr><th>这里插入公式</th><th>(2)</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><table><thead><tr><th>这里插入公式</th><th>(3)</th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h1 id="5-The-name-of-model-2"><a href="#5-The-name-of-model-2" class="headerlink" title="5 The name of model 2"></a>5 The name of model 2</h1><p>和上一个部分类似的写法。</p><h1 id="6-The-name-of-model-3"><a href="#6-The-name-of-model-3" class="headerlink" title="6 The name of model 3"></a>6 The name of model 3</h1><p>和上一个部分类似的写法。</p><p>注意：大多数美赛优秀论文都是对每个问题或者每个模型作为一个一级标题，就像我们上面的这种布局；也有一部分论文建立一个大的一级标题，取名为“Models and Solutions”，然后在这个大的标题下设计每个问题或者模型对应的二级标题，这一种排版布局在国赛中用的更多。</p><h1 id="7-Sensitivity-Analysis"><a href="#7-Sensitivity-Analysis" class="headerlink" title="7 Sensitivity Analysis"></a>7 Sensitivity Analysis</h1><p>模型的分析 ：在建模比赛中模型分析主要有两种，一个是灵敏度(性)分析，另一个是误差分析。灵敏度分析是研究与分析一个系统（或模型）的状态或输出变化对系统参数或周围条件变化的敏感程度的方法。其通用的步骤是：控制其他参数不变的情况下，改变模型中某个重要参数的值，然后观察模型的结果的变化情况。误差分析是指分析模型中的误差来源，或者估算模型中存在的误差，一般用于预测问题或者数值计算类问题。</p><p>模型的检验：模型检验可以分为两种，一种是使用模型之前应该进行的检验，例如层次分析法中一致性检验，灰色预测中的准指数规律的检验，这部分内容应该放在模型的建立部分；另一种是使用了模型后对模型的结果进行检验，数模中最常见的是稳定性检验，实际上这里的稳定性检验和前面的灵敏度分析非常类似，等会大家看到例子就明白了。</p><p>在美赛的写作中，写的最多的就是灵敏度分析（Sensitivity Analysis），因此这里我们的标题就直接取得是灵敏度分析；如果你既要写灵敏度分析，又要写误差分析（Error Analysis），那么你可以把标题改成： Sensitivity Analysis and Error Analysis</p><h1 id="8-Model-Evaluation-and-Further-Discussion"><a href="#8-Model-Evaluation-and-Further-Discussion" class="headerlink" title="8 Model Evaluation and Further Discussion"></a>8 Model Evaluation and Further Discussion</h1><p>注：本部分的标题需要根据你的内容进行调整，例如：如果你没有写进一步讨论的话，就直接把标题写成模型的评价。（优缺点一定要写）</p><h2 id="8-1-Strengths"><a href="#8-1-Strengths" class="headerlink" title="8.1 Strengths"></a>8.1 Strengths</h2><p>这里写论文或者模型的优点</p><h2 id="8-2-Weaknesses"><a href="#8-2-Weaknesses" class="headerlink" title="8.2 Weaknesses"></a>8.2 Weaknesses</h2><p>这里写缺点：缺点写的个数一般要比优点少</p><h2 id="8-3-Further-Discussion"><a href="#8-3-Further-Discussion" class="headerlink" title="8.3 Further Discussion"></a>8.3 Further Discussion</h2><p>进行进一步的讨论，这里可以写模型的改进和拓展：</p><p>模型的改进：主要是针对模型中缺点有哪些可以改进的地方；</p><p>模型的拓展：将原题的要求进行扩展，进一步讨论模型的实用性和可行性。</p><h1 id="9-Conclusion"><a href="#9-Conclusion" class="headerlink" title="9 Conclusion"></a>9 Conclusion</h1><p>结论部分，这个部分在国赛论文很少见到，但在美赛中出现的频率很高。</p><p>这个部分可以是论文中心思想的重申、研究结果或主要观点的归纳，也可以是某些启示性的解释或考虑。</p><p>有些论文把“Model Evaluation and Further Discussion”的内容放到了结论部分，这也是可以的，大家可以灵活调整。</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p>参考文献：所有引用他人或公开资料(包括网上资料)的成果必须按照科技论文的规范列出参考文献，并在正文引用处予以标注。</p><p>一般新起一页列出参考文献，如果上一个部分的下面有很多空白，那么就不用新起一页了。</p><p>美赛中不要出现中文，如果引用中文文献请翻译过来。</p><h1 id="Appendices"><a href="#Appendices" class="headerlink" title="Appendices"></a>Appendices</h1><table><thead><tr><th>Appendix 1</th></tr></thead><tbody><tr><td>Introduce: 这里放上附录1的介绍</td></tr><tr><td></td></tr></tbody></table><table><thead><tr><th>Appendix 2</th></tr></thead><tbody><tr><td>Introduce: 这里放上附录2的介绍</td></tr><tr><td></td></tr></tbody></table><p>本部分是附录部分，美赛对于附录不是特别看重，今年还限制了论文的页数（从第二页开始编号，不能超过25页）。</p><p>一般新起一页列出附录。</p><p>在不超过页数限制的条件下，附录中可以包括下面内容：</p><p>² 你们写的代码；</p><p>² 某一问题的详细证明或求解过程；</p><p>² 自己在网上找到的数据；</p><p>² 比较大的流程图；</p><p>² 较繁杂的图表或计算结果。</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模模型汇总</title>
      <link href="/2024/01/30/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%A8%A1%E5%9E%8B%E6%B1%87%E6%80%BB/"/>
      <url>/2024/01/30/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E6%A8%A1%E5%9E%8B%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="数学分析模型总结"><a href="#数学分析模型总结" class="headerlink" title="数学分析模型总结"></a>数学分析模型总结</h1><h2 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h2><h3 id="1-建立层次结构模型"><a href="#1-建立层次结构模型" class="headerlink" title="1.建立层次结构模型"></a>1.建立层次结构模型</h3><p>将决策的目标、考虑的因素（决策准则）和决策对象按照他们之间的相互关系分为最高层、中间层和最低层，绘出层次结构图。<br>最高层： 决策的目的、要解决的问题。<br>最低层： 决策时的备选方案。<br>中间层： 考虑的因素、决策的准则。<br>对相邻的两层，称高层为目标层，低层为因素层。<br>层次分析法所要解决的问题是关于最低层对最高层的相对权重的问题，按此相对权重可以对最低层中的各种方案、措施进行排序，从而在不同的方案中做出选择或形成选择方案的原则。</p><p><strong>2.构造判断矩阵</strong><br>层次分析法中构造判断矩阵的方法是一致矩阵法，即：不把所有因素放在一起比较，而是两两相互比较；对此时采用相对尺度，以尽可能减少性质不同因素相互比较的困难，以提高准确度。</p><p>3.层次单排序及其一致性检验<br>对应于判断矩阵最大特征根λ m a x的特征向量，经归一化（使向量中各元素之和为1）后记为W。W的元素为同一层次元素对于上一层因素某因素相对重要性的排序权值，这一过程称为层次单排序。</p><p><strong>4.层次总排序及其一致性检验</strong></p><ul><li>计算某一层次所有因素对于最高层（总目标）相对重要性的权值，称为层次总排序。</li><li>这一过程是从最高层次到最低层次依次进行的。</li></ul><p><img src="/images/image-20240130105508933.png" alt="image-20240130105508933"></p><p><img src="/images/image-20240130105522533.png" alt="image-20240130105522533"></p><p><img src="/images/image-20240130105530952.png" alt="image-20240130105530952"></p><p><img src="/images/image-20240130105602627.png" alt="image-20240130105602627"></p><p><img src="/images/image-20240130105612247.png" alt="image-20240130105612247"></p><p><img src="/images/image-20240130105622706.png" alt="image-20240130105622706"></p><p><img src="/images/image-20240130105634826.png" alt="image-20240130105634826"></p><p><img src="/images/image-20240130105642063.png" alt="image-20240130105642063"></p><h2 id="多属性决策模型"><a href="#多属性决策模型" class="headerlink" title="多属性决策模型"></a>多属性决策模型</h2><h3 id="加权平均"><a href="#加权平均" class="headerlink" title="加权平均"></a>加权平均</h3><p><img src="/images/image-20240130110100685.png" alt="image-20240130110100685"></p><h3 id="正向化标准化（内容不贴了）"><a href="#正向化标准化（内容不贴了）" class="headerlink" title="正向化标准化（内容不贴了）"></a>正向化标准化（内容不贴了）</h3><p><img src="/images/image-20240130110331660.png" alt="image-20240130110331660"></p><p><img src="/images/image-20240130110339299.png" alt="image-20240130110339299"></p><p><img src="/images/image-20240130110351212.png" alt="image-20240130110351212"></p><p><img src="/images/image-20240130110356088.png" alt="image-20240130110356088"></p><h2 id="灰色预测"><a href="#灰色预测" class="headerlink" title="灰色预测"></a>灰色预测</h2><blockquote><p>美赛不推荐使用，评委不知道这个算法</p></blockquote><h2 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h2><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h3><p><img src="/images/image-20240130110629888.png" alt="image-20240130110629888"></p><p>每次从 「未求出最短路径的点」中 <strong>取出</strong> 距离距离起点 <strong>最小路径的点</strong>，以这个点为桥梁 <strong>刷新</strong>「未求出最短路径的点」的距<img src="/images/image-20240130110726035.png" alt="image-20240130110726035"></p><h2 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line">vector&lt;PII&gt;E[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dj</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">dis[i]=INF;</span><br><span class="line">vis[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">dis[s]=<span class="number">0</span>;</span><br><span class="line">priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt;q;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t=q.<span class="built_in">top</span>().second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(vis[t])&#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">vis[t]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,l=E[t].<span class="built_in">size</span>();i&lt;l;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> v=E[t][i].first;</span><br><span class="line"><span class="type">int</span> w=E[t][i].second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dis[v]&gt;dis[t]+w)</span><br><span class="line">&#123;</span><br><span class="line">dis[v]=dis[t]+w;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);cin.<span class="built_in">tie</span>(<span class="number">0</span>);cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">E[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dj</span>(s);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;dis[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% Matlab作无向图</span></span><br><span class="line"><span class="comment">% （1）无权重（每条边的权重默认为1）</span></span><br><span class="line"><span class="comment">% 函数graph(s,t)：可在 s 和 t 中的对应节点之间创建边，并生成一个图</span></span><br><span class="line"><span class="comment">% s 和 t 都必须具有相同的元素数；这些节点必须都是从1开始的正整数，或都是字符串元胞数组。</span></span><br><span class="line">s1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">t1 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">G1 = graph(s1, t1);</span><br><span class="line"><span class="built_in">plot</span>(G1)</span><br><span class="line"><span class="comment">% 注意哦，编号最好是从1开始连续编号，不要自己随便定义编号</span></span><br><span class="line">s1 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">t1 = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">G1 = graph(s1, t1);</span><br><span class="line"><span class="built_in">plot</span>(G1)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 注意字符串元胞数组是用大括号包起来的哦</span></span><br><span class="line">s2 = &#123;<span class="string">&#x27;学校&#x27;</span>,<span class="string">&#x27;电影院&#x27;</span>,<span class="string">&#x27;网吧&#x27;</span>,<span class="string">&#x27;酒店&#x27;</span>&#125;;</span><br><span class="line">t2 = &#123;<span class="string">&#x27;电影院&#x27;</span>,<span class="string">&#x27;酒店&#x27;</span>,<span class="string">&#x27;酒店&#x27;</span>,<span class="string">&#x27;KTV&#x27;</span>&#125;;</span><br><span class="line">G2 = graph(s2, t2);</span><br><span class="line"><span class="built_in">plot</span>(G2, <span class="string">&#x27;linewidth&#x27;</span>, <span class="number">2</span>)  <span class="comment">% 设置线的宽度</span></span><br><span class="line"><span class="comment">% 下面的命令是在画图后不显示坐标</span></span><br><span class="line">set( gca, <span class="string">&#x27;XTick&#x27;</span>, [], <span class="string">&#x27;YTick&#x27;</span>, [] );  </span><br><span class="line"></span><br><span class="line"><span class="comment">% （2）有权重</span></span><br><span class="line"><span class="comment">% 函数graph(s,t,w)：可在 s 和 t 中的对应节点之间以w的权重创建边，并生成一个图</span></span><br><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">t = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">w = [<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>];</span><br><span class="line">G = graph(s, t, w);</span><br><span class="line"><span class="built_in">plot</span>(G, <span class="string">&#x27;EdgeLabel&#x27;</span>, G.Edges.Weight, <span class="string">&#x27;linewidth&#x27;</span>, <span class="number">2</span>) </span><br><span class="line">set( gca, <span class="string">&#x27;XTick&#x27;</span>, [], <span class="string">&#x27;YTick&#x27;</span>, [] );  </span><br><span class="line"></span><br><span class="line"><span class="comment">%% Matlab作有向图</span></span><br><span class="line"><span class="comment">% 无权图 digraph(s,t)</span></span><br><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>];</span><br><span class="line">t = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">4</span>];</span><br><span class="line">G = digraph(s, t);</span><br><span class="line"><span class="built_in">plot</span>(G)</span><br><span class="line">set( gca, <span class="string">&#x27;XTick&#x27;</span>, [], <span class="string">&#x27;YTick&#x27;</span>, [] );  </span><br><span class="line"></span><br><span class="line"><span class="comment">% 有权图 digraph(s,t,w)</span></span><br><span class="line">s = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">t = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">w = [<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">2</span>];</span><br><span class="line">G = digraph(s, t, w);</span><br><span class="line"><span class="built_in">plot</span>(G, <span class="string">&#x27;EdgeLabel&#x27;</span>, G.Edges.Weight, <span class="string">&#x27;linewidth&#x27;</span>, <span class="number">2</span>) </span><br><span class="line">set( gca, <span class="string">&#x27;XTick&#x27;</span>, [], <span class="string">&#x27;YTick&#x27;</span>, [] );  </span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 注意：以下代码需要较新版本的matlab才能运行（最好是2016版本及以上哦）</span></span><br><span class="line"><span class="comment">% 如果运行出错请下载新版的matlab代码再运行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 注意哦，Matlab中的图节点要从1开始编号，所以这里把0全部改为了9</span></span><br><span class="line"><span class="comment">% 编号最好是从1开始连续编号，不要自己随便定义编号</span></span><br><span class="line">s = [<span class="number">9</span> <span class="number">9</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">7</span> <span class="number">7</span> <span class="number">6</span> <span class="number">6</span>  <span class="number">5</span>  <span class="number">5</span> <span class="number">4</span>];</span><br><span class="line">t = [<span class="number">1</span> <span class="number">7</span> <span class="number">7</span> <span class="number">2</span> <span class="number">8</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">6</span> <span class="number">8</span> <span class="number">5</span>  <span class="number">3</span>  <span class="number">4</span> <span class="number">3</span>];</span><br><span class="line">w = [<span class="number">4</span> <span class="number">8</span> <span class="number">3</span> <span class="number">8</span> <span class="number">2</span> <span class="number">7</span> <span class="number">4</span> <span class="number">1</span> <span class="number">6</span> <span class="number">6</span> <span class="number">2</span> <span class="number">14</span> <span class="number">10</span> <span class="number">9</span>];</span><br><span class="line">G = graph(s,t,w);</span><br><span class="line"><span class="built_in">plot</span>(G, <span class="string">&#x27;EdgeLabel&#x27;</span>, G.Edges.Weight, <span class="string">&#x27;linewidth&#x27;</span>, <span class="number">2</span>) </span><br><span class="line">set( gca, <span class="string">&#x27;XTick&#x27;</span>, [], <span class="string">&#x27;YTick&#x27;</span>, [] );  </span><br><span class="line">[P,d] = shortestpath(G, <span class="number">9</span>, <span class="number">4</span>)  <span class="comment">%注意：该函数matlab2015b之后才有哦</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 在图中高亮我们的最短路径</span></span><br><span class="line">myplot = <span class="built_in">plot</span>(G, <span class="string">&#x27;EdgeLabel&#x27;</span>, G.Edges.Weight, <span class="string">&#x27;linewidth&#x27;</span>, <span class="number">2</span>);  <span class="comment">%首先将图赋给一个变量</span></span><br><span class="line">highlight(myplot, P, <span class="string">&#x27;EdgeColor&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)   <span class="comment">%对这个变量即我们刚刚绘制的图形进行高亮处理（给边加上r红色）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 求出任意两点的最短路径矩阵</span></span><br><span class="line">D = distances(G)   <span class="comment">%注意：该函数matlab2015b之后才有哦</span></span><br><span class="line">D(<span class="number">1</span>,<span class="number">2</span>)  <span class="comment">% 1 -&gt; 2的最短路径</span></span><br><span class="line">D(<span class="number">9</span>,<span class="number">4</span>)  <span class="comment">% 9 -&gt; 4的最短路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 找出给定范围内的所有点  nearest(G,s,d)</span></span><br><span class="line"><span class="comment">% 返回图形 G 中与节点 s 的距离在 d 之内的所有节点</span></span><br><span class="line">[nodeIDs,dist] = nearest(G, <span class="number">2</span>, <span class="number">10</span>)   <span class="comment">%注意：该函数matlab2016a之后才有哦</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h3><p><img src="/images/image-20240130111841434.png" alt="image-20240130111841434"></p><p>Floyd算法代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[dist,path]</span> = <span class="title">Floyd_algorithm</span><span class="params">(D)</span></span></span><br><span class="line"><span class="comment">%% 该函数用于求解一个权重邻接矩阵任意两个节点之间的最短路径</span></span><br><span class="line"><span class="comment">% 输入：</span></span><br><span class="line"><span class="comment">%        D是权重邻接矩阵</span></span><br><span class="line"><span class="comment">% 输出：</span></span><br><span class="line"><span class="comment">%        dist是最短距离矩阵，其元素dist_ij表示表示i,j两个节点的最短距离</span></span><br><span class="line"><span class="comment">%        path是路径矩阵，其元素path_ij表示起点为i，终点为j的两个节点之间的最短路径要经过的节点</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">size</span>(D,<span class="number">1</span>);  <span class="comment">% 计算节点的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化dist矩阵</span></span><br><span class="line">dist = D;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面我们来初始化path矩阵</span></span><br><span class="line">path = <span class="built_in">zeros</span>(n);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:n</span><br><span class="line">    path(:,<span class="built_in">j</span>) = <span class="built_in">j</span>;   <span class="comment">% 将第j列的元素变为j</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    path(<span class="built_in">i</span>,<span class="built_in">i</span>) = <span class="number">-1</span>;  <span class="comment">% 将主对角线元素变为-1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面开始三个循环</span></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:n    <span class="comment">% 中间节点k从1- n 循环</span></span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n     <span class="comment">% 起始节点i从1- n 循环</span></span><br><span class="line">      <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n    <span class="comment">% 终点节点j从1-n 循环</span></span><br><span class="line">          <span class="keyword">if</span> dist(<span class="built_in">i</span>,<span class="built_in">j</span>)&gt;dist(<span class="built_in">i</span>,k)+dist(k,<span class="built_in">j</span>)  <span class="comment">% 如果i,j两个节点间的最短距离大于i和k的最短距离+k和j的最短距离</span></span><br><span class="line">             dist(<span class="built_in">i</span>,<span class="built_in">j</span>)=dist(<span class="built_in">i</span>,k)+dist(k,<span class="built_in">j</span>);  <span class="comment">% 那么我们就令这两个较短的距离之和取代i,j两点之间的最短距离</span></span><br><span class="line">             path(<span class="built_in">i</span>,<span class="built_in">j</span>)=path(<span class="built_in">i</span>,k);   <span class="comment">% 起点为i，终点为j的两个节点之间的最短路径要经过的节点更新为path(i,k)</span></span><br><span class="line">             <span class="comment">% 注意，上面一行语句不能写成path(i,j) = k; 这是网上很多地方都容易犯的错误，在PPT11页中会告诉大家为什么不能这么写</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>例子</p><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% PPT第七页的例子</span></span><br><span class="line"><span class="comment">%% 首先将图转换为权重邻接矩阵D</span></span><br><span class="line">n = <span class="number">5</span>;  <span class="comment">%一共五个节点</span></span><br><span class="line">D = <span class="built_in">ones</span>(n) ./ <span class="built_in">zeros</span>(n);  <span class="comment">% 全部元素初始化为Inf</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    D(<span class="built_in">i</span>,<span class="built_in">i</span>) = <span class="number">0</span>;  <span class="comment">% 主对角线元素为0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">D(<span class="number">1</span>,<span class="number">2</span>) = <span class="number">3</span>;</span><br><span class="line">D(<span class="number">1</span>,<span class="number">3</span>) = <span class="number">8</span>;</span><br><span class="line">D(<span class="number">1</span>,<span class="number">5</span>) = <span class="number">-4</span>;</span><br><span class="line">D(<span class="number">2</span>,<span class="number">5</span>) = <span class="number">7</span>;</span><br><span class="line">D(<span class="number">2</span>,<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">D(<span class="number">3</span>,<span class="number">2</span>) = <span class="number">4</span>;</span><br><span class="line">D(<span class="number">4</span>,<span class="number">3</span>) = <span class="number">-5</span>;</span><br><span class="line">D(<span class="number">5</span>,<span class="number">4</span>) = <span class="number">6</span>;</span><br><span class="line">D(<span class="number">4</span>,<span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 调用Floyd_algorithm函数求解</span></span><br><span class="line">[dist,path] = Floyd_algorithm(D)</span><br><span class="line"></span><br><span class="line">print_path(path,dist,<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">print_path(path,dist,<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">print_path(path,dist,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">clc</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;下面我们打印任意两点之间的最短距离：&#x27;</span>)</span><br><span class="line">print_all_path(D)</span><br></pre></td></tr></table></figure><h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 思考题的参考答案</span></span><br><span class="line"><span class="comment">%% 首先将图转换为权重邻接矩阵D</span></span><br><span class="line">n = <span class="number">9</span>;  <span class="comment">%一共九个节点</span></span><br><span class="line">D = <span class="built_in">zeros</span>(n);  <span class="comment">% 全部元素初始化为0, 等会你们就知道为什么这样设置啦</span></span><br><span class="line"><span class="comment">% 因为是无向图，所以权重邻接矩阵是一个对称矩阵</span></span><br><span class="line">D(<span class="number">1</span>,<span class="number">2</span>) = <span class="number">4</span>; D(<span class="number">1</span>,<span class="number">8</span>) = <span class="number">8</span>; </span><br><span class="line">D(<span class="number">2</span>,<span class="number">8</span>) = <span class="number">3</span>; D(<span class="number">2</span>,<span class="number">3</span>) = <span class="number">8</span>;</span><br><span class="line">D(<span class="number">8</span>,<span class="number">9</span>) = <span class="number">1</span>; D(<span class="number">8</span>,<span class="number">7</span>) = <span class="number">6</span>; </span><br><span class="line">D(<span class="number">9</span>,<span class="number">7</span>) = <span class="number">6</span>; D(<span class="number">9</span>,<span class="number">3</span>) = <span class="number">2</span>;</span><br><span class="line">D(<span class="number">7</span>,<span class="number">6</span>) = <span class="number">2</span>; D(<span class="number">3</span>,<span class="number">4</span>) = <span class="number">7</span>; </span><br><span class="line">D(<span class="number">3</span>,<span class="number">6</span>) = <span class="number">4</span>; D(<span class="number">6</span>,<span class="number">4</span>) = <span class="number">14</span>;</span><br><span class="line">D(<span class="number">4</span>,<span class="number">5</span>) = <span class="number">9</span>; D(<span class="number">6</span>,<span class="number">5</span>) = <span class="number">10</span>;</span><br><span class="line">D = D+D&#x27;;   <span class="comment">% 这个操作可以得到对称矩阵的另一半</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">i</span> ~= <span class="built_in">j</span>) &amp;&amp; (D(<span class="built_in">i</span>,<span class="built_in">j</span>) == <span class="number">0</span>)  </span><br><span class="line">            D(<span class="built_in">i</span>,<span class="built_in">j</span>) = Inf;   <span class="comment">% 将非主对角线上的0元素全部变为Inf</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 调用Floyd_algorithm函数求解</span></span><br><span class="line">[dist,path] = Floyd_algorithm(D)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function [] = <span class="built_in">print_all_path</span>(D)</span><br><span class="line">%% 该函数的作用是求解一个权重邻接矩阵任意两个节点之间的最短路径,并打印所有的结果出来</span><br><span class="line">% 输入：</span><br><span class="line">%        D是权重邻接矩阵</span><br><span class="line">% 输出：无</span><br><span class="line"></span><br><span class="line">[dist,path] = <span class="built_in">Floyd_algorithm</span>(D);   % 调用之前的Floyd_algorithm函数</span><br><span class="line">n = <span class="built_in">size</span>(D,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span></span><br><span class="line">    <span class="built_in">warning</span>(<span class="string">&#x27;请输入至少两阶以上的权重邻接矩阵&#x27;</span>)   % 在屏幕中提示警告信息</span><br><span class="line">    <span class="keyword">return</span>;   % 不运行下面的语句，直接退出函数</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>:n</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> i ~= j  % 不等号用~=表示</span><br><span class="line">            <span class="built_in">print_path</span>(path,dist,i,j);   % 调用之前的print_path函数</span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;-------------------------------------------&#x27;</span>)</span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;  &#x27;</span>)</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[]</span> = <span class="title">print_path</span><span class="params">(path,dist,i,j)</span></span></span><br><span class="line"><span class="comment">%% 该函数的作用是打印从i到j经过的最短路径</span></span><br><span class="line"><span class="comment">% 输入：</span></span><br><span class="line"><span class="comment">%        path是使用floyd算法求出来的路径矩阵</span></span><br><span class="line"><span class="comment">%        dist是使用floyd算法求出来的最短距离矩阵</span></span><br><span class="line"><span class="comment">%        i是起始节点的编号</span></span><br><span class="line"><span class="comment">%        j是终点节点的编号</span></span><br><span class="line"><span class="comment">% 输出：无</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">i</span> == <span class="built_in">j</span></span><br><span class="line">    warning(<span class="string">&#x27;起点和终点相同，请检查后重新输入&#x27;</span>)  <span class="comment">% 在屏幕中提示警告信息</span></span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">% 不运行下面的语句，直接退出函数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> path(<span class="built_in">i</span>,<span class="built_in">j</span>) == <span class="built_in">j</span>   <span class="comment">% 如果path(i,j) = j，则有两种可能：</span></span><br><span class="line"><span class="comment">% （1）如果dist(i,j) 为 Inf , 则说明从i到j没有路径可以到达</span></span><br><span class="line">    <span class="keyword">if</span> dist(<span class="built_in">i</span>,<span class="built_in">j</span>) == Inf</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;从&#x27;</span>,num2str(<span class="built_in">i</span>),<span class="string">&#x27;到&#x27;</span>,num2str(<span class="built_in">j</span>),<span class="string">&#x27;没有路径可以到达&#x27;</span>])</span><br><span class="line"><span class="comment">% （2）如果dist(i,j) 不为 Inf , 则说明从i到j可直接到达，且为最短路径</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;从&#x27;</span>,num2str(<span class="built_in">i</span>),<span class="string">&#x27;到&#x27;</span>,num2str(<span class="built_in">j</span>),<span class="string">&#x27;的最短路径为&#x27;</span>])</span><br><span class="line">        <span class="built_in">disp</span>([num2str(<span class="built_in">i</span>),<span class="string">&#x27; ---&gt; &#x27;</span>,num2str(<span class="built_in">j</span>)])</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;最短距离为&#x27;</span>,num2str(dist(<span class="built_in">i</span>,<span class="built_in">j</span>))])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span>  <span class="comment">% 如果path(i,j) ~= j，则说明中间经过了其他节点：</span></span><br><span class="line">    k = path(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">    result = [num2str(<span class="built_in">i</span>),<span class="string">&#x27; ---&gt; &#x27;</span>];  <span class="comment">% 初始化要打印的这个字符串</span></span><br><span class="line">    <span class="keyword">while</span> k ~= <span class="built_in">j</span>  <span class="comment">% 只要k不等于j, 就一直循环下去</span></span><br><span class="line">        result = [result , num2str(k) , <span class="string">&#x27; ---&gt; &#x27;</span> ];  <span class="comment">% i先走到k这个节点处</span></span><br><span class="line">        k = path(k,<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result = [result , num2str(k)];</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;从&#x27;</span>,num2str(<span class="built_in">i</span>),<span class="string">&#x27;到&#x27;</span>,num2str(<span class="built_in">j</span>),<span class="string">&#x27;的最短路径为&#x27;</span>])</span><br><span class="line">    <span class="built_in">disp</span>(result)</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;最短距离为&#x27;</span>,num2str(dist(<span class="built_in">i</span>,<span class="built_in">j</span>))])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h2><blockquote><p> 模拟退火是物理上退火的方法，通过N次迭代，逼近函数上的一个值</p><p> 大方向：循环算法</p><p> 模拟退火算法(Simulated Annealing，简称SA)的思想最早是由Metropolis等提出的。其出发点是基于物理中固体物质的退火过程与一般的组合优化问题之间的相似性。模拟退火法是一种通用的优化算法，其物理退火过程由以下三部分组成:</p><p> （1） 加温过程。其目的是增强粒子的热运动，使其偏离平衡位置。当温度足够高时，固体将熔为液体，从而消除系统原先存在的非均匀状态。</p><p> （2） 等温过程。对于与周围环境交换热量而温度不变的封闭系统，系统状态的自发变化总是朝自由能减少的方向进行的，当自由能达到最小时，系统达到平衡状态。</p><p> （3） 冷却过程。使粒子热运动减弱，系统能量下降，得到晶体结构。</p><p> 加温过程相当于对算法设定初值，等温过程对应算法的Metropolis抽样过程，冷却过程对应控制参数的下降。这里能量的变化就是目标函数，我们要得到的最优解就是能量最低态。其中Metropolis准则是SA算法收敛于全局最优解的关键所在，Metropolis准则以一定的概率接受恶化解，这样就使算法跳离局部最优的陷阱。</p><p> SA算法的Metropolis准则允许接受一定的恶化解，具体来讲，是以一定概率来接受非最优解。举个例子，相当于保留一些“潜力股”，使解空间里有更多的可能性。对比轮盘赌法，从概率论来讲，它是对非最优解给予概率0，即全部抛弃。</p><p> 模拟退火本身是求一个最小值问题，但可以转化为求最大值问题，只需要对目标函数加个负号或者取倒数。</p></blockquote><p><img src="/images/bf3f480b814b4128a9a8b56e67cc7292.png" alt="img"><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动">编辑</p><p>不断滚动，概率变动</p><p><img src="/images/2332b75e55ef41f5bdf4bce6d91a0108.png" alt="img"><img src="/images/c9d8f8aa383c40a1b94e63165a248b36.png" alt="img"></p><p><img src="/images/a057b531f74e42e08cc661aad387f675.png" alt="img"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% SA 模拟退火: 求解函数y = 11*sin(x) + 7*cos(5*x)在[-3,3]内的最大值(动画演示）</span></span><br><span class="line">tic</span><br><span class="line">clear; clc</span><br><span class="line"> </span><br><span class="line"><span class="comment">%% 绘制函数的图形</span></span><br><span class="line">x = <span class="number">-3</span>:<span class="number">0.1</span>:<span class="number">3</span>;</span><br><span class="line">y = <span class="number">11</span>*<span class="built_in">sin</span>(x) + <span class="number">7</span>*<span class="built_in">cos</span>(<span class="number">5</span>*x);</span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;b-&#x27;</span>)</span><br><span class="line"><span class="built_in">hold</span> on  <span class="comment">% 不关闭图形，继续在上面画图</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%% 参数初始化</span></span><br><span class="line">narvs = <span class="number">1</span>; <span class="comment">% 变量个数</span></span><br><span class="line">T0 = <span class="number">100</span>;   <span class="comment">% 初始温度</span></span><br><span class="line">T = T0; <span class="comment">% 迭代中温度会发生改变，第一次迭代时温度就是T0</span></span><br><span class="line">maxgen = <span class="number">200</span>;  <span class="comment">% 最大迭代次数</span></span><br><span class="line">Lk = <span class="number">100</span>;  <span class="comment">% 每个温度下的迭代次数</span></span><br><span class="line">alfa = <span class="number">0.95</span>;  <span class="comment">% 温度衰减系数</span></span><br><span class="line">x_lb = <span class="number">-3</span>; <span class="comment">% x的下界</span></span><br><span class="line">x_ub = <span class="number">3</span>; <span class="comment">% x的上界</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%%  随机生成一个初始解</span></span><br><span class="line">x0 = <span class="built_in">zeros</span>(<span class="number">1</span>,narvs);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: narvs</span><br><span class="line">    x0(<span class="built_in">i</span>) = x_lb(<span class="built_in">i</span>) + (x_ub(<span class="built_in">i</span>)-x_lb(<span class="built_in">i</span>))*<span class="built_in">rand</span>(<span class="number">1</span>);    </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">y0 = Obj_fun1(x0); <span class="comment">% 计算当前解的函数值</span></span><br><span class="line">h = <span class="built_in">scatter</span>(x0,y0,<span class="string">&#x27;*r&#x27;</span>);  <span class="comment">% scatter是绘制二维散点图的函数（这里返回h是为了得到图形的句柄，未来我们对其位置进行更新）</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%% 定义一些保存中间过程的量，方便输出结果和画图</span></span><br><span class="line">max_y = y0;     <span class="comment">% 初始化找到的最佳的解对应的函数值为y0</span></span><br><span class="line">MAXY = <span class="built_in">zeros</span>(maxgen,<span class="number">1</span>); <span class="comment">% 记录每一次外层循环结束后找到的max_y (方便画图）</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%% 模拟退火过程</span></span><br><span class="line"><span class="keyword">for</span> iter = <span class="number">1</span> : maxgen  <span class="comment">% 外循环, 我这里采用的是指定最大迭代次数</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : Lk  <span class="comment">% 内循环，在每个温度下开始迭代</span></span><br><span class="line">        y = <span class="built_in">randn</span>(<span class="number">1</span>,narvs);  <span class="comment">% 生成1行narvs列的N(0,1)随机数</span></span><br><span class="line">        z = y / <span class="built_in">sqrt</span>(sum(y.^<span class="number">2</span>)); <span class="comment">% 根据新解的产生规则计算z</span></span><br><span class="line">        x_new = x0 + z*T; <span class="comment">% 根据新解的产生规则计算x_new的值</span></span><br><span class="line">        <span class="comment">% 如果这个新解的位置超出了定义域，就对其进行调整</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>: narvs</span><br><span class="line">            <span class="keyword">if</span> x_new(<span class="built_in">j</span>) &lt; x_lb(<span class="built_in">j</span>)</span><br><span class="line">                r = <span class="built_in">rand</span>(<span class="number">1</span>);</span><br><span class="line">                x_new(<span class="built_in">j</span>) = r*x_lb(<span class="built_in">j</span>)+(<span class="number">1</span>-r)*x0(<span class="built_in">j</span>);</span><br><span class="line">            <span class="keyword">elseif</span> x_new(<span class="built_in">j</span>) &gt; x_ub(<span class="built_in">j</span>)</span><br><span class="line">                r = <span class="built_in">rand</span>(<span class="number">1</span>);</span><br><span class="line">                x_new(<span class="built_in">j</span>) = r*x_ub(<span class="built_in">j</span>)+(<span class="number">1</span>-r)*x0(<span class="built_in">j</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        x1 = x_new;    <span class="comment">% 将调整后的x_new赋值给新解x1</span></span><br><span class="line">        y1 = Obj_fun1(x1);  <span class="comment">% 计算新解的函数值</span></span><br><span class="line">        <span class="keyword">if</span> y1 &gt; y0    <span class="comment">% 如果新解函数值大于当前解的函数值</span></span><br><span class="line">            x0 = x1; <span class="comment">% 更新当前解为新解</span></span><br><span class="line">            y0 = y1;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = <span class="built_in">exp</span>(-(y0 - y1)/T); <span class="comment">% 根据Metropolis准则计算一个概率</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">rand</span>(<span class="number">1</span>) &lt; p   <span class="comment">% 生成一个随机数和这个概率比较，如果该随机数小于这个概率</span></span><br><span class="line">                x0 = x1; <span class="comment">% 更新当前解为新解</span></span><br><span class="line">                y0 = y1;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="comment">% 判断是否要更新找到的最佳的解</span></span><br><span class="line">        <span class="keyword">if</span> y0 &gt; max_y  <span class="comment">% 如果当前解更好，则对其进行更新</span></span><br><span class="line">            max_y = y0;  <span class="comment">% 更新最大的y</span></span><br><span class="line">            best_x = x0;  <span class="comment">% 更新找到的最好的x</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    MAXY(iter) = max_y; <span class="comment">% 保存本轮外循环结束后找到的最大的y</span></span><br><span class="line">    T = alfa*T;   <span class="comment">% 温度下降</span></span><br><span class="line">    pause(<span class="number">0.01</span>)  <span class="comment">% 暂停一段时间(单位：秒)后再接着画图</span></span><br><span class="line">    h.XData = x0;  <span class="comment">% 更新散点图句柄的x轴的数据（此时解的位置在图上发生了变化）</span></span><br><span class="line">    h.YData = Obj_fun1(x0); <span class="comment">% 更新散点图句柄的y轴的数据（此时解的位置在图上发生了变化）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最佳的位置是：&#x27;</span>); <span class="built_in">disp</span>(best_x)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;此时最优值是：&#x27;</span>); <span class="built_in">disp</span>(max_y)</span><br><span class="line"> </span><br><span class="line">pause(<span class="number">0.5</span>)</span><br><span class="line">h.XData = [];  h.YData = [];  <span class="comment">% 将原来的散点删除</span></span><br><span class="line"><span class="built_in">scatter</span>(best_x,max_y,<span class="string">&#x27;*r&#x27;</span>);  <span class="comment">% 在最大值处重新标上散点</span></span><br><span class="line">title([<span class="string">&#x27;模拟退火找到的最大值为&#x27;</span>, num2str(max_y)])  <span class="comment">% 加上图的标题</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">%% 画出每次迭代后找到的最大y的图形</span></span><br><span class="line"><span class="built_in">figure</span></span><br><span class="line"><span class="built_in">plot</span>(<span class="number">1</span>:maxgen,MAXY,<span class="string">&#x27;b-&#x27;</span>);</span><br><span class="line">xlabel(<span class="string">&#x27;迭代次数&#x27;</span>);</span><br><span class="line">ylabel(<span class="string">&#x27;y的值&#x27;</span>);</span><br><span class="line">toc</span><br></pre></td></tr></table></figure><h3 id="旅行商问题也可以用蒙特卡罗解决"><a href="#旅行商问题也可以用蒙特卡罗解决" class="headerlink" title="旅行商问题也可以用蒙特卡罗解决"></a>旅行商问题也可以用蒙特卡罗解决</h3><h2 id="种群竞争模型"><a href="#种群竞争模型" class="headerlink" title="种群竞争模型"></a>种群竞争模型</h2><p><img src="/images/image-20240130112916180.png" alt="image-20240130112916180"></p><p><img src="/images/image-20240130112922246.png" alt="image-20240130112922246"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">clc;clear</span><br><span class="line"><span class="comment">%  Matlab求不出来解析解</span></span><br><span class="line"><span class="comment">% dsolve(&#x27;Dx1 = 0.5*x1*(1-x1/300-0.5*x2/500)&#x27;,&#x27;Dx2=0.5*x2*(1-x2/500-2*x1/300)&#x27;,&#x27;x1(0)=80,x2(0)=100&#x27;,&#x27;t&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面用ode45函数求数值解</span></span><br><span class="line"><span class="comment">% 自变量为时间t，范围为0-30； 甲乙两个种群的数量初始值为80，100（随便给的，大家可以调整来看结果的变化）</span></span><br><span class="line">[t,x]=ode45(<span class="string">&#x27;fun&#x27;</span>,[<span class="number">0</span> <span class="number">30</span>],[<span class="number">80</span> <span class="number">100</span>]); </span><br><span class="line"><span class="built_in">plot</span>(t,x(:,<span class="number">1</span>),<span class="string">&#x27;r-&#x27;</span>,t,x(:,<span class="number">2</span>),<span class="string">&#x27;b-&#x27;</span>)  <span class="comment">% x的第一列是甲种群数量，x的第二列是乙种群数量</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;种群甲&#x27;</span>,<span class="string">&#x27;种群乙&#x27;</span>)</span><br><span class="line"><span class="comment">% axis([0 30 0 500])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dx</span>=<span class="title">fun</span><span class="params">(t,x)</span>   % 大家可以修改里面的参数，来看结果的变化</span></span><br><span class="line">    r1=<span class="number">0.5</span>;  r <span class="number">2</span>=<span class="number">0.5</span>; <span class="comment">% 甲乙的增长率</span></span><br><span class="line"><span class="comment">%     r1=0.8;  r2=1; % 甲乙的增长率</span></span><br><span class="line">    N1=<span class="number">300</span>;   N2=<span class="number">500</span>;   <span class="comment">% 甲乙的最大数量</span></span><br><span class="line">    <span class="comment">% sigma1: 单位数量的乙种群(相对于N2)消耗的供养甲的食物量为单位数量的甲(相对于N1)消耗的供养甲的食物量的倍数。</span></span><br><span class="line">    <span class="comment">% sigma2: 单位数量的甲种群(相对于N1)消耗的供养乙的食物量为单位数量的乙(相对于N2)消耗的供养乙的食物量的倍数。</span></span><br><span class="line">    sigma1=<span class="number">0.5</span>;  sigma2=<span class="number">2</span>;   </span><br><span class="line"><span class="comment">%     sigma1=0.5;  sigma2=4;   </span></span><br><span class="line"><span class="comment">%     sigma1=0.4;  sigma2=0.2;</span></span><br><span class="line"><span class="comment">%   当sigma1和sigma2同时大于1时（这种现象本身在自然界就几乎不可能出现），得到的结果不稳定。</span></span><br><span class="line"><span class="comment">%     sigma1=3;  sigma2=2;   </span></span><br><span class="line"><span class="comment">%     sigma1=2.2;  sigma2=2;   </span></span><br><span class="line"></span><br><span class="line">    dx = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    dx(<span class="number">1</span>) = r1*x(<span class="number">1</span>)*(<span class="number">1</span>-x(<span class="number">1</span>)/N1-sigma1*x(<span class="number">2</span>)/N2);</span><br><span class="line">    dx(<span class="number">2</span>) = r2*x(<span class="number">2</span>)*(<span class="number">1</span>-x(<span class="number">2</span>)/N2-sigma2*x(<span class="number">1</span>)/N1);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/image-20240130113132533.png" alt="image-20240130113132533"></p><h2 id="数学规划模型"><a href="#数学规划模型" class="headerlink" title="数学规划模型"></a>数学规划模型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/images/image-20240128212145083.png" alt="image-20240128212145083"></p><p><img src="/images/image-20240128212202777.png" alt="image-20240128212202777"></p><p><img src="/images/image-20240128212217297.png" alt="image-20240128212217297"></p><p><img src="/images/image-20240128212234617.png" alt="image-20240128212234617"></p><h3 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h3><p><img src="/images/image-20240128212439349.png" alt="image-20240128212439349"></p><p><img src="/images/image-20240128212611139.png" alt="image-20240128212611139"></p><p><img src="/images/image-20240128212925755.png" alt="image-20240128212925755"></p><h4 id="代码命令解释"><a href="#代码命令解释" class="headerlink" title="代码命令解释"></a>代码命令解释</h4><p><img src="/images/image-20240128213014243.png" alt="image-20240128213014243"></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% Matlab求解线性规划</span></span><br><span class="line"><span class="comment">% [x fval] = linprog(c, A, b, Aeq, beq, lb,ub, x0)  </span></span><br><span class="line"><span class="comment">% c是目标函数的系数向量，A是不等式约束Ax&lt;=b的系数矩阵，b是不等式约束Ax&lt;=b的常数项</span></span><br><span class="line"><span class="comment">% Aeq是等式约束Aeq x=beq的系数矩阵，beq是等式约束Aeq x=beq的常数项</span></span><br><span class="line"><span class="comment">% lb是X的下限，ub是X的上限，X是向量[x1,x2,...xn]&#x27; , 即决策变量。</span></span><br><span class="line"><span class="comment">% 迭代的初始值为x0（一般不用给）</span></span><br><span class="line"><span class="comment">% 更多该函数的用法说明请看讲义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题1</span></span><br><span class="line">c = [<span class="number">-5</span> <span class="number">-4</span> <span class="number">-6</span>]&#x27;;  <span class="comment">% 加单引号表示转置</span></span><br><span class="line"><span class="comment">% c = [-5 -4 -6];  % 写成行向量也是可以的，不过不推荐，我们按照标准型来写看起来比较正规</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">-1</span> <span class="number">1</span>;</span><br><span class="line">        <span class="number">3</span> <span class="number">2</span> <span class="number">4</span>;</span><br><span class="line">        <span class="number">3</span> <span class="number">2</span> <span class="number">0</span>];</span><br><span class="line">b = [<span class="number">20</span> <span class="number">42</span> <span class="number">30</span>]&#x27;;   </span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]&#x27;; </span><br><span class="line">[x fval] = linprog(c, A, b, [], [], lb)  <span class="comment">% ub我们直接不写，则意味着没有上界的约束</span></span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">%    15.0000</span></span><br><span class="line"><span class="comment">%     3.0000</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%    -78</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题2</span></span><br><span class="line">c = [<span class="number">0.04</span> <span class="number">0.15</span> <span class="number">0.1</span> <span class="number">0.125</span>]&#x27;;  </span><br><span class="line">A = [<span class="number">-0.03</span> <span class="number">-0.3</span> <span class="number">0</span> <span class="number">-0.15</span>;</span><br><span class="line">        <span class="number">0.14</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.07</span>];</span><br><span class="line">b = [<span class="number">-32</span> <span class="number">42</span>]&#x27;;</span><br><span class="line">Aeq = [<span class="number">0.05</span> <span class="number">0</span> <span class="number">0.2</span> <span class="number">0.1</span>];</span><br><span class="line">beq = <span class="number">24</span>;</span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]&#x27;;</span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)</span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">%   106.6667</span></span><br><span class="line"><span class="comment">%   120.0000</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%     28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 这个题可能有多个解，即有多个x可以使得目标函数的最小值为28（不同的Matlab版本可能得到的x的值不同，但最后的最小值一定是28）</span></span><br><span class="line"><span class="comment">% 例如我们更改一个限定条件：令x1要大于0（注意Matlab中线性规划的标准型要求的不等式约束的符号是小于等于0）</span></span><br><span class="line"><span class="comment">% x1 &gt;0  等价于  -x1 &lt; 0，那么给定 -x1 &lt;= -0.1 (根据实际问题可以给一个略小于0的数-0.1)，这样能将小于号转换为小于等于号，满足Matlab的标准型</span></span><br><span class="line">c = [<span class="number">0.04</span> <span class="number">0.15</span> <span class="number">0.1</span> <span class="number">0.125</span>]&#x27;;  </span><br><span class="line">A = [<span class="number">-0.03</span> <span class="number">-0.3</span> <span class="number">0</span> <span class="number">-0.15</span>;</span><br><span class="line">        <span class="number">0.14</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.07</span></span><br><span class="line">        <span class="number">-1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">b = [<span class="number">-32</span> <span class="number">42</span> <span class="number">-0.1</span>]&#x27;;</span><br><span class="line">Aeq = [<span class="number">0.05</span> <span class="number">0</span> <span class="number">0.2</span> <span class="number">0.1</span>];</span><br><span class="line">beq = <span class="number">24</span>;</span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]&#x27;;</span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)</span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%     0.1000</span></span><br><span class="line"><span class="comment">%   106.6567</span></span><br><span class="line"><span class="comment">%   119.9750</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%    28.0000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题3</span></span><br><span class="line">c = [<span class="number">-2</span> <span class="number">-3</span> <span class="number">5</span>]&#x27;;</span><br><span class="line">A = [<span class="number">-2</span> <span class="number">5</span> <span class="number">-1</span>;</span><br><span class="line">          <span class="number">1</span> <span class="number">3</span> <span class="number">1</span>];</span><br><span class="line">b = [<span class="number">-10</span> <span class="number">12</span>];</span><br><span class="line">Aeq = <span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">beq = <span class="number">7</span>;</span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)</span><br><span class="line">fval = -fval <span class="comment">% 注意这个fval要取负号（原来是求最大值，我们添加负号变成了最小值问题）</span></span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%     6.4286</span></span><br><span class="line"><span class="comment">%     0.5714</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%   -14.5714</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%    14.5714</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 多个解的情况</span></span><br><span class="line"><span class="comment">% 例如 ： min z = x1 + x2   s.t.  x1 + x2 &gt;= 10</span></span><br><span class="line">c = [<span class="number">1</span> <span class="number">1</span>]&#x27;;   </span><br><span class="line">A = [<span class="number">-1</span> <span class="number">-1</span>];</span><br><span class="line">b = <span class="number">-10</span>;</span><br><span class="line">[x fval] = linprog(c, A, b)   <span class="comment">% Aeq, beq, lb和ub我们都没写，意味着没有等式约束和上下界约束</span></span><br><span class="line"><span class="comment">% x有多个解时，Matlab会给我们返回其中的一个解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 不存在解的情况</span></span><br><span class="line"><span class="comment">% 例如 ： min z = x1 + x2   s.t.  x1 + x2 = 10 、 x1 + 2*x2 &lt;= 8、 x1 &gt;=0 ，x2 &gt;=0 </span></span><br><span class="line">c = [<span class="number">1</span> <span class="number">1</span>]&#x27;; </span><br><span class="line">A = [<span class="number">1</span> <span class="number">2</span>];</span><br><span class="line">b = <span class="number">8</span>;</span><br><span class="line">Aeq = [<span class="number">1</span> <span class="number">1</span>];</span><br><span class="line">beq = <span class="number">10</span>;</span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span>]&#x27;;</span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)  <span class="comment">% Linprog stopped because no point satisfies the constraints.（没有任何一个点满足约束条件）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="线性规划的典型例题"><a href="#线性规划的典型例题" class="headerlink" title="线性规划的典型例题"></a>线性规划的典型例题</h3><p><img src="/images/image-20240128213640923.png" alt="image-20240128213640923"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 生产决策问题</span></span><br><span class="line">format long g   <span class="comment">%可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"><span class="comment">% (1) 系数向量</span></span><br><span class="line">c = <span class="built_in">zeros</span>(<span class="number">9</span>,<span class="number">1</span>); <span class="comment">% 初始化目标函数的系数向量全为0</span></span><br><span class="line">c(<span class="number">1</span>) = <span class="number">1.25</span> <span class="number">-0.25</span> <span class="number">-300</span>/<span class="number">6000</span>*<span class="number">5</span>;  <span class="comment">% x1前面的系数是c1</span></span><br><span class="line">c(<span class="number">2</span>) = <span class="number">1.25</span> <span class="number">-0.25</span> <span class="number">-321</span>/<span class="number">10000</span>*<span class="number">7</span>;</span><br><span class="line">c(<span class="number">3</span>) = <span class="number">-250</span> / <span class="number">4000</span> * <span class="number">6</span>;</span><br><span class="line">c(<span class="number">4</span>)  = <span class="number">-783</span>/<span class="number">7000</span>*<span class="number">4</span>;</span><br><span class="line">c(<span class="number">5</span>) = <span class="number">-200</span>/<span class="number">4000</span> * <span class="number">7</span>;</span><br><span class="line">c(<span class="number">6</span>) = <span class="number">-300</span>/<span class="number">6000</span>*<span class="number">10</span>;</span><br><span class="line">c(<span class="number">7</span>) = <span class="number">-321</span> / <span class="number">10000</span> * <span class="number">9</span>;</span><br><span class="line">c(<span class="number">8</span>) = <span class="number">2</span><span class="number">-0.35</span><span class="number">-250</span>/<span class="number">4000</span>*<span class="number">8</span>;</span><br><span class="line">c(<span class="number">9</span>) = <span class="number">2.8</span><span class="number">-0.5</span><span class="number">-321</span>/<span class="number">10000</span>*<span class="number">12</span><span class="number">-783</span>/<span class="number">7000</span>*<span class="number">11</span>;</span><br><span class="line">c = -c;  <span class="comment">% 我们求的是最大值，所以这里需要改变符号</span></span><br><span class="line"><span class="comment">% (2) 不等式约束</span></span><br><span class="line">A = <span class="built_in">zeros</span>(<span class="number">5</span>,<span class="number">9</span>);</span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">5</span>;  A(<span class="number">1</span>,<span class="number">6</span>) = <span class="number">10</span>;</span><br><span class="line">A(<span class="number">2</span>,<span class="number">2</span>) = <span class="number">7</span>;  A(<span class="number">2</span>,<span class="number">7</span>) = <span class="number">9</span>; A(<span class="number">2</span>,<span class="number">9</span>) = <span class="number">12</span>;</span><br><span class="line">A(<span class="number">3</span>,<span class="number">3</span>) = <span class="number">6</span>;  A(<span class="number">3</span>,<span class="number">8</span>) = <span class="number">8</span>;</span><br><span class="line">A(<span class="number">4</span>,<span class="number">4</span>) = <span class="number">4</span>;  A(<span class="number">4</span>,<span class="number">9</span>) = <span class="number">11</span>;</span><br><span class="line">A(<span class="number">5</span>,<span class="number">5</span>) = <span class="number">7</span>;  </span><br><span class="line">b = [<span class="number">6000</span> <span class="number">10000</span> <span class="number">4000</span> <span class="number">7000</span> <span class="number">4000</span>]&#x27;;</span><br><span class="line"><span class="comment">% (3) 等式约束</span></span><br><span class="line">Aeq = [<span class="number">1</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">            <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">0</span>];</span><br><span class="line">beq = [<span class="number">0</span> <span class="number">0</span>]&#x27;;</span><br><span class="line"><span class="comment">%（4）上下界</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">9</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 进行求解</span></span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)</span><br><span class="line">fval = -fval</span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%           1146.56650246305</span></span><br><span class="line"><span class="comment">%  注意，本题应该是一个整数规划的例子，我们在后面的整数规划部分再来重新求解。</span></span><br><span class="line">intcon = <span class="number">1</span>:<span class="number">9</span>;</span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,Aeq,beq,lb)</span><br><span class="line">fval = -fval</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h3><p><img src="/images/image-20240128214116824.png" alt="image-20240128214116824"></p><p><img src="/images/image-20240128214417024.png" alt="image-20240128214417024"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 线性整数规划问题</span></span><br><span class="line"><span class="comment">%% 例1</span></span><br><span class="line">c=[<span class="number">-20</span>,<span class="number">-10</span>]&#x27;;</span><br><span class="line">intcon=[<span class="number">1</span>,<span class="number">2</span>];  <span class="comment">% x1和x2限定为整数</span></span><br><span class="line">A=[<span class="number">5</span>,<span class="number">4</span>;</span><br><span class="line">      <span class="number">2</span>,<span class="number">5</span>];</span><br><span class="line">b=[<span class="number">24</span>;<span class="number">13</span>];</span><br><span class="line">lb=<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);  </span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,[],[],lb)</span><br><span class="line">fval = -fval</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例2</span></span><br><span class="line">c=[<span class="number">18</span>,<span class="number">23</span>,<span class="number">5</span>]&#x27;;</span><br><span class="line">intcon=<span class="number">3</span>;  <span class="comment">% x3限定为整数</span></span><br><span class="line">A=[<span class="number">107</span>,<span class="number">500</span>,<span class="number">0</span>;</span><br><span class="line">      <span class="number">72</span>,<span class="number">121</span>,<span class="number">65</span>;</span><br><span class="line">      <span class="number">-107</span>,<span class="number">-500</span>,<span class="number">0</span>;</span><br><span class="line">      <span class="number">-72</span>,<span class="number">-121</span>,<span class="number">-65</span>];</span><br><span class="line">b=[<span class="number">50000</span>;<span class="number">2250</span>;<span class="number">-500</span>;<span class="number">-2000</span>];</span><br><span class="line">lb=<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,[],[],lb)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例3</span></span><br><span class="line">c=[<span class="number">-3</span>;<span class="number">-2</span>;<span class="number">-1</span>]; intcon=<span class="number">3</span>; <span class="comment">% x3限定为整数</span></span><br><span class="line">A=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">3</span>); b=<span class="number">7</span>;</span><br><span class="line">Aeq=[<span class="number">4</span> <span class="number">2</span> <span class="number">1</span>]; beq=<span class="number">12</span>;</span><br><span class="line">lb=<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>); ub=[+<span class="built_in">inf</span>;+<span class="built_in">inf</span>;<span class="number">1</span>]; <span class="comment">%x(3)为0-1变量</span></span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,Aeq,beq,lb,ub)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h3><p><img src="/images/image-20240128214732168.png" alt="image-20240128214732168"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 背包问题（货车运送货物的问题）</span></span><br><span class="line">c = -[<span class="number">540</span> <span class="number">200</span> <span class="number">180</span> <span class="number">350</span> <span class="number">60</span> <span class="number">150</span> <span class="number">280</span> <span class="number">450</span> <span class="number">320</span> <span class="number">120</span>];  <span class="comment">% 目标函数的系数矩阵(最大化问题记得加负号)</span></span><br><span class="line">intcon=[<span class="number">1</span>:<span class="number">10</span>];  <span class="comment">% 整数变量的位置(一共10个决策变量，均为0-1整数变量)</span></span><br><span class="line">A = [<span class="number">6</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span>];  b = <span class="number">30</span>;   <span class="comment">% 线性不等式约束的系数矩阵和常数项向量（物品的重量不能超过30）</span></span><br><span class="line">Aeq = []; beq =[];  <span class="comment">% 不存在线性等式约束</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">10</span>,<span class="number">1</span>);  <span class="comment">% 约束变量的范围下限</span></span><br><span class="line">ub = <span class="built_in">ones</span>(<span class="number">10</span>,<span class="number">1</span>);  <span class="comment">% 约束变量的范围上限</span></span><br><span class="line"><span class="comment">%最后调用intlinprog()函数</span></span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,Aeq,beq,lb,ub)</span><br><span class="line">fval = -fval</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="指派问题"><a href="#指派问题" class="headerlink" title="指派问题"></a>指派问题</h3><p><img src="/images/image-20240128215024353.png" alt="image-20240128215024353"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 指派问题（选择队员去进行游泳接力比赛）</span></span><br><span class="line">clear;clc</span><br><span class="line">c = [<span class="number">66.8</span> <span class="number">75.6</span> <span class="number">87</span> <span class="number">58.6</span> <span class="number">57.2</span> <span class="number">66</span> <span class="number">66.4</span> <span class="number">53</span> <span class="number">78</span> <span class="number">67.8</span> <span class="number">84.6</span> <span class="number">59.4</span> <span class="number">70</span> <span class="number">74.2</span> <span class="number">69.6</span> <span class="number">57.2</span> <span class="number">67.4</span> <span class="number">71</span> <span class="number">83.8</span> <span class="number">62.4</span>]&#x27;;  <span class="comment">% 目标函数的系数矩阵（先列后行的写法）</span></span><br><span class="line">intcon = [<span class="number">1</span>:<span class="number">20</span>];  <span class="comment">% 整数变量的位置(一共20个决策变量，均为0-1整数变量)</span></span><br><span class="line"><span class="comment">% 线性不等式约束的系数矩阵和常数项向量（每个人只能入选四种泳姿之一，一共五个约束）</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">       <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">       <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">       <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">       <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% A = zeros(5,20);</span></span><br><span class="line"><span class="comment">% for i = 1:5</span></span><br><span class="line"><span class="comment">%     A(i, (4*i-3): 4*i) = 1;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line">b = [<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>];</span><br><span class="line"><span class="comment">% 线性等式约束的系数矩阵和常数项向量 （每种泳姿有且仅有一人参加，一共四个约束）</span></span><br><span class="line">Aeq = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">          <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">          <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>;</span><br><span class="line">          <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% Aeq = [eye(4),eye(4),eye(4),eye(4),eye(4)];  % 或者写成 repmat(eye(4),1,5)  </span></span><br><span class="line">beq = [<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>];</span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">20</span>,<span class="number">1</span>);  <span class="comment">% 约束变量的范围下限</span></span><br><span class="line">ub = <span class="built_in">ones</span>(<span class="number">20</span>,<span class="number">1</span>);  <span class="comment">% 约束变量的范围上限</span></span><br><span class="line"><span class="comment">%最后调用intlinprog()函数</span></span><br><span class="line">[x,fval] = intlinprog(c,intcon,A,b,Aeq,beq,lb,ub)</span><br><span class="line"><span class="comment">% reshape(x,4,5)&#x27;</span></span><br><span class="line"><span class="comment">%      0     0     0     1    甲自由泳</span></span><br><span class="line"><span class="comment">%      1     0     0     0    乙蝶泳</span></span><br><span class="line"><span class="comment">%      0     1     0     0    丙仰泳</span></span><br><span class="line"><span class="comment">%      0     0     1     0    丁蛙泳</span></span><br><span class="line"><span class="comment">%      0     0     0     0    戊不参加</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="钢管切割问题"><a href="#钢管切割问题" class="headerlink" title="钢管切割问题"></a>钢管切割问题</h3><p><img src="/images/image-20240128215414471.png" alt="image-20240128215414471"></p><p><img src="/images/image-20240128215510504.png" alt="image-20240128215510504"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 钢管切割问题</span></span><br><span class="line"><span class="comment">%% (1)枚举法找出同一个原材料上所有的切割方法</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">0</span>: <span class="number">2</span>  <span class="comment">% 2.9m长的圆钢的数量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">0</span>: <span class="number">3</span>  <span class="comment">% 2.1m长的圆钢的数量</span></span><br><span class="line">        <span class="keyword">for</span> k = <span class="number">0</span>:<span class="number">6</span>   <span class="comment">% 1m长的圆钢的数量</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">2.9</span>*<span class="built_in">i</span>+<span class="number">2.1</span>*<span class="built_in">j</span>+<span class="number">1</span>*k &gt;= <span class="number">6</span> &amp;&amp; <span class="number">2.9</span>*<span class="built_in">i</span>+<span class="number">2.1</span>*<span class="built_in">j</span>+<span class="number">1</span>*k &lt;= <span class="number">6.9</span></span><br><span class="line">                <span class="built_in">disp</span>([<span class="built_in">i</span>, <span class="built_in">j</span>, k])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 有同学使用比较老的MATLAB版本，会出现浮点数计算的误差</span></span><br><span class="line"><span class="comment">% 只需要将上面的if这一行进行适当的放缩即可。</span></span><br><span class="line"><span class="comment">% if 2.9*i+2.1*j+1*k &gt;= 6-0.0000001 &amp;&amp; 2.9*i+2.1*j+1*k &lt;= 6.9+0.0000001</span></span><br><span class="line"><span class="comment">% 有兴趣的同学可以百度下：浮点数计算误差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% (2) 线性整数规划问题的求解</span></span><br><span class="line">c = <span class="built_in">ones</span>(<span class="number">7</span>,<span class="number">1</span>);  <span class="comment">% 目标函数的系数矩阵</span></span><br><span class="line">intcon=[<span class="number">1</span>:<span class="number">7</span>];  <span class="comment">%  整数变量的位置(一共7个决策变量，均为整数变量)</span></span><br><span class="line">A = -[<span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>;  </span><br><span class="line">         <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;</span><br><span class="line">         <span class="number">4</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">1</span>];  <span class="comment">% 线性不等式约束的系数矩阵</span></span><br><span class="line">b = -[<span class="number">100</span> <span class="number">100</span> <span class="number">100</span>]&#x27;; <span class="comment">%  线性不等式约束的常数项向量</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">7</span>,<span class="number">1</span>); <span class="comment">% 约束变量的范围下限</span></span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,[],[],lb)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="非线性问题的求解"><a href="#非线性问题的求解" class="headerlink" title="非线性问题的求解"></a>非线性问题的求解</h3><p><img src="/images/image-20240128215640424.png" alt="image-20240128215640424"></p><p><img src="/images/image-20240128215838554.png" alt="image-20240128215838554"></p><p><img src="/images/image-20240128220006524.png" alt="image-20240128220006524"></p><h3 id="代码求解"><a href="#代码求解" class="headerlink" title="代码求解"></a>代码求解</h3><blockquote><p>可以先给定不同初始值，在里面找到最优解</p><p>也可以蒙特卡罗模拟找到一个蒙特卡罗解，再作为初始值进行求解。</p><p>min最小值</p><p>f函数</p><p>con约束</p><p>X0是一个初始值，线性规划里边初始值对于结果没影响，而非线性规划中x0的选取很关键，因为求出的是一个局部最优解。</p></blockquote><p><img src="/images/image-20240128221553606.png" alt="image-20240128221553606"></p><p>求解的方法有四种，可以提高结果的稳健性能。 </p><p><img src="/images/image-20240128221841171.png" alt="image-20240128221841171"></p><h3 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h3><p>如果考察了，建议蒙特卡洛加上四种方法一起用，这样就稳啦</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 非线性规划的函数</span></span><br><span class="line"><span class="comment">% [x,fval] = fmincon(@fun,x0,A,b,Aeq,beq,lb,ub,@nonlfun,option)</span></span><br><span class="line"><span class="comment">% x0表示给定的初始值（用行向量或者列向量表示），必须得写</span></span><br><span class="line"><span class="comment">% A b表示线性不等式约束</span></span><br><span class="line"><span class="comment">% Aeq beq 表示线性等式约束</span></span><br><span class="line"><span class="comment">% lb ub 表示上下界约束</span></span><br><span class="line"><span class="comment">% @fun表示目标函数</span></span><br><span class="line"><span class="comment">% @nonlfun表示非线性约束的函数</span></span><br><span class="line"><span class="comment">% option 表示求解非线性规划使用的方法</span></span><br><span class="line">clear;clc</span><br><span class="line">format long g   <span class="comment">%可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题1的求解</span></span><br><span class="line"><span class="comment">% max f(x) = x1^2 +x2^2 -x1*x2 -2x1 -5x2</span></span><br><span class="line"><span class="comment">% s.t. -(x1-1)^2 +x2 &gt;= 0 ;  2x1-3x2+6 &gt;= 0</span></span><br><span class="line">x0 = [<span class="number">0</span> <span class="number">0</span>];  <span class="comment">%任意给定一个初始值 </span></span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1)  <span class="comment">% 注意 fun1.m文件和nonlfun1.m文件都必须在当前文件夹目录下</span></span><br><span class="line">fval = -fval</span><br><span class="line"><span class="comment">% 一个值得讨论的地方，能不能把线性不等式约束Ax &lt;= b也写到nonlfun1函数中？</span></span><br><span class="line"><span class="comment">% 先把nonlfun1中的c改为下面这样：</span></span><br><span class="line"><span class="comment">% c = [(x(1)-1)^2-x(2); </span></span><br><span class="line"><span class="comment">%        -2*x(1)+3*x(2)-6];</span></span><br><span class="line"><span class="comment">%  [x,fval] = fmincon(@fun1,x0,[],[],[],[],[],[],@nonlfun1)</span></span><br><span class="line"><span class="comment">% 结果也是可以计算出来的，但并不推荐这样做~</span></span><br><span class="line"></span><br><span class="line">目标函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun1</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">% 注意：这里的f实际上就是目标函数，函数的返回值也是f</span></span><br><span class="line">    <span class="comment">% 输入值x实际上就是决策变量，由x1和x2组成的向量</span></span><br><span class="line">    <span class="comment">% fun1是函数名称，到时候会被fmincon函数调用, 可以任意取名</span></span><br><span class="line">    <span class="comment">% 保存的m文件和函数名称得一致，也要为fun1.m</span></span><br><span class="line"><span class="comment">%      max  f(x) = x1^2 +x2^2 -x1*x2 -2x1 -5x2</span></span><br><span class="line">    f = -x(<span class="number">1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)^<span class="number">2</span> +x(<span class="number">1</span>)*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>) ; </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">这是非线性约束</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[c,ceq]</span> = <span class="title">nonlfun1</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">% 注意：这里的c实际上就是非线性不等式约束，ceq实际上就是非线性等式约束</span></span><br><span class="line">    <span class="comment">% 输入值x实际上就是决策变量，由x1和x2组成的一个向量</span></span><br><span class="line">    <span class="comment">% 返回值有两个，一个是非线性不等式约束c，一个是非线性等式约束ceq</span></span><br><span class="line">    <span class="comment">% nonlfun1是函数名称，到时候会被fmincon函数调用, 可以任意取名，但不能和目标函数fun1重名</span></span><br><span class="line">    <span class="comment">% 保存的m文件和函数名称得一致，也要为nonlfun1.m</span></span><br><span class="line"><span class="comment">%     -(x1-1)^2 +x2 &gt;= 0 </span></span><br><span class="line">   c = [(x(<span class="number">1</span>)<span class="number">-1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)];   <span class="comment">% 千万別写成了: (x1-1)^2 -x2</span></span><br><span class="line">   ceq = [];  <span class="comment">% 不存在非线性等式约束，所以用[]表示</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 使用其他算法对例题1求解</span></span><br><span class="line"><span class="comment">% edit fmincon  % 查看fmincon的“源代码”</span></span><br><span class="line"><span class="comment">% Matlab2017a默认使用的算法是&#x27;interior-point&#x27; 内点法</span></span><br><span class="line"><span class="comment">% 使用interior point算法 （内点法）</span></span><br><span class="line">option = optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;interior-point&#x27;</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval</span><br><span class="line"><span class="comment">% 使用SQP算法 （序列二次规划法）</span></span><br><span class="line">option = optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;sqp&#x27;</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval   <span class="comment">%得到-4.358，远远大于内点法得到的-1,猜想是初始值的影响</span></span><br><span class="line"><span class="comment">% 改变初始值试试</span></span><br><span class="line">x0 = [<span class="number">1</span> <span class="number">1</span>];  <span class="comment">%任意给定一个初始值 </span></span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  <span class="comment">% 最小值为-1，和内点法相同（这说明内点法的适应性要好）</span></span><br><span class="line">fval = -fval  </span><br><span class="line"><span class="comment">% 使用active set算法 （有效集法）</span></span><br><span class="line">option = optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;active-set&#x27;</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)</span><br><span class="line">fval = -fval  </span><br><span class="line"><span class="comment">% 使用trust region reflective (信赖域反射算法)</span></span><br><span class="line">option = optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;trust-region-reflective&#x27;</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval  </span><br><span class="line"><span class="comment">% this algorithm does not solve problems with the constraints you have specified. </span></span><br><span class="line"><span class="comment">% 这说明这个算法不适用我们这个约束条件，所以以后遇到了不能求解的情况，记得更换其他算法试试！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 选取初始值得到的结果可能会不满足限定条件，出现了一个Bug 因此选择的初始值很重要</span></span><br><span class="line">x0 = [<span class="number">40.8</span>, <span class="number">10.8</span>];</span><br><span class="line">option = optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;interior-point&#x27;</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval  </span><br><span class="line"><span class="comment">% https://cn.mathworks.com/help/optim/ug/fmincon.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 生成不同的随机初始值来优化代码，有一定几率会触发上面那个Bug，因此不推荐</span></span><br><span class="line">n = <span class="number">10</span>;  <span class="comment">% 重复n次</span></span><br><span class="line">Fval = +<span class="built_in">inf</span>; X = [<span class="number">0</span>,<span class="number">0</span>];  <span class="comment">%初始化最优的结果</span></span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    x0 = [<span class="built_in">rand</span>()*<span class="number">10</span> , <span class="built_in">rand</span>()*<span class="number">10</span>];  <span class="comment">%用随机数生成一个初始值（随机数的范围自己根据题目条件设置） </span></span><br><span class="line">    [x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option); <span class="comment">% 注意 fun1.m文件和nonlfun1.m文件都必须在当前文件夹目录下</span></span><br><span class="line">    <span class="keyword">if</span> fval &lt; Fval  <span class="comment">% 如果找到了更小的值，那么就代替最优的结果</span></span><br><span class="line">        Fval = fval;</span><br><span class="line">        X = x;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Fval = -Fval</span><br><span class="line">X</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 使用蒙特卡罗的方法来找初始值(推荐）</span></span><br><span class="line">clc,clear;</span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">-100</span>,<span class="number">100</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[-100,100]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2=unifrnd(<span class="number">-100</span>,<span class="number">100</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[-100,100]之间均匀分布的随机数组成的n行1列的向量构成x2</span></span><br><span class="line">fmin=+<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最小值为正无穷（后续只要找到一个比它小的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2]</span></span><br><span class="line">    <span class="keyword">if</span> ((x(<span class="number">1</span>)<span class="number">-1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)&lt;=<span class="number">0</span>)  &amp; (<span class="number">-2</span>*x(<span class="number">1</span>)+<span class="number">3</span>*x(<span class="number">2</span>)<span class="number">-6</span> &lt;= <span class="number">0</span>)     <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result = -x(<span class="number">1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)^<span class="number">2</span> +x(<span class="number">1</span>)*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>) ;  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &lt; fmin  <span class="comment">% 如果这个函数值小于我们之前计算出来的最小值</span></span><br><span class="line">            fmin = result;  <span class="comment">% 那么就更新这个函数值为新的最小值</span></span><br><span class="line">            x0 = x;  <span class="comment">% 并且将此时的x1 x2更新为初始值</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;蒙特卡罗选取的初始值为：&#x27;</span>); <span class="built_in">disp</span>(x0)</span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1)</span><br><span class="line">fval = -fval  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 例题二的求解</span></span><br><span class="line">x0 = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];  <span class="comment">%任意给定一个初始值 </span></span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];  <span class="comment">% 决策变量的下界</span></span><br><span class="line">[x,fval] = fmincon(@fun2,x0,[],[],[],[],lb,[],@nonlfun2)  <span class="comment">% 注意 fun2.m文件和nonfun2.m文件都必须在当前文件夹目录下</span></span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%          0.552167405729277          1.20325915507969         0.947824046150443</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%           10.6510918606939</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 使用蒙特卡罗的方法来找初始值(推荐）</span></span><br><span class="line">clc,clear;</span><br><span class="line">n=<span class="number">1000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1= unifrnd(<span class="number">0</span>,<span class="number">2</span>,n,<span class="number">1</span>);   <span class="comment">% 生成在[0,2]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2 = <span class="built_in">sqrt</span>(<span class="number">2</span>-x1);  <span class="comment">% 根据非线性等式约束用x1计算出x2</span></span><br><span class="line">x3 = <span class="built_in">sqrt</span>((<span class="number">3</span>-x2)/<span class="number">2</span>); <span class="comment">% 根据非线性等式约束用x2计算出x3</span></span><br><span class="line">fmin=+<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最小值为正无穷（后续只要找到一个比它小的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>), x3(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2, x3]</span></span><br><span class="line">    <span class="keyword">if</span> (-x(<span class="number">1</span>)^<span class="number">2</span>+x(<span class="number">2</span>)-x(<span class="number">3</span>)^<span class="number">2</span>&lt;=<span class="number">0</span>) &amp; (x(<span class="number">1</span>)+x(<span class="number">2</span>)^<span class="number">2</span>+x(<span class="number">3</span>)^<span class="number">2</span><span class="number">-20</span>&lt;=<span class="number">0</span>)   <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result =sum(x.*x) + <span class="number">8</span> ;  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &lt; fmin  <span class="comment">% 如果这个函数值小于我们之前计算出来的最小值</span></span><br><span class="line">            fmin = result;  <span class="comment">% 那么就更新这个函数值为新的最小值</span></span><br><span class="line">            x0 = x;  <span class="comment">% 并且将此时的x1 x2 x3更新为初始值</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;蒙特卡罗选取的初始值为：&#x27;</span>); <span class="built_in">disp</span>(x0)</span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];  <span class="comment">% 决策变量的下界</span></span><br><span class="line">[x,fval] = fmincon(@fun2,x0,[],[],[],[],lb,[],@nonlfun2)  <span class="comment">% 注意 fun2.m文件和nonfun2.m文件都必须在当前文件夹目录下</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun2</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">%     f = x(1)^2+x(2)^2 +x(3)^2+8 ; </span></span><br><span class="line">    f = sum(x.*x) + <span class="number">8</span>;  <span class="comment">% 可别忘了x实际上是一个向量，我们可以使用矩阵的运算符号对其计算</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 例题三的求解(蒙特卡罗模拟那一讲的例题)</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="comment">% 蒙特卡罗模拟得到的最大值为3445.6014</span></span><br><span class="line"><span class="comment">% 最大值处x1 x2 x3的取值为：</span></span><br><span class="line"><span class="comment">%           22.5823101903968          12.5823101903968          12.1265223966757</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">-2</span> <span class="number">-2</span>;  <span class="number">1</span> <span class="number">2</span> <span class="number">2</span>];  b = [<span class="number">0</span> <span class="number">72</span>];</span><br><span class="line">x0 = [ <span class="number">22.58</span>   <span class="number">12.58</span>  <span class="number">12.13</span>];</span><br><span class="line">Aeq = [<span class="number">1</span> <span class="number">-1</span> <span class="number">0</span>]; beq = <span class="number">10</span>;</span><br><span class="line">lb = [-<span class="built_in">inf</span> <span class="number">10</span> -<span class="built_in">inf</span>];  ub = [<span class="built_in">inf</span> <span class="number">20</span> <span class="built_in">inf</span>];  </span><br><span class="line">[x,fval] = fmincon(@fun3,x0,A,b,Aeq,beq,lb,ub,[])  <span class="comment">% 注意没有非线性约束，所以这里可以用[]替代，或者干脆不写</span></span><br><span class="line">fval = -fval</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun3</span><span class="params">(x)</span></span></span><br><span class="line">    f = -prod(x);  <span class="comment">% 可别忘了x实际上是一个向量（prod表示连乘符号，用法和sum类似）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="选址问题"><a href="#选址问题" class="headerlink" title="选址问题"></a>选址问题</h3><blockquote><p>背景</p></blockquote><p><img src="/images/image-20240129110524287-1706585735308-9.png" alt="image-20240129110524287"></p><p><img src="/images/image-20240129110713468-1706585735308-10.png" alt="image-20240129110713468"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 选址问题</span></span><br><span class="line">clear;clc</span><br><span class="line">format long g   <span class="comment">%可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"><span class="comment">% % (1) 系数向量（原来线性规划问题的写法,我们只需要在此基础上改动一点就可以了）</span></span><br><span class="line"><span class="comment">% a=[1.25  8.75  0.5  5.75  3  7.25];  % 工地的横坐标</span></span><br><span class="line"><span class="comment">% b=[1.25  0.75  4.755  6.5  7.25];   % 工地的纵坐标</span></span><br><span class="line"><span class="comment">% x = [5  2];  % 料场的横坐标</span></span><br><span class="line"><span class="comment">% y = [1  7];  % 料场的纵坐标</span></span><br><span class="line"><span class="comment">% c = [];  % 初始化用来保存工地和料场距离的向量 (这个向量就是我们的系数向量）</span></span><br><span class="line"><span class="comment">% for  j =1:2</span></span><br><span class="line"><span class="comment">%     for i = 1:6</span></span><br><span class="line"><span class="comment">%         c = [c;  sqrt( (a(i)-x(j))^2 + (b(i)-y(j))^2)];  % 每循环一次就在c的末尾插入新的元素</span></span><br><span class="line"><span class="comment">%     end</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% (2) 不等式约束</span></span><br><span class="line">A =<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">16</span>);  <span class="comment">% 注意这里要改成16</span></span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>:<span class="number">6</span>) = <span class="number">1</span>;</span><br><span class="line">A(<span class="number">2</span>,<span class="number">7</span>:<span class="number">12</span>) = <span class="number">1</span>;</span><br><span class="line">b = [<span class="number">20</span>,<span class="number">20</span>]&#x27;;</span><br><span class="line"><span class="comment">% (3) 等式约束</span></span><br><span class="line">Aeq = <span class="built_in">zeros</span>(<span class="number">6</span>,<span class="number">16</span>);  <span class="comment">% 注意这里要改成16</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">6</span></span><br><span class="line">    Aeq(<span class="built_in">i</span>,<span class="built_in">i</span>) = <span class="number">1</span>;  Aeq(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">6</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">beq = [<span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span> <span class="number">11</span>]&#x27;;  <span class="comment">% 每个工地的日需求量</span></span><br><span class="line"><span class="comment">%（4）上下界</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">16</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% lb = [zeros(12,1); -inf*ones(4,1)];  两个新料场坐标的下界可以设为-inf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 进行求解</span></span><br><span class="line"><span class="comment">% 注意哦，这里我们只尝试了这一个初始值，大家可以试试其他的初始值，有可能能够找到更好的解。</span></span><br><span class="line"><span class="comment">% 未来我会在遗传算法中再来看这个例题。</span></span><br><span class="line">x0 = [<span class="number">3</span> <span class="number">5</span> <span class="number">0</span> <span class="number">7</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">6</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">7</span>];  <span class="comment">% 用第一问的结果作为初始值</span></span><br><span class="line">[x,fval] = fmincon(@fun5,x0,A,b,Aeq,beq,lb)  <span class="comment">% 注意没有非线性约束，所以这里可以用[]替代，或者干脆不写</span></span><br><span class="line"><span class="built_in">reshape</span>(x(<span class="number">1</span>:<span class="number">12</span>),<span class="number">6</span>,<span class="number">2</span>)  <span class="comment">% 将x的前12个元素变为6行2列便于观察（reshape函数是按照列的顺序进行转换的，也就是第一列读完，读第二列，即x1对应x_1,1，x2对应x_2,1）</span></span><br><span class="line"><span class="comment">% 新坐标（5.74，4.99） （7.25，7.25）</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%           89.9231692432933</span></span><br><span class="line"><span class="comment">% 第一问的fval =</span></span><br><span class="line"><span class="comment">%           135.281541790676</span></span><br><span class="line"><span class="number">135.281541790676</span> - <span class="number">89.9231692432933</span>  <span class="comment">%  45.3583725473827</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun5</span><span class="params">(xx)</span>  % 注意为了避免和下面的<span class="title">x</span>同号，我们把决策变量的向量符号用<span class="title">xx</span>表示（注意<span class="title">xx</span>的长度为16）</span></span><br><span class="line">    a=[<span class="number">1.25</span>  <span class="number">8.75</span>  <span class="number">0.5</span>  <span class="number">5.75</span>  <span class="number">3</span>  <span class="number">7.25</span>];  <span class="comment">% 工地的横坐标</span></span><br><span class="line">    b=[<span class="number">1.25</span>  <span class="number">0.75</span>  <span class="number">4.75</span><span class="number">5</span>  <span class="number">6.5</span>  <span class="number">7.25</span>];   <span class="comment">% 工地的纵坐标</span></span><br><span class="line">    x = [xx(<span class="number">13</span>)  xx(<span class="number">15</span>)];  <span class="comment">% 新料场的横坐标</span></span><br><span class="line">    y = [xx(<span class="number">14</span>)  xx(<span class="number">16</span>)];  <span class="comment">% 新料场的纵坐标</span></span><br><span class="line">    c = [];  <span class="comment">% 初始化用来保存工地和料场距离的向量 (这个向量就是我们的系数向量）</span></span><br><span class="line">    <span class="keyword">for</span>  <span class="built_in">j</span> =<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">6</span></span><br><span class="line">            c = [c;  <span class="built_in">sqrt</span>( (a(<span class="built_in">i</span>)-x(<span class="built_in">j</span>))^<span class="number">2</span> + (b(<span class="built_in">i</span>)-y(<span class="built_in">j</span>))^<span class="number">2</span>)];  <span class="comment">% 每循环一次就在c的末尾插入新的元素</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 下面我们要求吨千米数，注意c是列向量，我们计算非线性规划时给定的初始值x0是行向量</span></span><br><span class="line">    f = xx(<span class="number">1</span>:<span class="number">12</span>) * c;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="最大最小化模型"><a href="#最大最小化模型" class="headerlink" title="最大最小化模型"></a>最大最小化模型</h3><p><img src="/images/image-20240129005314765.png" alt="image-20240129005314765"></p><h4 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h4><p><img src="/images/image-20240129005430279.png" alt="image-20240129005430279"></p><h3 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h3><p><img src="/images/image-20240129005556115.png" alt="image-20240129005556115"> </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 最大最小化模型  :   min&#123;max[f1,f2,···,fm]&#125;</span></span><br><span class="line">x0 = [<span class="number">6</span>, <span class="number">6</span>];      <span class="comment">% 给定初始值</span></span><br><span class="line">lb = [<span class="number">3</span>, <span class="number">4</span>];  <span class="comment">% 决策变量的下界</span></span><br><span class="line">ub = [<span class="number">8</span>, <span class="number">10</span>];  <span class="comment">% 决策变量的上界</span></span><br><span class="line">[x,feval] = fminimax(@Fun,x0,[],[],[],[],lb,ub)</span><br><span class="line"><span class="built_in">max</span>(feval)</span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%     8.0000    8.5000</span></span><br><span class="line"><span class="comment">% feval =</span></span><br><span class="line"><span class="comment">%    13.5000    5.5000    5.5000   12.5000    8.5000    8.5000    5.5000   13.5000    9.5000    0.5000</span></span><br><span class="line"><span class="comment">% 结论：</span></span><br><span class="line"><span class="comment">% 在坐标为(8,8.5)处建立供应中心可以使该点到各需求点的最大距离最小，最小的最大距离为13.5单位。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">Fun</span><span class="params">(x)</span></span></span><br><span class="line">    a=[<span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">12</span> <span class="number">6</span> <span class="number">20</span> <span class="number">17</span> <span class="number">8</span>];</span><br><span class="line">    b=[<span class="number">2</span> <span class="number">10</span> <span class="number">8</span> <span class="number">18</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">10</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">    <span class="comment">%  函数向量</span></span><br><span class="line">    f=<span class="built_in">zeros</span>(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">        f(<span class="built_in">i</span>) = <span class="built_in">abs</span>(x(<span class="number">1</span>)-a(<span class="built_in">i</span>))+<span class="built_in">abs</span>(x(<span class="number">2</span>)-b(<span class="built_in">i</span>));  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">% f(1) = abs(x(1)-a(1))+abs(x(2)-b(1));  </span></span><br><span class="line"><span class="comment">% f(2) = abs(x(1)-a(2))+abs(x(2)-b(2));</span></span><br><span class="line"><span class="comment">% f(3) = abs(x(1)-a(3))+abs(x(2)-b(3));</span></span><br><span class="line"><span class="comment">% f(4) = abs(x(1)-a(4))+abs(x(2)-b(4));</span></span><br><span class="line"><span class="comment">% f(5) = abs(x(1)-a(5))+abs(x(2)-b(5));</span></span><br><span class="line"><span class="comment">% f(6) = abs(x(1)-a(6))+abs(x(2)-b(6));</span></span><br><span class="line"><span class="comment">% f(7) = abs(x(1)-a(7))+abs(x(2)-b(7));</span></span><br><span class="line"><span class="comment">% f(8) = abs(x(1)-a(8))+abs(x(2)-b(8));</span></span><br><span class="line"><span class="comment">% f(9) = abs(x(1)-a(9))+abs(x(2)-b(9));</span></span><br><span class="line"><span class="comment">% f(10) = abs(x(1)-a(10))+abs(x(2)-b(10));</span></span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="多目标规划问题"><a href="#多目标规划问题" class="headerlink" title="多目标规划问题"></a>多目标规划问题</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p><img src="/images/image-20240129010114001.png" alt="image-20240129010114001"></p><p>可能标准化，正向化，还有权重</p><h4 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h4><p><img src="/images/image-20240129010157820.png" alt="image-20240129010157820"></p><p><img src="/images/image-20240129010334935.png" alt="image-20240129010334935"></p><p><img src="/images/image-20240129010535787.png" alt="image-20240129010535787"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  多目标规划问题</span></span><br><span class="line">w1 = <span class="number">0.4</span>;  w2 = <span class="number">0.6</span>;  <span class="comment">% 两个目标函数的权重  x1 = 5  x2 = 2</span></span><br><span class="line">w1 = <span class="number">0.5</span>;  w2 = <span class="number">0.5</span>;  <span class="comment">% 两个目标函数的权重  x1 = 5  x2 = 2</span></span><br><span class="line">w1 = <span class="number">0.3</span>;  w2 = <span class="number">0.7</span>;  <span class="comment">% 两个目标函数的权重  x1 = 1  x2 = 6</span></span><br><span class="line">c = [w1/<span class="number">30</span>*<span class="number">2</span>+w2/<span class="number">2</span>*<span class="number">0.4</span> ;w1/<span class="number">30</span>*<span class="number">5</span>+w2/<span class="number">2</span>*<span class="number">0.3</span>];  <span class="comment">% 线性规划目标函数的系数</span></span><br><span class="line">A = [<span class="number">-1</span> <span class="number">-1</span>];  b = <span class="number">-7</span>; <span class="comment">% 不等式约束</span></span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span>]&#x27;; ub = [<span class="number">5</span> <span class="number">6</span>]&#x27;; <span class="comment">% 上下界</span></span><br><span class="line">[x,fval] = linprog(c,A,b,[],[],lb,ub)</span><br><span class="line">f1 = <span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>)</span><br><span class="line">f2 = <span class="number">0.4</span>*x(<span class="number">1</span>) + <span class="number">0.3</span>*x(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 敏感性分析 </span></span><br><span class="line">clear;clc</span><br><span class="line">W1 = <span class="number">0.1</span>:<span class="number">0.001</span>:<span class="number">0.5</span>;  W2 = <span class="number">1</span>- W1;  </span><br><span class="line">n =<span class="built_in">length</span>(W1);</span><br><span class="line">F1 = <span class="built_in">zeros</span>(n,<span class="number">1</span>);  F2 = <span class="built_in">zeros</span>(n,<span class="number">1</span>);   X1 = <span class="built_in">zeros</span>(n,<span class="number">1</span>);  X2 = <span class="built_in">zeros</span>(n,<span class="number">1</span>);   FVAL = <span class="built_in">zeros</span>(n,<span class="number">1</span>);</span><br><span class="line">A = [<span class="number">-1</span> <span class="number">-1</span>];  b = <span class="number">-7</span>; <span class="comment">% 不等式约束</span></span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span>]; ub = [<span class="number">5</span> <span class="number">6</span>]; <span class="comment">% 上下界</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    w1 = W1(<span class="built_in">i</span>);  w2 = W2(<span class="built_in">i</span>);</span><br><span class="line">    c = [w1/<span class="number">30</span>*<span class="number">2</span>+w2/<span class="number">2</span>*<span class="number">0.4</span> ;w1/<span class="number">30</span>*<span class="number">5</span>+w2/<span class="number">2</span>*<span class="number">0.3</span>];  <span class="comment">% 线性规划目标函数的系数</span></span><br><span class="line">    [x,fval] = linprog(c,A,b,[],[],lb,ub);</span><br><span class="line">    F1(<span class="built_in">i</span>) = <span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>);</span><br><span class="line">    F2(<span class="built_in">i</span>) = <span class="number">0.4</span>*x(<span class="number">1</span>) + <span class="number">0.3</span>*x(<span class="number">2</span>);</span><br><span class="line">    X1(<span class="built_in">i</span>) = x(<span class="number">1</span>);</span><br><span class="line">    X2(<span class="built_in">i</span>) = x(<span class="number">2</span>);</span><br><span class="line">    FVAL(<span class="built_in">i</span>) = fval;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 「Matlab」“LaTex字符汇总”讲解：https://blog.csdn.net/Robot_Starscream/article/details/89386748</span></span><br><span class="line"><span class="comment">% 在图上可以加上数据游标，按住Alt加鼠标左键可以设置多个数据游标出来。</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>) </span><br><span class="line"><span class="built_in">plot</span>(W1,F1,W1,F2)</span><br><span class="line">xlabel(<span class="string">&#x27;f_&#123;1&#125;的权重&#x27;</span>) </span><br><span class="line">ylabel(<span class="string">&#x27;f_&#123;1&#125;和f_&#123;2&#125;的取值&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;f_&#123;1&#125;&#x27;</span>,<span class="string">&#x27;f_&#123;2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(W1,X1,W1,X2)</span><br><span class="line">xlabel(<span class="string">&#x27;f_&#123;1&#125;的权重&#x27;</span>) </span><br><span class="line">ylabel(<span class="string">&#x27;x_&#123;1&#125;和x_&#123;2&#125;的取值&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;x_&#123;1&#125;&#x27;</span>,<span class="string">&#x27;x_&#123;2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(W1,FVAL)  <span class="comment">% 看起来是两个直线组合起来的下半部分</span></span><br><span class="line">xlabel(<span class="string">&#x27;f_&#123;1&#125;的权重&#x27;</span>) </span><br><span class="line">ylabel(<span class="string">&#x27;综合指标的值&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2><p><img src="/images/image-20240130113809842.png" alt="image-20240130113809842"></p><p><img src="/images/image-20240130113819544.png" alt="image-20240130113819544"></p><blockquote><p>主成分分析法</p><p>综述：数据降维的方法</p><p>可以用一种线性变换的思想去理解，比如二维的一条直线，我们可以通过变换，使得这一条直线落在x或y轴上，达到降维的效果。</p></blockquote><blockquote><p>去中心化（把坐标原点放在数据中心）</p><p>找坐标系，找到数据方差最大的方向，就是第一主成分。（如果第一主成分不足以表达，就考虑吧选取第二个）</p><p>为了有效反映原来信息，第一主成分和第二主成分的协方差为0.以此类推可以获得p个主成分。这些主成分是互不相关，是依次递减的。</p><p>累计方差贡献率大于百分之80就可以了，或者特征根大于1就可以了。</p><p>？根据线性代数的知识，我们需要一则伸缩，二则旋转，伸缩不是问题</p><p>旋转的矩阵R又从何而来？</p><p>即是协方差矩阵的特征向量就是R。</p><p>协方差定义&#x3D;</p><p><img src="/images/b4c05a2fa4534b348766263f53609b76.png" alt="img"></p></blockquote><p><img src="/images/image-20240129173904717.png" alt="image-20240129173904717"></p><p><img src="/images/image-20240129173917094.png" alt="image-20240129173917094"></p><p><img src="/images/image-20240129173940409.png" alt="image-20240129173940409"></p><p><img src="/images/image-20240129173956777.png" alt="image-20240129173956777"></p><h4 id="例题：-1"><a href="#例题：-1" class="headerlink" title="例题："></a>例题：</h4><p><img src="/images/image-20240129174252433.png" alt="image-20240129174252433"></p><p><img src="/images/image-20240129174259805.png" alt="image-20240129174259805"></p><p><img src="/images/image-20240129174305765.png" alt="image-20240129174305765"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line"> load data1.mat   <span class="comment">% 主成分聚类</span></span><br><span class="line"><span class="comment">%  load data2.mat   % 主成分回归</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 注意，这里可以对数据先进行描述性统计</span></span><br><span class="line"><span class="comment">% 描述性统计的内容见第5讲.相关系数</span></span><br><span class="line">[n,p] = <span class="built_in">size</span>(x);  <span class="comment">% n是样本个数，p是指标个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第一步：对数据x标准化为X</span></span><br><span class="line">X=zscore(x);   <span class="comment">% matlab内置的标准化函数（x-mean(x)）/std(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第二步：计算样本协方差矩阵</span></span><br><span class="line">R = cov(X);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 注意：以上两步可合并为下面一步：直接计算样本相关系数矩阵</span></span><br><span class="line">R = corrcoef(x);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;样本相关系数矩阵为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(R)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：计算R的特征值和特征向量</span></span><br><span class="line"><span class="comment">% 注意：R是半正定矩阵，所以其特征值不为负数</span></span><br><span class="line"><span class="comment">% R同时是对称矩阵，Matlab计算对称矩阵时，会将特征值按照从小到大排列哦</span></span><br><span class="line"><span class="comment">% eig函数的详解见第一讲层次分析法的视频</span></span><br><span class="line">[V,D] = eig(R);  <span class="comment">% V 特征向量矩阵  D 特征值构成的对角矩阵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：计算主成分贡献率和累计贡献率</span></span><br><span class="line">lambda = <span class="built_in">diag</span>(D);  <span class="comment">% diag函数用于得到一个矩阵的主对角线元素值(返回的是列向量)</span></span><br><span class="line">lambda = lambda(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>);  <span class="comment">% 因为lambda向量是从小大到排序的，我们将其调个头</span></span><br><span class="line">contribution_rate = lambda / sum(lambda);  <span class="comment">% 计算贡献率</span></span><br><span class="line">cum_contribution_rate = cumsum(lambda)/ sum(lambda);   <span class="comment">% 计算累计贡献率  cumsum是求累加值的函数</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;特征值为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(lambda&#x27;)  <span class="comment">% 转置为行向量，方便展示</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;贡献率为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(contribution_rate&#x27;)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;累计贡献率为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(cum_contribution_rate&#x27;)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;与特征值对应的特征向量矩阵为：&#x27;</span>)</span><br><span class="line"><span class="comment">% 注意：这里的特征向量要和特征值一一对应，之前特征值相当于颠倒过来了，因此特征向量的各列需要颠倒过来</span></span><br><span class="line"><span class="comment">%  rot90函数可以使一个矩阵逆时针旋转90度，然后再转置，就可以实现将矩阵的列颠倒的效果</span></span><br><span class="line">V=<span class="built_in">rot90</span>(V)&#x27;;</span><br><span class="line"><span class="built_in">disp</span>(V)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算我们所需要的主成分的值</span></span><br><span class="line">m =input(<span class="string">&#x27;请输入需要保存的主成分的个数:  &#x27;</span>);</span><br><span class="line">F = <span class="built_in">zeros</span>(n,m);  <span class="comment">%初始化保存主成分的矩阵（每一列是一个主成分）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">    ai = V(:,<span class="built_in">i</span>)&#x27;;   <span class="comment">% 将第i个特征向量取出，并转置为行向量</span></span><br><span class="line">    Ai = <span class="built_in">repmat</span>(ai,n,<span class="number">1</span>);   <span class="comment">% 将这个行向量重复n次，构成一个n*p的矩阵</span></span><br><span class="line">    F(:, <span class="built_in">i</span>) = sum(Ai .* X, <span class="number">2</span>);  <span class="comment">% 注意，对标准化的数据求了权重后要计算每一行的和</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% (1)主成分聚类 ： 将主成分指标所在的F矩阵复制到Excel表格，然后再用Spss进行聚类</span></span><br><span class="line"><span class="comment">% 在Excel第一行输入指标名称（F1,F2, ..., Fm）</span></span><br><span class="line"><span class="comment">% 双击Matlab工作区的F,进入变量编辑中，然后复制里面的数据到Excel表格</span></span><br><span class="line"><span class="comment">% 导出数据之后，我们后续的分析就可以在Spss中进行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%（2）主成分回归：将x使用主成分得到主成分指标，并将y标准化，接着导出到Excel，然后再使用Stata回归</span></span><br><span class="line"><span class="comment">% Y = zscore(y);  % 一定要将y进行标准化哦~</span></span><br><span class="line"><span class="comment">% 在Excel第一行输入指标名称（Y,F1, F2, ..., Fm）</span></span><br><span class="line"><span class="comment">% 分别双击Matlab工作区的Y和F,进入变量编辑中，然后复制里面的数据到Excel表格</span></span><br><span class="line"><span class="comment">% 导出数据之后，我们后续的分析就可以在Stata中进行。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h2><p><img src="/images/image-20240129194932249.png" alt="image-20240129194932249"></p><p>聚类不知道类别</p><h3 id="K-means聚类算法"><a href="#K-means聚类算法" class="headerlink" title="K-means聚类算法"></a>K-means聚类算法</h3><p><img src="/images/image-20240129194952521.png" alt="image-20240129194952521"></p><h4 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h4><p><img src="/images/image-20240129195121059.png" alt="image-20240129195121059"></p><h4 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h4><p><img src="/images/image-20240129195132844.png" alt="image-20240129195132844"></p><h3 id="K-means-算法"><a href="#K-means-算法" class="headerlink" title="K-means++算法"></a>K-means++算法</h3><p><img src="/images/image-20240129195226437.png" alt="image-20240129195226437"></p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p><img src="/images/image-20240129195330285.png" alt="image-20240129195330285"></p><p><img src="/images/image-20240129195405248.png" alt="image-20240129195405248"></p><h3 id="系统（层次）聚类"><a href="#系统（层次）聚类" class="headerlink" title="系统（层次）聚类"></a>系统（层次）聚类</h3><p><img src="/images/image-20240129195509250.png" alt="image-20240129195509250"></p><h4 id="距离计算"><a href="#距离计算" class="headerlink" title="距离计算"></a>距离计算</h4><p><img src="/images/image-20240129195530809.png" alt="image-20240129195530809"></p><p><img src="/images/image-20240129200236007.png" alt="image-20240129200236007"></p><p><img src="/images/image-20240129200246282.png" alt="image-20240129200246282"></p><p><img src="/images/image-20240129200254274.png" alt="image-20240129200254274"></p><p><img src="/images/image-20240129200321590.png" alt="image-20240129200321590"></p><p><img src="/images/image-20240129200335096.png" alt="image-20240129200335096"></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p><img src="/images/image-20240129200430566.png" alt="image-20240129200430566"></p><p><img src="/images/image-20240129200448939.png" alt="image-20240129200448939"></p><blockquote><p>会生成聚类谱系图，以此判断选择几类</p></blockquote><p><img src="/images/image-20240129200741109.png" alt="image-20240129200741109"></p><p><img src="/images/image-20240129200821668.png" alt="image-20240129200821668"></p><blockquote><p>详细操作见下博客</p></blockquote><p><a href="https://blog.csdn.net/My_daily_life/article/details/120627516">SPSS操作(四)：系统聚类分析_聚类分析spss操作-CSDN博客</a></p><h3 id="DBSCAN-算法"><a href="#DBSCAN-算法" class="headerlink" title="DBSCAN 算法"></a>DBSCAN 算法</h3><p><img src="/images/image-20240129201052622.png" alt="image-20240129201052622"></p><p>基本概念</p><p><img src="/images/image-20240129201312072.png" alt="image-20240129201312072"></p><p><img src="/images/image-20240129201355010.png" alt="image-20240129201355010"></p><p>代码</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Load Data</span></span><br><span class="line"></span><br><span class="line">load mydata;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Run DBSCAN Clustering Algorithm</span></span><br><span class="line"></span><br><span class="line">epsilon=<span class="number">0.5</span>;</span><br><span class="line">MinPts=<span class="number">10</span>;</span><br><span class="line">IDX=DBSCAN(X,epsilon,MinPts);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[IDX, isnoise]</span>=<span class="title">DBSCAN</span><span class="params">(X,epsilon,MinPts)</span></span></span><br><span class="line"></span><br><span class="line">    C=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    n=<span class="built_in">size</span>(X,<span class="number">1</span>);</span><br><span class="line">    IDX=<span class="built_in">zeros</span>(n,<span class="number">1</span>);  <span class="comment">% 初始化全部为0，即全部为噪音点</span></span><br><span class="line">    </span><br><span class="line">    D=pdist2(X,X);</span><br><span class="line">    </span><br><span class="line">    visited=<span class="built_in">false</span>(n,<span class="number">1</span>);</span><br><span class="line">    isnoise=<span class="built_in">false</span>(n,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> ~visited(<span class="built_in">i</span>)</span><br><span class="line">            visited(<span class="built_in">i</span>)=<span class="built_in">true</span>;</span><br><span class="line">            </span><br><span class="line">            Neighbors=RegionQuery(<span class="built_in">i</span>);</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">numel</span>(Neighbors)&lt;MinPts</span><br><span class="line">                <span class="comment">% X(i,:) is NOISE</span></span><br><span class="line">                isnoise(<span class="built_in">i</span>)=<span class="built_in">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C=C+<span class="number">1</span>;</span><br><span class="line">                ExpandCluster(<span class="built_in">i</span>,Neighbors,C);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ExpandCluster</span><span class="params">(i,Neighbors,C)</span></span></span><br><span class="line">        IDX(<span class="built_in">i</span>)=C;</span><br><span class="line">        </span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">true</span></span><br><span class="line">            <span class="built_in">j</span> = Neighbors(k);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ~visited(<span class="built_in">j</span>)</span><br><span class="line">                visited(<span class="built_in">j</span>)=<span class="built_in">true</span>;</span><br><span class="line">                Neighbors2=RegionQuery(<span class="built_in">j</span>);</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">numel</span>(Neighbors2)&gt;=MinPts</span><br><span class="line">                    Neighbors=[Neighbors Neighbors2];   <span class="comment">%#ok</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> IDX(<span class="built_in">j</span>)==<span class="number">0</span></span><br><span class="line">                IDX(<span class="built_in">j</span>)=C;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="built_in">numel</span>(Neighbors)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Neighbors</span>=<span class="title">RegionQuery</span><span class="params">(i)</span></span></span><br><span class="line">        Neighbors=<span class="built_in">find</span>(D(<span class="built_in">i</span>,:)&lt;=epsilon);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>当然，让我逐行解释这段MATLAB代码：</p><ol><li><p><strong>clc; clear; close all;</strong></p><ul><li><code>clc</code>：清除命令窗口。</li><li><code>clear</code>：清除工作区中的所有变量。</li><li><code>close all</code>：关闭所有打开的图形窗口。</li></ul></li><li><p><strong>load mydata;</strong></p><ul><li>从名为 ‘mydata’ 的文件中加载数据到工作区。这里的假设是 ‘mydata’ 包含一个表示数据点的变量 <code>X</code>。</li></ul></li><li><p><strong>epsilon&#x3D;0.5; MinPts&#x3D;10;</strong></p><ul><li>定义DBSCAN算法的参数，<code>epsilon</code> 是邻域半径，<code>MinPts</code> 是邻域内最小数据点数。</li></ul></li><li><p><strong>IDX&#x3D;DBSCAN(X,epsilon,MinPts);</strong></p><ul><li>调用DBSCAN函数，对数据 <code>X</code> 进行密度聚类，返回聚类结果 <code>IDX</code>。</li></ul></li><li><p><strong>function [IDX, isnoise]&#x3D;DBSCAN(X,epsilon,MinPts)</strong></p><ul><li>定义DBSCAN算法的主函数，接受输入参数 <code>X</code>、<code>epsilon</code> 和 <code>MinPts</code>。</li></ul></li><li><p><strong>C&#x3D;0;</strong></p><ul><li>初始化聚类簇数为0。</li></ul></li><li><p><strong>n&#x3D;size(X,1); IDX&#x3D;zeros(n,1);</strong></p><ul><li>获取数据点数量 <code>n</code>，初始化聚类标签 <code>IDX</code> 全部为0，表示所有点都是噪音点。</li></ul></li><li><p><strong>D&#x3D;pdist2(X,X);</strong></p><ul><li>计算数据点之间的距离矩阵 <code>D</code>。</li></ul></li><li><p><strong>visited&#x3D;false(n,1); isnoise&#x3D;false(n,1);</strong></p><ul><li>初始化用于标记是否访问过的向量 <code>visited</code> 和标记是否为噪音点的向量 <code>isnoise</code>。</li></ul></li><li><p><strong>for i&#x3D;1:n</strong></p><ul><li>开始对每个数据点进行迭代。</li></ul></li><li><p><strong>if ~visited(i)</strong></p><ul><li>如果当前点未被访问过，则执行以下操作。</li></ul></li><li><p><strong>visited(i)&#x3D;true; Neighbors&#x3D;RegionQuery(i);</strong></p><ul><li>将当前点标记为已访问，然后找到与当前点在邻域内的点集合 <code>Neighbors</code>。</li></ul></li><li><p><strong>if numel(Neighbors)&lt;MinPts</strong></p><ul><li>如果邻域内点的数量小于 <code>MinPts</code>，则将当前点标记为噪音点。</li></ul></li><li><p><strong>else</strong></p><ul><li>否则，执行以下聚类操作。</li></ul></li><li><p><strong>C&#x3D;C+1; ExpandCluster(i,Neighbors,C);</strong></p><ul><li>增加聚类簇数，并进行扩展聚类操作。</li></ul></li><li><p><strong>function ExpandCluster(i,Neighbors,C)</strong></p><ul><li>定义扩展聚类的子函数，给定当前点、邻域内点集合和当前簇数。</li></ul></li><li><p><strong>IDX(i)&#x3D;C;</strong></p><ul><li>将当前点标记为属于当前簇。</li></ul></li><li><p><strong>while true</strong></p><ul><li>进入循环，不断扩展聚类。</li></ul></li><li><p><strong>j &#x3D; Neighbors(k);</strong></p><ul><li>取出邻域内的第 k 个点。</li></ul></li><li><p><strong>if ~visited(j)</strong></p><ul><li>如果该点未被访问过，则执行以下操作。</li></ul></li><li><p><strong>visited(j)&#x3D;true; Neighbors2&#x3D;RegionQuery(j);</strong></p><ul><li>将该点标记为已访问，然后找到与该点在邻域内的点集合 <code>Neighbors2</code>。</li></ul></li><li><p><strong>if numel(Neighbors2)&gt;&#x3D;MinPts</strong></p><ul><li>如果新邻域内的点数量大于等于 <code>MinPts</code>，则将新邻域内的点添加到原邻域中。</li></ul></li><li><p><strong>Neighbors&#x3D;[Neighbors Neighbors2];</strong></p><ul><li>将新邻域内的点添加到原邻域中。</li></ul></li><li><p><strong>end</strong></p><ul><li>结束新邻域内点的处理。</li></ul></li><li><p><strong>if IDX(j)&#x3D;&#x3D;0</strong></p><ul><li>如果该点尚未被分配到任何簇，则将其分配到当前簇。</li></ul></li><li><p><strong>IDX(j)&#x3D;C;</strong></p><ul><li>将该点标记为属于当前簇。</li></ul></li><li><p><strong>k &#x3D; k + 1; if k &gt; numel(Neighbors) break; end</strong></p><ul><li>处理邻域内的下一个点，直到邻域内的所有点都被处理完。</li></ul></li><li><p><strong>function Neighbors&#x3D;RegionQuery(i)</strong></p><ul><li>定义邻域查询的子函数，给定当前点的索引 <code>i</code>，返回在邻域内的点的索引集合。</li></ul></li><li><p><strong>Neighbors&#x3D;find(D(i,:)&lt;&#x3D;epsilon);</strong></p><ul><li>根据距离矩阵，找到与当前点距离在 <code>epsilon</code> 以内的点。</li></ul></li><li><p><strong>end</strong></p><ul><li>结束邻域查询子函数。</li></ul></li><li><p><strong>end</strong></p><ul><li>结束主函数。</li></ul></li></ol><p>这样，整个代码就实现了DBSCAN聚类算法。</p></blockquote><h2 id="多元回归分析"><a href="#多元回归分析" class="headerlink" title="多元回归分析"></a>多元回归分析</h2><blockquote><p>回归分析是数据分析中最基础也是最重要的分析工具，绝大多数的数据分析问题，都可以使用回归的思想来解决。回归分析的任务就是通过研究自变量X和因变量Y的相关关系，尝试去解释Y的形成机制，进而达到通过X去预测Y的目的</p><p>回归分析:研究X和Y相关性的分析（相关性≠因果性）</p><p>常见的回归分析有：线性回归、0-1回归、定序回归、计数回归和生存回归，其划分的依据是因变量y的类型。</p></blockquote><p><img src="/images/image-20240129214522174.png" alt="image-20240129214522174"></p><p><img src="/images/image-20240129214533470.png" alt="image-20240129214533470"></p><h3 id="回归分析的作用"><a href="#回归分析的作用" class="headerlink" title="回归分析的作用"></a>回归分析的作用</h3><p><img src="/images/image-20240129214553725.png" alt="image-20240129214553725"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><img src="/images/image-20240129214629247.png" alt="image-20240129214629247"></p><p><strong>数据的分类：<br>横截面数据</strong>：在某一时点收集的不同对象的数据。</p><h3 id="本章节主要是多元线性回归"><a href="#本章节主要是多元线性回归" class="headerlink" title="本章节主要是多元线性回归"></a>本章节主要是多元线性回归</h3><p><img src="/images/image-20240129214810466.png" alt="image-20240129214810466"></p><h2 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h2><p><img src="/images/image-20240129214828532.png" alt="image-20240129214828532"></p><blockquote><p>线性是灵动的</p></blockquote><p><img src="/images/image-20240129214850518.png" alt="image-20240129214850518"></p><blockquote><p>注意引入变量时候要多加考虑</p></blockquote><p><img src="/images/image-20240129215013434.png" alt="image-20240129215013434"></p><p><img src="/images/image-20240129215038603.png" alt="image-20240129215038603"></p><h4 id="外生性的要求"><a href="#外生性的要求" class="headerlink" title="外生性的要求"></a>外生性的要求</h4><p><img src="/images/image-20240129215112238.png" alt="image-20240129215112238"></p><h4 id="什么时候取对数"><a href="#什么时候取对数" class="headerlink" title="什么时候取对数"></a>什么时候取对数</h4><p><strong>取对数的好处：</strong> （1）减弱数据的异方差性（2）如果变量本身不符合正态分布，取</p><p>了对数后 可能渐近服从正态分布（ 3 ）模型形式的需要，让模型具有经济学意义。</p><p> <img src="/images/image-20240129215205907.png" alt="image-20240129215205907"></p><p><img src="/images/image-20240129215212290.png" alt="image-20240129215212290"></p><p><strong>虚拟变量的解释:</strong></p><p><img src="/images/image-20240129215246712.png" alt="image-20240129215246712"></p><p><img src="/images/image-20240129215300615.png" alt="image-20240129215300615"></p><p><strong>多分类的虚拟变量的设置：</strong> </p><p><img src="/images/image-20240129215355156.png" alt="image-20240129215355156"></p><p><img src="/images/image-20240129215401967.png" alt="image-20240129215401967"></p><p><em><strong>&#x2F;*为了避免完全多重共线性的影响，引入虚拟变量的个数一般是分类数减&#x2F;**&#x2F;<strong>1,另外一个为对照组&#x2F;</strong>&#x2F;*<em>。&#x2F;</em></strong></em></p><p><strong>含有交互项的自变量：</strong></p><p><img src="/images/image-20240129215424047.png" alt="image-20240129215424047"></p><h3 id="回归实例："><a href="#回归实例：" class="headerlink" title="回归实例："></a><strong>回归实例：</strong></h3><p><img src="/images/image-20240129215502987.png" alt="image-20240129215502987"></p><p><strong>操作步骤：</strong></p><p><strong>stata软件：</strong></p><p>第一步：导入数据</p><p><img src="/images/image-20240129215527268.png" alt="image-20240129215527268"></p><p>第二步：数据描述性统计</p><p><img src="/images/image-20240129215541264.png" alt="image-20240129215541264"></p><p><img src="/images/image-20240129215607055.png" alt="image-20240129215607055"></p><p><img src="/images/image-20240129215619067.png" alt="image-20240129215619067"></p><p><img src="/images/image-20240129215627382.png" alt="image-20240129215627382"></p><p><img src="/images/image-20240129215637199.png" alt="image-20240129215637199"></p><p><strong>拟合优度R²较低怎么办：</strong></p><p><img src="/images/image-20240129215643497.png" alt="image-20240129215643497"></p><p><strong>标准回归化系数：</strong></p><p><img src="/images/image-20240129215700385.png" alt="image-20240129215700385"></p><p><img src="/images/image-20240129215707976.png" alt="image-20240129215707976"></p><p><strong>使用OLS时，扰动项μ需要满足的条件：</strong></p><p><img src="/images/image-20240129215902585.png" alt="image-20240129215902585"></p><p><img src="/images/image-20240129215928314.png" alt="image-20240129215928314"></p><p><img src="/images/image-20240129215935706.png" alt="image-20240129215935706"></p><p><img src="/images/image-20240129215945766.png" alt="image-20240129215945766"></p><p><img src="/images/image-20240129220020904.png" alt="image-20240129220020904"></p><p><img src="/images/image-20240129220048086.png" alt="image-20240129220048086"></p><p><img src="/images/image-20240129220104904.png" alt="image-20240129220104904"></p><p><img src="/images/image-20240129220124650.png" alt="image-20240129220124650"></p><p><img src="/images/image-20240129220136200.png" alt="image-20240129220136200"></p><p><strong>多重共线性：</strong></p><p><img src="/images/image-20240129220153354.png" alt="image-20240129220153354"></p><p><img src="/images/image-20240129220202916.png" alt="image-20240129220202916"></p><h3 id="处理方法："><a href="#处理方法：" class="headerlink" title="处理方法："></a>处理方法：</h3><p><img src="/images/image-20240129220239152.png" alt="image-20240129220239152"></p><p><img src="/images/image-20240129220248065.png" alt="image-20240129220248065"></p><p><img src="/images/image-20240129220300213.png" alt="image-20240129220300213"></p><p><img src="/images/image-20240129220322288.png" alt="image-20240129220322288"></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按键盘上的PageUp可以使用上一次输入的代码（Matlab中是上箭头）</span></span><br><span class="line"><span class="comment">// 清除所有变量</span></span><br><span class="line"><span class="keyword">clear</span></span><br><span class="line"><span class="comment">// 清屏 和 matlab的clc类似</span></span><br><span class="line">cls </span><br><span class="line"><span class="comment">// 导入数据（其实是我们直接在界面上粘贴过来的，我们用鼠标点界面导入更方便 本条请删除后再复制到论文中，如果评委老师看到了就知道这不是你写的了）</span></span><br><span class="line"><span class="comment">// import excel &quot;C:/Users/hc_lzp/Desktop/数学建模视频录制/第7讲.多元回归分析/代码和例题数据/课堂中讲解的奶粉数据.xlsx&quot;, sheet(&quot;Sheet1&quot;) firstrow</span></span><br><span class="line">import excel <span class="string">&quot;课堂中讲解的奶粉数据.xlsx&quot;</span>, sheet(<span class="string">&quot;Sheet1&quot;</span>) firstrow</span><br><span class="line"><span class="comment">// 定量变量的描述性统计</span></span><br><span class="line"><span class="keyword">summarize</span> 团购价元 评价量 商品毛重kg</span><br><span class="line"><span class="comment">// 定性变量的频数分布，并得到相应字母开头的虚拟变量</span></span><br><span class="line"><span class="keyword">tabulate</span> 配方,<span class="keyword">gen</span>(A)</span><br><span class="line"><span class="keyword">tabulate</span> 奶源产地 ,<span class="keyword">gen</span>(B)</span><br><span class="line"><span class="keyword">tabulate</span> 国产或进口 ,<span class="keyword">gen</span>(C)</span><br><span class="line"><span class="keyword">tabulate</span> 适用年龄岁 ,<span class="keyword">gen</span>(<span class="keyword">D</span>)</span><br><span class="line"><span class="keyword">tabulate</span> 包装单位 ,<span class="keyword">gen</span>(<span class="keyword">E</span>)</span><br><span class="line"><span class="keyword">tabulate</span> 分类 ,<span class="keyword">gen</span>(F)</span><br><span class="line"><span class="keyword">tabulate</span> 段位 ,<span class="keyword">gen</span>(<span class="keyword">G</span>)</span><br><span class="line"><span class="comment">// 下面进行回归</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg</span><br><span class="line"><span class="comment">// 下面的语句可帮助我们把回归结果保存在Word文档中</span></span><br><span class="line"><span class="comment">// 在使用之前需要运行下面这个代码来安装下这个功能包（运行一次之后就可以注释掉了）</span></span><br><span class="line"><span class="comment">// ssc install reg2docx, all replace</span></span><br><span class="line"><span class="comment">// 如果安装出现connection timed out的错误，可以尝试换成手机热点联网，如果手机热点也不能下载，就不用这个命令吧，可以自己做一个回归结果表，如果觉得麻烦就直接把回归结果截图。</span></span><br><span class="line"><span class="keyword">est</span> store m1</span><br><span class="line">reg2docx m1 using m1.docx, <span class="keyword">replace</span></span><br><span class="line"><span class="comment">// *** p&lt;0.01  ** p&lt;0.05 * p&lt;0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stata会自动剔除多重共线性的变量</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg A1 A2 A3 B1 B2 B3 B4 B5 B6 B7 B8 B9 C1 C2 D1 D2 D3 D4 D5 E1 E2 E3 E4 F1 F2 G1 G2 G3 G4</span><br><span class="line"><span class="keyword">est</span> store m2</span><br><span class="line">reg2docx m2 using m2.docx, <span class="keyword">replace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到标准化回归系数</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg, b </span><br><span class="line"></span><br><span class="line"><span class="comment">// 画出残差图</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg A1 A2 A3 B1 B2 B3 B4 B5 B6 B7 B8 B9 C1 C2 D1 D2 D3 D4 D5 E1 E2 E3 E4 F1 F2 G1 G2 G3 G4</span><br><span class="line"><span class="keyword">rvfplot</span> </span><br><span class="line"><span class="comment">// 残差与拟合值的散点图</span></span><br><span class="line"><span class="keyword">graph</span> export a1.png ,<span class="keyword">replace</span></span><br><span class="line"><span class="comment">// 残差与自变量团购价的散点图</span></span><br><span class="line"><span class="keyword">rvpplot</span>  团购价元</span><br><span class="line"><span class="keyword">graph</span> export a2.png ,<span class="keyword">replace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么评价量的拟合值会出现负数？</span></span><br><span class="line"><span class="comment">// 描述性统计并给出分位数对应的数值</span></span><br><span class="line"><span class="keyword">summarize</span> 评价量,<span class="keyword">d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作评价量的概率密度估计图</span></span><br><span class="line"><span class="keyword">kdensity</span> 评价量 </span><br><span class="line"><span class="keyword">graph</span> export a3.png ,<span class="keyword">replace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异方差BP检验</span></span><br><span class="line"><span class="keyword">estat</span> <span class="keyword">hettest</span> ,rhs iid</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异方差怀特检验</span></span><br><span class="line"><span class="keyword">estat</span> <span class="keyword">imtest</span>,white</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用OLS + 稳健的标准误</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg A1 A2 A3 B1 B2 B3 B4 B5 B6 B7 B8 B9 C1 C2 D1 D2 D3 D4 D5 E1 E2 E3 E4 F1 F2 G1 G2 G3 G4, r</span><br><span class="line"><span class="keyword">est</span> store m3</span><br><span class="line">reg2docx m3 using m3.docx, <span class="keyword">replace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算VIF</span></span><br><span class="line"><span class="keyword">estat</span>  <span class="keyword">vif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐步回归（一定要注意完全多重共线性的影响）</span></span><br><span class="line"><span class="comment">// 向前逐步回归（后面的r表示稳健的标准误）</span></span><br><span class="line"><span class="keyword">stepwise</span> <span class="keyword">reg</span> 评价量 团购价元 商品毛重kg A1 A3 B1 B2 B3 B4 B5 B6 B7 B9 C1 D1 D2 D3 D4 E1 E2 E3 F1 G1 G2 G3,  r pe(0.05)</span><br><span class="line"><span class="comment">// 向后逐步回归（后面的r表示稳健的标准误）</span></span><br><span class="line"><span class="keyword">stepwise</span> <span class="keyword">reg</span> 评价量 团购价元 商品毛重kg A1 A3 B1 B2 B3 B4 B5 B6 B7 B9 C1 D1 D2 D3 D4 E1 E2 E3 F1 G1 G2 G3,  r <span class="keyword">pr</span>(0.05)</span><br><span class="line"><span class="comment">// 向后逐步回归的同时使用标准化回归系数（在r后面跟上一个b即可）</span></span><br><span class="line"><span class="keyword">stepwise</span> <span class="keyword">reg</span> 评价量 团购价元 商品毛重kg A1 A3 B1 B2 B3 B4 B5 B6 B7 B9 C1 D1 D2 D3 D4 E1 E2 E3 F1 G1 G2 G3,  r b <span class="keyword">pr</span>(0.05)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 补充语法 (大家不需要具体的去学Stata软件，掌握我课堂上教给大家的一些命令应对数学建模比赛就可以啦)</span></span><br><span class="line"><span class="comment">// 事实上大家学好Excel，学好后应对90%的数据预处理问题都能解决</span></span><br><span class="line"><span class="comment">// (1) 用已知变量生成新的变量 </span></span><br><span class="line"><span class="keyword">generate</span> lny = <span class="built_in">log</span>(评价量)  </span><br><span class="line"><span class="keyword">generate</span> price_square = 团购价元 ^2</span><br><span class="line"><span class="keyword">generate</span> interaction_term = 团购价元*商品毛重kg</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 修改变量名称，因为用中文命名变量名称有时候可能容易出现未知Bug</span></span><br><span class="line"><span class="keyword">rename</span> 团购价元 price</span><br></pre></td></tr></table></figure><h2 id="lasso回归"><a href="#lasso回归" class="headerlink" title="lasso回归"></a>lasso回归</h2><blockquote><p>LASSO 回归也叫套索回归，是通过生成一个惩罚函数是回归模型中的变量系数进行压缩，达到防止过度拟合，解决严重共线性的问题，LASSO 回归最先由英国人Robert Tibshirani提出，目前在预测模型中应用非常广泛。在新格兰文献中，有大牛提出，对于变量过多而且变量数较少的模型拟合，首先要考虑使用LASSO 惩罚函数。</p></blockquote><blockquote><p>变量过多会导致多重共线性问题造成回归系数不显著，甚至导致ols估计失效。</p></blockquote><p><img src="/images/image-20240128130519231.png" alt="image-20240128130519231"></p><h3 id="Lasso回归的原理"><a href="#Lasso回归的原理" class="headerlink" title="Lasso回归的原理"></a>Lasso回归的原理</h3><p><img src="/images/image-20240128132142605.png" alt="image-20240128132142605"></p><h3 id="使用lasso回归分析"><a href="#使用lasso回归分析" class="headerlink" title="使用lasso回归分析"></a>使用lasso回归分析</h3><p><img src="/images/image-20240128132556845.png" alt="image-20240128132556845"></p><p><img src="/images/image-20240128132542976.png" alt="image-20240128132542976"></p><p><img src="/images/image-20240128132709587.png" alt="image-20240128132709587"></p><h2 id="什么时候使用lasso回归"><a href="#什么时候使用lasso回归" class="headerlink" title="什么时候使用lasso回归"></a>什么时候使用lasso回归</h2><p><img src="/images/image-20240128132838334.png" alt="image-20240128132838334"></p><h3 id="代码学习与实现："><a href="#代码学习与实现：" class="headerlink" title="代码学习与实现："></a>代码学习与实现：</h3><h4 id="Stata：拉索开心读懂-Lasso入门-lianxh-cn"><a href="#Stata：拉索开心读懂-Lasso入门-lianxh-cn" class="headerlink" title="Stata：拉索开心读懂-Lasso入门 (lianxh.cn)"></a><a href="https://www.lianxh.cn/news/c15e828b678e6.html">Stata：拉索开心读懂-Lasso入门 (lianxh.cn)</a></h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>排序题单总结</title>
      <link href="/2024/01/30/%E6%8E%92%E5%BA%8F%E9%A2%98%E5%8D%95%E6%80%BB%E7%BB%93/"/>
      <url>/2024/01/30/%E6%8E%92%E5%BA%8F%E9%A2%98%E5%8D%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="排序题单"><a href="#排序题单" class="headerlink" title="排序题单"></a>排序题单</h1><h1 id="【深基9-例1】选举学生会"><a href="#【深基9-例1】选举学生会" class="headerlink" title="【深基9.例1】选举学生会"></a>【深基9.例1】选举学生会</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>学校正在选举学生会成员，有 $n$（$n\le 999$）名候选人，每名候选人编号分别从 $1$ 到 $n$，现在收集到了 $m$（$m \le 2000000$）张选票，每张选票都写了一个候选人编号。现在想把这些堆积如山的选票按照投票数字从小到大排序。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入 $n$ 和 $m$ 以及 $m$ 个选票上的数字。</p><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>求出排序后的选票编号。</p><h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 10</span><br><span class="line">2 5 2 2 5 2 2 2 1 2</span><br></pre></td></tr></table></figure><h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 2 2 2 2 2 2 5 5</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> harsh[<span class="number">10000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">cin &gt;&gt; b;</span><br><span class="line">harsh[b]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (harsh[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (harsh[i]--)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【模板】排序"><a href="#【模板】排序" class="headerlink" title="【模板】排序"></a>【模板】排序</h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>将读入的 $N$ 个数从小到大排序后输出。</p><h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为一个正整数 $N$。</p><p>第二行包含 $N$ 个空格隔开的正整数 $a_i$，为你需要进行排序的数。</p><h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>将给定的 $N$ 个数从小到大输出，数之间空格隔开，行末换行且无空格。</p><h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">4 2 4 5 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 2 4 4 5</span><br></pre></td></tr></table></figure><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>对于 $20%$ 的数据，有 $1 \leq N \leq 10^3$；</p><p>对于 $100%$ 的数据，有 $1 \leq N \leq 10^5$，$1 \le a_i \le 10^9$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//堆排序</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for(int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//返回堆顶也就是最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>||w[x]&lt;w[x/<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//就是你已经到达根顶了，或者你已经小于你的父节点了</span></span><br><span class="line">    <span class="comment">//这样就行了实际上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(w[x],w[x/<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//这也正是没有达到上述情况，那么你就要交换</span></span><br><span class="line"><span class="built_in">modify</span>(x/<span class="number">2</span>);</span><br><span class="line"><span class="comment">//交换完继续处理上一个节点</span></span><br><span class="line"><span class="comment">//递归处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[++tot]=x;<span class="comment">//加入元素直接在尾部进行加入</span></span><br><span class="line">    <span class="built_in">modify</span>(tot);<span class="comment">//自底向上修复</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">repair</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x*<span class="number">2</span>&gt;tot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//已经到达叶子节点，和上个modify操作一样</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tar=<span class="number">2</span>*x;</span><br><span class="line"><span class="keyword">if</span>(x*<span class="number">2</span>+<span class="number">1</span>&lt;=tot)</span><br><span class="line">&#123;</span><br><span class="line">    tar=w[x*<span class="number">2</span>]&gt;w[x*<span class="number">2</span>+<span class="number">1</span>]?x*<span class="number">2</span>:x*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(w[x]&lt;w[tar])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(w[x],w[tar]);</span><br><span class="line">    <span class="built_in">repair</span>(tar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(w[<span class="number">1</span>],w[tot--]);</span><br><span class="line">    <span class="comment">//这一步有两个操作，第一个是交换头尾，第二个是删除尾部</span></span><br><span class="line">   <span class="comment">//接下来我们要修复头部</span></span><br><span class="line">   <span class="built_in">repair</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="built_in">push</span>(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;-<span class="built_in">top</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="【深基9-例4】求第-k-小的数"><a href="#【深基9-例4】求第-k-小的数" class="headerlink" title="【深基9.例4】求第 k 小的数"></a>【深基9.例4】求第 k 小的数</h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入 $n$（$1 \le n &lt; 5000000$ 且 $n$ 为奇数）个数字 $a_i$（$1 \le a_i &lt; {10}^9$），输出这些数字的第 $k$ 小的数。最小的数是第 $0$ 小。</p><p>请尽量不要使用 <code>nth_element</code> 来写本题，因为本题的重点在于练习分治算法。</p><h2 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h2><h2 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h2><h2 id="样例-1-2"><a href="#样例-1-2" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-2"><a href="#样例输入-1-2" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 1</span><br><span class="line">4 3 2 1 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-2"><a href="#样例输出-1-2" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, k, a[<span class="number">50000100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="built_in">nth_element</span>(a, a + k, a + n);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a[k]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="NOIP2006-普及组-明明的随机数"><a href="#NOIP2006-普及组-明明的随机数" class="headerlink" title="[NOIP2006 普及组] 明明的随机数"></a>[NOIP2006 普及组] 明明的随机数</h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了 $N$ 个 $1$ 到 $1000$ 之间的随机整数 $(N\leq100)$，对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作。</p><h2 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入有两行，第 $1$ 行为 $1$ 个正整数，表示所生成的随机数的个数 $N$。</p><p>第 $2$ 行有 $N$ 个用空格隔开的正整数，为所产生的随机数。</p><h2 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出也是两行，第 $1$ 行为 $1$ 个正整数 $M$，表示不相同的随机数的个数。</p><p>第 $2$ 行为 $M$ 个用空格隔开的正整数，为从小到大排好序的不相同的随机数。</p><h2 id="样例-1-3"><a href="#样例-1-3" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-3"><a href="#样例输入-1-3" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">20 40 32 67 40 20 89 300 400 15</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-3"><a href="#样例输出-1-3" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">15 20 32 40 67 89 300 400</span><br></pre></td></tr></table></figure><h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>NOIP 2006 普及组 第一题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100000</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a, a + n);</span><br><span class="line"><span class="type">int</span> cnt = <span class="built_in">unique</span>(a, a + n) - a;</span><br><span class="line">cout &lt;&lt; cnt &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="NOIP2007-普及组-奖学金"><a href="#NOIP2007-普及组-奖学金" class="headerlink" title="[NOIP2007 普及组] 奖学金"></a>[NOIP2007 普及组] 奖学金</h1><h2 id="题目背景"><a href="#题目背景" class="headerlink" title="题目背景"></a>题目背景</h2><p>NOIP2007 普及组 T1</p><h2 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h2><p>某小学最近得到了一笔赞助，打算拿出其中一部分为学习成绩优秀的前 $5$ 名学生发奖学金。期末，每个学生都有 $3$ 门课的成绩：语文、数学、英语。先按总分从高到低排序，如果两个同学总分相同，再按语文成绩从高到低排序，如果两个同学总分和语文成绩都相同，那么规定学号小的同学排在前面，这样，每个学生的排序是唯一确定的。</p><p>任务：先根据输入的 $3$ 门课的成绩计算总分，然后按上述规则排序，最后按排名顺序输出前五名名学生的学号和总分。</p><p>注意，在前 $5$ 名同学中，每个人的奖学金都不相同，因此，你必须严格按上述规则排序。例如，在某个正确答案中，如果前两行的输出数据（每行输出两个数：学号、总分) 是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7 279  </span><br><span class="line">5 279</span><br></pre></td></tr></table></figure><p>这两行数据的含义是：总分最高的两个同学的学号依次是 $7$ 号、$5$ 号。这两名同学的总分都是 $279$ (总分等于输入的语文、数学、英语三科成绩之和) ，但学号为 $7$ 的学生语文成绩更高一些。</p><p>如果你的前两名的输出数据是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5 279  </span><br><span class="line">7 279</span><br></pre></td></tr></table></figure><p>则按输出错误处理，不能得分。</p><h2 id="输入格式-4"><a href="#输入格式-4" class="headerlink" title="输入格式"></a>输入格式</h2><p>共 $n+1$ 行。</p><p>第 $1$ 行为一个正整数 $n \le 300$，表示该校参加评选的学生人数。</p><p>第 $2$ 到 $n+1$ 行，每行有 $3$ 个用空格隔开的数字，每个数字都在 $0$ 到 $100$ 之间。第 $j$ 行的 $3$ 个数字依次表示学号为 $j-1$ 的学生的语文、数学、英语的成绩。每个学生的学号按照输入顺序编号为 $1\sim n$（恰好是输入数据的行号减 $1$）。</p><p>保证所给的数据都是正确的，不必检验。</p><h2 id="输出格式-4"><a href="#输出格式-4" class="headerlink" title="输出格式"></a>输出格式</h2><p>共 $5$ 行，每行是两个用空格隔开的正整数，依次表示前 $5$ 名学生的学号和总分。</p><h2 id="样例-1-4"><a href="#样例-1-4" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-4"><a href="#样例输入-1-4" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">90 67 80</span><br><span class="line">87 66 91</span><br><span class="line">78 89 91</span><br><span class="line">88 99 77</span><br><span class="line">67 89 64</span><br><span class="line">78 89 98</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-4"><a href="#样例输出-1-4" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">6 265</span><br><span class="line">4 264</span><br><span class="line">3 258</span><br><span class="line">2 244</span><br><span class="line">1 237</span><br></pre></td></tr></table></figure><h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">80 89 89</span><br><span class="line">88 98 78</span><br><span class="line">90 67 80</span><br><span class="line">87 66 91</span><br><span class="line">78 89 91</span><br><span class="line">88 99 77</span><br><span class="line">67 89 64</span><br><span class="line">78 89 98</span><br></pre></td></tr></table></figure><h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">8 265</span><br><span class="line">2 264</span><br><span class="line">6 264</span><br><span class="line">1 258</span><br><span class="line">5 258</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">xuesheng</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;<span class="comment">//学号</span></span><br><span class="line"><span class="type">int</span> yuwen;</span><br><span class="line"><span class="type">int</span> zongfen;</span><br><span class="line">&#125;a[<span class="number">310</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(xuesheng x, xuesheng y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x.zongfen != y.zongfen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.zongfen &gt; y.zongfen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (x.zongfen == y.zongfen &amp;&amp; x.yuwen != y.yuwen)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.yuwen &gt; y.yuwen;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.num &lt; y.num;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="type">int</span> shuxue, yingyu;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">a[i].num = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i].yuwen;</span><br><span class="line">cin &gt;&gt; shuxue;</span><br><span class="line">cin &gt;&gt; yingyu;</span><br><span class="line">a[i].zongfen = a[i].yuwen + shuxue + yingyu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a, a + n, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i].num &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; a[i].zongfen &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="宇宙总统"><a href="#宇宙总统" class="headerlink" title="宇宙总统"></a>宇宙总统</h1><h2 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h2><p>地球历公元 6036 年，全宇宙准备竞选一个最贤能的人当总统，共有 $n$ 个非凡拔尖的人竞选总统，现在票数已经统计完毕，请你算出谁能够当上总统。</p><h2 id="输入格式-5"><a href="#输入格式-5" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行为一个整数 $n$，代表竞选总统的人数。</p><p>接下来有 $n$ 行，分别为第一个候选人到第 $n$ 个候选人的票数。</p><h2 id="输出格式-5"><a href="#输出格式-5" class="headerlink" title="输出格式"></a>输出格式</h2><p>共两行，第一行是一个整数 $m$，为当上总统的人的号数。</p><p>第二行是当上总统的人的选票。</p><h2 id="样例-1-5"><a href="#样例-1-5" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-5"><a href="#样例输入-1-5" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">98765</span><br><span class="line">12365</span><br><span class="line">87954</span><br><span class="line">1022356</span><br><span class="line">985678</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-5"><a href="#样例输出-1-5" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1022356</span><br></pre></td></tr></table></figure><h2 id="提示-2"><a href="#提示-2" class="headerlink" title="提示"></a>提示</h2><p>票数可能会很大，可能会到 $100$ 位数字。</p><p>$1 \leq n \leq 20$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">xuehsneg</span></span><br><span class="line">&#123;</span><br><span class="line">string s;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">&#125;a[<span class="number">22</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span>  <span class="title">cmp</span><span class="params">(xuehsneg x, xuehsneg y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x.s.<span class="built_in">length</span>()!=y.s.<span class="built_in">length</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.s.<span class="built_in">length</span>() &gt; y.s.<span class="built_in">length</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x.s &gt; y.s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">cin.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line">cout.<span class="built_in">tie</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; a[i].s;</span><br><span class="line">a[i].num = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>, a +<span class="number">1</span>+ n,cmp);</span><br><span class="line">cout &lt;&lt; a[<span class="number">1</span>].num &lt;&lt; <span class="string">&quot;\n&quot;</span> &lt;&lt; a[<span class="number">1</span>].s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="USACO07DEC-Bookshelf-B"><a href="#USACO07DEC-Bookshelf-B" class="headerlink" title="[USACO07DEC] Bookshelf B"></a>[USACO07DEC] Bookshelf B</h1><h2 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h2><p>Farmer John 最近为奶牛们的图书馆添置了一个巨大的书架，尽管它是如此的大，但它还是几乎瞬间就被各种各样的书塞满了。现在，只有书架的顶上还留有一点空间。 </p><p>所有 $N(1 \le N \le 20,000)$ 头奶牛都有一个确定的身高 $H_i(1 \le H_i \le 10,000)$。设所有奶牛身高的和为S。书架的高度为B，并且保证 $1 \le B \le S &lt; 2,000,000,007$。 </p><p>为了够到比最高的那头奶牛还要高的书架顶，奶牛们不得不像演杂技一般，一头站在另一头的背上，叠成一座“奶牛塔”。当然，这个塔的高度，就是塔中所有奶牛的身高之和。为了往书架顶上放东西，所有奶牛的身高和必须不小于书架的高度。</p><p>显然，塔中的奶牛数目越多，整座塔就越不稳定，于是奶牛们希望在能够到书架顶的前提下，让塔中奶牛的数目尽量少。 现在，奶牛们找到了你，希望你帮她们计算这个最小的数目。</p><h2 id="输入格式-6"><a href="#输入格式-6" class="headerlink" title="输入格式"></a>输入格式</h2><ul><li>第 $1$ 行: 2 个用空格隔开的整数：$N$ 和 $B$；</li><li>第 $2\dots N+1$ 行: 第 $i+1$ 行是 $1$ 个整数：$H_i$。</li></ul><h2 id="输出格式-6"><a href="#输出格式-6" class="headerlink" title="输出格式"></a>输出格式</h2><ul><li>第 $1$ 行: 输出 $1$ 个整数，即最少要多少头奶牛叠成塔，才能够到书架顶部</li></ul><h2 id="样例-1-6"><a href="#样例-1-6" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-6"><a href="#样例输入-1-6" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 40</span><br><span class="line">6</span><br><span class="line">18</span><br><span class="line">11</span><br><span class="line">13</span><br><span class="line">19</span><br><span class="line">11</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-6"><a href="#样例输出-1-6" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="提示-3"><a href="#提示-3" class="headerlink" title="提示"></a>提示</h2><p>输入说明:</p><p>一共有 $6$ 头奶牛，书架的高度为 $40$，奶牛们的身高在 $6\dots19$之间。</p><p>输出说明:</p><p>一种只用 $3$ 头奶牛就达到高度 $40$ 的方法：$18+11+13$。当然还有其他方法，在此不一一列出了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10000000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin &gt;&gt; n&gt;&gt;m;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a, a + n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-1</span>; i &gt;=<span class="number">0</span> ; i--)</span><br><span class="line">&#123;</span><br><span class="line">m -= a[i];</span><br><span class="line">count++;</span><br><span class="line"><span class="keyword">if</span> (m&lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; count;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="车厢重组"><a href="#车厢重组" class="headerlink" title="车厢重组"></a>车厢重组</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个旧式的火车站旁边有一座桥，其桥面可以绕河中心的桥墩水平旋转。一个车站的职工发现桥的长度最多能容纳两节车厢，如果将桥旋转 $180$ 度，则可以把相邻两节车厢的位置交换，用这种方法可以重新排列车厢的顺序。于是他就负责用这座桥将进站的车厢按车厢号从小到大排列。他退休后，火车站决定将这一工作自动化，其中一项重要的工作是编一个程序，输入初始的车厢顺序，计算最少用多少步就能将车厢排序。</p><h2 id="输入格式-7"><a href="#输入格式-7" class="headerlink" title="输入格式"></a>输入格式</h2><p>共两行。  </p><p>第一行是车厢总数 $N( \le 10000)$。</p><p>第二行是 $N$ 个不同的数表示初始的车厢顺序。<br>（<strong>注</strong>：实际上数据中并不都在同一行，有可能分行输入）</p><h2 id="输出格式-7"><a href="#输出格式-7" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个整数，最少的旋转次数。</p><h2 id="样例-1-7"><a href="#样例-1-7" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-7"><a href="#样例输入-1-7" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">4 3 2 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-7"><a href="#样例输出-1-7" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, sum;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j)</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[i])</span><br><span class="line">                sum++;;</span><br><span class="line">    cout &lt;&lt; sum;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="欢乐的跳"><a href="#欢乐的跳" class="headerlink" title="欢乐的跳"></a>欢乐的跳</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>一个 $n$ 个元素的整数数组，如果数组两个连续元素之间差的绝对值包括了 $[1,n-1]$ 之间的所有整数，则称之符合“欢乐的跳”，如数组 ${1,4,2,3}$ 符合“欢乐的跳”，因为差的绝对值分别为：$3,2,1$。</p><p>给定一个数组，你的任务是判断该数组是否符合“欢乐的跳”。</p><h2 id="输入格式-8"><a href="#输入格式-8" class="headerlink" title="输入格式"></a>输入格式</h2><p>每组测试数据第一行以一个整数 $n(1 \le n \le 1000)$ 开始，接下来 $n$ 个空格隔开的在 $[-10^8,10^8]$ 之间的整数。</p><h2 id="输出格式-8"><a href="#输出格式-8" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组测试数据，输出一行若该数组符合“欢乐的跳”则输出 <code>Jolly</code>，否则输出 <code>Not jolly</code>。</p><h2 id="样例-1-8"><a href="#样例-1-8" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-8"><a href="#样例输入-1-8" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 1 4 2 3</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-8"><a href="#样例输出-1-8" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Jolly</span><br></pre></td></tr></table></figure><h2 id="样例-2-1"><a href="#样例-2-1" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-1"><a href="#样例输入-2-1" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 1 4 2 -1 6</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-1"><a href="#样例输出-2-1" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Not jolly</span><br></pre></td></tr></table></figure><h2 id="提示-4"><a href="#提示-4" class="headerlink" title="提示"></a>提示</h2><p>$1 \le n \le 1000$</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100000</span>];</span><br><span class="line"><span class="type">int</span> sum[<span class="number">1000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">sum[i] = <span class="built_in">abs</span>(a[i + <span class="number">1</span>] - a[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(sum, sum + n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (sum[i]!=sum[i+<span class="number">1</span>]<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Not jolly&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Jolly&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="NOIP2009-普及组-分数线划定"><a href="#NOIP2009-普及组-分数线划定" class="headerlink" title="[NOIP2009 普及组] 分数线划定"></a>[NOIP2009 普及组] 分数线划定</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>世博会志愿者的选拔工作正在 A 市如火如荼的进行。为了选拔最合适的人才，A 市对所有报名的选手进行了笔试，笔试分数达到面试分数线的选手方可进入面试。面试分数线根据计划录取人数的 $150%$ 划定，即如果计划录取 $m$ 名志愿者，则面试分数线为排名第 $m \times 150%$（向下取整）名的选手的分数，而最终进入面试的选手为笔试成绩不低于面试分数线的所有选手。</p><p>现在就请你编写程序划定面试分数线，并输出所有进入面试的选手的报名号和笔试成绩。</p><h2 id="输入格式-9"><a href="#输入格式-9" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，两个整数 $n,m(5 \leq n \leq 5000,3 \leq m \leq n)$，中间用一个空格隔开，其中 $n$ 表示报名参加笔试的选手总数，$m$ 表示计划录取的志愿者人数。输入数据保证 $m \times 150%$ 向下取整后小于等于 $n$。</p><p>第二行到第 $n+1$ 行，每行包括两个整数，中间用一个空格隔开，分别是选手的报名号 $k(1000 \leq k \leq 9999)$和该选手的笔试成绩 $s(1 \leq s \leq 100)$。数据保证选手的报名号各不相同。</p><h2 id="输出格式-9"><a href="#输出格式-9" class="headerlink" title="输出格式"></a>输出格式</h2><p>第一行，有 $2$ 个整数，用一个空格隔开，第一个整数表示面试分数线；第二个整数为进入面试的选手的实际人数。</p><p>从第二行开始，每行包含 $2$ 个整数，中间用一个空格隔开，分别表示进入面试的选手的报名号和笔试成绩，按照笔试成绩从高到低输出，如果成绩相同，则按报名号由小到大的顺序输出。</p><h2 id="样例-1-9"><a href="#样例-1-9" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-9"><a href="#样例输入-1-9" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">6 3 </span><br><span class="line">1000 90 </span><br><span class="line">3239 88 </span><br><span class="line">2390 95 </span><br><span class="line">7231 84 </span><br><span class="line">1005 95 </span><br><span class="line">1001 88</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-9"><a href="#样例输出-1-9" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">88 5 </span><br><span class="line">1005 95 </span><br><span class="line">2390 95 </span><br><span class="line">1000 90 </span><br><span class="line">1001 88 </span><br><span class="line">3239 88</span><br></pre></td></tr></table></figure><h2 id="提示-5"><a href="#提示-5" class="headerlink" title="提示"></a>提示</h2><p>【样例说明】</p><p>$m \times 150% &#x3D; 3 \times150% &#x3D; 4.5$，向下取整后为 $4$。保证 $4$ 个人进入面试的分数线为 $88$，但因为 $88$ 有重分，所以所有成绩大于等于 $88$ 的选手都可以进入面试，故最终有 $5$ 个人进入面试。</p><p>NOIP 2009 普及组 第二题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">jiego</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="type">int</span> fenshu;</span><br><span class="line">&#125;a[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(jiego x, jiego y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x.fenshu==y.fenshu)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> x.num &lt; y.num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> x.fenshu &gt; y.fenshu;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="type">int</span> t = <span class="built_in">int</span>(m * <span class="number">1.5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i].num &gt;&gt; a[i].fenshu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="type">int</span> fenshuxian = a[t].fenshu;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i].fenshu&gt;=fenshuxian)</span><br><span class="line">&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; fenshuxian &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; count &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a[i].fenshu &gt;= fenshuxian)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i].num &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; a[i].fenshu &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="攀爬者"><a href="#攀爬者" class="headerlink" title="攀爬者"></a>攀爬者</h1><h2 id="题目背景-1"><a href="#题目背景-1" class="headerlink" title="题目背景"></a>题目背景</h2><p>HKE 考完 GDOI 之后跟他的神犇小伙伴们一起去爬山。</p><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>他在地形图上标记了 $N$ 个点，每个点 $P_i$ 都有一个坐标 $(x_i,y_i,z_i)$。所有点对中，高度值 $z$ 不会相等。HKE 准备从最低的点爬到最高的点，他的攀爬满足以下条件：</p><p> (1) 经过他标记的每一个点；</p><p> (2) 从第二个点开始，他经过的每一个点高度 $z$ 都比上一个点高；</p><p> (3) HKE 会飞，他从一个点 $P_i$ 爬到 $P_j$ 的距离为两个点的欧几里得距离。即，$\sqrt{(X_i-X_j)^2+(Y_i-Y_j)^2+(Z_i-Z_j)^2}$</p><p>现在，HKE 希望你能求出他攀爬的总距离。</p><h2 id="输入格式-10"><a href="#输入格式-10" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行，一个整数 $N$ 表示地图上的点数。</p><p>接下来 $N$ 行，三个整数 $x_i,y_i,z_i$ 表示第 $i$ 个点的坐标。</p><h2 id="输出格式-10"><a href="#输出格式-10" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个实数，表示 HKE 需要攀爬的总距离（保留三位小数）</p><h2 id="样例-1-10"><a href="#样例-1-10" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-10"><a href="#样例输入-1-10" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 2 2</span><br><span class="line">1 1 1</span><br><span class="line">4 4 4</span><br><span class="line">3 3 3</span><br><span class="line">5 5 5</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-10"><a href="#样例输出-1-10" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6.928</span><br></pre></td></tr></table></figure><h2 id="提示-6"><a href="#提示-6" class="headerlink" title="提示"></a>提示</h2><p>对于100%的数据，$1\leq N\leq 50000$，答案的范围在 double 范围内。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">qwq</span><span class="comment">//qwq</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">&#125;a[<span class="number">50001</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(qwq x, qwq y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.z &lt; y.z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> ans;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a[i].x, &amp;a[i].y, &amp;a[i].z);</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">ans += <span class="built_in">sqrt</span>((a[i - <span class="number">1</span>].x - a[i].x) * (a[i - <span class="number">1</span>].x - a[i].x) + (a[i - <span class="number">1</span>].y - a[i].y) * (a[i - <span class="number">1</span>].y - a[i].y) + (a[i - <span class="number">1</span>].z - a[i].z) * (a[i - <span class="number">1</span>].z - a[i].z));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%.3lf&quot;</span>, ans);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="生日"><a href="#生日" class="headerlink" title="生日"></a>生日</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>cjf 君想调查学校 OI 组每个同学的生日，并按照年龄从大到小的顺序排序。但 cjf 君最近作业很多，没有时间，所以请你帮她排序。</p><h2 id="输入格式-11"><a href="#输入格式-11" class="headerlink" title="输入格式"></a>输入格式</h2><p>输入共有 $n + 1$ 行，</p><p>第 $1$ 行为 OI 组总人数 $n$；</p><p>第 $2$ 行至第 $n+1$ 行分别是每人的姓名 $s$、出生年 $y$、月 $m$、日 $d$。</p><h2 id="输出格式-11"><a href="#输出格式-11" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共有 $n$ 行，</p><p>即 $n$ 个生日从大到小同学的姓名。（如果有两个同学生日相同，输入靠后的同学先输出）</p><h2 id="样例-1-11"><a href="#样例-1-11" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-11"><a href="#样例输入-1-11" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">Yangchu 1992 4 23</span><br><span class="line">Qiujingya 1993 10 13</span><br><span class="line">Luowen 1991 8 1</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-11"><a href="#样例输出-1-11" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Luowen</span><br><span class="line">Yangchu</span><br><span class="line">Qiujingya</span><br></pre></td></tr></table></figure><h2 id="提示-7"><a href="#提示-7" class="headerlink" title="提示"></a>提示</h2><p>数据保证，$1&lt;n&lt;100$，$1\leq |s|&lt;20$。保证年月日实际存在，且年份 $\in [1960,2020]$。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">shengri</span></span><br><span class="line">&#123;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> yue;</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line">&#125;c[<span class="number">100000</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(shengri a, shengri b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a.n != b.n)</span><br><span class="line"><span class="keyword">return</span> a.n &lt; b.n;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a.yue != b.yue) <span class="keyword">return</span> a.yue &lt; b.yue;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a.r == b.r ) <span class="keyword">return</span> a.num &gt;b.num;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (a.r != b.r ) <span class="keyword">return</span> a.r &lt; b.r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; c[i].name &gt;&gt; c[i].n &gt;&gt; c[i].yue &gt;&gt; c[i].r;</span><br><span class="line">c[i].num = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(c, c + m,cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; c[i].name &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="NOIP1998-提高组-拼数"><a href="#NOIP1998-提高组-拼数" class="headerlink" title="[NOIP1998 提高组] 拼数"></a>[NOIP1998 提高组] 拼数</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>设有 $n$ 个正整数 $a_1 \dots a_n$，将它们联接成一排，相邻数字首尾相接，组成一个最大的整数。</p><h2 id="输入格式-12"><a href="#输入格式-12" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行有一个整数，表示数字个数 $n$。</p><p>第二行有 $n$ 个整数，表示给出的 $n$ 个整数 $a_i$。</p><h2 id="输出格式-12"><a href="#输出格式-12" class="headerlink" title="输出格式"></a>输出格式</h2><p>一个正整数，表示最大的整数</p><h2 id="样例-1-12"><a href="#样例-1-12" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-12"><a href="#样例输入-1-12" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">13 312 343</span><br></pre></td></tr></table></figure><h3 id="样例输出-1-12"><a href="#样例输出-1-12" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">34331213</span><br></pre></td></tr></table></figure><h2 id="样例-2-2"><a href="#样例-2-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2-2"><a href="#样例输入-2-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">7 13 4 246</span><br></pre></td></tr></table></figure><h3 id="样例输出-2-2"><a href="#样例输出-2-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7424613</span><br></pre></td></tr></table></figure><h2 id="提示-8"><a href="#提示-8" class="headerlink" title="提示"></a>提示</h2><p>对于全部的测试点，保证 $1 \leq n \leq 20$，$1 \leq a_i \leq 10^9$。</p><p>NOIP1998 提高组 第二题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string x,string y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y &gt; y + x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line">string a[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>,cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; a[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="世间温柔，不过是芳春柳摇染花香，槐序蝉鸣入深巷，白茂叶落醉故乡。"><a href="#世间温柔，不过是芳春柳摇染花香，槐序蝉鸣入深巷，白茂叶落醉故乡。" class="headerlink" title="世间温柔，不过是芳春柳摇染花香，槐序蝉鸣入深巷，白茂叶落醉故乡。"></a>世间温柔，不过是芳春柳摇染花香，槐序蝉鸣入深巷，白茂叶落醉故乡。</h1>]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>美赛论文</title>
      <link href="/2024/01/30/%E7%BE%8E%E8%B5%9B%E8%AE%BA%E6%96%87/"/>
      <url>/2024/01/30/%E7%BE%8E%E8%B5%9B%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h1><h2 id="第一段：写论文解决什么问题-1．-问题的重述"><a href="#第一段：写论文解决什么问题-1．-问题的重述" class="headerlink" title="第一段：写论文解决什么问题 1．**  问题的重述"></a>第一段：写论文解决什么问题 <strong>1</strong>．**  问题的重述</h2><ol><li><h3 id="介绍重点词开头："><a href="#介绍重点词开头：" class="headerlink" title="介绍重点词开头："></a>介绍重点词开头：</h3></li></ol><blockquote><p>例 1：“Hand move” irrigation, a cheap but labor-intensive system used on small farms, consists of a movable pipe with sprinkler on top that can be attached to a stationary main. </p><p>“手动移动”灌溉是一种在小农场上使用的廉价但劳动密集型的系统，它包括一个可移动的管道，顶部配有喷头，可以连接到固定的主干上。</p><p>例 2:……is a real-life common phenomenon with many complexities. </p><p>是一个现实生活中常见且涉及许多复杂因素的现象。</p><p>例 3：An (effective plan) is crucial to……… </p><p>（一个有效的计划）对于……至关重要。</p></blockquote><ol start="2"><li><h3 id="直接指出问题："><a href="#直接指出问题：" class="headerlink" title="直接指出问题："></a>直接指出问题：</h3></li></ol><blockquote><p>例  1：We find the optimal number of tollbooths in a highway toll-plaza for a given number of highway lanes: the number of tollbooths that minimizes average delay experienced by cars.  </p><p>我们找到了在给定高速公路车道数量的情况下，收费站的最佳收费亭数量：使汽车经历的平均延迟最小化的收费亭数量。</p><p>例 2：A brand-new university needs to balance the cost of information technology security measures with the potential cost of attacks on its systems. </p><p>一个全新的大学需要在信息技术安全措施的成本与系统遭受攻击的潜在成本之间取得平衡。</p><p>例 3：We determine the number of sprinklers to use by analyzing the energy and motion of water in the pipe and examining the engineering parameters of sprinklers available in the market. </p><p>我们通过分析管道中水的能量和运动以及检查市场上可用的喷头的工程参数来确定使用的喷头数量。</p><p>例 4: After mathematically analyzing the …… problem, our modeling group would like to present our conclusions, strategies, (and recommendations )to the ……. </p><p>在数学分析了……问题之后，我们的建模团队希望向……呈现我们的结论、策略（和建议）。</p><p>例 5：Our goal is… that (minimizes the time )………. <strong>2</strong>．**  解决这个问题的伟大意义</p><p>我们的目标是……以（最小化时间）……的方式。解决这个问题具有重要的意义。</p><p>反面说明。如果没有…… </p><p>Without implementing defensive measure, the university is exposed to an expected loss of $8.9 million per year. </p><p>如果不实施防御措施，该大学每年将面临预计损失890万美元。</p></blockquote><h3 id="3．-总的解决概述"><a href="#3．-总的解决概述" class="headerlink" title="3．**  总的解决概述"></a><strong>3</strong>．**  总的解决概述</h3><blockquote><h4 id="a．通过什么方法解决什么问题"><a href="#a．通过什么方法解决什么问题" class="headerlink" title="a．通过什么方法解决什么问题"></a>a．通过什么方法解决什么问题</h4><p>例：We address the problem of optimizing amusement park enjoyment through distributing Quick Passes (QP), reservation slips that ideally allow an individual to spend less time waiting in line. </p><p>我们着手解决通过分发“快速通行券”（QP）来优化游乐园乐趣的问题，这些预约券理想情况下能够让个人在排队等候时花费更少的时间。</p><h4 id="b．实际问题转化为数学模型"><a href="#b．实际问题转化为数学模型" class="headerlink" title="b．实际问题转化为数学模型"></a>b．实际问题转化为数学模型</h4><p>例 1 We formulate the problem asa network flow in which vertices are the locations of escorts and wheelchair passengers. </p><p>我们将问题表述为一个网络流问题，其中顶点是护送人员和轮椅乘客的位置。</p><p>例 2 : A naïve strategy would be to employ the minimum number of escorts to guarantee that all passengers reach their gates on time. </p><p>一个天真的策略是雇佣最少数量的护送人员，以确保所有乘客准时到达他们的登机门。</p><h4 id="c-将问题分阶段考虑"><a href="#c-将问题分阶段考虑" class="headerlink" title="c.将问题分阶段考虑"></a>c.将问题分阶段考虑</h4><p>例 3：We divide the jump into three phases: flying through the air, punching through the stack, and landing on the ground. </p><p>我们将跳跃分为三个阶段：在空中飞翔，穿过障碍物，以及在地面着陆。</p></blockquote><h2 id="第二、三段：具体分析"><a href="#第二、三段：具体分析" class="headerlink" title="第二、三段：具体分析"></a>第二、三段：具体分析</h2><h3 id="1．在什么模型中-建立了什么模型"><a href="#1．在什么模型中-建立了什么模型" class="headerlink" title="1．在什么模型中**&#x2F;**  建立了什么模型"></a><strong>1</strong>．在什么模型中**&#x2F;**  建立了什么模型</h3><blockquote><ol><li><h4 id="主流模型"><a href="#主流模型" class="headerlink" title="主流模型"></a>主流模型</h4></li></ol><p>例 1：We formulate a differential model to account for the rates of change of these uses, and how this change would affect the overall consumption of water within the studied region.<br>我们建立了一个微分模型，考虑了这些用途的变化速率，以及这种变化对所研究地区整体用水的影响。</p><p>例 2: We examined the mathematical effects of……. We developed a detailed …… (simulation methodology) to test our ideas and to quantify the differences between (among) different …… (strategies).<br>我们研究了……的数学影响。我们制定了详细的……（模拟方法）来测试我们的想法，并量化不同的……（策略）之间的差异。</p><p>例 3：Based on (write your basis .such as the theory of supply and demand), we establish a model (such as differential equation system that includes demand, supply).<br>基于（写出你的基础，如供需理论），我们建立了一个模型（如包括需求和供给的微分方程系统）。</p><p>例 4：To (write the aims), we establish a criterion (write the criterion).<br>为了（写明目标），我们建立了一个标准（写明标准）。</p><ol start="2"><li><h4 id="模型非主流"><a href="#模型非主流" class="headerlink" title="模型非主流"></a>模型非主流</h4></li></ol><p>例 5：We build a model to determine how to lay out the pipe each time the equipment is moved.<br>我们建立一个模型，确定每次移动设备时如何布置管道。</p><p>例 6：We determine the optimal allocation of resources based on a cost-benefit analysis.<br>我们通过成本效益分析确定资源的最优配置。</p><p>例 7：We build a model to determine the most efficient route for transportation in a logistics network.<br>我们建立了一个模型，确定物流网络中运输的最有效路径。</p><p>例 8：We formulate a model for predicting market trends. By analyzing historical data and examining current market conditions, we aim to make accurate forecasts.<br>我们制定了一个预测市场趋势的模型。通过分析历史数据和审查当前市场状况，我们旨在做出准确的预测。</p></blockquote><h3 id="2．分析模型（使用什么数据，怎么做，一般三句话）"><a href="#2．分析模型（使用什么数据，怎么做，一般三句话）" class="headerlink" title="2．分析模型（使用什么数据，怎么做，一般三句话）"></a><strong>2</strong>．分析模型（使用什么数据，怎么做，一般三句话）</h3><blockquote><ol><li>写历史数据</li></ol><p>例 1：Using historical data from theUnited States, we determine initial conditions for our model. </p><p>利用来自美国的历史数据，我们确定了我们模型的初始条件。</p><ol start="2"><li>写计算机模拟<br>例 1：This model leads to a computer simulation of catch-can tests of the irrigation system and …… 这个模型导致了灌溉系统的截流罐测试的计算机模拟以及……</li></ol><p>例 2: Software packing reaches………by calculating and comparing………. 通过计算和比较，软件打包达到了………。</p><ol start="3"><li>运用数据模拟</li></ol><p>例 1：To ground this model in reality, we incorporate extensive demographic data and run……<br>为了使这个模型贴近现实，我们加入了大量的人口统计数据并进行了……</p><p>例 2：We fit the modified model to data (such as 1970-2003.). We conclude that (write the last conclude).<br>我们将修改后的模型拟合到数据中（例如1970-2003年）。我们得出的结论是（写出最后的结论）。</p><p>例 3：We analyze the environmental impact of the proposed construction project. By considering factors such as air and water quality, we aim to provide comprehensive insights.<br>我们分析了拟议建设项目的环境影响。通过考虑空气和水质等因素，我们旨在提供全面的见解。</p><ol start="4"><li>讲详细分析</li></ol><p>例 1：We physically characterize the system that…<br>我们对这个系统进行物理特性的表征……</p><p>例 2：We provide a strategy (write the logical strategy).<br>我们提供了一种策略（写出逻辑策略）。</p><p>例 3：The …model is (efficient, intuitive, and flexible) and could be applied to…<br>这个……模型是（高效、直观、灵活）的，可以应用于……</p><p>例 4：To meet the needs of people today without, we establish a criterion of rational oil allocation.<br>为了满足当今人们的需求，我们建立了合理的石油分配标准。</p></blockquote><h3 id="3．总结该模型的结果-得到什么结论"><a href="#3．总结该模型的结果-得到什么结论" class="headerlink" title="3．总结该模型的结果**&#x2F;**得到什么结论"></a><strong>3</strong>．总结该模型的结果**&#x2F;**得到什么结论</h3><blockquote><h4 id="a-说明不是最优但能产生作用"><a href="#a-说明不是最优但能产生作用" class="headerlink" title="a.说明不是最优但能产生作用"></a>a.说明不是最优但能产生作用</h4><p>例：We show that this strategy is not optimal but can be improved by assigning different numbers…… </p><p>我们表明这个策略并非最优的，但可以通过分配不同的数量进行改进。</p><h4 id="b-说明如果用这个模型，结果如何"><a href="#b-说明如果用这个模型，结果如何" class="headerlink" title="b.说明如果用这个模型，结果如何"></a>b.说明如果用这个模型，结果如何</h4><p>例 1：If Delta Airlines were to utilize the naïve strategy at Atlanta International Airport, the cost would be ……<br>如果达美航空公司在亚特兰大国际机场采用天真的策略，成本将是……</p><p>例 2：We modify the model to reflect (some trend such as exponentially increasing……) and generalize the model to (other field).<br>我们修改模型以反映（某种趋势，如呈指数增长……），并将模型推广到（其他领域）。</p><p>例 3：Our results are summarized in the formula for the optimal number B of tollbooths for…<br>我们的结果总结在寻找最佳收费亭数量 B 的公式中。</p><h4 id="c．通过其上情况的列举得到的结论"><a href="#c．通过其上情况的列举得到的结论" class="headerlink" title="c．通过其上情况的列举得到的结论"></a>c．通过其上情况的列举得到的结论</h4><p>例：For various situations, we propose an optimal solution. </p><p>针对各种情况，我们提出了一个最优解决方案。</p><h4 id="d-得出了结论"><a href="#d-得出了结论" class="headerlink" title="d. 得出了结论"></a>d. 得出了结论</h4><p>例 1：we elicit that a conclusion. </p><p>例 2：We conclude with a series of recommendations for how best to… </p><p>例 1：We elicit a conclusion from that.<br>我们从中得出一个结论。</p><p>例 2：We conclude with a series of recommendations for how best to…<br>我们以一系列建议总结，以确定最佳做法……</p><h4 id="e-进一步说明其他因素对模型的影响"><a href="#e-进一步说明其他因素对模型的影响" class="headerlink" title="e.进一步说明其他因素对模型的影响"></a>e.进一步说明其他因素对模型的影响</h4><p>例：In addition to the model, we also discuss policies for ….. </p><p>除了模型之外，我们还讨论了关于……的政策。</p><h4 id="f-用真实数据检验模型"><a href="#f-用真实数据检验模型" class="headerlink" title="f.用真实数据检验模型"></a>f.用真实数据检验模型</h4><p>例:To demonstrate how our model works, we apply it to ……….. </p><p>为了展示我们的模型如何工作，我们将其应用于……。</p></blockquote><h2 id="最后一段：写总的结论"><a href="#最后一段：写总的结论" class="headerlink" title="最后一段：写总的结论"></a>最后一段：写总的结论</h2><blockquote><p> a. 说明结论的可行性</p><p>例：Our suggested solution, which is easy to implement, includes a detailed timetable and the arrangement of pipes. </p><p>例：我们提出的解决方案易于实施，包括详细的时间表和管道布置。</p><p>b.说明算法的广泛性</p><p>例 1：Our algorithm is broad enough to accommodate various airport concourses, flight schedules, and flight delays. </p><p>我们的算法足够广泛，可以适应各种机场廊道、航班时间表和航班延误。</p><p>例 2：Our analysis began by determining what factor impact……, Our conclusions are presented…… </p><p>我们的分析始于确定哪些因素影响……，我们的结论呈现在……。</p><p>c.说明模型可用于其他领域</p><p>例：Since our model is based on…… it can be applied to (other domain). 其他（承上启下的连接词&#x2F;常用词组）</p><p>由于我们的模型基于……，它可以应用于（其他领域）。</p><p>例:In addition to the model, we also discuss…… </p><p>例：除了模型之外，我们还讨论了……。</p></blockquote><h1 id="引言部分"><a href="#引言部分" class="headerlink" title="引言部分"></a>引言部分</h1><blockquote><p>（1）回顾研究背景，常用词汇有 <strong>review, summarize, present, outline, describe</strong> 等 </p><p>（2）说明写作目的，常用词汇有 <strong>purpose, attempt, aim</strong> 等，另外还可以用动词不定式充当</p><p>目的状语来表达</p><p>（3）介绍论文的重点内容或研究范围，常用词汇有 <strong>study, present, include, focus, emphasize, emphasis, attention</strong> 等 </p></blockquote><h2 id="方法部分"><a href="#方法部分" class="headerlink" title="方法部分"></a>方法部分</h2><blockquote><p>（1）介绍研究或试验过程，常用词汇有 <strong>test study, investigate, examine, experiment, discuss, consider, analyze, analysis</strong> 等 </p><p>（2）说明研究或试验方法，常用词汇有 <strong>measure, estimate, calculate</strong> 等 （3）介绍应用、用途，常用词汇有等</p></blockquote><h2 id="结果部分"><a href="#结果部分" class="headerlink" title="结果部分"></a>结果部分</h2><blockquote><p>（1）展示研究结果，常用词汇有 <strong>show, result, present</strong> 等 </p><p>（2）介绍结论，常用词汇有 <strong>summary, introduce, conclude</strong> 等 </p></blockquote><h2 id="讨论部分"><a href="#讨论部分" class="headerlink" title="讨论部分"></a>讨论部分</h2><blockquote><p>（1）陈述论文的论点和作者的观点，常用词汇有 <strong>suggest, repot, present, expect, describe</strong> 等 </p><p>（2）说明论证，常用词汇有等 <strong>support, provide, indicate, identify, find, demonstrate, confirm,</strong> <strong>clarify</strong> </p><p>（3）推荐和建议，常用词汇有 <strong>suggest, suggestion, recommend, recommendation, propose, necessity, necessary, expect</strong> 等。 </p></blockquote><blockquote><p>摘要中常用的词语汇： </p><p>critical  至关重要的 </p><p>algorithm  运算法则 </p><p>a method of evaluating  评价方法 appropriate  近似的 </p><p>consider  考虑 </p><p>configurations  布局 </p><p>optimal  统一的 </p><p>maximize  使…最大化 </p><p>strategy  策略 </p><p>parameter  参数，主要的决定因素 accuracy  精确性 </p><p>strengths and weaknesses  优点和缺点</p><p>contact  相关的 </p><p>contract  建立，构造 </p><p>calculate  计算 </p><p>establish  建立 </p><p>formula  公式 </p><p>modify  改进 </p><p>rational  合理的 </p><p>countermeasure  对策 </p><p>criterion  标准，准则 </p><p>Assumptions 假设</p></blockquote><h2 id="引出："><a href="#引出：" class="headerlink" title="引出："></a>引出：</h2><blockquote><p>We make the following assumptions about……process in this paper. </p><p>在本文中，我们对……过程做出以下假设。</p><h3 id="1-a-不考虑因素"><a href="#1-a-不考虑因素" class="headerlink" title="1.  a.  不考虑因素"></a>1.  <strong>a.</strong>  不考虑因素</h3><p>例 1：We make the following assumptions about the process of …… in this paper. </p><p>我们在本文中对……的过程做出以下假设：我们没有考虑因素之间的相互作用。</p><p>例 2：The influence of …can be neglected</p><p>. …的影响可以忽略不计。</p><p>例 3：…is “ideal” in …, …can be neglected. </p><p>在……方面是“理想的”，可以忽略不计。</p><h3 id="1-b-为了简化模型，之后反驳不正确，但是合理。"><a href="#1-b-为了简化模型，之后反驳不正确，但是合理。" class="headerlink" title="1.  b.  为了简化模型，之后反驳不正确，但是合理。"></a>1.  <strong>b.</strong>  为了简化模型，之后反驳不正确，但是合理。</h3><p>例 1：In fact (in reality), factors affect each other, but in order to simplify the model, we ignore the interactions between factors. </p><p>实际上，各因素之间存在相互影响，但为了简化模型，我们忽略了它们之间的相互作用。</p><p>例 2：In fact, in reality, factors affect each other, but in order to simplify the model, we ignore the interactions between factors. </p><p>实际上，各因素之间存在相互影响，但为了简化模型，我们忽略了它们之间的相互作用。</p><h3 id="c-近似"><a href="#c-近似" class="headerlink" title="c. 近似"></a><strong>c.</strong> 近似</h3><p>Example 1: “…can be approximated as a linear function of…”</p><p> 例 1：”…可以近似看作是…的线性函数。”</p><p>Example 2: “…are assumed to be the same. In practice, there is a slight difference.” </p><p>例 2：”…被假设为相同。实际上，存在轻微差异。”</p><p>Example 3: “…can be approximated as a linear function of…” </p><p>例 3：”…可以近似看作是…的线性函数。”</p><h3 id="d-细致考虑（可附原因）"><a href="#d-细致考虑（可附原因）" class="headerlink" title="d. 细致考虑（可附原因）"></a><strong>d.</strong> 细致考虑（可附原因）</h3><p>Example 1: An airport consists of 1 to 10 concourses, each of which consists of 2 to 50 gates. Gates in the same concourse are generally located close to one another, while the travel time between concourses can be quite lengthy. Hence, we assume that inter-concourse travel is much lengthier than intra-concourse travel.</p><p>例 1：一个机场由1到10个航站楼组成，每个航站楼有2到50个登机口。同一航站楼的登机口通常彼此靠近，而航站楼之间的旅行时间可能相当长。因此，我们假设航站楼之间的旅行时间比航站楼内部的旅行时间长得多。</p><p>Example 2: An average fast walking speed is 250ft&#x2F;min (3mph), but the average speed when arms are immobilized (as when pushing a wheelchair) is only 180 ft&#x2F;min (2 mph) [Gross and Shi 2001]. We assume that an escort walks at these speeds.</p><p>例 2：普通快步行走速度为250英尺&#x2F;分钟（3英里&#x2F;小时），但当手臂无法动弹时（比如推轮椅时）的平均速度仅为180英尺&#x2F;分钟（2英里&#x2F;小时）[Gross and Shi 2001]。我们假设护送人员以这些速度行走。</p><p>Example 3: An escort can operate only one wheelchair at a time. U.S. Dept. of Transportation guidelines discourage leaving wheelchairs unattended. Hence, the escort takes a wheelchair passenger to the connecting flight and remains until the flight leaves.</p><p>例 3：一名护送人员一次只能操作一台轮椅。美国交通部的指南不鼓励让轮椅无人看管。因此，护送人员会将轮椅乘客带到连接的航班，并一直待到飞机起飞。</p><h3 id="e-直接定义-假设-："><a href="#e-直接定义-假设-：" class="headerlink" title="**e.直接定义(假设)**："></a>**e.<strong>直接定义</strong>(<strong>假设</strong>)**：</h3><p>例 1：To measure the……,we define……</p><p>为了衡量……，我们定义……</p><p>例 2：Yearly industry statistics can be used valid.</p><p>年度行业统计数据可以被有效使用。</p><p>例 3：Sth may be represented by</p><p>某物可以被表示为</p><p>例 4：….are independent and randomly distributed </p><p>……是独立且随机分布的</p><p>Additional assumptions are made to simplify analysis for individual sections. These assumptions will be discussed at the appropriate locations.</p><p>总结：为了简化各个部分的分析，我们做出了额外的假设。这些假设将在适当的地方进行讨论。</p></blockquote><h2 id="引用的文献数据所画的图："><a href="#引用的文献数据所画的图：" class="headerlink" title="引用的文献数据所画的图："></a>引用的文献数据所画的图：</h2><blockquote><h3 id="1、分阶段图的引入："><a href="#1、分阶段图的引入：" class="headerlink" title="1、分阶段图的引入："></a>1、分阶段图的引入：</h3><p>First we study the …… (文献)，showing …… under the situation. </p><p>首先我们研究……（文献），展示在这种情况下的……。</p><h3 id="分阶段图的引出："><a href="#分阶段图的引出：" class="headerlink" title="分阶段图的引出："></a>分阶段图的引出：</h3><p>The compression process is divided into three(数字) phases, as shown in the figure: </p><p>The first phase: …… deformation, according to ……; the second phase: …… deformation. The compression grows more slowly and reaches the maximum. The third phase: ……deformation: After compression reaches the maximum, the rate of deformation starts to fall. The unrecoverable deformation goes on increasing. (2003—65) </p><p>第一阶段：……变形，根据……；第二阶段：……变形。压缩速度变慢并达到最大值。第三阶段：……变形：在压缩达到最大值后，变形速率开始下降。不可恢复的变形继续增加。（2003—65）</p><h3 id="2、引用已有的模型图："><a href="#2、引用已有的模型图：" class="headerlink" title="2、引用已有的模型图："></a>2、引用已有的模型图：</h3><p>A model of flow rate for instant total failure is right triangular  【U.S. Army Corps of Engineers 1997】. (see Figure 1)(2005—53\54) </p><p>瞬时总失效的流量率模型是右三角形【美国陆军工程兵 1997】。（见图1）（2005—53\54）</p><h3 id="3、通过历史数据作图："><a href="#3、通过历史数据作图：" class="headerlink" title="3、通过历史数据作图："></a>3、通过历史数据作图：</h3><p>We validate our model by examining historical HIV rates from prenatal clinics inSouth Africabetween 1995 and 2005(Figure 1). (2006—244) </p><p>我们通过检查南非产前诊所在1995年至2005年间的历史HIV感染率来验证我们的模型（见图1）。（2006—244）</p><h3 id="4、拟合的图形："><a href="#4、拟合的图形：" class="headerlink" title="4、拟合的图形："></a>4、拟合的图形：</h3><p>Figure 1 shows the number of bags still left for the EDS to process at airport A after each minute in airport B, the results are similar. (2003—260) </p><p>图1显示了在机场B每分钟后机场A的EDS仍有多少袋要处理，结果是相似的。（2003—260）</p></blockquote><h2 id="自己根据计算所画的图："><a href="#自己根据计算所画的图：" class="headerlink" title="自己根据计算所画的图："></a>自己根据计算所画的图：</h2><blockquote><h3 id="1、为了……-目的-，我们作了……-图。"><a href="#1、为了……-目的-，我们作了……-图。" class="headerlink" title="1、为了…….(目的)，我们作了…….图。"></a>1、为了…….(目的)，我们作了…….图。</h3><p>To demonstrate better the change in flow rate with time when the breach begins t form, we plot over a shorter range of time in Figure 5. (2005—55) </p><p>We plot for values of from 6 to 13, in steps of 0.25, together with the best-fit quartic, in Figure 2 (2005—92) </p><p>为了更好地展示当破口开始形成时流量随时间的变化，我们在图5中绘制了一个较短的时间范围。</p><p>我们在图2中绘制了从6到13的数值，步长为0.25，并与最佳拟合的四次函数一起绘制出来。</p><h3 id="2、根据数据拟合的图："><a href="#2、根据数据拟合的图：" class="headerlink" title="2、根据数据拟合的图："></a>2、根据数据拟合的图：</h3><p>Fitting (式子) to the data in (表), we get the curve in Figure 1, for the function (公式). (2005—211) </p><p>We use the graph in Figure 1 to simulate the arrival of passengers. (2003—201) </p><p>The simulation model also generates system characteristics for the ETD machines at airport A. These results are shown in Figure 3. (2003—232) </p><p>将（式子）拟合到（表）中的数据，我们得到了图1中的曲线，用于表示函数（公式）。 （2005—211）</p><p>我们利用图1中的图形模拟乘客的到达。 （2003—201）</p><p>模拟模型还生成了机场A的ETD机器的系统特性。 这些结果显示在图3中。 （2003—232）</p><h3 id="3、根据取值不同画图："><a href="#3、根据取值不同画图：" class="headerlink" title="3、根据取值不同画图："></a>3、根据取值不同画图：</h3><p>We take 2001as the starting point, when total remaining oil was 1.1178bbl.We calculate the time to oil exhaustion under different cases: GDP growing at 10%, 5%, 3%,and 1%.(Figure 3) </p><p>For 10%, …… ; for 5%,……;for 3%,……;for 1%,……. (2005—213\233) </p><p>我们以2001年为起点，当时剩余总石油量为1.1178亿桶。我们在不同情况下计算石油枯竭的时间：GDP增长率分别为10％、5％、3％和1％。（图3）</p><p>对于10%，……；对于5%，……；对于3%，……；对于1%，……。 （2005—213\233）</p><h3 id="4、用软件（如-MATLAB）画图："><a href="#4、用软件（如-MATLAB）画图：" class="headerlink" title="4、用软件（如 MATLAB）画图："></a>4、用软件（如 MATLAB）画图：</h3><p>To solve the differential equations in our model, we use (the ODE45 numerical integrator) in MATLAB on (式子) to find the results in Figure 3.(2005—232) </p><p>为了解决我们模型中的微分方程，我们在MATLAB中使用ODE45数值积分器，作用在（式子）上，得到图3中的结果。 （2005—232）</p><h3 id="5、图形的改进："><a href="#5、图形的改进：" class="headerlink" title="5、图形的改进："></a>5、图形的改进：</h3><p>Generally speaking, the shape of the target is not too irregular, so we choose five typical shapes of the targets in different sizes. In Figure3a, we illustrate the maximum section of a typical bean-shaped target, whose maximum dimension is35mm. Using the skeleton generation algorithm, we get corresponding skeleton shown in Figure 3b. Then we apply the GA-based shot placement algorithm, resulting in three shots for the target: one14 mmhelmet and two8 mmhelmets. The locations and sizes of the helmets in 2D are indicated in Figure3c, while 3D shot placements are shown in Figure 4. (2003—130) </p><p>总体而言，目标的形状不会太不规则，因此我们选择了五种不同大小的典型目标形状。在图3a中，我们展示了一个典型的豆形目标的最大截面，其最大尺寸为35毫米。使用骨架生成算法，我们得到相应的骨架，如图3b所示。然后我们应用基于遗传算法的射击位置算法，得到了目标的三个射击点：一个14毫米头盔和两个8毫米头盔。头盔在2D中的位置和大小如图3c所示，而3D射击点显示在图4中。 （2003—130）</p><h3 id="6、画示意图："><a href="#6、画示意图：" class="headerlink" title="6、画示意图："></a>6、画示意图：</h3><p>The irrigation order and position of sprinklers are presented in Figure 4. (2006—127) </p><p>This algorithm can be viewed in the flowchart in Figure 3.We define some of the objects found in the chart. (2006—164\165) </p><p>灌溉的顺序和喷头的位置显示在图4中。 （2006—127）</p><p>该算法可以在图3的流程图中看到。我们定义了图表中找到的一些对象。 （2006—164\165）</p></blockquote><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><blockquote><p>表的格式：表头在上（注：红色字体的句子可通用）</p></blockquote><h2 id="1、-在表前对表的来源和数据进行说明"><a href="#1、-在表前对表的来源和数据进行说明" class="headerlink" title="1、**  在表前对表的来源和数据进行说明"></a><strong>1</strong>、**  在表前对表的来源和数据进行说明</h2><blockquote><p>例 <strong>1</strong> In <strong>Table 1</strong>, we summarize the minimum number of escorts needed to reach each service level </p><p>在<strong>表格1</strong>中，我们总结了达到每个服务水平所需的最少护送人员数量。</p><p>表的解释部分</p><p>For each airport, the difference between the Good and Adequate service levels is roughly a factor of two, with slightly increasing returns to scale; with larger scales, the staff are spread more uniformly, so it is less likely that a job will crop up with nobody close enough to take it. </p><p>对于每个机场，良好和足够服务水平之间的差异大约是两倍，而且存在稍微递增的规模收益；随着规模的扩大，工作人员分布更均匀，因此较大规模下出现无人能够及时处理的工作的可能性较小。</p><p>例 <strong>2</strong> </p><p>表的解释部分 （前面的说出数据的来源，然后筛选出比较代表性的数据进行说明）。</p><p>We determined absolute and relative criticality values for each country for which all the data used in computing parameters was available(108 countries). We then used relative criticality in selecting our most critical countries, by continent. Had we used absolute criticality it would have given precedence to large nations, despite relatively mild HIV&#x2F;AIDS situations. </p><p>我们确定了每个国家的绝对和相对关键性值，对于其中所有用于计算参数的数据都是可用的国家！（108个国家）然后，我们使用相对关键性在选择每个大洲的最关键国家时。如果我们使用了绝对关键性，它会优先考虑规模较大的国家，尽管其HIV&#x2F;AIDS情况相对较轻。</p><p>例 <strong>4</strong>:</p><p>The table below is the generated irrigation schedule for the repositioning of the sprinklers, given a 12-hour workday for a rancher. Each pipe is set in place for 5 hours.</p><p>下表是为重新调整喷头位置生成的灌溉计划，为牧场主提供了12小时的工作日。每个管道在位5小时。</p><p>例 <strong>5</strong>:</p><p>And after some data processing, we can obtain relevant statistical information about patient and donor characteristics for the simulation.</p><p>经过一些数据处理，我们可以获取有关患者和供体特征的模拟的相关统计信息。</p><p>The graft survival rates show in the following UNOS data for kidney transplants in the U.S (based on OPTN data as of 2006):</p><p>以下是美国肾脏移植的UNOS数据中显示的移植物存活率（基于截至2006年的OPTN数据）：</p></blockquote><h2 id="2、在表后对表的内容进行说明"><a href="#2、在表后对表的内容进行说明" class="headerlink" title="2、在表后对表的内容进行说明"></a><strong>2</strong>、在表后对表的内容进行说明</h2><blockquote><h3 id="例-1"><a href="#例-1" class="headerlink" title="例 1"></a>例 1</h3><p>Using the cellular automata model, we compute waiting time as a function of both the number of lanes and the number of tollbooths. For a fixed L, we compare all values of Ctotal and choose the lowest one. The results of this method are presented in Table6. </p><p>According to the above data, we can see that many of the European countries have the high rates of the donor, particularly inSpain. This phenomenon shows that the organ transplant is also hot inEurope. Although the relevant policies and statutes in these countries are less comprehensive than that in U.S, there still a lot what U.S could learn from. Here, we mainly analyze the organ transplant policies inSpain, U.K andKoreathis three countries. </p><p>使用元胞自动机模型，我们计算等待时间作为车道数和收费亭数的函数。对于固定的L，我们比较所有Ctotal的值并选择最低的一个。该方法的结果呈现在Table6中。</p><p>根据上述数据，我们可以看到许多欧洲国家的器官捐赠率很高，尤其是在西班牙。这一现象表明器官移植在欧洲也很热门。尽管这些国家的相关政策和法规不如美国全面，但美国仍然可以从中学到很多。在这里，我们主要分析了西班牙、英国和韩国这三个国家的器官移植政策。</p><p>……The population contained in each region is summarized in table </p><p>……每个地区的人口总数见表格。</p><h3 id="例-2"><a href="#例-2" class="headerlink" title="例 2"></a>例 2</h3><p>图表的解释部分 </p><p>As indicated in Table 6, there is fairly good agreement between the recommended number of booths for a typical day and for peak hours. However, we note that the optimal booth number for a typical day never exceeds that for rush hour. Rush hour seems to require slightly more booths than a typical day in order for the plaza to operate most efficiently. </p><p>Each value in Table 6 is representative of approximately 20 trials. Through these trials, we noted a remarkable stability in our model. Despite the stochastic nature of our algorithm, each number of lanes was almost always optimized to the same number of tollbooths. There were a handful of exceptions; they occurred exclusively for small numbers of highway lanes (&lt; 3 lanes). Integer values are presented in Table 6 only because fractional tollbooths have no physical meaning. </p><p>如表6所示，对于典型日和高峰小时，建议的收费亭数量之间存在相当好的一致性。然而，我们注意到典型日的最佳收费亭数量从未超过高峰小时的数量。高峰小时似乎需要稍多的收费亭才能使收费站运作最有效。</p><p>表6中的每个值代表大约20次试验的结果。通过这些试验，我们注意到模型的稳定性非常显著。尽管我们的算法具有随机性质，但每个车道数几乎总是优化到相同的收费亭数量。有少数例外情况；这些例外情况仅发生在高速公路车道较少的情况下（&lt; 3条车道）。表6中只呈现整数值，因为分数的收费亭没有物理意义。</p></blockquote><h2 id="3、表前表后有引入引出-，且中间对两表之间进行比较"><a href="#3、表前表后有引入引出-，且中间对两表之间进行比较" class="headerlink" title="3、表前表后有引入引出**  ，且中间对两表之间进行比较"></a><strong>3</strong>、表前表后有引入引出**  ，且中间对两表之间进行比较</h2><blockquote><p>例 <strong>1</strong> </p><p>表的解释部分 </p><p>We can obtain the data which is involved with the status of the American Organ </p><p>Transplant from the data banks. We have collected the demand of the various organs in United States to date, the annual donors，transplants and the demand (Here taking the kidney for example, by years 1995-2006) </p><p>From the above table1, we can see that the kidney accounts for 73% in the </p><p>total of the organ transplants. It accounts for a very large proportion as a most important organ which can be transplanted. Therefore, we only need to discuss the status of the kidney transplant here, being able to achieve the analysis and research on the organ transplant. </p><p>According to the above data, we can get the figures as follow: </p><p>我们可以从数据库中获取与美国器官移植状况有关的数据。我们已经收集了迄今为止在美国各器官的需求，年度的捐赠者、移植和需求（这里以肾脏为例，时间范围为1995年至2006年）。</p><p>从上表1可以看出，肾脏在器官移植总数中占73%。作为一种可以移植的最重要的器官，它占据了很大的比例。因此，我们只需在这里讨论肾脏移植的状况，就能进行器官移植的分析和研究。</p><p>根据上述数据，我们可以得到以下数据：</p><p>例 <strong>2</strong> </p><p>So after many times simulation under the conditions discussed above, we obtain statistic results as follow:</p><p>因此，在上述讨论的条件下进行了多次模拟后，我们得到了以下的统计结果：</p><p>表的解释部分 </p><p>By analyzing the above result, we can find: When there are more donors (more </p><p>resources), the number of transplant will increase obviously, and the matching rate changes only a little; When the network is divided into 11 regions (small networks), the costs of the transport and preservation of the organ will be reduced greatly. </p><p>通过分析上述结果，我们可以发现：当有更多的捐赠者（更多的资源）时，移植数量明显增加，而匹配率变化很小；当网络划分为11个区域（小网络）时，器官的运输和保存成本将大大降低。</p><p>例 <strong>3</strong> </p><p>Table 7 reports the general patient statistics under each regime in the columns. The first column in these tables reports the total live donor transplants as percentage of the population size, which is the sum of next two columns, transplants from own compatible donor and transplants from trades. The forth column is the percentage of patients upgraded to the top of the waitlist as heads of w-chains. The fifth and sixth columns report the quality of matches in the live donor transplants: the risk of graft failure relative to the risk under no-exchange mechanism with population size n&#x3D;400 is reported in the fifth column and the number of HLA mismatches for an average transplant is reported in the sixth column. In the table 8, we change the n into 200. </p><p>Table 7 报告了各种制度下的一般患者统计数据。这些表格中的第一列报告了总活体捐赠器移植手术占人口规模的百分比，该百分比是下两列的总和，即来自兼容的自体捐赠者的移植手术和来自交换的移植手术。第四列是升级为等待列表顶部的患者的百分比，作为 w-链的头部。第五和第六列报告了活体捐赠器移植的匹配质量：相对于没有交换机制的情况下，种群大小为n&#x3D;400的移植手术风险报告在第五列中，而平均移植手术的HLA不匹配数量报告在第六列中。在表8中，我们将 n 更改为 200。</p><p>表与表之间的比较</p><p>By comparison, we can found that the matching proportion become little and the matching quality will get worse as the total number of the patients decrease. The result is consistent with the reality. The 30% probability of the waiting list or low quality exchange is an adjustable parameter. </p><p>通过比较，我们发现随着患者总数减少，匹配比例变得较小，匹配质量也会变差。这个结果与现实情况一致。等待列表或低质量交换的30%概率是一个可调参数。</p><p>例 <strong>4</strong> </p><p>表与表的比较 </p><p>Also, we wish to explore the situation in which there is one lane per booth: </p><p>此外，我们希望探讨每个收费亭只有一条车道的情况：</p><p>例 <strong>5</strong> </p><p>The parameters we choose to modify are p (probability of advancement), „delay‟ (number of time steps required to serve a vehicle in a tollbooth), and q (the probability that a flagged vehicle opts to attempt a turn). The results of this analysis are presented in Table 7. Since we have used six lanes as our standard test case, we continue with this choice here. </p><p>我们选择修改的参数包括 p（晋升的概率）、”delay”（为便道上的车辆提供服务所需的时间步数）和 q（被标记的车辆选择尝试转弯的概率）。此分析的结果呈现在表7中。由于我们已经将六条车道作为标准测试案例，我们在这里继续使用这个选择。</p><p>As indicated in Table 7, our cellular automata model is relatively insensitive to both p and q. Changes of ±11% and ±5.2% in p and q, respectively, had no effect on the optimal number of tollbooths for a six lane highway. On the other hand, increasing the delay time by 25% shifted the optimal number of booths from 10 to 11 (10%). Decreasing the delay by 25% had no effect on the solution. Perhaps additional work could lead to an elucidation of the relation between delay and optimal booth number that could help stabilize the cellular automata model. </p><p>如表7所示，我们的元胞自动机模型对 p 和 q 都相对不敏感。对 p 和 q 的变化分别为 ±11% 和 ±5.2%，对于六车道高速公路的最佳收费亭数量没有影响。另一方面，将延迟时间增加25%会将最佳收费亭数量从10个变为11个（增加10%）。将延迟减少25%对解决方案没有影响。也许进一步的工作可以阐明延迟和最佳收费亭数量之间的关系，从而有助于稳定元胞自动机模型。</p></blockquote><h1 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h1><h2 id="由假设得到公式"><a href="#由假设得到公式" class="headerlink" title="由假设得到公式"></a>由假设得到公式</h2><blockquote><p>1．We assume laminar flow and use Bernoulli‟s equation:（由假设得到的公式）</p><p>我们假设层流，并使用伯努利方程：（由假设得到的公式）</p><p>According to the assumptions, at every junction we have  （由于假设）</p><p> 根据假设，在每个交叉口，我们有：（由于假设）</p></blockquote><h2 id="由原因得到公式"><a href="#由原因得到公式" class="headerlink" title="由原因得到公式"></a>由原因得到公式</h2><blockquote><p>2．Because our field is flat, we have 公式, so the height of our source relative to our sprinklers does not affect the exit speed v2  （由原因得到的公式）；</p><p>由于我们的区域是平坦的，我们有公式，因此我们的喷头相对于源的高度不会影响出口速度 v2（由原因得到的公式）。</p><p>Since the fluid is incompressible(由于液体是不可压缩的), we have </p><p>由于流体是不可压缩的，我们有：</p></blockquote><h2 id="用原来的公式推出公式"><a href="#用原来的公式推出公式" class="headerlink" title="用原来的公式推出公式"></a>用原来的公式推出公式</h2><blockquote><p>3．Plugging v1 into the equation for v2 ,we obtain</p><p>  （将公式 1 代入公式 2 中得到） </p><p>Putting these together, because of the law of conservation of energy, yields:</p><p>将这些放在一起，由于能量守恒定律，得到：</p><p>Therefore, from (2), (3), (5), we have the ith junction:</p><p>因此，从（2），（3），（5）得到：</p><p>Putting (1)-(5) together, we can obtain pressure at every junction. In fact, at the last junction, we have:</p><p>将（1）-（5）放在一起，我们可以得到每个交叉口的压力。实际上，在最后的交叉口，我们有：</p><p>Putting these into (1), we get:</p><p>将这些代入（1），我们得到：</p><p>Which means that the pressure difference ΔP across the junction is:</p><p>这意味着跨越交叉口的压力差 ΔP 是：</p><p>Commonly, h is about 2 meters:</p><p>通常情况下，h 约为2米：</p><p>From these equations, we know that:</p><p>从这些方程中，我们知道：</p></blockquote><h2 id="计算结果"><a href="#计算结果" class="headerlink" title="计算结果**"></a>计算结果**</h2><blockquote><ol start="6"><li>To find the new pressure, we use the continuity equation (0 0), which states that the volume of water flowing in equals the volume of water flowing out:</li></ol><p>为了找到新的压力，我们使用连续方程（0 0），该方程说明流入的水体积等于流出的水体积：</p><ol start="7"><li>Solving for V_N, we obtain the formula:</li></ol><p>解出 V_N，我们得到公式：</p><p>Where ( n ) is the …（其中 ( n ) 是…）</p><p>We have the following differential equations for speeds in the x- and y- directions:</p><p>我们有以下关于x和y方向速度的微分方程：</p><p>Whose solutions are:</p><p>它们的解为：</p><p>Where ( x_0 ) and ( y_0 ) are the initial positions, ( V ) is the speed, ( \theta ) is the angle.</p><p>（其中 ( x_0 ) 和 ( y_0 ) 是初始位置，( V ) 是速度，( \theta ) 是角度。）</p><ol start="9"><li>We use the following initial conditions to determine the drag constant:</li></ol><p>Using the initial conditions:</p><p>We can determine the drag constant according to the given formula:</p><p>我们使用以下的初始条件来确定阻力常数：</p><p>利用初始条件：</p><p>我们可以根据给定的公式确定阻力常数：</p><p>Where ( m ) is the mass, ( g ) is the acceleration due to gravity.（其中 ( m ) 是质量，( g ) 是重力加速度。）</p><p>10．We apply the law of conservation of energy.</p><p>The work done by the forces is </p><p>The decrease in potential energy is  </p><p>The increase in kinetic energy is</p><p>Drug acts directly against velocity, so the acceleration vector from drag can be found Newton‟s law F&#x3D;ma as : </p><p>Where a is the acceleration vector and m is mass </p><p>Using theNewton‟s Second Law, we have that F&#x2F;m&#x3D;a and </p><p>So that Setting the two expressions for t1&#x2F;t2 equal and cross-multiplying gives </p><p>我们应用能量守恒定律。</p><p>力所做的功是</p><p>势能的减少是</p><p>动能的增加是</p><p>阻力直接作用于速度，因此可以通过牛顿的第二定律 F&#x3D;ma 找到阻力的加速度向量：</p><p>其中 a 是加速度向量，m 是质量</p><p>利用牛顿第二定律，我们有 F&#x2F;m&#x3D;a 和</p><p>因此，将 t1&#x2F;t2 的两个表达式设置为相等，并进行交叉相乘得到…</p><p>22．We approximate the binomial distribution of contenders with a normal distribution: </p><p>Where x is the cumulative distribution function of the standard normal distribution. Clearing denominators and solving the resulting quadratic in B gives </p><p>As an analytic approximation to . for k&#x3D;1, we get B&#x3D;c </p><p>我们用正态分布来近似候选人的二项分布：</p><p>其中 x 是标准正态分布的累积分布函数。消去分母并解出得到的二次方程中的 B，得到</p><p>作为对 的解析近似，当 k&#x3D;1 时，我们得到 B&#x3D;c</p><p>26．Integrating,  we get PVT&#x3D;constant, where </p><p>The main composition of the air is nitrogen and oxygen, so i&#x3D;5 and r&#x3D;1.4, so 23．According to First Law of Thermodynamics, we get </p><p>Where ( ) . we also then have </p><p>Where P is the pressure of the gas and V is the volume. We put them into the Ideal Gas Internal Formula: </p><p>积分后，我们得到PVT&#x3D;常数，其中</p><p>空气的主要成分是氮和氧，因此i&#x3D;5，r&#x3D;1.4，所以23. 根据热力学第一定律，我们得到</p><p>其中( )。我们还有</p><p>其中P是气体的压力，V是体积。我们将它们代入理想气体内部公式：</p><p>对公式变形</p><p>13．Define A&#x3D;nlw to be the ( )（定义）; rearranging (1) produces  （将公式变形得到）</p><p>We maximize E for each layer, subject to the constraint (2). The calculations are easier if we minimize 1&#x2F;E.（为了得到最大值，求他倒数的最小值）  Neglecting constant factors  （忽略常 数）, we minimize </p><p>定义A&#x3D;nlw为( )；重新排列(1)得到</p><p>我们对每一层最大化E，受制于约束(2)。如果我们最小化1&#x2F;E，计算会更容易。忽略常数因子，我们最小化</p><p>使服从约束条件</p><p>14．Subject to the constraint  （使服从约束条件）</p><p>Where B is constant defined in (2). However, as long as we are obeying this constraint, we can write  （根据约束条件我们得到）</p><p>And thus f depends only on h , the function f is minimized at  （求最小值）</p><p>At this value of h, the constraint reduces to </p><p>其中B是在（2）中定义的常数。然而，只要我们遵守这个约束，我们可以写成</p><p>因此，f仅依赖于h，函数f在这个值上被最小化</p><p>在这个h的值上，约束条件简化为</p></blockquote><h2 id="结果说明"><a href="#结果说明" class="headerlink" title="结果说明**"></a>结果说明**</h2><blockquote><p>15．This implies（暗示）  that the harmonic mean of l and w should be </p><p>So , in the optimal situation. ……… </p><ol start="15"><li>这意味着 l 和 w 的调和平均值应该是</li></ol><p>因此，在最优的情况下，………</p><p>5．This value shows very little loss due to friction.（结果说明）  The escape speed with friction is </p><p>这个值表明由于摩擦引起的损失非常小。逃逸速度在考虑摩擦的情况下为…</p><p>16．  We use a similar process to find the position of the droplet, resulting in </p><p>With t&#x3D;0.0001 s, error from the approximation is virtually zero. </p><p>我们使用类似的过程来找到液滴的位置，结果是</p><p>当 t&#x3D;0.0001 秒时，近似值的误差几乎为零。</p><p>17．We calculated its trajectory(轨道) using </p><p>我们使用…计算了它的轨迹</p><p>18．For that case, using the same expansion for e as above, </p><p>对于这种情况，使用与上述相同的 e 展开式，…</p><p>19．Solving for t and equating it to the earlier expression for t, we get </p><p>求解 t 并将其等同于之前的 t 表达式，我们得到…</p><p>20．Recalling that in this equality only n is a function of f, we substitute for n and solve for f. the result is </p><p> As v&#x3D;…, this equation becomes singular (单数的). 由语句得到公式</p><p>回忆一下，在这个等式中只有 n 是 f 的函数，我们用 n 代入并解出 f。结果是</p><p>当 v&#x3D;… 时，这个方程变得奇异。</p><p>21．The revenue generated by the flight is </p><p>这次航班所产生的收入是…</p><p>22．Then we have </p><p>We differentiate the ideal-gas state equation </p><p> Getting </p><p>然后我们有</p><p>我们对理想气体状态方程进行微分</p><p>得到…</p><p>23．We eliminate dT from the last two equations to get  （排除因素得到）</p><p> 我们从最后两个方程中消除 dT，得到…</p><p>24．We fist examine the path that the motorcycle follows. Taking the air resistance into account, we get two differential equations </p><p>Where P is the relative pressure. We must first find the speed v1 of water at our source: （找初值）</p><p>我们首先考察摩托车所经过的路径。考虑到空气阻力，我们得到两个微分方程：</p><p>公式</p><p>其中 P 是相对压力。我们首先需要找到水源处水的速度 v1：（找初值）</p></blockquote><h1 id="Evaluations-of-solutions"><a href="#Evaluations-of-solutions" class="headerlink" title="Evaluations of solutions"></a>Evaluations of solutions</h1><h2 id="Strengths"><a href="#Strengths" class="headerlink" title="Strengths"></a>Strengths</h2><blockquote><ul><li><p>Our main model’s strength is its enormous edibility. For instance, including all these factors into a single, robust framework, our model enables.</p><ul><li>我们主要模型的优势在于其巨大的可编辑性。例如，将所有这些因素纳入一个单一而强大的框架中，我们的模型能够。</li></ul></li><li><p>We developed a theoretical line formation model which agrees without rough data. Our computer model agrees with both despite working on different principles, implying it behaves as we want.</p><ul><li>我们开发了一个理论的线形成模型，与粗糙数据一致。我们的计算机模型与两者都一致，尽管基于不同的原则工作，这意味着它表现得符合我们的期望。</li></ul></li><li><p>This allows us to make substantive conclusions about.</p><ul><li>这使我们能够就……得出实质性的结论。</li></ul></li><li><p>Finally, our model is strong because of.</p><ul><li>最后，我们的模型之所以强大是因为。</li></ul></li><li><p>The Monte Carlo simulation has been perfectly used in our models, and the simulation results are consistent with the reality.</p><ul><li>蒙特卡洛模拟在我们的模型中得到了完美的运用，模拟结果与现实一致。</li></ul></li><li><p>We introduced … in order to improve the exchange quality. The chain rules can also be modified to a degree.</p><ul><li>我们引入了……以提高交换质量。链规则也可以在一定程度上进行修改。</li></ul></li><li><p>The models used in our paper are promotional, in view of different considerations.</p><ul><li>我们论文中使用的模型是推动性的，考虑了不同的因素。</li></ul></li><li><p>We can modify our models conveniently.</p><ul><li>我们可以方便地修改我们的模型。</li></ul></li><li><p>The model is independent of the site simulated.</p><ul><li>该模型与模拟的站点无关。</li></ul></li><li><p>The model is intuitive.</p><ul><li>该模型是直观的。</li></ul></li><li><p>The algorithm is efficient.</p><ul><li>该算法是高效的。</li></ul></li><li><p>A corresponding strength of our model is that it would be relatively easy to include a parameter for the probability of ….</p><ul><li>我们模型的一个相应优势是相对容易加入一个关于……概率的参数。</li></ul></li><li><p>Our model is particularly appropriate for the simulation of …, a problem that naturally lends itself to such discrete modeling.</p><ul><li>我们的模型特别适用于模拟……，这是一个自然适合这种离散建模的问题。</li></ul></li><li><p>The fundamental strengths of our model are…</p><ul><li>我们模型的基本优势是…</li></ul></li><li><p>The model is independent of…</p><ul><li>该模型与…无关。</li></ul></li><li><p>Processor-based model has few input parameters, leading to good robustness and sensitivity.</p><ul><li>基于处理器的模型具有很少的输入参数，导致良好的鲁棒性和灵敏度。</li></ul></li><li><p>Uses a variety of modeling techniques in an integrated, holistic model.</p><ul><li>在一个集成的、整体性的模型中使用了各种建模技术。</li></ul></li><li><p>Our model effectively achieved all of the goals we set initially. It was fast and could handle large quantities of data but also had the flexibility we desired. Though we did not test all possibilities, we showed that our model optimizes state districts for any of a number of variables. If we had chosen to input income, poverty, crime, or education data into our interest function, we could have produced high-quality results with virtually no added difficulty. As well, our method was robust.</p><ul><li>我们的模型有效地实现了我们最初设定的所有目标。它速度快，能处理大量数据，同时还具有我们期望的灵活性。尽管我们没有测试所有可能性，但我们表明了我们的模型能够优化任何一种变量的状态地区。如果我们选择将收入、贫困、犯罪或教育数据输入到我们的兴趣函数中，我们几乎可以毫不费力地产生高质量的结果。此外，我们的方法是稳健的。</li></ul></li><li><p>Our main model’s strength is its enormous flexibility. For instance.</p><ul><li>我们主要模型的优势在于其巨大的灵活性。例如。</li></ul></li><li><p>This allows us to make substantive conclusions about policy issues, even without extensive data sets. By varying parameters, allocation rules, and our program’s objective function, all quite feasible within the structure, we can examine the guts of policymaking: the ethical principles underlying a policy, the implementation rules designed to fulfill them, and the sometimes nebulous numbers that govern the results.</p><ul><li>这使我们能够就政策问题得出实质性的结论，即使没有广泛的数据集。通过改变参数、分配规则和我们</li></ul></li></ul><p>程序的目标函数——在结构内是相当可行的——我们可以审视政策制定的核心：支撑政策的伦理原则、旨在实现这些原则的实施规则以及在结果中起作用的有时模糊的数字。</p><ul><li><p>Finally, our model is strong because of its discrete setup.</p><ul><li>最后，我们的模型之所以强大是因为它是离散设置的。</li></ul></li><li><p>The fundamental strengths of our model are its robustness and flexibility. All of the data are fully parameterized, so the model can be applied to…</p><ul><li>我们模型的基本优势在于其鲁棒性和灵活性。所有数据都是完全参数化的，因此该模型可以应用于…</li></ul></li></ul></blockquote><h2 id="Weaknesses"><a href="#Weaknesses" class="headerlink" title="Weaknesses"></a>Weaknesses</h2><blockquote><ul><li><p>Some special data can’t be found, and it makes that we have to make some proper assumptions before the solution of our models. A more abundant data resource can guarantee a better result in our models. Current line length is not taken into account by the line formation model. In real life…</p><ul><li>一些特殊的数据无法找到，这使得我们在解决模型之前必须进行适当的假设。更丰富的数据资源可以保证我们模型中更好的结果。当前线长没有被线形成模型考虑在内。在现实生活中…</li></ul></li><li><p>Weaknesses of the model included assumptions made for simplicity that likely do not hold. For instance, in most runs of our model on (sides…), cases (impact&#x2F;conclusion) to… This feature is likely a result of our assumption that &#x2F;The primary weakness of this model is the ( ), It should be possible to eliminate this; another weakness that could be corrected with more analysis is ( )</p><ul><li>模型的弱点包括为简单起见而做出的可能不成立的假设。例如，在我们模型的大多数运行中，(对…的影响&#x2F;结论) 在某些情况下可能会… 这个特点可能是我们假设的结果，这个模型的主要弱点是( )，有可能消除这一点；还有一个可以通过更多分析来纠正的弱点是( )</li></ul></li><li><p>The primary weakness of this model is the…</p><ul><li>这个模型的主要弱点是…</li></ul><p>Another weakness that could be corrected with more analysis is…</p><ul><li>另一个可以通过更多分析来纠正的弱点是…</li></ul></li><li><p>Parameters have to be derived from physical occurrences.</p><ul><li>参数必须从物理事件中导出。</li></ul></li><li><p>The other primary weakness of our model is our lack of metrics for comparison.</p><ul><li>我们模型的另一个主要弱点是我们缺乏用于比较的度量标准。</li></ul></li><li><p>Although we list the model’s comprehensive, discrete simulation as a strength, it is (paradoxically) also the most notable weakness. Our results lack clear…</p><ul><li>尽管我们将模型的全面、离散的模拟列为优点，但它（矛盾地）也是最显着的弱点。我们的结果缺乏明确的…</li></ul><p>Second, our model demands great attention to…</p><ul><li>其次，我们的模型需要对…的高度关注。</li></ul><p>While its general structure and methodology are valid, the specific figures embedded in its code are not airtight.</p><ul><li>尽管其一般结构和方法是有效的，但嵌入其代码中的具体数字并不是完全牢固的。</li></ul></li><li><p>Although we list the model’s comprehensive, … as a strength, it is (paradoxically) also the most notable weakness. Our results lack clear illustrative power; data manipulated through a computer program cannot achieve the same effect as…</p><ul><li>尽管我们将模型的全面…列为优点，但它（矛盾地）也是最显着的弱点。我们的结果缺乏明确的说明力；通过计算机程序操纵的数据无法达到与…</li></ul></li><li><p>Indeed, there is a fundamental tradeoff here between realism and elegance, and our model arguably veers toward over-realism.</p><ul><li>的确，在现实主义和优雅之间存在根本的权衡，我们的模型可能偏向过度现实主义。</li></ul></li><li></li></ul></blockquote><h1 id="Conclusions-总结"><a href="#Conclusions-总结" class="headerlink" title="Conclusions 总结"></a><strong>Conclusions</strong> 总结</h1><blockquote><p>1、  As our team set out to come up with a strategy on what would be the most efficient way to 我们提出了一种最有效的方法去解决…… </p><p>2、  The first aspect that we took into major consideration was……. </p><p>Other important findings through research made it apparent that the standard </p><p>首先我们考虑到……，其他重要的是我们通过研究使</p><p>4、We have used mathematical modeling in a……to analyze some of the factors associated with such an activity。 </p><p>为了分析这类问题的一些因素，我们运用数学模型…… </p><p>5、This “cannon problem” has been used in many forms in many differential equations courses in the Department of Mathematical Sciences for several years. </p><p>这些年这些问题已经以不同的微分方程形式运用于自然科学部门。 </p><p>6、In conclusion our team is very certain that the methods we came up with in 总之，我们很确定我们提出的方法</p><p>7、We already know how well our results worked for…… 我们已经知道我们结果对…… </p><p>8、Now that the problem areas have been defined, we offer some ways to reduce the effect of these problems. </p><p>既然已经定义了结果，我们提出一些方法减少对问题的影响。</p><p>9、There are many methods in existence for……Furthermore each is mostly successful in what is sets out to do. However, all of these seem to </p><p>有许多的方法研究……，因此最好的是我们要作的，然而，所有的这些好像…… </p><p>10、While our approaches and models were effective and produced results, there remain several types of model weaknesses: </p><p>我们的方法和模型很有效对结果进行延伸，我们的模型也存在些缺点。</p><p>11、We next developed a detailed simulation engine to perform simulations. Our simulations allowed us to …… </p><p>我们接下来研究计算，我们的模拟允许我们…… </p><p>12、We have reached several valuable conclusions about the nature of……and some of the possible policy solutions that can be implemented to make it more effective  ，Most importantly, we believe in the absolute necessity of implementing </p><p>我们得到关于这类问题的结果，一些可能的政策结果使它很有效，最重要的是，我们认为…… 相当有必要性。 </p><p>13、We use …to …</p><ul><li>我们使用…来…</li></ul><p>14、Thus, we recommend…</p><ul><li>因此，我们建议…</li></ul><p>15、Considering the…</p><ul><li>考虑到…</li></ul><p>16、In this paper, we examine the results of some fundamental avaricious in structure:……</p><ul><li>在本文中，我们检查了结构中一些基本的贪婪结果：……</li></ul><p>17、We also wish to tie our exploration of sensitive……</p><ul><li>我们还希望将对敏感性的探索与……</li></ul><p>18、we suspect that such systems are in general less effective than simpler ones……</p><ul><li>我们怀疑这类系统一般比简单的系统效果较差……</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多元线性回归</title>
      <link href="/2024/01/29/%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2024/01/29/%E5%A4%9A%E5%85%83%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="多元回归分析"><a href="#多元回归分析" class="headerlink" title="多元回归分析"></a>多元回归分析</h1><blockquote><p>回归分析是数据分析中最基础也是最重要的分析工具，绝大多数的数据分析问题，都可以使用回归的思想来解决。回归分析的任务就是通过研究自变量X和因变量Y的相关关系，尝试去解释Y的形成机制，进而达到通过X去预测Y的目的</p><p>回归分析:研究X和Y相关性的分析（相关性≠因果性）</p><p>常见的回归分析有：线性回归、0-1回归、定序回归、计数回归和生存回归，其划分的依据是因变量y的类型。</p></blockquote><p><img src="/images/image-20240129214522174.png" alt="image-20240129214522174"></p><p><img src="/images/image-20240129214533470.png" alt="image-20240129214533470"></p><h2 id="回归分析的作用"><a href="#回归分析的作用" class="headerlink" title="回归分析的作用"></a>回归分析的作用</h2><p><img src="/images/image-20240129214553725.png" alt="image-20240129214553725"></p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p><img src="/images/image-20240129214629247.png" alt="image-20240129214629247"></p><p><strong>数据的分类：<br>横截面数据</strong>：在某一时点收集的不同对象的数据。</p><h2 id="本章节主要是多元线性回归"><a href="#本章节主要是多元线性回归" class="headerlink" title="本章节主要是多元线性回归"></a>本章节主要是多元线性回归</h2><p><img src="/images/image-20240129214810466.png" alt="image-20240129214810466"></p><h1 id="一元线性回归"><a href="#一元线性回归" class="headerlink" title="一元线性回归"></a>一元线性回归</h1><p><img src="/images/image-20240129214828532.png" alt="image-20240129214828532"></p><blockquote><p>线性是灵动的</p></blockquote><p><img src="/images/image-20240129214850518.png" alt="image-20240129214850518"></p><blockquote><p>注意引入变量时候要多加考虑</p></blockquote><p><img src="/images/image-20240129215013434.png" alt="image-20240129215013434"></p><p><img src="/images/image-20240129215038603.png" alt="image-20240129215038603"></p><h2 id="外生性的要求"><a href="#外生性的要求" class="headerlink" title="外生性的要求"></a>外生性的要求</h2><p><img src="/images/image-20240129215112238.png" alt="image-20240129215112238"></p><h2 id="什么时候取对数"><a href="#什么时候取对数" class="headerlink" title="什么时候取对数"></a>什么时候取对数</h2><p><strong>取对数的好处：</strong> （1）减弱数据的异方差性（2）如果变量本身不符合正态分布，取</p><p>了对数后 可能渐近服从正态分布（ 3 ）模型形式的需要，让模型具有经济学意义。</p><p> <img src="/images/image-20240129215205907.png" alt="image-20240129215205907"></p><p><img src="/images/image-20240129215212290.png" alt="image-20240129215212290"></p><p><strong>虚拟变量的解释:</strong></p><p><img src="/images/image-20240129215246712.png" alt="image-20240129215246712"></p><p><img src="/images/image-20240129215300615.png" alt="image-20240129215300615"></p><p><strong>多分类的虚拟变量的设置：</strong> </p><p><img src="/images/image-20240129215355156.png" alt="image-20240129215355156"></p><p><img src="/images/image-20240129215401967.png" alt="image-20240129215401967"></p><p><em><strong>&#x2F;*为了避免完全多重共线性的影响，引入虚拟变量的个数一般是分类数减&#x2F;**&#x2F;<strong>1,另外一个为对照组&#x2F;</strong>&#x2F;*<em>。&#x2F;</em></strong></em></p><p><strong>含有交互项的自变量：</strong></p><p><img src="/images/image-20240129215424047.png" alt="image-20240129215424047"></p><h1 id="回归实例："><a href="#回归实例：" class="headerlink" title="回归实例："></a><strong>回归实例：</strong></h1><p><img src="/images/image-20240129215502987.png" alt="image-20240129215502987"></p><p><strong>操作步骤：</strong></p><p><strong>stata软件：</strong></p><p>第一步：导入数据</p><p><img src="/images/image-20240129215527268.png" alt="image-20240129215527268"></p><p>第二步：数据描述性统计</p><p><img src="/images/image-20240129215541264.png" alt="image-20240129215541264"></p><p><img src="/images/image-20240129215607055.png" alt="image-20240129215607055"></p><p><img src="/images/image-20240129215619067.png" alt="image-20240129215619067"></p><p><img src="/images/image-20240129215627382.png" alt="image-20240129215627382"></p><p><img src="/images/image-20240129215637199.png" alt="image-20240129215637199"></p><p><strong>拟合优度R²较低怎么办：</strong></p><p><img src="/images/image-20240129215643497.png" alt="image-20240129215643497"></p><p><strong>标准回归化系数：</strong></p><p><img src="/images/image-20240129215700385.png" alt="image-20240129215700385"></p><p><img src="/images/image-20240129215707976.png" alt="image-20240129215707976"></p><p><strong>使用OLS时，扰动项μ需要满足的条件：</strong></p><p><img src="/images/image-20240129215902585.png" alt="image-20240129215902585"></p><p><img src="/images/image-20240129215928314.png" alt="image-20240129215928314"></p><p><img src="/images/image-20240129215935706.png" alt="image-20240129215935706"></p><p><img src="/images/image-20240129215945766.png" alt="image-20240129215945766"></p><p><img src="/images/image-20240129220020904.png" alt="image-20240129220020904"></p><p><img src="/images/image-20240129220048086.png" alt="image-20240129220048086"></p><p><img src="/images/image-20240129220104904.png" alt="image-20240129220104904"></p><p><img src="/images/image-20240129220124650.png" alt="image-20240129220124650"></p><p><img src="/images/image-20240129220136200.png" alt="image-20240129220136200"></p><p><strong>多重共线性：</strong></p><p><img src="/images/image-20240129220153354.png" alt="image-20240129220153354"></p><p><img src="/images/image-20240129220202916.png" alt="image-20240129220202916"></p><h3 id="处理方法："><a href="#处理方法：" class="headerlink" title="处理方法："></a>处理方法：</h3><p><img src="/images/image-20240129220239152.png" alt="image-20240129220239152"></p><p><img src="/images/image-20240129220248065.png" alt="image-20240129220248065"></p><p><img src="/images/image-20240129220300213.png" alt="image-20240129220300213"></p><p><img src="/images/image-20240129220322288.png" alt="image-20240129220322288"></p><h2 id="全是图片（汗颜）"><a href="#全是图片（汗颜）" class="headerlink" title="全是图片（汗颜）"></a>全是图片（汗颜）</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按键盘上的PageUp可以使用上一次输入的代码（Matlab中是上箭头）</span></span><br><span class="line"><span class="comment">// 清除所有变量</span></span><br><span class="line"><span class="keyword">clear</span></span><br><span class="line"><span class="comment">// 清屏 和 matlab的clc类似</span></span><br><span class="line">cls </span><br><span class="line"><span class="comment">// 导入数据（其实是我们直接在界面上粘贴过来的，我们用鼠标点界面导入更方便 本条请删除后再复制到论文中，如果评委老师看到了就知道这不是你写的了）</span></span><br><span class="line"><span class="comment">// import excel &quot;C:/Users/hc_lzp/Desktop/数学建模视频录制/第7讲.多元回归分析/代码和例题数据/课堂中讲解的奶粉数据.xlsx&quot;, sheet(&quot;Sheet1&quot;) firstrow</span></span><br><span class="line">import excel <span class="string">&quot;课堂中讲解的奶粉数据.xlsx&quot;</span>, sheet(<span class="string">&quot;Sheet1&quot;</span>) firstrow</span><br><span class="line"><span class="comment">// 定量变量的描述性统计</span></span><br><span class="line"><span class="keyword">summarize</span> 团购价元 评价量 商品毛重kg</span><br><span class="line"><span class="comment">// 定性变量的频数分布，并得到相应字母开头的虚拟变量</span></span><br><span class="line"><span class="keyword">tabulate</span> 配方,<span class="keyword">gen</span>(A)</span><br><span class="line"><span class="keyword">tabulate</span> 奶源产地 ,<span class="keyword">gen</span>(B)</span><br><span class="line"><span class="keyword">tabulate</span> 国产或进口 ,<span class="keyword">gen</span>(C)</span><br><span class="line"><span class="keyword">tabulate</span> 适用年龄岁 ,<span class="keyword">gen</span>(<span class="keyword">D</span>)</span><br><span class="line"><span class="keyword">tabulate</span> 包装单位 ,<span class="keyword">gen</span>(<span class="keyword">E</span>)</span><br><span class="line"><span class="keyword">tabulate</span> 分类 ,<span class="keyword">gen</span>(F)</span><br><span class="line"><span class="keyword">tabulate</span> 段位 ,<span class="keyword">gen</span>(<span class="keyword">G</span>)</span><br><span class="line"><span class="comment">// 下面进行回归</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg</span><br><span class="line"><span class="comment">// 下面的语句可帮助我们把回归结果保存在Word文档中</span></span><br><span class="line"><span class="comment">// 在使用之前需要运行下面这个代码来安装下这个功能包（运行一次之后就可以注释掉了）</span></span><br><span class="line"><span class="comment">// ssc install reg2docx, all replace</span></span><br><span class="line"><span class="comment">// 如果安装出现connection timed out的错误，可以尝试换成手机热点联网，如果手机热点也不能下载，就不用这个命令吧，可以自己做一个回归结果表，如果觉得麻烦就直接把回归结果截图。</span></span><br><span class="line"><span class="keyword">est</span> store m1</span><br><span class="line">reg2docx m1 using m1.docx, <span class="keyword">replace</span></span><br><span class="line"><span class="comment">// *** p&lt;0.01  ** p&lt;0.05 * p&lt;0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Stata会自动剔除多重共线性的变量</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg A1 A2 A3 B1 B2 B3 B4 B5 B6 B7 B8 B9 C1 C2 D1 D2 D3 D4 D5 E1 E2 E3 E4 F1 F2 G1 G2 G3 G4</span><br><span class="line"><span class="keyword">est</span> store m2</span><br><span class="line">reg2docx m2 using m2.docx, <span class="keyword">replace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到标准化回归系数</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg, b </span><br><span class="line"></span><br><span class="line"><span class="comment">// 画出残差图</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg A1 A2 A3 B1 B2 B3 B4 B5 B6 B7 B8 B9 C1 C2 D1 D2 D3 D4 D5 E1 E2 E3 E4 F1 F2 G1 G2 G3 G4</span><br><span class="line"><span class="keyword">rvfplot</span> </span><br><span class="line"><span class="comment">// 残差与拟合值的散点图</span></span><br><span class="line"><span class="keyword">graph</span> export a1.png ,<span class="keyword">replace</span></span><br><span class="line"><span class="comment">// 残差与自变量团购价的散点图</span></span><br><span class="line"><span class="keyword">rvpplot</span>  团购价元</span><br><span class="line"><span class="keyword">graph</span> export a2.png ,<span class="keyword">replace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为什么评价量的拟合值会出现负数？</span></span><br><span class="line"><span class="comment">// 描述性统计并给出分位数对应的数值</span></span><br><span class="line"><span class="keyword">summarize</span> 评价量,<span class="keyword">d</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 作评价量的概率密度估计图</span></span><br><span class="line"><span class="keyword">kdensity</span> 评价量 </span><br><span class="line"><span class="keyword">graph</span> export a3.png ,<span class="keyword">replace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异方差BP检验</span></span><br><span class="line"><span class="keyword">estat</span> <span class="keyword">hettest</span> ,rhs iid</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异方差怀特检验</span></span><br><span class="line"><span class="keyword">estat</span> <span class="keyword">imtest</span>,white</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用OLS + 稳健的标准误</span></span><br><span class="line"><span class="keyword">regress</span> 评价量 团购价元 商品毛重kg A1 A2 A3 B1 B2 B3 B4 B5 B6 B7 B8 B9 C1 C2 D1 D2 D3 D4 D5 E1 E2 E3 E4 F1 F2 G1 G2 G3 G4, r</span><br><span class="line"><span class="keyword">est</span> store m3</span><br><span class="line">reg2docx m3 using m3.docx, <span class="keyword">replace</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算VIF</span></span><br><span class="line"><span class="keyword">estat</span>  <span class="keyword">vif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 逐步回归（一定要注意完全多重共线性的影响）</span></span><br><span class="line"><span class="comment">// 向前逐步回归（后面的r表示稳健的标准误）</span></span><br><span class="line"><span class="keyword">stepwise</span> <span class="keyword">reg</span> 评价量 团购价元 商品毛重kg A1 A3 B1 B2 B3 B4 B5 B6 B7 B9 C1 D1 D2 D3 D4 E1 E2 E3 F1 G1 G2 G3,  r pe(0.05)</span><br><span class="line"><span class="comment">// 向后逐步回归（后面的r表示稳健的标准误）</span></span><br><span class="line"><span class="keyword">stepwise</span> <span class="keyword">reg</span> 评价量 团购价元 商品毛重kg A1 A3 B1 B2 B3 B4 B5 B6 B7 B9 C1 D1 D2 D3 D4 E1 E2 E3 F1 G1 G2 G3,  r <span class="keyword">pr</span>(0.05)</span><br><span class="line"><span class="comment">// 向后逐步回归的同时使用标准化回归系数（在r后面跟上一个b即可）</span></span><br><span class="line"><span class="keyword">stepwise</span> <span class="keyword">reg</span> 评价量 团购价元 商品毛重kg A1 A3 B1 B2 B3 B4 B5 B6 B7 B9 C1 D1 D2 D3 D4 E1 E2 E3 F1 G1 G2 G3,  r b <span class="keyword">pr</span>(0.05)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 补充语法 (大家不需要具体的去学Stata软件，掌握我课堂上教给大家的一些命令应对数学建模比赛就可以啦)</span></span><br><span class="line"><span class="comment">// 事实上大家学好Excel，学好后应对90%的数据预处理问题都能解决</span></span><br><span class="line"><span class="comment">// (1) 用已知变量生成新的变量 </span></span><br><span class="line"><span class="keyword">generate</span> lny = <span class="built_in">log</span>(评价量)  </span><br><span class="line"><span class="keyword">generate</span> price_square = 团购价元 ^2</span><br><span class="line"><span class="keyword">generate</span> interaction_term = 团购价元*商品毛重kg</span><br><span class="line"></span><br><span class="line"><span class="comment">// (2) 修改变量名称，因为用中文命名变量名称有时候可能容易出现未知Bug</span></span><br><span class="line"><span class="keyword">rename</span> 团购价元 price</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>时间序列分析</title>
      <link href="/2024/01/29/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/"/>
      <url>/2024/01/29/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="时间序列分析"><a href="#时间序列分析" class="headerlink" title="时间序列分析"></a>时间序列分析</h1><p><img src="/images/image-20240129204113266.png" alt="image-20240129204113266"></p><blockquote><p>通过描述过去和分析规律，最后预测未来。</p></blockquote><blockquote><p>时间序列数据：同一对象不同时间</p><p>例如:<br>(1)从出生到现在，你的体重的数据（每年生日称一次。</p><p>(2)中国历年来GDP的数据。<br>(3）在某地方每隔一小时测得的温度数据。</p><p>时间序列由两个组成要素构成:<br>1、第一个要素是时间要素;<br>年、季度、月、周、日、小时、分钟、秒</p><p>2、第二个要素是数值要素。</p><p>时间序列根据时间和数值性质的不同，可以分为时期时间序列和时点时间序列。<br>时期序列中，数值要素反映现象在一定时期内发展的结果;</p><p>时点序列中，数值要素反映现象在一定时点上的瞬间水平。</p><p>区分时期和时点序列<br>时期序列可加，时点序列不可加<br>例如:</p><p>(1)从出生到现在，你的体重的数据（每年生日称一次)。</p><p>(2）中国历年来GDP的数据。</p><p>(3）在某地方每隔一小时测得的温度数据。</p><p>(1）和 (3) 是时点时间序列;</p><p>(2)是时期时间序列</p><p>时期序列中的观测值反映现象在一段时期内发展过程的总量，不同时期的观测值可以相加，相加结果表明现象在更长一段时间内的活动总量;而时点序列中的观测值反映现象在某一瞬间上所达到的水平，不同时期的观测值不能相加，相加结果没有实际意义。</p></blockquote><h1 id="时间序列分解"><a href="#时间序列分解" class="headerlink" title="时间序列分解"></a>时间序列分解</h1><blockquote><p>因为时间序列是某个指标数值长期变化的数值表现，所以时间序列数值变化背后必然蕴含着数值变换的规律性，这些规律性就是时间序列分析的切入点。</p><p>一般情况下，时间序列的数值变化规律有以下四种:</p><p>长期变动趋势<br>季节变动规律<br>周期变动规律<br>不规则变动（随机扰动项）<br>一个时间序列往往是以上四类变化形式的叠加。</p></blockquote><p><img src="/images/image-20240129204311471.png" alt="image-20240129204311471"></p><h4 id="长期趋势：T"><a href="#长期趋势：T" class="headerlink" title="长期趋势：T"></a>长期趋势：T</h4><p><img src="/images/image-20240129204447227.png" alt="image-20240129204447227"></p><blockquote><p>季节一是季节</p><h4 id="季节趋势：S"><a href="#季节趋势：S" class="headerlink" title="季节趋势：S"></a>季节趋势：S</h4></blockquote><p><img src="/images/image-20240129204457289.png" alt="image-20240129204457289"></p><blockquote><p>循环一般以年</p><h4 id="循环变动：C"><a href="#循环变动：C" class="headerlink" title="循环变动：C"></a>循环变动：C</h4></blockquote><p><img src="/images/image-20240129204509424.png" alt="image-20240129204509424"></p><h4 id="不规则变动：I"><a href="#不规则变动：I" class="headerlink" title="不规则变动：I"></a>不规则变动：I</h4><p><img src="/images/image-20240129204543986.png" alt="image-20240129204543986"></p><p><img src="/images/image-20240129204606055.png" alt="image-20240129204606055"></p><blockquote><p><strong>四种变动与指标数值最终变动的关系可能是叠加关系，也可能是乘积关系。</strong></p></blockquote><p><img src="/images/image-20240129204615718.png" alt="image-20240129204615718"></p><blockquote><p>叠加模型和乘积模型<br>1 如果四种变动之间是相互独立的关系，那么叠加模型可以表示为:<br>Y &#x3D; T + S + C + I Y &#x3D;T+S+C+I<br>Y&#x3D;T+S+C+I</p><p>(⑵)如果四种变动之间存在相互影响关系，那么应该使用乘积模型:</p><p>Y&#x3D;T×S×C×I</p><p>Y:指标数值的最终变动;</p><p>T:长期趋势变动;<br>S:季节变动;</p><p>C:循环变动;</p><p>Ⅰ:不规则变动。</p><p>使用条件<br>(1）数据具有年内的周期性时才能使用时间序列分解，例如数据是月份数据(周期为12)、季度数据(周期为4)，如果是年份数据则不行。<br>(2）在具体的时间序列图上，如果随着时间的推移，序列的季节波动变得越来越大，则反映各种变动之间的关系发生变化,建议使用乘积模型;反之，如果时间序列图的波动保持恒定，则可以直接使用叠加模型;当然，如果不存在季节波动，则两种分解均可以。</p></blockquote><h2 id="定义时间与日期"><a href="#定义时间与日期" class="headerlink" title="定义时间与日期"></a>定义时间与日期</h2><p><img src="/images/image-20240129213359429.png" alt="image-20240129213359429"></p><p><img src="/images/image-20240129213433303.png" alt="image-20240129213433303"></p><p><img src="/images/image-20240129213445448.png" alt="image-20240129213445448"></p><p><img src="/images/image-20240129213500321.png" alt="image-20240129213500321"></p><p><img src="/images/image-20240129213512364.png" alt="image-20240129213512364"></p><h1 id="spss处理缺失值"><a href="#spss处理缺失值" class="headerlink" title="spss处理缺失值"></a>spss处理缺失值</h1><p><img src="/images/image-20240129204716291.png" alt="image-20240129204716291"></p><blockquote><p>头部和尾部直接删除</p><p>缺失值替换的方法</p></blockquote><p><img src="/images/image-20240129204752881.png" alt="image-20240129204752881"></p><h1 id="SPSS定义时间变量（好习惯）"><a href="#SPSS定义时间变量（好习惯）" class="headerlink" title="SPSS定义时间变量（好习惯）"></a>SPSS定义时间变量（好习惯）</h1><p><img src="/images/image-20240129204840670.png" alt="image-20240129204840670"></p><blockquote><p>画出时序图，可以自行查阅资料</p></blockquote><p><img src="/images/image-20240129204939792.png" alt="image-20240129204939792"></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p><img src="/images/image-20240129205021491.png" alt="image-20240129205021491"></p><h1 id="建立时间序列模型"><a href="#建立时间序列模型" class="headerlink" title="建立时间序列模型"></a>建立时间序列模型</h1><p><img src="/images/image-20240129205125040.png" alt="image-20240129205125040"></p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p><img src="/images/image-20240129205711465.png" alt="image-20240129205711465"></p><blockquote><p>只能得到一期的结果</p></blockquote><p><img src="/images/image-20240129211621801.png" alt="image-20240129211621801"></p><p><img src="/images/image-20240129211729298.png" alt="image-20240129211729298"></p><p><img src="/images/image-20240129211750586.png" alt="image-20240129211750586"></p><p><img src="/images/image-20240129211850473.png" alt="image-20240129211850473"></p><p><img src="/images/image-20240129211856999.png" alt="image-20240129211856999"></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p><img src="/images/image-20240129212113112.png" alt="image-20240129212113112"></p><blockquote><p>了解时间序列的变化趋势，做一个序列表就可以了，单击”分析”，里面选择”时间序列预测，选择”序列图”对话框，然后把’平均值’移到”变量”框里面，‘DATE_’移到”时间轴标签”框中，单击”确定”。结果如图</p></blockquote><blockquote><p>单击“分析”，选择时间序列预测，然后选择“季节性分解”，弹出“季节性分解”对话框，确认无误之后点击确定，如图：</p></blockquote><blockquote><p>发现多了四个变量，ERR表示的误差分析；SAS表示的是季节因素校正后序列；SAF表示的季节因子；STC表示的是长期趋势和循环变动序列。</p></blockquote><blockquote><p>后面就是开始预测了：<br>1、 单击“分析”，选择“时间序列预测”，然后选择“创建传统模型”，之后就会弹出“时间序列建模”对话框。<br>2、 将“平均值”移至“因变量”框中，然后确定中间的“方法”，在下拉列表中选择“专家建模器”项，单击右侧的“条件”按钮，弹出“时间序列建模器：专家建模器条件”对话框。<br>3、 在“时间序列建模器：专家建模器条件”对话框的“模型”选项卡中，在“模型类型”框中选择“所有模型”项，并勾选“专家建模器考虑季节性模型”复选框，设置完，点“继续”按钮<br>4、 在“时间序列建模器”对话框中，切换至“保存”选项卡中，勾选“预测值”复选框，单击“导出模型条件”框中“XML文件”后面的“浏览”按钮，然后设置导出的模型文件和保存路径，然后单击“确定”按钮就可以了。</p></blockquote><blockquote><p>1、 单击“分析”，选择“时间序列预测”，然后选择“应用传统模型”，弹出“应用模型序列”对话框。具体的操作如下图：</p><p>做完上面的之后最后一步就是切换至“保存”界面，勾选“预测值”之后单击确定就可以了。</p></blockquote><h1 id="Spss时间序列建模器"><a href="#Spss时间序列建模器" class="headerlink" title="Spss时间序列建模器"></a>Spss时间序列建模器</h1><p><img src="/images/image-20240129213553891.png" alt="image-20240129213553891"></p><p><img src="/images/image-20240129213615274.png" alt="image-20240129213615274"></p><p><img src="/images/image-20240129213625724.png" alt="image-20240129213625724"></p><p><img src="/images/image-20240129213632648.png" alt="image-20240129213632648"></p><p><img src="/images/image-20240129213641106.png" alt="image-20240129213641106"></p><p><img src="/images/image-20240129213649085.png" alt="image-20240129213649085"></p><p><img src="/images/image-20240129213658104.png" alt="image-20240129213658104"></p><h5 id="白噪声进行残差检验"><a href="#白噪声进行残差检验" class="headerlink" title="白噪声进行残差检验"></a>白噪声进行残差检验</h5><p><img src="/images/image-20240129213733570.png" alt="image-20240129213733570"></p><blockquote><p>从残差的ACF和PACF冬形中可以看出，所有滞后阶数的自相关系数和偏自相关系数均和o没有显著的差异;<br>另外从下表可以看出，对残差进行Q检验得到的p值为0.741，即我们无法拒绝原假设，认为残差就是白噪声序列，因此温特加法模型能够很好的识别本例中的销量数据</p></blockquote><p><img src="/images/image-20240129213756183.png" alt="image-20240129213756183"></p><p><img src="/images/image-20240129213931870.png" alt="image-20240129213931870"></p><blockquote><p>温特加法模型能很好的对该产品的销量数据进行预测。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华南理工大学2023女生赛</title>
      <link href="/2024/01/29/%E5%8D%8E%E5%8D%97%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A62023%E5%A5%B3%E7%94%9F%E8%B5%9B/"/>
      <url>/2024/01/29/%E5%8D%8E%E5%8D%97%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A62023%E5%A5%B3%E7%94%9F%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="吃宵夜"><a href="#吃宵夜" class="headerlink" title="吃宵夜"></a>吃宵夜</h1><p><a href="https://www.luogu.com.cn/problem/U374729?contestId=141340">U374729 hrmm 吃宵夜 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>非常粗糙的dp，一开始想用搜索，其实是大错特错，这个题实际上第二天有且仅有从第一天推导出来。</p><p>所以我们可以采用dp。</p><p>dp[i][j]表示第i天我们买第j种宵夜，这样我们的结果就是最后第n天买这三种宵夜的最大值，可能不太直观，但确实是我这个蒟蒻所能想到的了。</p><p>还是来想想转移方程吧，第i天选第j种，我们是不是第i-1天一定不能选第j种是不是这样。</p><p>然后我们是不是要加上a[i][j],这点不否认吧。</p><p>那我们多出来的循环K是干什么的，为什么要多出来，有什么用呢？</p><p>因为我们已经在第天选了第j种宵夜了，那我们在前面，也就是第i-1天我们可以选其他两种宵夜，这也是这个循环的由来，第二个原因是我们可以判断k&#x3D;&#x3D;j嘛，这样就可以实现买的宵夜隔一天不同了对吧。</p><p>所以说我们的状态转移方程就是，应该不太难懂，就是第i天选了j种，然后前面一天我们有k种选择，所以说，要枚举一下，最后别忘了加上去就可以了。</p><p>真是有趣(×)难想（√）！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[i][j]=max(dp[i][j],dp[i-1][k]+a[i][j]);</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000000</span>][<span class="number">4</span>];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">1000000</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>;k&lt;=<span class="number">3</span>;k++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j!=k)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i][j],dp[i<span class="number">-1</span>][k]+a[i][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;<span class="built_in">max</span>(dp[n][<span class="number">3</span>],<span class="built_in">max</span>(dp[n][<span class="number">1</span>],dp[n][<span class="number">2</span>]));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="学数学"><a href="#学数学" class="headerlink" title="学数学"></a>学数学</h1><p><a href="https://www.luogu.com.cn/problem/U374726?contestId=141340">U374726 hrmm 学数学 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s=<span class="string">&quot;3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679&quot;</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n+<span class="number">2</span>;i++)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;s[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="去种树"><a href="#去种树" class="headerlink" title="去种树"></a>去种树</h1><p><a href="https://www.luogu.com.cn/problem/U374725?contestId=141340">U374725 hrmm 去种树 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>本题有个难点，但有且仅有一个</p><p>我们观察数据范围，二维数组肯定不行，字符串行不行我没试过，但可变数组vector应该行。于是就莫名其妙的过了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;h[<span class="number">210000</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= a; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> s;</span><br><span class="line">cin &gt;&gt;s;</span><br><span class="line">h[i].<span class="built_in">push_back</span>(s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (q--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">cout &lt;&lt; h[x][y- <span class="number">1</span>]&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="期末考"><a href="#期末考" class="headerlink" title="期末考"></a>期末考</h1><p><a href="https://www.luogu.com.cn/problem/U374720?contestId=141340">U374720 hrmm 期末考 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">3</span>] == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y== <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">6</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (y == <span class="number">7</span>)</span><br><span class="line">&#123;</span><br><span class="line">a[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">a[<span class="number">3</span>] =<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">1</span>] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">2</span>] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum += <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[<span class="number">3</span>] == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">sum += <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; sum;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="玩原神"><a href="#玩原神" class="headerlink" title="玩原神"></a>玩原神</h1><p><a href="https://www.luogu.com.cn/problem/U374722?contestId=141340">U374722 hrmm 玩原神 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>好像讨论不太难，就讨论在不在一边，同时再讨论讨论位置，画画图就可以了。我说的很轻松对吧，但本蒟蒻写了半天。</p><p>据说有二进制优化，但不会……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x, y, z;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;</span><br><span class="line"><span class="keyword">if</span> (x * y &lt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="built_in">abs</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x * y &gt; <span class="number">0</span>&amp;&amp;x&gt;<span class="number">0</span>&amp;&amp;y&gt;<span class="number">0</span>&amp;&amp;x&lt;y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x * y &gt; <span class="number">0</span> &amp;&amp; x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; x &gt; y&amp;&amp;z&gt;y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x * y &gt; <span class="number">0</span> &amp;&amp; x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; x &gt; y &amp;&amp; z &lt; y&amp;&amp;z&gt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x * y &gt; <span class="number">0</span> &amp;&amp; x &gt; <span class="number">0</span> &amp;&amp; y &gt; <span class="number">0</span> &amp;&amp; x &gt; y &amp;&amp; z &lt; y&amp;&amp;z&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="number">2</span>*<span class="built_in">abs</span>(z)+<span class="built_in">abs</span>(x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x * y &gt; <span class="number">0</span> &amp;&amp; x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; x &gt; y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x * y &lt; <span class="number">0</span> &amp;&amp; x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; x &lt; y &amp;&amp; z &lt; y)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x * y &gt; <span class="number">0</span> &amp;&amp; x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; x &lt; y &amp;&amp; z &gt; y &amp;&amp; z&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; x;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x * y &gt; <span class="number">0</span> &amp;&amp; x &lt; <span class="number">0</span> &amp;&amp; y &lt; <span class="number">0</span> &amp;&amp; x &lt; y &amp;&amp; z &gt; y &amp;&amp; z &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="number">2</span> * <span class="built_in">abs</span>(z) + <span class="built_in">abs</span>(x);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="走迷宫"><a href="#走迷宫" class="headerlink" title="走迷宫"></a>走迷宫</h1><p><a href="https://www.luogu.com.cn/problem/U374723?contestId=141340">U374723 hrmm 走迷宫 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>好难！！</p><p>虽然据说是模板，但我对这个存储想了大半年。</p><p>姑且来说一说吧，毕竟练多就菜。</p><p>首先，最短路，bfs合理吧。</p><p>我们存边，用最简便的邻接表合理吧。</p><p>我们是无向图，存两条边合理吧。</p><p>我们bfs开个队列，常规的取出，弹出，枚举合理吧。</p><p>如果是输入最小步数，其实到这里就结束了，走多少个点记录一下也就那么回事。</p><p>但()要打印。</p><p>好吧，我们来想吧，一开始我是想用一整个来存，就存储上一个结点的所有信息，然后没过。</p><p>于是，群友有种存储上一个结点的想法启发了我，于是我也只存储上一个结点了，就每次都把队首的结点要存储自己给扔进去，然后把要遍历的边也进行一个存储，继承一下。</p><p>这样其实存储也完成了。</p><p>那我们就差最后一个输出环节了。</p><p>我们用递归，从最后一个点开始递归，注意后面有个细节，究竟是递归先呢，还是输出先呢？</p><p>是个问题，如果我们输出先，我们想一下，是不是我们的点就从后往前输出了，是不是错了。</p><p>但如果我们下递归，是不是最后的点，其实是最后输出的，达成目的！</p><p>好了，交上去吧。过了，非常难受，泪流满面！！</p><p>等等，打印那里有个回退操作，打印完一直润就是了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;g[<span class="number">200000</span>];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;s[<span class="number">300000</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="type">int</span> vis[<span class="number">300000</span>];</span><br><span class="line"><span class="type">int</span> r;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">q.<span class="built_in">push</span>(x);</span><br><span class="line">vis[x] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">s[t].<span class="built_in">push_back</span>(t);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[t].<span class="built_in">size</span>(); i++)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!vis[g[t][i]])</span><br><span class="line">&#123;</span><br><span class="line">vis[g[t][i]] = <span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(g[t][i]);</span><br><span class="line"></span><br><span class="line">s[g[t][i]].<span class="built_in">push_back</span>(t);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (g[t][i] == r)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"><span class="type">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(r==m)</span><br><span class="line">&#123;</span><br><span class="line">flag=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[r][<span class="number">0</span>]);</span><br><span class="line">cout&lt;&lt;s[r][<span class="number">0</span>]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">cin &gt;&gt; r;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line">cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">g[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">g[y].<span class="built_in">push_back</span>(x);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">bfs</span>(m);</span><br><span class="line"><span class="built_in">print</span>(r);</span><br><span class="line">cout &lt;&lt; r;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="开趴体"><a href="#开趴体" class="headerlink" title="开趴体"></a>开趴体</h1><p>最后一题！</p><p><a href="https://www.luogu.com.cn/problem/U374728?contestId=141340">U374728 hrmm 开趴体 - 洛谷 | 计算机科学教育新生态 (luogu.com.cn)</a></p><p>给大家开个Party</p><p>一道贪心题，就是说我们先把最大的排在偶数位，然后次大排在奇数位，然后比较就可以了。</p><p>群友真厉害啊，我是想不出来一点，被群友一说才会写！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">1000000</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">1000000</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x&gt;y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a+<span class="number">1</span>,a+<span class="number">1</span>+n,cmp);</span><br><span class="line"><span class="type">int</span> n2=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i+=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">b[i]=a[n2++];</span><br><span class="line">&#125;</span><br><span class="line">b[<span class="number">0</span>]=<span class="number">999999999</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">b[i]=a[n2++];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i+=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(b[i]&lt;=b[i<span class="number">-1</span>]||b[i]&lt;=b[i+<span class="number">1</span>])</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;No&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Yes&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="世间温柔，不过是芳春柳摇染花香，槐序蝉鸣入深巷，白茂叶落醉故乡。"><a href="#世间温柔，不过是芳春柳摇染花香，槐序蝉鸣入深巷，白茂叶落醉故乡。" class="headerlink" title="世间温柔，不过是芳春柳摇染花香，槐序蝉鸣入深巷，白茂叶落醉故乡。"></a>世间温柔，不过是芳春柳摇染花香，槐序蝉鸣入深巷，白茂叶落醉故乡。</h1><h1 id="人生何处不相逢，各位再见。"><a href="#人生何处不相逢，各位再见。" class="headerlink" title="人生何处不相逢，各位再见。"></a>人生何处不相逢，各位再见。</h1>]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚类分析</title>
      <link href="/2024/01/29/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/"/>
      <url>/2024/01/29/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="聚类分析"><a href="#聚类分析" class="headerlink" title="聚类分析"></a>聚类分析</h1><p><img src="/images/image-20240129194932249.png" alt="image-20240129194932249"></p><p>聚类不知道类别</p><h1 id="K-means聚类算法"><a href="#K-means聚类算法" class="headerlink" title="K-means聚类算法"></a>K-means聚类算法</h1><p><img src="/images/image-20240129194952521.png" alt="image-20240129194952521"></p><h2 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h2><p><img src="/images/image-20240129195121059.png" alt="image-20240129195121059"></p><h2 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><p><img src="/images/image-20240129195132844.png" alt="image-20240129195132844"></p><h1 id="K-means-算法"><a href="#K-means-算法" class="headerlink" title="K-means++算法"></a>K-means++算法</h1><p><img src="/images/image-20240129195226437.png" alt="image-20240129195226437"></p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p><img src="/images/image-20240129195330285.png" alt="image-20240129195330285"></p><p><img src="/images/image-20240129195405248.png" alt="image-20240129195405248"></p><h1 id="系统（层次）聚类"><a href="#系统（层次）聚类" class="headerlink" title="系统（层次）聚类"></a>系统（层次）聚类</h1><p><img src="/images/image-20240129195509250.png" alt="image-20240129195509250"></p><h2 id="距离计算"><a href="#距离计算" class="headerlink" title="距离计算"></a>距离计算</h2><p><img src="/images/image-20240129195530809.png" alt="image-20240129195530809"></p><p><img src="/images/image-20240129200236007.png" alt="image-20240129200236007"></p><p><img src="/images/image-20240129200246282.png" alt="image-20240129200246282"></p><p><img src="/images/image-20240129200254274.png" alt="image-20240129200254274"></p><p><img src="/images/image-20240129200321590.png" alt="image-20240129200321590"></p><p><img src="/images/image-20240129200335096.png" alt="image-20240129200335096"></p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><img src="/images/image-20240129200430566.png" alt="image-20240129200430566"></p><p><img src="/images/image-20240129200448939.png" alt="image-20240129200448939"></p><blockquote><p>会生成聚类谱系图，以此判断选择几类</p></blockquote><p><img src="/images/image-20240129200741109.png" alt="image-20240129200741109"></p><p><img src="/images/image-20240129200821668.png" alt="image-20240129200821668"></p><blockquote><p>详细操作见下博客</p></blockquote><p><a href="https://blog.csdn.net/My_daily_life/article/details/120627516">SPSS操作(四)：系统聚类分析_聚类分析spss操作-CSDN博客</a></p><h1 id="DBSCAN-算法"><a href="#DBSCAN-算法" class="headerlink" title="DBSCAN 算法"></a>DBSCAN 算法</h1><p><img src="/images/image-20240129201052622.png" alt="image-20240129201052622"></p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><img src="/images/image-20240129201312072.png" alt="image-20240129201312072"></p><p><img src="/images/image-20240129201355010.png" alt="image-20240129201355010"></p><p>代码</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">clc;</span><br><span class="line">clear;</span><br><span class="line">close all;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Load Data</span></span><br><span class="line"></span><br><span class="line">load mydata;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Run DBSCAN Clustering Algorithm</span></span><br><span class="line"></span><br><span class="line">epsilon=<span class="number">0.5</span>;</span><br><span class="line">MinPts=<span class="number">10</span>;</span><br><span class="line">IDX=DBSCAN(X,epsilon,MinPts);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[IDX, isnoise]</span>=<span class="title">DBSCAN</span><span class="params">(X,epsilon,MinPts)</span></span></span><br><span class="line"></span><br><span class="line">    C=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    n=<span class="built_in">size</span>(X,<span class="number">1</span>);</span><br><span class="line">    IDX=<span class="built_in">zeros</span>(n,<span class="number">1</span>);  <span class="comment">% 初始化全部为0，即全部为噪音点</span></span><br><span class="line">    </span><br><span class="line">    D=pdist2(X,X);</span><br><span class="line">    </span><br><span class="line">    visited=<span class="built_in">false</span>(n,<span class="number">1</span>);</span><br><span class="line">    isnoise=<span class="built_in">false</span>(n,<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> ~visited(<span class="built_in">i</span>)</span><br><span class="line">            visited(<span class="built_in">i</span>)=<span class="built_in">true</span>;</span><br><span class="line">            </span><br><span class="line">            Neighbors=RegionQuery(<span class="built_in">i</span>);</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">numel</span>(Neighbors)&lt;MinPts</span><br><span class="line">                <span class="comment">% X(i,:) is NOISE</span></span><br><span class="line">                isnoise(<span class="built_in">i</span>)=<span class="built_in">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                C=C+<span class="number">1</span>;</span><br><span class="line">                ExpandCluster(<span class="built_in">i</span>,Neighbors,C);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">ExpandCluster</span><span class="params">(i,Neighbors,C)</span></span></span><br><span class="line">        IDX(<span class="built_in">i</span>)=C;</span><br><span class="line">        </span><br><span class="line">        k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> <span class="built_in">true</span></span><br><span class="line">            <span class="built_in">j</span> = Neighbors(k);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> ~visited(<span class="built_in">j</span>)</span><br><span class="line">                visited(<span class="built_in">j</span>)=<span class="built_in">true</span>;</span><br><span class="line">                Neighbors2=RegionQuery(<span class="built_in">j</span>);</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">numel</span>(Neighbors2)&gt;=MinPts</span><br><span class="line">                    Neighbors=[Neighbors Neighbors2];   <span class="comment">%#ok</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> IDX(<span class="built_in">j</span>)==<span class="number">0</span></span><br><span class="line">                IDX(<span class="built_in">j</span>)=C;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            </span><br><span class="line">            k = k + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="built_in">numel</span>(Neighbors)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Neighbors</span>=<span class="title">RegionQuery</span><span class="params">(i)</span></span></span><br><span class="line">        Neighbors=<span class="built_in">find</span>(D(<span class="built_in">i</span>,:)&lt;=epsilon);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><blockquote><p>当然，让我逐行解释这段MATLAB代码：</p><ol><li><p><strong>clc; clear; close all;</strong></p><ul><li><code>clc</code>：清除命令窗口。</li><li><code>clear</code>：清除工作区中的所有变量。</li><li><code>close all</code>：关闭所有打开的图形窗口。</li></ul></li><li><p><strong>load mydata;</strong></p><ul><li>从名为 ‘mydata’ 的文件中加载数据到工作区。这里的假设是 ‘mydata’ 包含一个表示数据点的变量 <code>X</code>。</li></ul></li><li><p><strong>epsilon&#x3D;0.5; MinPts&#x3D;10;</strong></p><ul><li>定义DBSCAN算法的参数，<code>epsilon</code> 是邻域半径，<code>MinPts</code> 是邻域内最小数据点数。</li></ul></li><li><p><strong>IDX&#x3D;DBSCAN(X,epsilon,MinPts);</strong></p><ul><li>调用DBSCAN函数，对数据 <code>X</code> 进行密度聚类，返回聚类结果 <code>IDX</code>。</li></ul></li><li><p><strong>function [IDX, isnoise]&#x3D;DBSCAN(X,epsilon,MinPts)</strong></p><ul><li>定义DBSCAN算法的主函数，接受输入参数 <code>X</code>、<code>epsilon</code> 和 <code>MinPts</code>。</li></ul></li><li><p><strong>C&#x3D;0;</strong></p><ul><li>初始化聚类簇数为0。</li></ul></li><li><p><strong>n&#x3D;size(X,1); IDX&#x3D;zeros(n,1);</strong></p><ul><li>获取数据点数量 <code>n</code>，初始化聚类标签 <code>IDX</code> 全部为0，表示所有点都是噪音点。</li></ul></li><li><p><strong>D&#x3D;pdist2(X,X);</strong></p><ul><li>计算数据点之间的距离矩阵 <code>D</code>。</li></ul></li><li><p><strong>visited&#x3D;false(n,1); isnoise&#x3D;false(n,1);</strong></p><ul><li>初始化用于标记是否访问过的向量 <code>visited</code> 和标记是否为噪音点的向量 <code>isnoise</code>。</li></ul></li><li><p><strong>for i&#x3D;1:n</strong></p><ul><li>开始对每个数据点进行迭代。</li></ul></li><li><p><strong>if ~visited(i)</strong></p><ul><li>如果当前点未被访问过，则执行以下操作。</li></ul></li><li><p><strong>visited(i)&#x3D;true; Neighbors&#x3D;RegionQuery(i);</strong></p><ul><li>将当前点标记为已访问，然后找到与当前点在邻域内的点集合 <code>Neighbors</code>。</li></ul></li><li><p><strong>if numel(Neighbors)&lt;MinPts</strong></p><ul><li>如果邻域内点的数量小于 <code>MinPts</code>，则将当前点标记为噪音点。</li></ul></li><li><p><strong>else</strong></p><ul><li>否则，执行以下聚类操作。</li></ul></li><li><p><strong>C&#x3D;C+1; ExpandCluster(i,Neighbors,C);</strong></p><ul><li>增加聚类簇数，并进行扩展聚类操作。</li></ul></li><li><p><strong>function ExpandCluster(i,Neighbors,C)</strong></p><ul><li>定义扩展聚类的子函数，给定当前点、邻域内点集合和当前簇数。</li></ul></li><li><p><strong>IDX(i)&#x3D;C;</strong></p><ul><li>将当前点标记为属于当前簇。</li></ul></li><li><p><strong>while true</strong></p><ul><li>进入循环，不断扩展聚类。</li></ul></li><li><p><strong>j &#x3D; Neighbors(k);</strong></p><ul><li>取出邻域内的第 k 个点。</li></ul></li><li><p><strong>if ~visited(j)</strong></p><ul><li>如果该点未被访问过，则执行以下操作。</li></ul></li><li><p><strong>visited(j)&#x3D;true; Neighbors2&#x3D;RegionQuery(j);</strong></p><ul><li>将该点标记为已访问，然后找到与该点在邻域内的点集合 <code>Neighbors2</code>。</li></ul></li><li><p><strong>if numel(Neighbors2)&gt;&#x3D;MinPts</strong></p><ul><li>如果新邻域内的点数量大于等于 <code>MinPts</code>，则将新邻域内的点添加到原邻域中。</li></ul></li><li><p><strong>Neighbors&#x3D;[Neighbors Neighbors2];</strong></p><ul><li>将新邻域内的点添加到原邻域中。</li></ul></li><li><p><strong>end</strong></p><ul><li>结束新邻域内点的处理。</li></ul></li><li><p><strong>if IDX(j)&#x3D;&#x3D;0</strong></p><ul><li>如果该点尚未被分配到任何簇，则将其分配到当前簇。</li></ul></li><li><p><strong>IDX(j)&#x3D;C;</strong></p><ul><li>将该点标记为属于当前簇。</li></ul></li><li><p><strong>k &#x3D; k + 1; if k &gt; numel(Neighbors) break; end</strong></p><ul><li>处理邻域内的下一个点，直到邻域内的所有点都被处理完。</li></ul></li><li><p><strong>function Neighbors&#x3D;RegionQuery(i)</strong></p><ul><li>定义邻域查询的子函数，给定当前点的索引 <code>i</code>，返回在邻域内的点的索引集合。</li></ul></li><li><p><strong>Neighbors&#x3D;find(D(i,:)&lt;&#x3D;epsilon);</strong></p><ul><li>根据距离矩阵，找到与当前点距离在 <code>epsilon</code> 以内的点。</li></ul></li><li><p><strong>end</strong></p><ul><li>结束邻域查询子函数。</li></ul></li><li><p><strong>end</strong></p><ul><li>结束主函数。</li></ul></li></ol><p>这样，整个代码就实现了DBSCAN聚类算法。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>主成分分析</title>
      <link href="/2024/01/29/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/"/>
      <url>/2024/01/29/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="主成分分析法"><a href="#主成分分析法" class="headerlink" title="主成分分析法"></a>主成分分析法</h1><blockquote><p>主成分分析法</p><p>综述：数据降维的方法</p><p>可以用一种线性变换的思想去理解，比如二维的一条直线，我们可以通过变换，使得这一条直线落在x或y轴上，达到降维的效果。</p></blockquote><blockquote><p>去中心化（把坐标原点放在数据中心）</p><p>找坐标系，找到数据方差最大的方向，就是第一主成分。（如果第一主成分不足以表达，就考虑吧选取第二个）</p><p>为了有效反映原来信息，第一主成分和第二主成分的协方差为0.以此类推可以获得p个主成分。这些主成分是互不相关，是依次递减的。</p><p>累计方差贡献率大于百分之80就可以了，或者特征根大于1就可以了。</p><p>？根据线性代数的知识，我们需要一则伸缩，二则旋转，伸缩不是问题</p><p>旋转的矩阵R又从何而来？</p><p>即是协方差矩阵的特征向量就是R。</p><p>协方差定义&#x3D;</p><p><img src="/2024/01/29/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\b4c05a2fa4534b348766263f53609b76.png" alt="img"></p></blockquote><p><img src="/2024/01/29/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240129173904717.png" alt="image-20240129173904717"></p><p><img src="/2024/01/29/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240129173917094.png" alt="image-20240129173917094"></p><p><img src="/2024/01/29/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240129173940409.png" alt="image-20240129173940409"></p><p><img src="/2024/01/29/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240129173956777.png" alt="image-20240129173956777"></p><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><p><img src="/2024/01/29/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240129174252433.png" alt="image-20240129174252433"></p><p><img src="/2024/01/29/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240129174259805.png" alt="image-20240129174259805"></p><p><img src="/2024/01/29/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90/Totoro.trip\blog-demo\source\images\image-20240129174305765.png" alt="image-20240129174305765"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line"> load data1.mat   <span class="comment">% 主成分聚类</span></span><br><span class="line"><span class="comment">%  load data2.mat   % 主成分回归</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 注意，这里可以对数据先进行描述性统计</span></span><br><span class="line"><span class="comment">% 描述性统计的内容见第5讲.相关系数</span></span><br><span class="line">[n,p] = <span class="built_in">size</span>(x);  <span class="comment">% n是样本个数，p是指标个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第一步：对数据x标准化为X</span></span><br><span class="line">X=zscore(x);   <span class="comment">% matlab内置的标准化函数（x-mean(x)）/std(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第二步：计算样本协方差矩阵</span></span><br><span class="line">R = cov(X);</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 注意：以上两步可合并为下面一步：直接计算样本相关系数矩阵</span></span><br><span class="line">R = corrcoef(x);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;样本相关系数矩阵为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(R)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：计算R的特征值和特征向量</span></span><br><span class="line"><span class="comment">% 注意：R是半正定矩阵，所以其特征值不为负数</span></span><br><span class="line"><span class="comment">% R同时是对称矩阵，Matlab计算对称矩阵时，会将特征值按照从小到大排列哦</span></span><br><span class="line"><span class="comment">% eig函数的详解见第一讲层次分析法的视频</span></span><br><span class="line">[V,D] = eig(R);  <span class="comment">% V 特征向量矩阵  D 特征值构成的对角矩阵</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：计算主成分贡献率和累计贡献率</span></span><br><span class="line">lambda = <span class="built_in">diag</span>(D);  <span class="comment">% diag函数用于得到一个矩阵的主对角线元素值(返回的是列向量)</span></span><br><span class="line">lambda = lambda(<span class="keyword">end</span>:<span class="number">-1</span>:<span class="number">1</span>);  <span class="comment">% 因为lambda向量是从小大到排序的，我们将其调个头</span></span><br><span class="line">contribution_rate = lambda / sum(lambda);  <span class="comment">% 计算贡献率</span></span><br><span class="line">cum_contribution_rate = cumsum(lambda)/ sum(lambda);   <span class="comment">% 计算累计贡献率  cumsum是求累加值的函数</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;特征值为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(lambda&#x27;)  <span class="comment">% 转置为行向量，方便展示</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;贡献率为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(contribution_rate&#x27;)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;累计贡献率为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(cum_contribution_rate&#x27;)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;与特征值对应的特征向量矩阵为：&#x27;</span>)</span><br><span class="line"><span class="comment">% 注意：这里的特征向量要和特征值一一对应，之前特征值相当于颠倒过来了，因此特征向量的各列需要颠倒过来</span></span><br><span class="line"><span class="comment">%  rot90函数可以使一个矩阵逆时针旋转90度，然后再转置，就可以实现将矩阵的列颠倒的效果</span></span><br><span class="line">V=<span class="built_in">rot90</span>(V)&#x27;;</span><br><span class="line"><span class="built_in">disp</span>(V)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算我们所需要的主成分的值</span></span><br><span class="line">m =input(<span class="string">&#x27;请输入需要保存的主成分的个数:  &#x27;</span>);</span><br><span class="line">F = <span class="built_in">zeros</span>(n,m);  <span class="comment">%初始化保存主成分的矩阵（每一列是一个主成分）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:m</span><br><span class="line">    ai = V(:,<span class="built_in">i</span>)&#x27;;   <span class="comment">% 将第i个特征向量取出，并转置为行向量</span></span><br><span class="line">    Ai = <span class="built_in">repmat</span>(ai,n,<span class="number">1</span>);   <span class="comment">% 将这个行向量重复n次，构成一个n*p的矩阵</span></span><br><span class="line">    F(:, <span class="built_in">i</span>) = sum(Ai .* X, <span class="number">2</span>);  <span class="comment">% 注意，对标准化的数据求了权重后要计算每一行的和</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% (1)主成分聚类 ： 将主成分指标所在的F矩阵复制到Excel表格，然后再用Spss进行聚类</span></span><br><span class="line"><span class="comment">% 在Excel第一行输入指标名称（F1,F2, ..., Fm）</span></span><br><span class="line"><span class="comment">% 双击Matlab工作区的F,进入变量编辑中，然后复制里面的数据到Excel表格</span></span><br><span class="line"><span class="comment">% 导出数据之后，我们后续的分析就可以在Spss中进行。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%（2）主成分回归：将x使用主成分得到主成分指标，并将y标准化，接着导出到Excel，然后再使用Stata回归</span></span><br><span class="line"><span class="comment">% Y = zscore(y);  % 一定要将y进行标准化哦~</span></span><br><span class="line"><span class="comment">% 在Excel第一行输入指标名称（Y,F1, F2, ..., Fm）</span></span><br><span class="line"><span class="comment">% 分别双击Matlab工作区的Y和F,进入变量编辑中，然后复制里面的数据到Excel表格</span></span><br><span class="line"><span class="comment">% 导出数据之后，我们后续的分析就可以在Stata中进行。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>相关系数</title>
      <link href="/2024/01/29/%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/"/>
      <url>/2024/01/29/%E7%9B%B8%E5%85%B3%E7%B3%BB%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h1><p><img src="/images/image-20240129170729588.png" alt="image-20240129170729588"></p><h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p><img src="/images/image-20240129170914371.png" alt="image-20240129170914371"></p><p><img src="/images/image-20240129170932334.png" alt="image-20240129170932334"></p><p><img src="/images/image-20240129170952987.png" alt="image-20240129170952987"></p><blockquote><p>一定要确定两个变量之间线性相关程度的指标</p></blockquote><p><img src="/images/image-20240129171117827.png" alt="image-20240129171117827"></p><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><img src="/images/image-20240129171136975.png" alt="image-20240129171136975"></p><p><img src="/images/image-20240129171450116.png" alt="image-20240129171450116"></p><h2 id="假设检验理论部分：略"><a href="#假设检验理论部分：略" class="headerlink" title="假设检验理论部分：略"></a>假设检验理论部分：略</h2><blockquote><p>这篇讲的很好，可以直接看</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/194254252">数学建模笔记——相关系数 - 知乎 (zhihu.com)</a></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line">load <span class="string">&#x27;physical fitness test.mat&#x27;</span>  <span class="comment">%文件名如果有空格隔开，那么需要加引号</span></span><br><span class="line"><span class="comment">% https://ww2.mathworks.cn/help/matlab/ref/corrcoef.html</span></span><br><span class="line"><span class="comment">%% 统计描述</span></span><br><span class="line">MIN = <span class="built_in">min</span>(Test);  <span class="comment">% 每一列的最小值</span></span><br><span class="line">MAX = <span class="built_in">max</span>(Test);   <span class="comment">% 每一列的最大值</span></span><br><span class="line">MEAN = <span class="built_in">mean</span>(Test);  <span class="comment">% 每一列的均值</span></span><br><span class="line">MEDIAN = median(Test);  <span class="comment">%每一列的中位数</span></span><br><span class="line">SKEWNESS = skewness(Test); <span class="comment">%每一列的偏度</span></span><br><span class="line">KURTOSIS = kurtosis(Test);  <span class="comment">%每一列的峰度</span></span><br><span class="line">STD = std(Test);  <span class="comment">% 每一列的标准差</span></span><br><span class="line">RESULT = [MIN;MAX;MEAN;MEDIAN;SKEWNESS;KURTOSIS;STD]  <span class="comment">%将这些统计量放到一个矩阵中表示</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算各列之间的相关系数</span></span><br><span class="line"><span class="comment">% 在计算皮尔逊相关系数之前,一定要做出散点图来看两组变量之间是否有线性关系</span></span><br><span class="line"><span class="comment">% 这里使用Spss比较方便: 图形 - 旧对话框 - 散点图/点图 - 矩阵散点图</span></span><br><span class="line"></span><br><span class="line">R = corrcoef(Test)   <span class="comment">% correlation coefficient</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 假设检验部分</span></span><br><span class="line">x = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">y = tpdf(x,<span class="number">28</span>);  <span class="comment">%求t分布的概率密度值 28是自由度  </span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">grid on  <span class="comment">% 在画出的图上加上网格线</span></span><br><span class="line"><span class="built_in">hold</span> on  <span class="comment">% 保留原来的图，以便继续在上面操作</span></span><br><span class="line"><span class="comment">% matlab可以求出临界值，函数如下</span></span><br><span class="line">tinv(<span class="number">0.975</span>,<span class="number">28</span>)    <span class="comment">%    2.0484</span></span><br><span class="line"><span class="comment">% 这个函数是累积密度函数cdf的反函数</span></span><br><span class="line"><span class="built_in">plot</span>([<span class="number">-2.048</span>,<span class="number">-2.048</span>],[<span class="number">0</span>,tpdf(<span class="number">-2.048</span>,<span class="number">28</span>)],<span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">2.048</span>,<span class="number">2.048</span>],[<span class="number">0</span>,tpdf(<span class="number">2.048</span>,<span class="number">28</span>)],<span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算p值</span></span><br><span class="line">x = <span class="number">-4</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">y = tpdf(x,<span class="number">28</span>);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">grid on </span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="comment">% 画线段的方法</span></span><br><span class="line"><span class="built_in">plot</span>([<span class="number">-3.055</span>,<span class="number">-3.055</span>],[<span class="number">0</span>,tpdf(<span class="number">-3.055</span>,<span class="number">28</span>)],<span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">3.055</span>,<span class="number">3.055</span>],[<span class="number">0</span>,tpdf(<span class="number">3.055</span>,<span class="number">28</span>)],<span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;该检验值对应的p值为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>((<span class="number">1</span>-tcdf(<span class="number">3.055</span>,<span class="number">28</span>))*<span class="number">2</span>)  <span class="comment">%双侧检验的p值要乘以2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算各列之间的相关系数以及p值</span></span><br><span class="line">[R,P] = corrcoef(Test)</span><br><span class="line"><span class="comment">% 在EXCEL表格中给数据右上角标上显著性符号吧</span></span><br><span class="line">P &lt; <span class="number">0.01</span>  <span class="comment">% 标记3颗星的位置</span></span><br><span class="line">(P &lt; <span class="number">0.05</span>) .* (P &gt; <span class="number">0.01</span>)  <span class="comment">% 标记2颗星的位置</span></span><br><span class="line">(P &lt; <span class="number">0.1</span>) .* (P &gt; <span class="number">0.05</span>) <span class="comment">% % 标记1颗星的位置</span></span><br><span class="line"><span class="comment">% 也可以使用Spss操作哦 看我演示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 正态分布检验</span></span><br><span class="line"><span class="comment">% 正态分布的偏度和峰度</span></span><br><span class="line">x = normrnd(<span class="number">2</span>,<span class="number">3</span>,<span class="number">100</span>,<span class="number">1</span>);   <span class="comment">% 生成100*1的随机向量，每个元素是均值为2，标准差为3的正态分布</span></span><br><span class="line">skewness(x)  <span class="comment">%偏度</span></span><br><span class="line">kurtosis(x)  <span class="comment">%峰度</span></span><br><span class="line">qqplot(x)</span><br><span class="line">    </span><br><span class="line"><span class="comment">% 检验第一列数据是否为正态分布</span></span><br><span class="line">[h,p] = jbtest(Test(:,<span class="number">1</span>),<span class="number">0.05</span>)</span><br><span class="line">[h,p] = jbtest(Test(:,<span class="number">1</span>),<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 用循环检验所有列的数据</span></span><br><span class="line">n_c = <span class="built_in">size</span>(Test,<span class="number">2</span>);  <span class="comment">% number of column 数据的列数</span></span><br><span class="line">H = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">6</span>);  <span class="comment">% 初始化节省时间和消耗</span></span><br><span class="line">P = <span class="built_in">zeros</span>(<span class="number">1</span>,<span class="number">6</span>);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n_c</span><br><span class="line">    [h,p] = jbtest(Test(:,<span class="built_in">i</span>),<span class="number">0.05</span>);</span><br><span class="line">    H(<span class="built_in">i</span>)=h;</span><br><span class="line">    P(<span class="built_in">i</span>)=p;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(H)</span><br><span class="line"><span class="built_in">disp</span>(P)</span><br><span class="line"></span><br><span class="line"><span class="comment">% Q-Q图</span></span><br><span class="line">qqplot(Test(:,<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 斯皮尔曼相关系数</span></span><br><span class="line">X = [<span class="number">3</span> <span class="number">8</span> <span class="number">4</span> <span class="number">7</span> <span class="number">2</span>]&#x27;  <span class="comment">% 一定要是列向量哦，一撇&#x27;表示求转置</span></span><br><span class="line">Y = [<span class="number">5</span> <span class="number">10</span> <span class="number">9</span> <span class="number">10</span> <span class="number">6</span>]&#x27;</span><br><span class="line"><span class="comment">% 第一种计算方法</span></span><br><span class="line"><span class="number">1</span><span class="number">-6</span>*(<span class="number">1</span>+<span class="number">0.25</span>+<span class="number">0.25</span>+<span class="number">1</span>)/<span class="number">5</span>/<span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二种计算方法</span></span><br><span class="line">coeff = corr(X , Y , <span class="string">&#x27;type&#x27;</span> , <span class="string">&#x27;Spearman&#x27;</span>)</span><br><span class="line"><span class="comment">% 等价于：</span></span><br><span class="line">RX = [<span class="number">2</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">1</span>]</span><br><span class="line">RY = [<span class="number">1</span> <span class="number">4.5</span> <span class="number">3</span> <span class="number">4.5</span> <span class="number">2</span>]</span><br><span class="line">R = corrcoef(RX,RY)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 计算矩阵各列的斯皮尔曼相关系数</span></span><br><span class="line">R = corr(Test, <span class="string">&#x27;type&#x27;</span> , <span class="string">&#x27;Spearman&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 大样本下的假设检验</span></span><br><span class="line"><span class="comment">% 计算检验值</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="built_in">sqrt</span>(<span class="number">590</span>)*<span class="number">0.0301</span>)</span><br><span class="line"><span class="comment">% 计算p值</span></span><br><span class="line"><span class="built_in">disp</span>((<span class="number">1</span>-normcdf(<span class="number">0.7311</span>))*<span class="number">2</span>) <span class="comment">% normcdf用来计算标准正态分布的累积概率密度函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 直接给出相关系数和p值</span></span><br><span class="line">[R,P]=corr(Test, <span class="string">&#x27;type&#x27;</span> , <span class="string">&#x27;Spearman&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插值与拟合</title>
      <link href="/2024/01/29/%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/"/>
      <url>/2024/01/29/%E6%8F%92%E5%80%BC%E4%B8%8E%E6%8B%9F%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="插值与拟合"><a href="#插值与拟合" class="headerlink" title="插值与拟合"></a>插值与拟合</h1><h2 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 分段三次埃尔米特插值</span></span><br><span class="line">x = -<span class="built_in">pi</span>:<span class="built_in">pi</span>; y = <span class="built_in">sin</span>(x); </span><br><span class="line">new_x = -<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="built_in">pi</span>;</span><br><span class="line">p = pchip(x,y,new_x);</span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>); <span class="comment">% 在同一个脚本文件里面，要想画多个图，需要给每个图编号，否则只会显示最后一个图哦~</span></span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;o&#x27;</span>, new_x, p, <span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% plot函数用法:</span></span><br><span class="line"><span class="comment">% plot(x1,y1,x2,y2) </span></span><br><span class="line"><span class="comment">% 线方式： - 实线 :点线 -. 虚点线 - - 波折线 </span></span><br><span class="line"><span class="comment">% 点方式： . 圆点  +加号  * 星号  x x形  o 小圆</span></span><br><span class="line"><span class="comment">% 颜色： y黄； r红； g绿； b蓝； w白； k黑； m紫； c青</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 三次样条插值和分段三次埃尔米特插值的对比</span></span><br><span class="line">x = -<span class="built_in">pi</span>:<span class="built_in">pi</span>; </span><br><span class="line">y = <span class="built_in">sin</span>(x); </span><br><span class="line">new_x = -<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="built_in">pi</span>;</span><br><span class="line">p1 = pchip(x,y,new_x);   <span class="comment">%分段三次埃尔米特插值</span></span><br><span class="line">p2 = spline(x,y,new_x);  <span class="comment">%三次样条插值</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>,new_x,p1,<span class="string">&#x27;r-&#x27;</span>,new_x,p2,<span class="string">&#x27;b-&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;样本点&#x27;</span>,<span class="string">&#x27;三次埃尔米特插值&#x27;</span>,<span class="string">&#x27;三次样条插值&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,<span class="string">&#x27;SouthEast&#x27;</span>)   <span class="comment">%标注显示在东南方向</span></span><br><span class="line"><span class="comment">% 说明：</span></span><br><span class="line"><span class="comment">% LEGEND(string1,string2,string3, …)</span></span><br><span class="line"><span class="comment">% 分别将字符串1、字符串2、字符串3……标注到图中，每个字符串对应的图标为画图时的图标。</span></span><br><span class="line"><span class="comment">% ‘Location’用来指定标注显示的位置</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% n维数据的插值</span></span><br><span class="line">x = -<span class="built_in">pi</span>:<span class="built_in">pi</span>; y = <span class="built_in">sin</span>(x); </span><br><span class="line">new_x = -<span class="built_in">pi</span>:<span class="number">0.1</span>:<span class="built_in">pi</span>;</span><br><span class="line">p = interpn (x, y, new_x, <span class="string">&#x27;spline&#x27;</span>);</span><br><span class="line"><span class="comment">% 等价于 p = spline(x, y, new_x);</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">plot</span>(x, y, <span class="string">&#x27;o&#x27;</span>, new_x, p, <span class="string">&#x27;r-&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 人口预测（注意：一般我们很少使用插值算法来预测数据，随着课程的深入，后面的章节会有更适合预测的算法供大家选择，例如灰色预测、拟合预测等）</span></span><br><span class="line">population=[<span class="number">133126</span>,<span class="number">133770</span>,<span class="number">134413</span>,<span class="number">135069</span>,<span class="number">135738</span>,<span class="number">136427</span>,<span class="number">137122</span>,<span class="number">137866</span>,<span class="number">138639</span>, <span class="number">139538</span>];</span><br><span class="line">year = <span class="number">2009</span>:<span class="number">2018</span>;</span><br><span class="line">p1 = pchip(year, population, <span class="number">2019</span>:<span class="number">2021</span>)  <span class="comment">%分段三次埃尔米特插值预测</span></span><br><span class="line">p2 = spline(year, population, <span class="number">2019</span>:<span class="number">2021</span>) <span class="comment">%三次样条插值预测</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">4</span>);</span><br><span class="line"><span class="built_in">plot</span>(year, population,<span class="string">&#x27;o&#x27;</span>,<span class="number">2019</span>:<span class="number">2021</span>,p1,<span class="string">&#x27;r*-&#x27;</span>,<span class="number">2019</span>:<span class="number">2021</span>,p2,<span class="string">&#x27;bx-&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;样本点&#x27;</span>,<span class="string">&#x27;三次埃尔米特插值预测&#x27;</span>,<span class="string">&#x27;三次样条插值预测&#x27;</span>,<span class="string">&#x27;Location&#x27;</span>,<span class="string">&#x27;SouthEast&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="拟合"><a href="#拟合" class="headerlink" title="拟合"></a>拟合</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line">load  data1</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="comment">% 给x和y轴加上标签</span></span><br><span class="line">xlabel(<span class="string">&#x27;x的值&#x27;</span>)</span><br><span class="line">ylabel(<span class="string">&#x27;y的值&#x27;</span>)</span><br><span class="line">n = <span class="built_in">size</span>(x,<span class="number">1</span>);</span><br><span class="line">k = (n*sum(x.*y)-sum(x)*sum(y))/(n*sum(x.*x)-sum(x)*sum(x))</span><br><span class="line">b = (sum(x.*x)*sum(y)-sum(x)*sum(x.*y))/(n*sum(x.*x)-sum(x)*sum(x))</span><br><span class="line"><span class="built_in">hold</span> on <span class="comment">% 继续在之前的图形上来画图形</span></span><br><span class="line">grid on <span class="comment">% 显示网格线</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% % 画出y=kx+b的函数图像 plot(x,y)</span></span><br><span class="line"><span class="comment">% % 传统的画法：模拟生成x和y的序列，比如要画出[0,5]上的图形</span></span><br><span class="line"><span class="comment">% xx = 2.5: 0.1 :7  % 间隔设置的越小画出来的图形越准确</span></span><br><span class="line"><span class="comment">% yy = k * xx + b  % k和b都是已知值</span></span><br><span class="line"><span class="comment">% plot(xx,yy,&#x27;-&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 匿名函数的基本用法。</span></span><br><span class="line"><span class="comment">% handle = @(arglist) anonymous_function</span></span><br><span class="line"><span class="comment">% 其中handle为调用匿名函数时使用的名字。</span></span><br><span class="line"><span class="comment">% arglist为匿名函数的输入参数，可以是一个，也可以是多个，用逗号分隔。</span></span><br><span class="line"><span class="comment">% anonymous_function为匿名函数的表达式。</span></span><br><span class="line"><span class="comment">% 举个小例子</span></span><br><span class="line"><span class="comment">%  z=@(x,y) x^2+y^2; </span></span><br><span class="line"><span class="comment">%  z(1,2) </span></span><br><span class="line"><span class="comment">% % ans =  5</span></span><br><span class="line"><span class="comment">% fplot函数可用于画出匿名一元函数的图形。</span></span><br><span class="line"><span class="comment">% fplot(f,xinterval) 将匿名函数f在指定区间xinterval绘图。xinterval =  [xmin xmax] 表示定义域的范围</span></span><br><span class="line"></span><br><span class="line">f=@(x) k*x+b;</span><br><span class="line">fplot(f,[<span class="number">2.5</span>,<span class="number">7</span>]);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;样本数据&#x27;</span>,<span class="string">&#x27;拟合函数&#x27;</span>,<span class="string">&#x27;location&#x27;</span>,<span class="string">&#x27;SouthEast&#x27;</span>)</span><br><span class="line"></span><br><span class="line">y_hat = k*x+b; <span class="comment">% y的拟合值</span></span><br><span class="line">SSR = sum((y_hat-<span class="built_in">mean</span>(y)).^<span class="number">2</span>)  <span class="comment">% 回归平方和</span></span><br><span class="line">SSE = sum((y_hat-y).^<span class="number">2</span>) <span class="comment">% 误差平方和</span></span><br><span class="line">SST = sum((y-<span class="built_in">mean</span>(y)).^<span class="number">2</span>) <span class="comment">% 总体平方和</span></span><br><span class="line">SST-SSE-SSR   <span class="comment">% 5.6843e-14  =   5.6843*10^-14   matlab浮点数计算的一个误差</span></span><br><span class="line">R_2 = SSR / SST</span><br></pre></td></tr></table></figure><h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% （1）randi : 产生均匀分布的随机整数（i = int）  </span></span><br><span class="line"><span class="comment">%产生一个1至10之间的随机整数矩阵，大小为2x5；</span></span><br><span class="line">s1 = randi(<span class="number">10</span>,<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">%产生一个-5至5之间的随机整数矩阵，大小为1x10；</span></span><br><span class="line">s2 = randi([<span class="number">-5</span>,<span class="number">5</span>],<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%  （2） rand: 产生0至1之间均匀分布的随机数</span></span><br><span class="line"><span class="comment">%产生一个0至1之间的随机矩阵，大小为1x5；</span></span><br><span class="line">s3 = <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment">%产生一个a至b之间的随机矩阵，大小为1x5；  % a + (b-a) * rand(1,5); 如：a,b = 2,5</span></span><br><span class="line">s4= <span class="number">2</span> + (<span class="number">5</span><span class="number">-2</span>) * <span class="built_in">rand</span>(<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% （3）normrnd:产生正态分布的随机数</span></span><br><span class="line"><span class="comment">%产生一个均值为0，标准差（方差开根号）为2的正态分布的随机矩阵，大小为3x4；</span></span><br><span class="line">s5 = normrnd(<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% （4）roundn—任意位置四舍五入</span></span><br><span class="line"><span class="comment">% 0个位 1十位  2百位 -1小数点后一位  </span></span><br><span class="line">a = <span class="number">3.1415</span></span><br><span class="line">roundn(a,<span class="number">-2</span>)    <span class="comment">% ans   =  3.1400</span></span><br><span class="line">roundn(a,<span class="number">2</span>)      <span class="comment">% ans   =  0</span></span><br><span class="line">a =<span class="number">31415</span></span><br><span class="line">roundn(a,<span class="number">2</span>)   <span class="comment">% ans  = 31400</span></span><br><span class="line">roundn(<span class="number">5.5</span>,<span class="number">0</span>)  <span class="comment">%6</span></span><br><span class="line">roundn(<span class="number">5.5</span>,<span class="number">1</span>) <span class="comment">%10</span></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">clear;clc </span><br><span class="line">x = <span class="built_in">rand</span>(<span class="number">30</span>,<span class="number">1</span>) * <span class="number">10</span>;  <span class="comment">% x是0-10之间均匀分布的随机向量（30个样本）</span></span><br><span class="line">y = <span class="number">3</span> * <span class="built_in">exp</span>(<span class="number">0.5</span>*x) <span class="number">-5</span> + normrnd(<span class="number">0</span>,<span class="number">1</span>,<span class="number">30</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% cftool </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="CSDN博客搬运"><a href="#CSDN博客搬运" class="headerlink" title="CSDN博客搬运"></a>CSDN博客搬运</h1><p>一维插值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hours = <span class="number">1</span>:<span class="number">12</span>;</span><br><span class="line">temps = [<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">16</span>,<span class="number">24</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">29</span>,<span class="number">22</span>,<span class="number">25</span>,<span class="number">27</span>,<span class="number">24</span>];</span><br><span class="line">t = interp1(hours,temps,[<span class="number">3.5</span>,<span class="number">6.3</span>,<span class="number">7.2</span>],<span class="string">&#x27;linear&#x27;</span>)</span><br></pre></td></tr></table></figure><p><code>interp1</code>是 MATLAB 中用于一维插值的函数。它可以用于在给定数据点上进行线性或其他类型的插值。在例子中，已经定义了时间点<code>hours</code>和对应的温度数据点<code>temps</code>，然后使用<code>interp1</code>来插值在一些新的时间点上的温度值。</p><p> code</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hours = <span class="number">1</span>:<span class="number">12</span>; <span class="comment">% 时间点 temps = [5,7,9,16,24,28,31,29,22,25,27,24]; % 对应的温度数据点 % 在新的时间点上进行线性插值 new_hours = [3.5, 6.3, 7.2]; % 新的时间点 interpolated_temps = interp1(hours, temps, new_hours, &#x27;linear&#x27;); disp(interpolated_temps); </span></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>interp1</code>的语法是：</p><p> code</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vq = interp1(X, V, Xq, method); </span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><code>X</code>是原始数据点的横坐标（这里是<code>hours</code>）。</li><li><code>V</code>是原始数据点的纵坐标（这里是<code>temps</code>）。</li><li><code>Xq</code>是要在其上进行插值的新横坐标（这里是<code>new_hours</code>）。</li><li><code>method</code>是插值方法，这里使用线性插值，可以选择其他方法，如<code>&#39;spline&#39;</code>等。</li></ul><p>在这个例子中，<code>interpolated_temps</code>是在新时间点上通过线性插值得到的温度值。</p><p>运行结果</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; test1</span><br><span class="line">t =</span><br><span class="line">   <span class="number">12.5000</span>   <span class="number">28.9000</span>   <span class="number">30.6000</span></span><br></pre></td></tr></table></figure><p>三次样条插值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">years = <span class="number">1900</span>:<span class="number">10</span>:<span class="number">2010</span>;   <span class="comment">% 年份数据点</span></span><br><span class="line">production = [<span class="number">75.995</span>,<span class="number">91.972</span>,<span class="number">105.711</span>,<span class="number">123.203</span>,<span class="number">131.699</span>,<span class="number">150.697</span>,<span class="number">179.323</span>,<span class="number">203.212</span>,<span class="number">226.505</span>,<span class="number">249.633</span>,<span class="number">256.344</span>,<span class="number">267.893</span>];   <span class="comment">% 对应的产量数据点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 在 1995 年进行三次样条插值</span></span><br><span class="line">p1995 = interp1(years, production, <span class="number">1995</span>, <span class="string">&#x27;pchip&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 由于版本问题，这里的三次样条命令为&#x27;phip&#x27;</span></span><br><span class="line"><span class="built_in">plot</span>(years, production, <span class="string">&#x27;-*&#x27;</span>);</span><br></pre></td></tr></table></figure><p>在 MATLAB 中，<code>pchip</code>是三次样条插值方法（Piecewise Cubic Hermite Interpolating Polynomial）的一种。三次样条插值是一种用于在给定数据点之间进行平滑插值的技术。<code>pchip</code> 插值使用分段三次 Hermite 曲线，确保插值曲线在原始数据点上是光滑的。</p><p>在例子中，使用了<code>interp1</code>函数来进行三次样条插值，代码如下：</p><p> code</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">years = <span class="number">1900</span>:<span class="number">10</span>:<span class="number">2010</span>; <span class="comment">% 年份数据点 production = [75.995,91.972,105.711,123.203,131.699,150.697,179.323,203.212,226.505,249.633,256.344,267.893]; % 对应的产量数据点 % 在 1995 年进行三次样条插值 p1995 = interp1(years, production, 1995, &#x27;pchip&#x27;); % 由于版本问题，这里的三次样条命令为&#x27;phip&#x27; plot(years, production, &#x27;-*&#x27;); </span></span><br></pre></td></tr></table></figure><p>这里的<code>&#39;pchip&#39;</code>表示使用三次样条插值方法，确保在插值曲线上保持平滑。<code>interp1</code>函数将在给定的年份数据点上插值得到 1995 年的产量值，并将结果存储在变量<code>p1995</code>中。在<code>plot</code>命令中，你可以看到原始数据点的图形以及插值曲线。</p><p>运行结果</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; test2</span><br><span class="line">p1995 = <span class="number">253.2278</span></span><br></pre></td></tr></table></figure><p>二维插值</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>:<span class="number">5</span>;</span><br><span class="line">y = <span class="number">1</span>:<span class="number">3</span>;</span><br><span class="line">temps=[<span class="number">82</span>,<span class="number">81</span>,<span class="number">80</span>,<span class="number">82</span>,<span class="number">84</span>;<span class="number">79</span>,<span class="number">63</span>,<span class="number">61</span>,<span class="number">65</span>,<span class="number">81</span>;<span class="number">84</span>,<span class="number">84</span>,<span class="number">82</span>,<span class="number">85</span>,<span class="number">86</span>];</span><br><span class="line">mesh(x,y,temps)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span>:<span class="number">5</span>;</span><br><span class="line">y = <span class="number">1</span>:<span class="number">3</span>;</span><br><span class="line">temps = [<span class="number">82</span>,<span class="number">81</span>,<span class="number">80</span>,<span class="number">82</span>,<span class="number">84</span>;<span class="number">79</span>,<span class="number">63</span>,<span class="number">61</span>,<span class="number">65</span>,<span class="number">81</span>;<span class="number">84</span>,<span class="number">84</span>,<span class="number">82</span>,<span class="number">85</span>,<span class="number">86</span>];</span><br><span class="line">xi = <span class="number">1</span>:<span class="number">0.2</span>:<span class="number">5</span>;</span><br><span class="line">yi = <span class="number">1</span>:<span class="number">0.2</span>:<span class="number">3</span>;</span><br><span class="line">zi = interp2(x,y,temps,xi&#x27;,yi,<span class="string">&#x27;cubic&#x27;</span>);</span><br><span class="line">mesh(xi,yi,zi)</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">0.5</span>,<span class="number">1.0</span>,<span class="number">1.5</span>,<span class="number">2.0</span>,<span class="number">2.5</span>,<span class="number">3.0</span>];</span><br><span class="line">y = [<span class="number">1.75</span>,<span class="number">2.45</span>,<span class="number">3.81</span>,<span class="number">4.80</span>,<span class="number">7.00</span>,<span class="number">8.60</span>];</span><br><span class="line">p = polyfit(x,y,<span class="number">2</span>)</span><br><span class="line">x1 = <span class="number">0.5</span>:<span class="number">0.05</span>:<span class="number">3.0</span>;</span><br><span class="line">y1 = polyval(p,x1);</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;-*r&#x27;</span>,x1,y1,<span class="string">&#x27;-b&#x27;</span>)</span><br></pre></td></tr></table></figure><p>这段 MATLAB 代码用于进行多项式拟合和绘制拟合曲线。下面是对每一句的解释：</p><ol><li><code>x = [0.5,1.0,1.5,2.0,2.5,3.0];</code><br> 定义了横坐标的数据点。</li><li><code>y = [1.75,2.45,3.81,4.80,7.00,8.60];</code><br> 定义了纵坐标的数据点。</li><li><code>p = polyfit(x, y, 2);</code><br> 使用 <code>polyfit</code> 函数进行二次多项式拟合。这将返回一个包含多项式系数的向量 <code>p</code>，使得 <code>polyval(p, x)</code> 可以计算拟合曲线在给定 <code>x</code> 值上的纵坐标值。</li><li><code>x1 = 0.5:0.05:3.0;</code><br> 定义了一系列更密集的横坐标值，用于在拟合曲线上绘制平滑的曲线。</li><li><code>y1 = polyval(p, x1);</code><br> 使用 <code>polyval</code> 函数计算拟合曲线在新的横坐标值 <code>x1</code> 上的纵坐标值。</li><li><code>plot(x, y, &#39;-*r&#39;, x1, y1, &#39;-b&#39;)</code><br> 使用 <code>plot</code> 函数绘制图形。<code>&#39;-*r&#39;</code>表示绘制原始数据点，使用红色星号标记；<code>&#39;-b&#39;</code>表示绘制拟合曲线，使用蓝色实线。</li></ol><p>综合起来，这段代码进行了二次多项式拟合，并将原始数据点和拟合曲线绘制在同一张图上，以便进行可视化比较。</p><p>在 MATLAB 中，<code>polyfit</code>函数用于进行多项式拟合。其中的参数<code>2</code>表示拟合的多项式的次数。具体来说，<code>polyfit(x, y, 2)</code>表示对给定的数据点<code>x</code>和<code>y</code>进行二次多项式拟合。</p><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><blockquote><p>数据不一致性，如单位。</p><p>噪声数据，错误的数据，异常的数据，偏离期望值或常理。</p></blockquote><p><img src="/images/48d4f1f007de4011bc2d80f43560292a.png" alt="img"></p><p><img src="/images/6c8506cfd9964514b2328a5eadb4747f.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Topsis法</title>
      <link href="/2024/01/29/Topsis%E6%B3%95/"/>
      <url>/2024/01/29/Topsis%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Topsis法"><a href="#Topsis法" class="headerlink" title="Topsis法"></a>Topsis法</h1><p><img src="/images/image-20240129163013762.png" alt="image-20240129163013762"></p><blockquote><h4 id="找出最优与最最差，比较程度"><a href="#找出最优与最最差，比较程度" class="headerlink" title="找出最优与最最差，比较程度"></a>找出最优与最最差，比较程度</h4><p>常用的综合<a href="https://so.csdn.net/so/search?q=%E8%AF%84%E4%BB%B7%E6%96%B9%E6%B3%95&spm=1001.2101.3001.7020">评价方法</a>，充分利用原始数据</p><p>指标很多数据已知的评分问题</p><p>层次分析不适合指标太多的，都是主观的，没数据</p><p>指标的处理（正向化）</p><p>效益类</p><p>极小类</p><p>中间型</p><p>区间型</p></blockquote><h2 id="指标的处理"><a href="#指标的处理" class="headerlink" title="指标的处理"></a>指标的处理</h2><p><img src="/images/0a807263b4fe4710887d77a97cd0d0d7.png" alt="img"></p><h2 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h2><p><img src="/images/image-20240129163301619.png" alt="image-20240129163301619"></p><p><img src="/images/image-20240129163316013.png" alt="image-20240129163316013"></p><h2 id="计算距离与得分"><a href="#计算距离与得分" class="headerlink" title="计算距离与得分"></a>计算距离与得分</h2><p><img src="/images/image-20240129163340888.png" alt="image-20240129163340888"></p><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p><img src="/images/image-20240129163405891.png" alt="image-20240129163405891"></p><p><img src="/images/image-20240129163431275.png" alt="image-20240129163431275"></p><h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><p><img src="/images/image-20240129163513843.png" alt="image-20240129163513843"></p><p><img src="/images/image-20240129163522594.png" alt="image-20240129163522594"></p><p><img src="/images/image-20240129163529473.png" alt="image-20240129163529473"></p><p><img src="/images/image-20240129163536903.png" alt="image-20240129163536903"></p><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><p><img src="/images/image-20240129163548186.png" alt="image-20240129163548186"></p><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><blockquote><p><strong>计算各评价对象与最优方案的贴近程度。</strong>正其中</p><p>的取值范围为[0,1]，越接近1表明样本评分越好。</p></blockquote><p><img src="/images/image-20240129163558967.png" alt="image-20240129163558967"></p><h1 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h1><h2 id="进行排序即可"><a href="#进行排序即可" class="headerlink" title="进行排序即可"></a>进行排序即可</h2><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  第一步：把数据复制到工作区，并将这个矩阵命名为X</span></span><br><span class="line"><span class="comment">% （1）在工作区右键，点击新建（Ctrl+N)，输入变量名称为X</span></span><br><span class="line"><span class="comment">% （2）在Excel中复制数据，再回到Matlab中右键，点击粘贴Excel数据（Ctrl+Shift+V）</span></span><br><span class="line"><span class="comment">% （3）关掉这个窗口，点击X变量，右键另存为，保存为mat文件（下次就不用复制粘贴了，只需使用load命令即可加载数据）</span></span><br><span class="line"><span class="comment">% （4）注意，代码和数据要放在同一个目录下哦，且Matlab的当前文件夹也要是这个目录。</span></span><br><span class="line">clear;clc</span><br><span class="line">load data_water_quality.mat</span><br><span class="line"><span class="comment">%% 注意：如果提示: 错误使用 load，无法读取文件 &#x27;data_water_quality.mat&#x27;。没有此类文件或目录。</span></span><br><span class="line"><span class="comment">% 那么原因是因为你的Matlab的当前文件夹中不存在这个文件</span></span><br><span class="line"><span class="comment">% 可以使用cd函数修改Matlab的当前文件夹</span></span><br><span class="line"><span class="comment">% 比如说，我的代码和数据放在了: D:第2讲.TOPSIS法（优劣解距离法）/代码和例题数据</span></span><br><span class="line"><span class="comment">% 那么我就可以输入命令：</span></span><br><span class="line"><span class="comment">% cd &#x27;D:第2讲.TOPSIS法（优劣解距离法）/代码和例题数据&#x27;</span></span><br><span class="line"><span class="comment">% 也可以看我更新的视频：“更新9_Topsis代码为什么运行失败_得分结果怎么可视化以及权重的确定如何更加准确”，里面有介绍</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  第二步：判断是否需要正向化</span></span><br><span class="line">[n,m] = <span class="built_in">size</span>(X);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;共有&#x27;</span> num2str(n) <span class="string">&#x27;个评价对象, &#x27;</span> num2str(m) <span class="string">&#x27;个评价指标&#x27;</span>]) </span><br><span class="line">Judge = input([<span class="string">&#x27;这&#x27;</span> num2str(m) <span class="string">&#x27;个指标是否需要经过正向化处理，需要请输入1 ，不需要输入0：  &#x27;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> Judge == <span class="number">1</span></span><br><span class="line">    Position = input(<span class="string">&#x27;请输入需要正向化处理的指标所在的列，例如第2、3、6三列需要处理，那么你需要输入[2,3,6]： &#x27;</span>); <span class="comment">%[2,3,4]</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;请输入需要处理的这些列的指标类型（1：极小型， 2：中间型， 3：区间型） &#x27;</span>)</span><br><span class="line">    Type = input(<span class="string">&#x27;例如：第2列是极小型，第3列是区间型，第6列是中间型，就输入[1,3,2]：  &#x27;</span>); <span class="comment">%[2,1,3]</span></span><br><span class="line">    <span class="comment">% 注意，Position和Type是两个同维度的行向量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span> : <span class="built_in">size</span>(Position,<span class="number">2</span>)  <span class="comment">%这里需要对这些列分别处理，因此我们需要知道一共要处理的次数，即循环的次数</span></span><br><span class="line">        X(:,Position(<span class="built_in">i</span>)) = Positivization(X(:,Position(<span class="built_in">i</span>)),Type(<span class="built_in">i</span>),Position(<span class="built_in">i</span>));</span><br><span class="line">    <span class="comment">% Positivization是我们自己定义的函数，其作用是进行正向化，其一共接收三个参数</span></span><br><span class="line">    <span class="comment">% 第一个参数是要正向化处理的那一列向量 X(:,Position(i))   回顾上一讲的知识，X(:,n)表示取第n列的全部元素</span></span><br><span class="line">    <span class="comment">% 第二个参数是对应的这一列的指标类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line">    <span class="comment">% 第三个参数是告诉函数我们正在处理的是原始矩阵中的哪一列</span></span><br><span class="line">    <span class="comment">% 该函数有一个返回值，它返回正向化之后的指标，我们可以将其直接赋值给我们原始要处理的那一列向量</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;正向化后的矩阵 X =  &#x27;</span>)</span><br><span class="line">    <span class="built_in">disp</span>(X)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第三步：对正向化后的矩阵进行标准化</span></span><br><span class="line">Z = X ./ <span class="built_in">repmat</span>(sum(X.*X) .^ <span class="number">0.5</span>, n, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;标准化矩阵 Z = &#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(Z)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 第四步：计算与最大值的距离和最小值的距离，并算出得分</span></span><br><span class="line">D_P = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">max</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ],<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D+ 与最大值的距离向量</span></span><br><span class="line">D_N = sum([(Z - <span class="built_in">repmat</span>(<span class="built_in">min</span>(Z),n,<span class="number">1</span>)) .^ <span class="number">2</span> ],<span class="number">2</span>) .^ <span class="number">0.5</span>;   <span class="comment">% D- 与最小值的距离向量</span></span><br><span class="line">S = D_N ./ (D_P+D_N);    <span class="comment">% 未归一化的得分</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最后的得分为：&#x27;</span>)</span><br><span class="line">stand_S = S / sum(S)</span><br><span class="line">[sorted_S,index] = <span class="built_in">sort</span>(stand_S ,<span class="string">&#x27;descend&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% function [输出变量] = 函数名称(输入变量）  </span></span><br><span class="line"><span class="comment">% 函数的中间部分都是函数体</span></span><br><span class="line"><span class="comment">% 函数的最后要用end结尾</span></span><br><span class="line"><span class="comment">% 输出变量和输入变量可以有多个，用逗号隔开</span></span><br><span class="line"><span class="comment">% function [a,b,c]=test(d,e,f)</span></span><br><span class="line"><span class="comment">%     a=d+e;</span></span><br><span class="line"><span class="comment">%     b=e+f;</span></span><br><span class="line"><span class="comment">%     c=f+d;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% 自定义的函数要单独放在一个m文件中，不可以直接放在主函数里面（和其他大多数语言不同）</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Positivization</span><span class="params">(x,type,i)</span></span></span><br><span class="line"><span class="comment">% 输入变量有三个：</span></span><br><span class="line"><span class="comment">% x：需要正向化处理的指标对应的原始列向量</span></span><br><span class="line"><span class="comment">% type： 指标的类型（1：极小型， 2：中间型， 3：区间型）</span></span><br><span class="line"><span class="comment">% i: 正在处理的是原始矩阵中的哪一列</span></span><br><span class="line"><span class="comment">% 输出变量posit_x表示：正向化后的列向量</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> == <span class="number">1</span>  <span class="comment">%极小型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是极小型，正在正向化&#x27;</span>] )</span><br><span class="line">        posit_x = Min2Max(x);  <span class="comment">%调用Min2Max函数来正向化</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列极小型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">2</span>  <span class="comment">%中间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是中间型&#x27;</span>] )</span><br><span class="line">        best = input(<span class="string">&#x27;请输入最佳的那一个值： &#x27;</span>);</span><br><span class="line">        posit_x = Mid2Max(x,best);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列中间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">elseif</span> <span class="built_in">type</span> == <span class="number">3</span>  <span class="comment">%区间型</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列是区间型&#x27;</span>] )</span><br><span class="line">        a = input(<span class="string">&#x27;请输入区间的下界： &#x27;</span>);</span><br><span class="line">        b = input(<span class="string">&#x27;请输入区间的上界： &#x27;</span>); </span><br><span class="line">        posit_x = Inter2Max(x,a,b);</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;第&#x27;</span> num2str(<span class="built_in">i</span>) <span class="string">&#x27;列区间型正向化处理完成&#x27;</span>] )</span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;~~~~~~~~~~~~~~~~~~~~分界线~~~~~~~~~~~~~~~~~~~~&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;没有这种类型的指标，请检查Type向量中是否有除了1、2、3之外的其他值&#x27;</span>)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">最大值</span><br><span class="line">Intermax</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Inter2Max</span><span class="params">(x,a,b)</span></span></span><br><span class="line">    r_x = <span class="built_in">size</span>(x,<span class="number">1</span>);  <span class="comment">% row of x </span></span><br><span class="line">    M = <span class="built_in">max</span>([a-<span class="built_in">min</span>(x),<span class="built_in">max</span>(x)-b]);</span><br><span class="line">    posit_x = <span class="built_in">zeros</span>(r_x,<span class="number">1</span>);   <span class="comment">%zeros函数用法: zeros(3)  zeros(3,1)  ones(3)</span></span><br><span class="line">    <span class="comment">% 初始化posit_x全为0  初始化的目的是节省处理时间</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>: r_x</span><br><span class="line">        <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt; a</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(a-x(<span class="built_in">i</span>))/M;</span><br><span class="line">        <span class="keyword">elseif</span> x(<span class="built_in">i</span>) &gt; b</span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>-(x(<span class="built_in">i</span>)-b)/M;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">           posit_x(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">MId2max</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Mid2Max</span><span class="params">(x,best)</span></span></span><br><span class="line">    M = <span class="built_in">max</span>(<span class="built_in">abs</span>(x-best));</span><br><span class="line">    posit_x = <span class="number">1</span> - <span class="built_in">abs</span>(x-best) / M;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">min2max</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[posit_x]</span> = <span class="title">Min2Max</span><span class="params">(x)</span></span></span><br><span class="line">    posit_x = <span class="built_in">max</span>(x) - x;</span><br><span class="line">     <span class="comment">%posit_x = 1 ./ x;    %如果x全部都大于0，也可以这样正向化</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><p><img src="/images/image-20240129164107645.png" alt="image-20240129164107645"></p><p><img src="/images/image-20240129164125974.png" alt="image-20240129164125974"></p><p><img src="/images/image-20240129164135640.png" alt="image-20240129164135640"></p><h1 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h1>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>层次分析法</title>
      <link href="/2024/01/29/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/"/>
      <url>/2024/01/29/%E5%B1%82%E6%AC%A1%E5%88%86%E6%9E%90%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="层次分析法"><a href="#层次分析法" class="headerlink" title="层次分析法"></a>层次分析法</h1><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><blockquote><p>层次分析法作为一种主观权重设计方法，一般不需要大量的数据，适合应用于那些比较难以用定量方法解决的问题。</p><p>是在对复杂的决策问题的本质、影响因素及其内在关系等进行深入分析的基础上，利用较少的定量信息使决策的思维过程数学化，从而为多目标、多准则或无结构特性的复杂决策问题提供简便的决策方法</p></blockquote><h2 id="层次分析法的应用"><a href="#层次分析法的应用" class="headerlink" title="层次分析法的应用"></a>层次分析法的应用</h2><p><img src="/images/7322bd6649634cf0aee14656d073dfe1.png" alt="img"></p><h2 id="Matlab-小知识"><a href="#Matlab-小知识" class="headerlink" title="Matlab 小知识"></a>Matlab 小知识</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% Matlab基本的小常识</span></span><br><span class="line"><span class="comment">% (1)在每一行的语句后面加上分号(一定要是英文的哦;中文的长这个样子；)表示不显示运行结果</span></span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line">a = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% (2)多行注释:选中要注释的若干语句,快捷键Ctrl+R</span></span><br><span class="line"><span class="comment">% a = 3;</span></span><br><span class="line"><span class="comment">% a = 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% (3)取消注释:选中要取消注释的语句,快捷键Ctrl+T</span></span><br><span class="line"><span class="comment">% 我想要取消注释下面这行</span></span><br><span class="line"><span class="comment">% 还有这一行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% clear可以清楚工作区的所有变量</span></span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line"><span class="comment">% clc可以清除命令行窗口中的所有文本,让屏幕变得干净</span></span><br><span class="line">clc</span><br><span class="line"></span><br><span class="line"><span class="comment">% 所以大家在很多代码开头，都会见到:</span></span><br><span class="line">clear;clc   <span class="comment">% 分号也用于区分行。</span></span><br><span class="line"><span class="comment">% 这两条一起使用，起到“初始化”的作用，防止之前的结果对新脚本文件（后缀名是 .m）产生干扰。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 输出和输入函数(disp 和 input)</span></span><br><span class="line"><span class="comment">% disp函数</span></span><br><span class="line"><span class="comment">% matlab中disp()就是屏幕输出函数，类似于c语言中的printf（）函数</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;我是清风，大家好鸭~~~记得投币关注我哦&#x27;</span>)</span><br><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]    <span class="comment">%同一行中间用逗号分隔，也可以不用逗号，直接用空格</span></span><br><span class="line">a = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="built_in">disp</span>(a) </span><br><span class="line"><span class="comment">% 注意，disp函数比较特殊，这里可要分号，可不要分号哦</span></span><br><span class="line"><span class="built_in">disp</span>(a);</span><br><span class="line"><span class="comment">% matlab中两个字符串的合并有两种方法</span></span><br><span class="line"><span class="comment">% （1）strcat(str1,str2……,strn) </span></span><br><span class="line"> strcat(<span class="string">&#x27;字符串1&#x27;</span>,<span class="string">&#x27;字符串2&#x27;</span>) </span><br><span class="line"><span class="comment">% （2）[str 1,str 2，……, str n]或[str1  str2  ……  strn]</span></span><br><span class="line">[<span class="string">&#x27;字符串1&#x27;</span>  <span class="string">&#x27;字符串2&#x27;</span>]</span><br><span class="line">[<span class="string">&#x27;字符串1&#x27;</span>,<span class="string">&#x27;字符串2&#x27;</span>]</span><br><span class="line"><span class="comment">% 一个有用的字符串函数：num2str  将数字转换为字符串</span></span><br><span class="line">c = <span class="number">100</span></span><br><span class="line">num2str(c)</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;c的取值为&#x27;</span> num2str(c)])</span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">&#x27;c的取值为&#x27;</span>, num2str(c)))</span><br><span class="line"></span><br><span class="line"><span class="comment">% input函数</span></span><br><span class="line"><span class="comment">% 一般我们会将输入的数、向量、矩阵、字符串等赋给一个变量，这里我们赋给A</span></span><br><span class="line">A = input(<span class="string">&#x27;请输入A：&#x27;</span>);</span><br><span class="line">B = input(<span class="string">&#x27;请输入B：&#x27;</span>)</span><br><span class="line"><span class="comment">% 注意观察工作区，并体会input后面加分号和不加分号的区别</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% sum函数</span></span><br><span class="line"><span class="comment">% （1）如果是向量（无论是行向量还是列向量），都是直接求和</span></span><br><span class="line">E = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">sum(E)</span><br><span class="line">E = [<span class="number">1</span>;<span class="number">2</span>;<span class="number">3</span>]</span><br><span class="line">sum(E)</span><br><span class="line"><span class="comment">% （2）如果是矩阵，则需要根据行和列的方向作区分</span></span><br><span class="line">clc</span><br><span class="line">E = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>;<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="comment">% a=sum(x); %按列求和(得到一个行向量）</span></span><br><span class="line">a = sum(E)</span><br><span class="line">a = sum(E,<span class="number">1</span>)</span><br><span class="line"><span class="comment">% a=sum(x,2); %按行求和(得到一个列向量）</span></span><br><span class="line">a = sum(E,<span class="number">2</span>)</span><br><span class="line"><span class="comment">% a=sum(x(:));%对整个矩阵求和</span></span><br><span class="line">a = sum(sum(E))</span><br><span class="line">a = sum(E(:))</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 基础：matlab中如何提取矩阵中指定位置的元素？</span></span><br><span class="line"><span class="comment">% （1）取指定行和列的一个元素（输出的是一个值）</span></span><br><span class="line">clc;A=[<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">2</span>;<span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span>;<span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>];</span><br><span class="line">A</span><br><span class="line">A(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">A(<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">% （2）取指定的某一行的全部元素（输出的是一个行向量）</span></span><br><span class="line">clc;A</span><br><span class="line">A(<span class="number">2</span>,:)</span><br><span class="line">A(<span class="number">5</span>,:)</span><br><span class="line"><span class="comment">% （3）取指定的某一列的全部元素（输出的是一个列向量）</span></span><br><span class="line">clc;A</span><br><span class="line">A(:,<span class="number">1</span>)</span><br><span class="line">A(:,<span class="number">3</span>)</span><br><span class="line"><span class="comment">% （4）取指定的某些行的全部元素（输出的是一个矩阵）</span></span><br><span class="line">clc;A</span><br><span class="line">A([<span class="number">2</span>,<span class="number">5</span>],:)      <span class="comment">% 只取第二行和第五行（一共2行）</span></span><br><span class="line">A(<span class="number">2</span>:<span class="number">5</span>,:)        <span class="comment">% 取第二行到第五行（一共4行）</span></span><br><span class="line">A(<span class="number">2</span>:<span class="number">2</span>:<span class="number">5</span>,:)     <span class="comment">% 取第二行和第四行 （从2开始，每次递增2个单位，到5结束）</span></span><br><span class="line"><span class="number">1</span>:<span class="number">3</span>:<span class="number">10</span></span><br><span class="line"><span class="number">10</span>:<span class="number">-1</span>:<span class="number">1</span></span><br><span class="line">A(<span class="number">2</span>:<span class="keyword">end</span>,:)      <span class="comment">% 取第二行到最后一行</span></span><br><span class="line">A(<span class="number">2</span>:<span class="keyword">end</span><span class="number">-1</span>,:)    <span class="comment">% 取第二行到倒数第二行</span></span><br><span class="line"><span class="comment">% （5）取全部元素(按列拼接的，最终输出的是一个列向量)</span></span><br><span class="line">clc;A</span><br><span class="line">A(:)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% size函数</span></span><br><span class="line">clc;</span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"><span class="built_in">size</span>(A)</span><br><span class="line"><span class="built_in">size</span>(B)</span><br><span class="line"><span class="comment">% size(A)函数是用来求矩阵A的大小的,它返回一个行向量，第一个元素是矩阵的行数，第二个元素是矩阵的列数</span></span><br><span class="line">[r,c] = <span class="built_in">size</span>(A)</span><br><span class="line"><span class="comment">% 将矩阵A的行数返回到第一个变量r，将矩阵的列数返回到第二个变量c</span></span><br><span class="line">r = <span class="built_in">size</span>(A,<span class="number">1</span>)  <span class="comment">%返回行数</span></span><br><span class="line">c = <span class="built_in">size</span>(A,<span class="number">2</span>) <span class="comment">%返回列数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% repmat函数</span></span><br><span class="line"><span class="comment">% B = repmat(A,m,n):将矩阵A复制m×n块，即把A作为B的元素，B由m×n个A平铺而成。</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">B = <span class="built_in">repmat</span>(A,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">B = <span class="built_in">repmat</span>(A,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Matlab中矩阵的运算</span></span><br><span class="line"><span class="comment">% MATLAB在矩阵的运算中，“*”号和“/”号代表矩阵之间的乘法与除法(A/B = A*inv(B))</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">A * B</span><br><span class="line">inv(B)  <span class="comment">% 求B的逆矩阵</span></span><br><span class="line">B * inv(B)</span><br><span class="line">A * inv(B)</span><br><span class="line">A / B</span><br><span class="line"></span><br><span class="line"><span class="comment">% 两个形状相同的矩阵对应元素之间的乘除法需要使用“.*”和“./”</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">B = [<span class="number">1</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">1</span>]</span><br><span class="line">A .* B</span><br><span class="line">A ./ B</span><br><span class="line"></span><br><span class="line"><span class="comment">% 每个元素同时和常数相乘或相除操作都可以使用</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">A * <span class="number">2</span></span><br><span class="line">A .* <span class="number">2</span></span><br><span class="line">A / <span class="number">2</span> </span><br><span class="line">A ./ <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 每个元素同时乘方时只能用 .^</span></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>;<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">A .^ <span class="number">2</span></span><br><span class="line">A ^ <span class="number">2</span> </span><br><span class="line">A * A</span><br><span class="line"></span><br><span class="line"><span class="comment">%% Matlab中求特征值和特征向量</span></span><br><span class="line"><span class="comment">% 在Matlab中，计算矩阵A的特征值和特征向量的函数是eig(A),其中最常用的两个用法：</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> ;<span class="number">2</span> <span class="number">2</span> <span class="number">1</span>;<span class="number">2</span> <span class="number">0</span> <span class="number">3</span>]</span><br><span class="line"><span class="comment">% （1）E=eig(A)：求矩阵A的全部特征值，构成向量E。</span></span><br><span class="line">E=eig(A)</span><br><span class="line"><span class="comment">% （2）[V,D]=eig(A)：求矩阵A的全部特征值，构成对角阵D，并求A的特征向量构成V的列向量。（V的每一列都是D中与之相同列的特征值的特征向量）</span></span><br><span class="line">[V,D]=eig(A)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% find函数的基本用法</span></span><br><span class="line"><span class="comment">% 下面例子来自博客：https://www.cnblogs.com/anzhiwu815/p/5907033.html 博客内有更加深入的探究</span></span><br><span class="line"><span class="comment">% find函数，它可以用来返回向量或者矩阵中不为0的元素的位置索引。</span></span><br><span class="line">clc;X = [<span class="number">1</span> <span class="number">0</span> <span class="number">4</span> <span class="number">-3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">8</span> <span class="number">6</span>]</span><br><span class="line">ind = <span class="built_in">find</span>(X)</span><br><span class="line"><span class="comment">% 其有多种用法，比如返回前2个不为0的元素的位置：</span></span><br><span class="line">ind = <span class="built_in">find</span>(X,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%上面针对的是向量（一维），若X是一个矩阵（二维，有行和列），索引该如何返回呢？</span></span><br><span class="line">clc;X = [<span class="number">1</span> <span class="number">-3</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">8</span>;<span class="number">4</span> <span class="number">0</span> <span class="number">6</span>]</span><br><span class="line">ind = <span class="built_in">find</span>(X)</span><br><span class="line"><span class="comment">% 这是因为在Matlab在存储矩阵时，是一列一列存储的，我们可以做一下验证：</span></span><br><span class="line">X(<span class="number">4</span>)</span><br><span class="line"><span class="comment">% 假如你需要按照行列的信息输出该怎么办呢？</span></span><br><span class="line">[r,c] = <span class="built_in">find</span>(X)</span><br><span class="line">[r,c] = <span class="built_in">find</span>(X,<span class="number">1</span>) <span class="comment">%只找第一个非0元素</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 矩阵与常数的大小判断运算</span></span><br><span class="line"><span class="comment">% 共有三种运算符：大于&gt; ;小于&lt; ;等于 ==  （一个等号表示赋值；两个等号表示判断）</span></span><br><span class="line">clc</span><br><span class="line">X = [<span class="number">1</span> <span class="number">-3</span> <span class="number">0</span>;<span class="number">0</span> <span class="number">0</span> <span class="number">8</span>;<span class="number">4</span> <span class="number">0</span> <span class="number">6</span>]</span><br><span class="line">X &gt; <span class="number">0</span></span><br><span class="line">X == <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 判断语句</span></span><br><span class="line"><span class="comment">% Matlab的判断语句，if所在的行不需要冒号，语句的最后一定要以end结尾 ；中间的语句要注意缩进。</span></span><br><span class="line">a = input(<span class="string">&#x27;请输入考试分数:&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> a &gt;= <span class="number">85</span>  </span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;成绩优秀&#x27;</span>)</span><br><span class="line"><span class="keyword">elseif</span> a &gt;= <span class="number">60</span> </span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;成绩合格&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;成绩挂科&#x27;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">A = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>;</span><br><span class="line">    <span class="number">1</span>/<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>;</span><br><span class="line">    <span class="number">1</span>/<span class="number">4</span>,<span class="number">1</span>/<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">[V,D] = eig(A)  <span class="comment">% 求出A的特征值和特征向量</span></span><br><span class="line">A*[<span class="number">1</span>;<span class="number">1</span>/<span class="number">2</span>;<span class="number">1</span>/<span class="number">4</span>] - <span class="number">3</span>*[<span class="number">1</span>;<span class="number">1</span>/<span class="number">2</span>;<span class="number">1</span>/<span class="number">4</span>]   <span class="comment">% 验证[1;1/2;1/4]是否为特征值3对应的特征向量</span></span><br><span class="line"><span class="comment">% A X = /lamba X</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><blockquote><p>建立层次结构模型<br>简述：</p><p>将决策的目标、考虑的因素(决策准则)和决策方案，按它们之间的相互关系分为最高层、中间层和最低层，绘出层次结构图。</p><p>最高层：决策的目的、要解决的问题。</p><p>中间层：考虑的因素、决策的准则。</p><p>最低层：决策时的备选方案。</p><p>对于相邻的两层，称高层为目标层，低层为因素层。</p><p>如图：</p></blockquote><p><img src="/images/image-20240129161333080.png" alt="image-20240129161333080"></p><p><img src="/images/image-20240129161346001.png" alt="image-20240129161346001"></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><blockquote><p>构造判断矩阵<br>从层次结构模型的第2层开始，对于从属于(或影响)上一层每个因素的同一层诸因素，构造判断矩阵，直到最下层。</p><p>在确定各层次各因素之间的权重时，如果只是定性的结果，则常常不容易被别人接受，因而Saaty等人提出：一致矩阵法，即：</p><p>1.不把所有因素放在一起比较，而是两两相互比较。</p><p>2.对此时采用相对尺度，以尽可能减少性质不同的诸因素相互比较的困难，以提高准确度。</p><p>判断矩阵是表示本层所有因素针对上一层某一个因素的相对重要性的比较。判断矩阵的元素���用Saaty的1-9标度方法给出。</p><p>心理学家认为成对比较的因素不宜超过9个，即每层不要超过9个因素。</p></blockquote><p><img src="/images/image-20240129161357280.png" alt="image-20240129161357280"></p><p><img src="/images/image-20240129161419855.png" alt="image-20240129161419855"></p><p><img src="/images/image-20240129161445463.png" alt="image-20240129161445463"></p><p><img src="/images/image-20240129161505143.png" alt="image-20240129161505143"></p><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><blockquote><h4 id="计算单层权向量并做一致性检验"><a href="#计算单层权向量并做一致性检验" class="headerlink" title="计算单层权向量并做一致性检验"></a><strong>计算单层权向量并做一致性检验</strong></h4><p>能否确认层次单排序，需要进行一致性检验，所谓一致性检验是指对A确定不一致的<strong>允许范围</strong>。</p><p><strong>定理1：n阶一致阵的唯一非零特征根为n</strong></p><p><strong>定理2：n阶正互反阵A的最大特征根λ≥n，当且仅当λ&#x3D;n时A为一致阵</strong></p></blockquote><p><img src="/images/image-20240129161525745.png" alt="image-20240129161525745"></p><p><img src="/images/image-20240129161542137.png" alt="image-20240129161542137"></p><p><img src="/images/image-20240129161552150.png" alt="image-20240129161552150"></p><h2 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h2><p><img src="/images/image-20240129161610809.png" alt="image-20240129161610809"></p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p><img src="/images/image-20240129161633027.png" alt="image-20240129161633027"></p><h1 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 注意：在论文写作中，应该先对判断矩阵进行一致性检验，然后再计算权重，因为只有判断矩阵通过了一致性检验，其权重才是有意义的。</span></span><br><span class="line"><span class="comment">%% 在下面的代码中，我们先计算了权重，然后再进行了一致性检验，这是为了顺应计算过程，事实上在逻辑上是说不过去的。</span></span><br><span class="line"><span class="comment">%% 因此大家自己写论文中如果用到了层次分析法，一定要先对判断矩阵进行一致性检验。</span></span><br><span class="line"><span class="comment">%% 而且要说明的是，只有非一致矩阵的判断矩阵才需要进行一致性检验。</span></span><br><span class="line"><span class="comment">%% 如果你的判断矩阵本身就是一个一致矩阵，那么就没有必要进行一致性检验。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 输入判断矩阵</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;请输入判断矩阵A： &#x27;</span>)</span><br><span class="line"><span class="comment">% A = input(&#x27;判断矩阵A=&#x27;)</span></span><br><span class="line">A =[<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;</span><br><span class="line"> <span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;</span><br><span class="line"> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">2</span>;</span><br><span class="line"> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span>;</span><br><span class="line"> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>]</span><br><span class="line"><span class="comment">% matlab矩阵有两种写法，可以直接写到一行:</span></span><br><span class="line"><span class="comment">% [1 1 4 1/3 3;1 1 4 1/3 3;1/4 1/4 1 1/3 1/2;3 3 3 1 3;1/3 1/3 2 1/3 1]</span></span><br><span class="line"><span class="comment">% 也可以写成多行:</span></span><br><span class="line">[<span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;</span><br><span class="line"> <span class="number">1</span> <span class="number">1</span> <span class="number">4</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">3</span>;</span><br><span class="line"> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span>/<span class="number">4</span> <span class="number">1</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">2</span>;</span><br><span class="line"> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">1</span> <span class="number">3</span>;</span><br><span class="line"> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">2</span> <span class="number">1</span>/<span class="number">3</span> <span class="number">1</span>]</span><br><span class="line"><span class="comment">% 两行之间以分号结尾（最后一行的分号可加可不加），同行元素之间以空格（或者逗号）分开。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 方法1：算术平均法求权重</span></span><br><span class="line"><span class="comment">% 第一步：将判断矩阵按照列归一化（每一个元素除以其所在列的和）</span></span><br><span class="line">Sum_A = sum(A)</span><br><span class="line"></span><br><span class="line">[n,n] = <span class="built_in">size</span>(A)  <span class="comment">% 也可以写成n = size(A,1)</span></span><br><span class="line"><span class="comment">% 因为我们的判断矩阵A是一个方阵，所以这里的r和c相同，我们可以就用同一个字母n表示</span></span><br><span class="line">SUM_A = <span class="built_in">repmat</span>(Sum_A,n,<span class="number">1</span>)   <span class="comment">%repeat matrix的缩写</span></span><br><span class="line"><span class="comment">% 另外一种替代的方法如下：</span></span><br><span class="line">    SUM_A = [];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n   <span class="comment">%循环哦，这一行后面不能加冒号（和Python不同），这里表示循环n次</span></span><br><span class="line">        SUM_A = [SUM_A; Sum_A]</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">clc;A</span><br><span class="line">SUM_A</span><br><span class="line">Stand_A = A ./ SUM_A</span><br><span class="line"><span class="comment">% 这里我们直接将两个矩阵对应的元素相除即可</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：将归一化的各列相加(按行求和)</span></span><br><span class="line">sum(Stand_A,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 第三步：将相加后得到的向量中每个元素除以n即可得到权重向量</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;算术平均法求权重的结果为：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(sum(Stand_A,<span class="number">2</span>) / n)</span><br><span class="line"><span class="comment">% 首先对标准化后的矩阵按照行求和，得到一个列向量</span></span><br><span class="line"><span class="comment">% 然后再将这个列向量的每个元素同时除以n即可（注意这里也可以用./哦）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 方法2：几何平均法求权重</span></span><br><span class="line"><span class="comment">% 第一步：将A的元素按照行相乘得到一个新的列向量</span></span><br><span class="line">clc;A</span><br><span class="line">Prduct_A = prod(A,<span class="number">2</span>)</span><br><span class="line"><span class="comment">% prod函数和sum函数类似，一个用于乘，一个用于加  dim = 2 维度是行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：将新的向量的每个分量开n次方</span></span><br><span class="line">Prduct_n_A = Prduct_A .^ (<span class="number">1</span>/n)</span><br><span class="line"><span class="comment">% 这里对每个元素进行乘方操作，因此要加.号哦。  ^符号表示乘方哦  这里是开n次方，所以我们等价求1/n次方</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第三步：对该列向量进行归一化即可得到权重向量</span></span><br><span class="line"><span class="comment">% 将这个列向量中的每一个元素除以这一个向量的和即可</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;几何平均法求权重的结果为：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>(Prduct_n_A ./ sum(Prduct_n_A))</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 方法3：特征值法求权重</span></span><br><span class="line"><span class="comment">% 第一步：求出矩阵A的最大特征值以及其对应的特征向量</span></span><br><span class="line">clc</span><br><span class="line">[V,D] = eig(A)    <span class="comment">%V是特征向量, D是由特征值构成的对角矩阵（除了对角线元素外，其余位置元素全为0）</span></span><br><span class="line">Max_eig = <span class="built_in">max</span>(<span class="built_in">max</span>(D)) <span class="comment">%也可以写成max(D(:))哦~</span></span><br><span class="line"><span class="comment">% 那么怎么找到最大特征值所在的位置了？ 需要用到find函数，它可以用来返回向量或者矩阵中不为0的元素的位置索引。</span></span><br><span class="line"><span class="comment">% 那么问题来了，我们要得到最大特征值的位置，就需要将包含所有特征值的这个对角矩阵D中，不等于最大特征值的位置全变为0</span></span><br><span class="line"><span class="comment">% 这时候可以用到矩阵与常数的大小判断运算</span></span><br><span class="line">D == Max_eig</span><br><span class="line">[r,c] = <span class="built_in">find</span>(D == Max_eig , <span class="number">1</span>)</span><br><span class="line"><span class="comment">% 找到D中第一个与最大特征值相等的元素的位置，记录它的行和列。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 第二步：对求出的特征向量进行归一化即可得到我们的权重</span></span><br><span class="line">V(:,c)</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;特征值法求权重的结果为：&#x27;</span>);</span><br><span class="line"><span class="built_in">disp</span>( V(:,c) ./ sum(V(:,c)) )</span><br><span class="line"><span class="comment">% 我们先根据上面找到的最大特征值的列数c找到对应的特征向量，然后再进行标准化。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算一致性比例CR</span></span><br><span class="line">clc</span><br><span class="line">CI = (Max_eig - n) / (n<span class="number">-1</span>);</span><br><span class="line">RI=[<span class="number">0</span> <span class="number">0</span> <span class="number">0.52</span> <span class="number">0.89</span> <span class="number">1.12</span> <span class="number">1.26</span> <span class="number">1.36</span> <span class="number">1.41</span> <span class="number">1.46</span> <span class="number">1.49</span> <span class="number">1.52</span> <span class="number">1.54</span> <span class="number">1.56</span> <span class="number">1.58</span> <span class="number">1.59</span>];  <span class="comment">%注意哦，这里的RI最多支持 n = 15</span></span><br><span class="line">CR=CI/RI(n);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;一致性指标CI=&#x27;</span>);<span class="built_in">disp</span>(CI);</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;一致性比例CR=&#x27;</span>);<span class="built_in">disp</span>(CR);</span><br><span class="line"><span class="keyword">if</span> CR&lt;<span class="number">0.10</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;因为CR &lt; 0.10，所以该判断矩阵A的一致性可以接受!&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;注意：CR &gt;= 0.10，因此该判断矩阵A需要进行修改!&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="例题展示"><a href="#例题展示" class="headerlink" title="例题展示"></a>例题展示</h1><p><img src="/images/5895ff6f46cf426ab481a3ba9bd50cd7.png" alt="img"></p><p><img src="/images/b1065d4eac534cccab3811ecf3e4bc27.png" alt="img"></p><p><img src="/images/2a1108a776c04bb2ada307f4b61b090e.png" alt="img"></p><p><img src="/images/52955017804f475980d96c0087f2209e.png" alt="img"></p><p><img src="/images/00d7639e39fd47cbb43747226782f852.png" alt="img"></p><p><img src="/images/c21abac314ac42289ce23bf511e8a443.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微分方程模块</title>
      <link href="/2024/01/29/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9D%97/"/>
      <url>/2024/01/29/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="微分方程模块"><a href="#微分方程模块" class="headerlink" title="微分方程模块"></a>微分方程模块</h1><h1 id="引例"><a href="#引例" class="headerlink" title="引例"></a>引例</h1><h2 id="列出方程组"><a href="#列出方程组" class="headerlink" title="列出方程组"></a>列出方程组</h2><p><img src="/images/image-20240129132038919.png" alt="image-20240129132038919"></p><p>速度公式</p><p>一个导弹头对准的等式（斜率相等）</p><p><img src="/images/image-20240129132523940.png" alt="image-20240129132523940"></p><p><img src="/images/image-20240129132602724.png" alt="image-20240129132602724"></p><h2 id="求解方程组"><a href="#求解方程组" class="headerlink" title="求解方程组"></a>求解方程组</h2><p><img src="/images/image-20240129132622152.png" alt="image-20240129132622152"></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="/images/image-20240129132920565.png" alt="image-20240129132920565"></p><p><img src="/images/image-20240129133016467.png" alt="image-20240129133016467"></p><h1 id="Matlab求微分方程的解析解"><a href="#Matlab求微分方程的解析解" class="headerlink" title="Matlab求微分方程的解析解"></a>Matlab求微分方程的解析解</h1><p>求解析解</p><p><img src="/images/image-20240129133211310.png" alt="image-20240129133211310"></p><p><img src="/images/image-20240129133240995.png" alt="image-20240129133240995"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 例1</span></span><br><span class="line">clear;clc</span><br><span class="line">dsolve(<span class="string">&#x27;y-Dy=2*x&#x27;</span>,<span class="string">&#x27;x&#x27;</span>)  <span class="comment">% 这里要指定自变量为x</span></span><br><span class="line"><span class="comment">% 2*x + C1*exp(x) + 2  (这里的C1表示任意常数，有时候也会出现C2 C3等)</span></span><br><span class="line">dsolve(<span class="string">&#x27;y-Dy=2*x&#x27;</span>)  <span class="comment">% 如果不指定自变量的话，会默认自变量为t，x会看成一个常数</span></span><br><span class="line"><span class="comment">% 2*x + C2*exp(t)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 注意：最新版本的matlab会逐渐淘汰上面那种写法（虽然我个人觉得上面的写法更方便）</span></span><br><span class="line"><span class="comment">% 下面这种写法是新版的matlab推荐的方式（和我们上一讲符号运算中解方程的写法类似）</span></span><br><span class="line">syms y(x)</span><br><span class="line">eqn = (y - diff(y,x) == <span class="number">2</span>*x);    <span class="comment">% 注意原来方程中的“=”一定要改成“==”</span></span><br><span class="line">dsolve(eqn)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 如果微分方程中还有其他的未知参数怎么办？</span></span><br><span class="line"><span class="comment">% 方法1</span></span><br><span class="line">dsolve(<span class="string">&#x27;y-Dy=a*x&#x27;</span>,<span class="string">&#x27;x&#x27;</span>)  <span class="comment">% a是一个未知的参数</span></span><br><span class="line"><span class="comment">% 方法2</span></span><br><span class="line">syms y(x) a</span><br><span class="line">eqn = (y - diff(y,x) == a*x);  </span><br><span class="line">dsolve(eqn)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例2 </span></span><br><span class="line"><span class="comment">% 方法1</span></span><br><span class="line">dsolve(<span class="string">&#x27;y-Dy=2*x&#x27;</span>,<span class="string">&#x27;y(0)=3&#x27;</span>,<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line"><span class="comment">% 2*x + exp(x) + 2</span></span><br><span class="line"><span class="comment">% 方法2</span></span><br><span class="line">syms y(x)</span><br><span class="line">eqn = (y - diff(y,x) == <span class="number">2</span>*x);  </span><br><span class="line">cond = (y(<span class="number">0</span>) == <span class="number">3</span>);</span><br><span class="line">dsolve(eqn,cond)</span><br><span class="line"><span class="comment">% 2*x + exp(x) + 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例3</span></span><br><span class="line"><span class="comment">% 方法1</span></span><br><span class="line">dsolve(<span class="string">&#x27;D2y+4*Dy+29*y=0&#x27;</span>,<span class="string">&#x27;y(0)=0,Dy(0)=15&#x27;</span>,<span class="string">&#x27;x&#x27;</span>) </span><br><span class="line"><span class="comment">% 3*sin(5*x)*exp(-2*x)</span></span><br><span class="line"><span class="comment">% 方法2</span></span><br><span class="line">syms y(x)</span><br><span class="line">eqn = (diff(y,x,<span class="number">2</span>) + <span class="number">4</span> *diff(y,x) + <span class="number">29</span>*y  == <span class="number">0</span>);  </span><br><span class="line">Dy = diff(y,x); <span class="comment">% 定义变量Dy为y的一阶导数</span></span><br><span class="line">cond = [(y(<span class="number">0</span>) == <span class="number">0</span>) ,(Dy(<span class="number">0</span>) ==<span class="number">15</span>)] ; <span class="comment">% 有两个条件，可以写到一个向量中保存</span></span><br><span class="line">dsolve(eqn,cond)</span><br><span class="line"><span class="comment">% 3*sin(5*x)*exp(-2*x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例4</span></span><br><span class="line"><span class="comment">% 方法1</span></span><br><span class="line">[x,y,z] = dsolve(<span class="string">&#x27;Dx=2*x-3*y+3*z+t&#x27;</span>,<span class="string">&#x27;Dy=4*x-5*y+3*z+t&#x27;</span>,<span class="string">&#x27;Dz=4*x-4*y+2*z+t&#x27;</span>,<span class="string">&#x27;t&#x27;</span>) </span><br><span class="line"></span><br><span class="line"><span class="comment">% 方法2</span></span><br><span class="line">syms x(t) y(t) z(t)</span><br><span class="line">eqn1 = (diff(x,t)  == <span class="number">2</span>*x<span class="number">-3</span>*y+<span class="number">3</span>*z+t); </span><br><span class="line">eqn2 = (diff(y,t)  == <span class="number">4</span>*x<span class="number">-5</span>*y+<span class="number">3</span>*z+t); </span><br><span class="line">eqn3 = (diff(z,t)  == <span class="number">4</span>*x<span class="number">-4</span>*y+<span class="number">2</span>*z+t); </span><br><span class="line">eqns = [eqn1 eqn2 eqn3];</span><br><span class="line">[x,y,z] = dsolve(eqns)</span><br><span class="line"><span class="comment">% x = exp(2*t)*(C2- (exp(-2*t)*(2*t + 1))/4) + C3*exp(-t)</span></span><br><span class="line"><span class="comment">% y = exp(2*t)*(C2 - (exp(-2*t)*(2*t + 1))/4) + C3*exp(-t) + C4*exp(-2*t)</span></span><br><span class="line"><span class="comment">% z = exp(2*t)*(C2 - (exp(-2*t)*(2*t + 1))/4) + C4*exp(-2*t)</span></span><br><span class="line">mupad  <span class="comment">% 最新版本matlab可能会报错，将计算结果复制到里面，使结果可读。</span></span><br><span class="line"><span class="comment">% 如果新版matlab用不了mupad的话，可以使用更新13中介绍到的实时脚本</span></span><br><span class="line">simplify(y)  <span class="comment">% simplify函数可以简化表达式</span></span><br><span class="line">latex(y) <span class="comment">% 转换成latex代码，复制到Axmath或者word自带的公式编辑器（低版本不知道支不支持）</span></span><br><span class="line"><span class="comment">% 如果太过于复杂的话可能会报错，大家可以自己测试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 不是所有的微分方程都可以，导弹追击那一题就没有解析解</span></span><br><span class="line"><span class="comment">% 假设 v=100</span></span><br><span class="line">[x,y] = dsolve(<span class="string">&#x27;Dx = 3*100*(20+sqrt(2)/2*100*t-x)/sqrt((20+sqrt(2)/2*100*t-x)^2+(sqrt(2)/2*100*t-y)^2)&#x27;</span>,<span class="string">&#x27;Dy = 3*100*(sqrt(2)/2*100*t-y)/sqrt((20+sqrt(2)/2*100*t-x)^2+(sqrt(2)/2*100*t-y)^2)&#x27;</span>,<span class="string">&#x27;x(0)=0,y(0)=0&#x27;</span>,<span class="string">&#x27;t&#x27;</span>)  </span><br><span class="line"><span class="comment">% 警告: Explicit solution could not be found. </span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Matlab求解微分方程的数值解"><a href="#Matlab求解微分方程的数值解" class="headerlink" title="Matlab求解微分方程的数值解"></a>Matlab求解微分方程的数值解</h1><p><img src="/images/image-20240129133711729.png" alt="image-20240129133711729"></p><h2 id="函数如下"><a href="#函数如下" class="headerlink" title="函数如下"></a>函数如下</h2><p><img src="/images/image-20240129134021044.png" alt="image-20240129134021044"></p><h2 id="标准形式"><a href="#标准形式" class="headerlink" title="标准形式"></a>标准形式</h2><p><img src="/images/image-20240129134123447.png" alt="image-20240129134123447"></p><blockquote><p>一般用ode45和ode15s</p></blockquote><p><img src="/images/image-20240129134325396.png" alt="image-20240129134325396"></p><p><img src="/images/image-20240129134427546.png" alt="image-20240129134427546"></p><h2 id="判断标准：刚性和非刚性的判断"><a href="#判断标准：刚性和非刚性的判断" class="headerlink" title="判断标准：刚性和非刚性的判断"></a>判断标准：刚性和非刚性的判断</h2><p><img src="/images/image-20240129134449713.png" alt="image-20240129134449713"></p><blockquote><p> 基本都是非刚性问题，因此一般用ode45，百分之90</p></blockquote><h2 id="例题一："><a href="#例题一：" class="headerlink" title="例题一："></a>例题一：</h2><p><img src="/images/image-20240129134704414.png" alt="image-20240129134704414"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 调用ode45函数求解微分方程df1，自变量为x，范围为[0,2],  初始值y(0)=3 ; 因变量为y</span></span><br><span class="line">clear;clc</span><br><span class="line">[x,y] = ode45(<span class="string">&#x27;df1&#x27;</span>,[<span class="number">0</span>,<span class="number">2</span>],<span class="number">3</span>);  <span class="comment">% [x,y] = ode45(@df1,[0,2],3);</span></span><br><span class="line"><span class="comment">% [x,y] = ode23(&#x27;df1&#x27;,[0,2],3);</span></span><br><span class="line"><span class="comment">% [x,y] = ode113(&#x27;df1&#x27;,[0,2],3);</span></span><br><span class="line"><span class="comment">% [x,y] = ode15s(&#x27;df1&#x27;,[0,2],3); % 刚性</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;r*-&#x27;</span>)  <span class="comment">% 画出x和y的函数图像，用红色的直线和*标记</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  下面我们直接画出微分方程的解析解的图像进行对比</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">x = <span class="number">0</span>:<span class="number">0.01</span>:<span class="number">2</span>;</span><br><span class="line">y = <span class="built_in">exp</span>(x)+<span class="number">2</span>*x+<span class="number">2</span>;</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;b-&#x27;</span>)  <span class="comment">% 蓝色的直线</span></span><br><span class="line"><span class="comment">% 从图中可以看出，ode45函数得到的数值解的精度很高。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  设定相对误差和绝对误差，这样可以提高微分方程数值解的精度</span></span><br><span class="line">options = odeset(<span class="string">&#x27;reltol&#x27;</span>,<span class="number">1e-4</span>,<span class="string">&#x27;abstol&#x27;</span>,<span class="number">1e-8</span>);</span><br><span class="line">[x,y] = ode45(<span class="string">&#x27;df1&#x27;</span>,[<span class="number">0</span>,<span class="number">2</span>],<span class="number">3</span>,options);</span><br><span class="line"></span><br><span class="line"><span class="comment">%%  如果觉得x的间隔不够小，我们可以指定要求解的位置</span></span><br><span class="line">[x,y] = ode45(<span class="string">&#x27;df1&#x27;</span>,[<span class="number">0</span>:<span class="number">0.001</span>:<span class="number">2</span>],<span class="number">3</span>,options);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dy</span> = <span class="title">df1</span><span class="params">(x,y)</span></span></span><br><span class="line">    <span class="comment">% 微分方程：y-y&#x27;=2x（函数名称可以任意取）</span></span><br><span class="line">    dy = y - <span class="number">2</span>*x; <span class="comment">% 写成标准形式 y&#x27; = y - 2x </span></span><br><span class="line">    <span class="comment">% 注意函数的返回值一定是因变量y的一阶导数</span></span><br><span class="line">    <span class="comment">% 函数的输入有两个，分别是自变量x和因变量y</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="例题二："><a href="#例题二：" class="headerlink" title="例题二："></a>例题二：</h2><p><img src="/images/image-20240129135125772.png" alt="image-20240129135125772"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 在真正比赛中，我们往往会倾向于先去看有无解析解，如果没有解析解再考虑数值解</span></span><br><span class="line"><span class="comment">% [y1 y2 y3] = dsolve(&#x27;Dy1=y2*y3&#x27;,&#x27;Dy2=-y1*y3&#x27;,&#x27;Dy3=-0.51*y1*y2&#x27;,&#x27;y1(0)=0,y2(0)=1,y3(0)=1&#x27;,&#x27;x&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 调用ode45函数求解微分方程df2，自变量为x，范围为[0,4*pi] ; 因变量为y1,y2和y3，初始值: y1(0)=0,y2(0)=y3(0)=1 </span></span><br><span class="line">[x, y] = ode45(<span class="string">&#x27;df2&#x27;</span>, [<span class="number">0</span> <span class="number">4</span>*<span class="built_in">pi</span>], [<span class="number">0</span> <span class="number">1</span> <span class="number">1</span>]);  <span class="comment">% 这里的y是一个有3列的矩阵哦！</span></span><br><span class="line"><span class="built_in">plot</span>(x, y(:,<span class="number">1</span>), <span class="string">&#x27;o&#x27;</span>, x, y(:,<span class="number">2</span>), <span class="string">&#x27;*&#x27;</span>, x, y(:,<span class="number">3</span>), <span class="string">&#x27;+&#x27;</span>) </span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;y1&#x27;</span>,<span class="string">&#x27;y2&#x27;</span>,<span class="string">&#x27;y3&#x27;</span>)  <span class="comment">% 加上标注</span></span><br><span class="line">axis([<span class="number">0</span>, <span class="number">4</span>*<span class="built_in">pi</span>, -<span class="built_in">inf</span>, +<span class="built_in">inf</span>])  <span class="comment">% 设置横坐标范围为0-4pi，纵坐标范围不需要设置，写成-inf到+inf</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dy</span> = <span class="title">df2</span><span class="params">(x,y)</span> </span></span><br><span class="line">       <span class="comment">% 注意哦，x是自变量，y是因变量，由y1,y2,y3组成 </span></span><br><span class="line">       dy = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);  <span class="comment">% 初始化用来储存因变量一阶导数的列向量（不能写成行向量哦）</span></span><br><span class="line">       dy(<span class="number">1</span>) = y(<span class="number">2</span>) * y(<span class="number">3</span>);</span><br><span class="line">       dy(<span class="number">2</span>) = -y(<span class="number">1</span>) * y(<span class="number">3</span>);</span><br><span class="line">       dy(<span class="number">3</span>) = <span class="number">-0.51</span> * y(<span class="number">1</span>) * y(<span class="number">2</span>);</span><br><span class="line"><span class="comment">%     上面四行可以写成一行：   dy = [ y(2) * y(3);   -y(1) * y(3);  -0.51 * y(1) * y(2)]</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="例题三："><a href="#例题三：" class="headerlink" title="例题三："></a>例题三：</h2><p><img src="/images/image-20240129135929028.png" alt="image-20240129135929028"></p><p><img src="/images/image-20240129140127574.png" alt="image-20240129140127574"></p><p><img src="/images/image-20240129140153081.png" alt="image-20240129140153081"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 我们先看这个微分方程有没有解析解</span></span><br><span class="line">dsolve(<span class="string">&#x27;(1+x*x)*D2y=2*x*Dy&#x27;</span>,<span class="string">&#x27;y(-2)=3,Dy(-2)=4&#x27;</span>,<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">x = <span class="number">-2</span>:<span class="number">0.01</span>:<span class="number">2</span>;</span><br><span class="line">y = (<span class="number">4</span>*x.*(x.^<span class="number">2</span> + <span class="number">3</span>))/<span class="number">15</span> + <span class="number">101</span>/<span class="number">15</span>;</span><br><span class="line"><span class="built_in">plot</span>(x,y,<span class="string">&#x27;b-&#x27;</span>)</span><br><span class="line"><span class="comment">% 事实上有了解析解后我们就完全不需要数值解了，下面我们只是为了演示怎么进行求解~</span></span><br><span class="line"><span class="built_in">hold</span> on <span class="comment">% 继续在上面作图</span></span><br><span class="line">[x,y]=ode45(<span class="string">&#x27;df3&#x27;</span>,[<span class="number">-2</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]);  <span class="comment">% 求出这个微分方程df3的数值解</span></span><br><span class="line"><span class="built_in">plot</span>(x,y(:,<span class="number">1</span>),<span class="string">&#x27;r*&#x27;</span>) <span class="comment">% 注意，y变量有两列，第一列是y1(我们要求的y)，第二列是y2(y的一阶导数) </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dy</span>=<span class="title">df3</span><span class="params">(x,y)</span> </span></span><br><span class="line">       dy=<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);  <span class="comment">% 初始化用来储存因变量一阶导数的矩阵</span></span><br><span class="line">       dy(<span class="number">1</span>)=y(<span class="number">2</span>);</span><br><span class="line">       dy(<span class="number">2</span>)=(<span class="number">2</span>*x)/(<span class="number">1</span>+x*x)*y(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="例题4"><a href="#例题4" class="headerlink" title="例题4:"></a>例题4:</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 我们先看这个微分方程有没有解析解</span></span><br><span class="line">dsolve(<span class="string">&#x27;D2y=1000*(1-y^2)*Dy-y&#x27;</span>,<span class="string">&#x27;y(0)=2,Dy(0)=0&#x27;</span>,<span class="string">&#x27;x&#x27;</span>)  <span class="comment">% 警告: Explicit solution could not be found. </span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面计算数值解</span></span><br><span class="line"><span class="comment">% 如果使用ode45函数会发现计算的非常慢，matlab一直显示正忙(windows电脑在命令行窗口按Ctrl+C可以终止运行)</span></span><br><span class="line"><span class="comment">% [x,y]=ode45(&#x27;df4&#x27;,[0,3000],[2,0]);  % 求出这个微分方程df4的数值解</span></span><br><span class="line"><span class="comment">% 所以我们可以使用刚性问题的函数ode15s对其求解</span></span><br><span class="line">[x,y]=ode15s(<span class="string">&#x27;df4&#x27;</span>,[<span class="number">0</span>,<span class="number">3000</span>],[<span class="number">2</span>,<span class="number">0</span>]);  <span class="comment">% 求出这个微分方程df4的数值解</span></span><br><span class="line"><span class="built_in">plot</span>(x,y(:,<span class="number">1</span>),<span class="string">&#x27;*&#x27;</span>) <span class="comment">% 注意，y变量有两列，第一列是y1(我们要求的y)，第二列是y2(y的一阶导数)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dy</span>=<span class="title">df4</span><span class="params">(x,y)</span></span></span><br><span class="line">    dy=<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    dy(<span class="number">1</span>)=y(<span class="number">2</span>);</span><br><span class="line">    dy(<span class="number">2</span>)=<span class="number">1000</span>*(<span class="number">1</span>-y(<span class="number">1</span>)^<span class="number">2</span>)*y(<span class="number">2</span>)-y(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="例题5：导弹追踪问题"><a href="#例题5：导弹追踪问题" class="headerlink" title="例题5：导弹追踪问题"></a>例题5：导弹追踪问题</h2><p><img src="/images/image-20240129140449477.png" alt="image-20240129140449477"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">clear; clc</span><br><span class="line">options = odeset(<span class="string">&#x27;reltol&#x27;</span>,<span class="number">1e-4</span>,<span class="string">&#x27;abstol&#x27;</span>,<span class="number">1e-8</span>);  <span class="comment">%  设定相对误差和绝对误差，这样可以提高微分方程数值解的精度</span></span><br><span class="line"><span class="comment">% 下面的[0,0.1]表示时间t的范围，因为我们导弹速度假设的是200，所以这里的范围给小点</span></span><br><span class="line">[t,y]=ode45(<span class="string">&#x27;df5&#x27;</span> ,[<span class="number">0</span>,<span class="number">0.1</span>],[<span class="number">0</span> <span class="number">0</span>], options); <span class="comment">% y是因变量，第一列为导弹运行的横坐标，第二列为导弹运行的纵坐标</span></span><br><span class="line"><span class="comment">% [t,y]=ode45(&#x27;df5&#x27; ,[0:0.0001:0.1],[0 0], options); % y是因变量，第一列为导弹运行的横坐标，第二列为导弹运行的纵坐标</span></span><br><span class="line">x = y(:,<span class="number">1</span>);  y =y(:,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">plot</span>(x, y,<span class="string">&#x27;*&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">1</span>)  <span class="comment">% 画出导弹的运行轨迹</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>([<span class="number">20</span>,<span class="number">30</span>],[<span class="number">0</span>,<span class="number">10</span>]) <span class="comment">% 画出B船的运行轨迹: x-y-20=0</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="comment">% 下面我们找到导弹与B船相撞的点（由于Matlab浮点数计算的原因，距离足够近时即可认为相撞）</span></span><br><span class="line">n =<span class="built_in">length</span>(t);  <span class="comment">% 找到Matlab计算微分方程的数值解时一共有多少个时间点</span></span><br><span class="line">d = <span class="number">0</span>;  <span class="comment">% 初始化导弹飞行的距离</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n <span class="comment">% 开始循环</span></span><br><span class="line">    dd = <span class="built_in">abs</span>(x(<span class="built_in">i</span>) - y(<span class="built_in">i</span>) - <span class="number">20</span>) / <span class="built_in">sqrt</span>(<span class="number">2</span>);  <span class="comment">% 利用点到直线的距离公式计算导弹和船的距离</span></span><br><span class="line">    <span class="keyword">if</span> dd &lt; <span class="number">0.001</span> <span class="comment">% 如果这个距离足够小了，我们就认为相撞了，但再此之前别忘了判断导弹是否达到了有效射程</span></span><br><span class="line">        <span class="keyword">for</span> k = <span class="number">2</span>:<span class="built_in">i</span></span><br><span class="line">            d = <span class="built_in">sqrt</span>((x(k)-x(k<span class="number">-1</span>))^<span class="number">2</span>+(y(k)-y(k<span class="number">-1</span>))^<span class="number">2</span>) + d;  <span class="comment">% 以直代曲的思想求曲线的长度，即导弹飞行的距离</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">if</span> d &lt;= <span class="number">50</span> <span class="comment">% 导弹的有效射程为50个单位,如果没有达到50单位</span></span><br><span class="line">            <span class="built_in">disp</span>([<span class="string">&#x27;导弹飞行&#x27;</span>,num2str(d),<span class="string">&#x27;单位后击中B船&#x27;</span>])</span><br><span class="line">            <span class="built_in">disp</span>([<span class="string">&#x27;导弹飞行的时间为&#x27;</span>,num2str(t(<span class="built_in">i</span>)*<span class="number">60</span> ),<span class="string">&#x27;分钟&#x27;</span>]) <span class="comment">% 输出导弹击中B船的时间(转换为分钟)</span></span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;击中点的坐标：&#x27;</span>) ;  <span class="built_in">disp</span>([x(<span class="built_in">i</span>),y(<span class="built_in">i</span>)])  <span class="comment">% 输出导弹击中B船的坐标</span></span><br><span class="line">            <span class="built_in">plot</span>(x(<span class="built_in">i</span>),y(<span class="built_in">i</span>),<span class="string">&#x27;r*&#x27;</span>);</span><br><span class="line">            text(x(<span class="built_in">i</span>)+<span class="number">0.5</span>,y(<span class="built_in">i</span>)+<span class="number">0.1</span>,<span class="string">&#x27;击中点&#x27;</span>)</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">% 跳出循环</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> d &gt;<span class="number">50</span> || dd &gt;= <span class="number">0.001</span> <span class="comment">% 如果射程大于50或导弹与B船的距离始终都没有小于0.001（这个数需要根据实际情况调整）</span></span><br><span class="line">    <span class="built_in">disp</span>(<span class="string">&#x27;导弹没有击中B船&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">t(<span class="built_in">i</span>) * <span class="number">200</span> * <span class="number">3</span>   <span class="comment">% 更快计算导弹飞行距离的公式：速度*时间</span></span><br><span class="line"><span class="comment">% 得到的结果和我们上面以直代曲的结果很接近</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面是以前使用蒙特卡罗模拟得到的解，大家可以对比下：</span></span><br><span class="line"><span class="comment">% 导弹飞行27.8019单位后击中B船</span></span><br><span class="line"><span class="comment">% 导弹飞行的时间为2.7802分钟</span></span><br><span class="line"><span class="comment">% 击中点的坐标：</span></span><br><span class="line"><span class="comment">%    26.5523    6.5523</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dy</span>=<span class="title">df5</span><span class="params">(t,y)</span></span></span><br><span class="line">    v = <span class="number">200</span>; </span><br><span class="line">    dy=<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    dy(<span class="number">1</span>)=<span class="number">3</span>*v*(<span class="number">20</span>+<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>*v*t-y(<span class="number">1</span>))/<span class="built_in">sqrt</span>((<span class="number">20</span>+<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>*v*t-y(<span class="number">1</span>))^<span class="number">2</span>+(<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>*v*t-y(<span class="number">2</span>))^<span class="number">2</span>);</span><br><span class="line">    dy(<span class="number">2</span>)=<span class="number">3</span>*v*(<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>*v*t-y(<span class="number">2</span>))/<span class="built_in">sqrt</span>((<span class="number">20</span>+<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>*v*t-y(<span class="number">1</span>))^<span class="number">2</span>+(<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>*v*t-y(<span class="number">2</span>))^<span class="number">2</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="微分方程模型"><a href="#微分方程模型" class="headerlink" title="微分方程模型"></a>微分方程模型</h1><p><img src="/images/image-20240129141545307.png" alt="image-20240129141545307"></p><p><img src="/images/image-20240129141735253.png" alt="image-20240129141735253"></p><p><img src="/images/image-20240129141815500.png" alt="image-20240129141815500"></p><p><img src="/images/image-20240129142046760.png" alt="image-20240129142046760"></p><p><img src="/images/image-20240129142146748.png" alt="image-20240129142146748"></p><p><img src="/images/image-20240129142209940.png" alt="image-20240129142209940"></p><p><img src="/images/image-20240129142557126.png" alt="image-20240129142557126"></p><p><img src="/images/image-20240129142619881.png" alt="image-20240129142619881"></p><h2 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% Malthus模型（马尔萨斯模型）</span></span><br><span class="line">clear;clc</span><br><span class="line">x = dsolve(<span class="string">&#x27;Dx=r*x&#x27;</span>,<span class="string">&#x27;x(0)=x0&#x27;</span>,<span class="string">&#x27;t&#x27;</span>)    <span class="comment">% x = dsolve(&#x27;Dx=r*x&#x27;,&#x27;x(t0)=x0&#x27;,&#x27;t&#x27;)</span></span><br><span class="line"><span class="comment">% x = x0*exp(r*t)</span></span><br><span class="line"><span class="comment">% 怎么把上面这个式子中的x0和r替换成确定的值？</span></span><br><span class="line">x0 = <span class="number">100</span>; </span><br><span class="line">r = <span class="number">0.1</span>;</span><br><span class="line">subs(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始人口为1000，画出50年且增长率分别为0.5%，1%，1.5% 一直到5%的人口变化曲线</span></span><br><span class="line">x0 = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">    r = <span class="number">0.005</span>*<span class="built_in">i</span>;</span><br><span class="line">    xx = subs(x);</span><br><span class="line">    fplot(xx,[<span class="number">0</span>,<span class="number">50</span>])   <span class="comment">% fplot函数可以绘制表达式的图形</span></span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 阻滞增长模型（logistic模型）</span></span><br><span class="line">clear;clc</span><br><span class="line">x = dsolve(<span class="string">&#x27;Dx=r*(1-x/xm)*x&#x27;</span>,<span class="string">&#x27;x(t0)=x0&#x27;</span>,<span class="string">&#x27;t&#x27;</span>)   <span class="comment">% 化简后和书上的结果一样</span></span><br><span class="line"><span class="comment">% mupad  % 把计算出来的结果粘贴过去可以得到直观的表达式</span></span><br><span class="line"><span class="comment">% 高版本可以使用实时脚本</span></span><br><span class="line">t0 = <span class="number">0</span>;</span><br><span class="line">x0 = <span class="number">1000</span>;</span><br><span class="line">xm = <span class="number">10000</span>;</span><br><span class="line">r = <span class="number">0.05</span>;</span><br><span class="line">xx = subs(x);    <span class="comment">%  10000/(exp(log(9) - t/20) + 1)</span></span><br><span class="line">fplot(xx,[<span class="number">0</span>,<span class="number">200</span>])  </span><br><span class="line"></span><br><span class="line"><span class="comment">% 如果不会用上面的fplot函数怎么办？</span></span><br><span class="line">t = <span class="number">0</span>:<span class="number">200</span>;</span><br><span class="line">x = <span class="number">10000</span> ./ (<span class="built_in">exp</span>(<span class="built_in">log</span>(<span class="number">9</span>) - t/<span class="number">20</span>) + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">plot</span>(t,x,<span class="string">&#x27;-&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="预测美国人口"><a href="#预测美国人口" class="headerlink" title="预测美国人口"></a>预测美国人口</h2><p><img src="/images/image-20240129143246601.png" alt="image-20240129143246601"></p><p><img src="/images/image-20240129143301788.png" alt="image-20240129143301788"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line">year = <span class="number">1790</span>:<span class="number">10</span>:<span class="number">2000</span>;</span><br><span class="line">population = [<span class="number">3.9</span>,<span class="number">5.3</span>,<span class="number">7.2</span>,<span class="number">9.6</span>,<span class="number">12.9</span>,<span class="number">17.1</span>,<span class="number">23.2</span>,<span class="number">31.4</span>,<span class="number">38.6</span>,<span class="number">50.2</span>,<span class="number">62.9</span>,<span class="number">76.0</span>,<span class="number">92.0</span>,<span class="number">106.5</span>,<span class="number">123.2</span>,<span class="number">131.7</span>,<span class="number">150.7</span>,<span class="number">179.3</span>,<span class="number">204.0</span>,<span class="number">226.5</span>,<span class="number">251.4</span>,<span class="number">281.4</span>];</span><br><span class="line">cftool  <span class="comment">% 拟合工具箱</span></span><br><span class="line"><span class="comment">% (1) X data 选择 year</span></span><br><span class="line"><span class="comment">% (2) Y data 选择 population</span></span><br><span class="line"><span class="comment">% (3) 拟合方式选择：Custom Equation (自定义方程)</span></span><br><span class="line"><span class="comment">% (4) 修改下方的方框为：x = f(t) = xm/(1+(xm/3.9-1)*exp(-r*(t-1790)))</span></span><br><span class="line"><span class="comment">% (5) 左边的result一栏最上面显示：Fit computation did not converge:即没有找到收敛解，右边的拟合图形也表明拟合结果不理想</span></span><br><span class="line"><span class="comment">% (6) 点击Fit Options，修改非线性最小二乘估计法拟合的初始值(StartPoint), r修改为0.02，xm修改为500</span></span><br><span class="line"><span class="comment">% (7) 此时左边的result一览得到了拟合结果：r = 0.02735, xm = 342.4</span></span><br><span class="line"><span class="comment">% (8) 依次点击拟合工具箱的菜单栏最左边的文件—Generate Code(导出代码到时候可以放在你的论文附录)，可以得到一个未命名的脚本文件</span></span><br><span class="line"><span class="comment">% (9) 在这个打开的脚本中按快捷键Ctrl+S，将这个文件保存到当前文件夹。</span></span><br><span class="line"><span class="comment">% (10) 在现在这个文件中调用这个函数得到参数的拟合值和预测的效果</span></span><br><span class="line">[fitresult, gof] = createFit(year, population) </span><br><span class="line">t = <span class="number">2001</span>:<span class="number">2030</span>;</span><br><span class="line">xm = <span class="number">342.4</span>;   </span><br><span class="line">r =  <span class="number">0.02735</span>;</span><br><span class="line">predictions = xm./(<span class="number">1</span>+(xm./<span class="number">3.9</span><span class="number">-1</span>).*<span class="built_in">exp</span>(-r.*(t<span class="number">-1790</span>)));  <span class="comment">% 计算预测值（注意这里要写成点乘和点除）</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(year,population,<span class="string">&#x27;o&#x27;</span>,t,predictions,<span class="string">&#x27;.&#x27;</span>)  <span class="comment">% 绘制预测结果图</span></span><br><span class="line"><span class="built_in">disp</span>(predictions)  <span class="comment">% 预测的数值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[fitresult, gof]</span> = <span class="title">createFit</span><span class="params">(year, population)</span></span></span><br><span class="line"><span class="comment">%CREATEFIT(YEAR,POPULATION)</span></span><br><span class="line"><span class="comment">%  Create a fit.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%  Data for &#x27;untitled fit 1&#x27; fit:</span></span><br><span class="line"><span class="comment">%      X Input : year</span></span><br><span class="line"><span class="comment">%      Y Output: population</span></span><br><span class="line"><span class="comment">%  Output:</span></span><br><span class="line"><span class="comment">%      fitresult : a fit object representing the fit.</span></span><br><span class="line"><span class="comment">%      gof : structure with goodness-of fit info.</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%  另请参阅 FIT, CFIT, SFIT.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%  由 MATLAB 于 02-Jan-2020 23:14:10 自动生成</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% Fit: &#x27;untitled fit 1&#x27;.</span></span><br><span class="line">[xData, yData] = prepareCurveData( year, population );</span><br><span class="line"></span><br><span class="line"><span class="comment">% Set up fittype and options.</span></span><br><span class="line">ft = fittype( <span class="string">&#x27;xm/(1+(xm/3.9-1)*exp(-r*(t-1790)))&#x27;</span>, <span class="string">&#x27;independent&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;dependent&#x27;</span>, <span class="string">&#x27;x&#x27;</span> );</span><br><span class="line">opts = fitoptions( <span class="string">&#x27;Method&#x27;</span>, <span class="string">&#x27;NonlinearLeastSquares&#x27;</span> );</span><br><span class="line">opts.Display = <span class="string">&#x27;Off&#x27;</span>;</span><br><span class="line">opts.StartPoint = [<span class="number">0.2</span> <span class="number">500</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">% Fit model to data.</span></span><br><span class="line">[fitresult, gof] = fit( xData, yData, ft, opts );</span><br><span class="line"></span><br><span class="line"><span class="comment">% Plot fit with data.</span></span><br><span class="line"><span class="built_in">figure</span>( <span class="string">&#x27;Name&#x27;</span>, <span class="string">&#x27;untitled fit 1&#x27;</span> );</span><br><span class="line">h = <span class="built_in">plot</span>( fitresult, xData, yData );</span><br><span class="line"><span class="built_in">legend</span>( h, <span class="string">&#x27;population vs. year&#x27;</span>, <span class="string">&#x27;untitled fit 1&#x27;</span>, <span class="string">&#x27;Location&#x27;</span>, <span class="string">&#x27;NorthEast&#x27;</span> );</span><br><span class="line"><span class="comment">% Label axes</span></span><br><span class="line">xlabel year</span><br><span class="line">ylabel population</span><br><span class="line">grid on</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="捕食者猎物模型"><a href="#捕食者猎物模型" class="headerlink" title="捕食者猎物模型"></a>捕食者猎物模型</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/images/image-20240129143537340.png" alt="image-20240129143537340"></p><p><img src="/images/image-20240129143946435.png" alt="image-20240129143946435"></p><p><img src="/images/image-20240129145756075.png" alt="image-20240129145756075"></p><p><img src="/images/image-20240129145847371.png" alt="image-20240129145847371"></p><p><img src="/images/image-20240129145919864.png" alt="image-20240129145919864"></p><p><img src="/images/image-20240129145944577.png" alt="image-20240129145944577"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">clear;clc</span><br><span class="line"><span class="comment">%  Matlab求不出来解析解</span></span><br><span class="line"><span class="comment">% dsolve(&#x27;Dx1=x1*(0.9-0.1*x2)&#x27;,&#x27;Dx2=x2*(-0.6+0.02*x1)&#x27;,&#x27;x1(0)=25,x2(0)=2&#x27;,&#x27;t&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面用ode45函数求数值解</span></span><br><span class="line"><span class="comment">% 自变量t的范围为0-15年，食饵和捕食者（鲨鱼）初始值分别为25和2 </span></span><br><span class="line"><span class="comment">% 注意：战前和战后是战争开始前和战争开始后的简写哦</span></span><br><span class="line">[t1,x1]=ode45(<span class="string">&#x27;pre_war&#x27;</span>,[<span class="number">0</span> <span class="number">15</span>],[<span class="number">25</span> <span class="number">2</span>]);  <span class="comment">% 战前的微分方程       </span></span><br><span class="line">[t2,x2]=ode45(<span class="string">&#x27;past_war&#x27;</span>,[<span class="number">0</span> <span class="number">15</span>],[<span class="number">25</span> <span class="number">2</span>]);     <span class="comment">% 战后的微分方程</span></span><br><span class="line"><span class="comment">% [t1,x1]=ode45(&#x27;pre_war&#x27;,[0:15],[25 2]);  % 战前的微分方程       </span></span><br><span class="line"><span class="comment">% [t2,x2]=ode45(&#x27;past_war&#x27;,[0:15],[25 2]);     % 战后的微分方程</span></span><br><span class="line"></span><br><span class="line">pre_prey=x1(:,<span class="number">1</span>); pre_shark=x1(:,<span class="number">2</span>);   <span class="comment">% 战前的食饵和鲨鱼的数量</span></span><br><span class="line">past_prey=x2(:,<span class="number">1</span>); past_shark=x2(:,<span class="number">2</span>);  <span class="comment">% 战后的食饵和鲨鱼的数量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(pre_prey,pre_shark,<span class="string">&#x27;--r&#x27;</span>,past_prey,past_shark,<span class="string">&#x27;-b&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;战前&#x27;</span>,<span class="string">&#x27;战后&#x27;</span>)</span><br><span class="line">title(<span class="string">&#x27;鲨鱼和食饵数量变化的相轨线图&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;食饵数量&#x27;</span>);   ylabel(<span class="string">&#x27;鲨鱼数量&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(t1,pre_prey,<span class="string">&#x27;--r&#x27;</span>,t1,pre_shark,<span class="string">&#x27;-r&#x27;</span>,t2,past_prey,<span class="string">&#x27;--b&#x27;</span>,t2,past_shark,<span class="string">&#x27;-b&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;战前食饵数量&#x27;</span>,<span class="string">&#x27;战前鲨鱼数量&#x27;</span>,<span class="string">&#x27;战后食饵数量&#x27;</span>,<span class="string">&#x27;战后鲨鱼数量&#x27;</span>)</span><br><span class="line">xlabel(<span class="string">&#x27;时间&#x27;</span>);   ylabel(<span class="string">&#x27;数量&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 鲨鱼比例  =  鲨鱼数量 /（鲨鱼数+食饵数）</span></span><br><span class="line">pre_rate=pre_shark./(pre_prey+pre_shark);  <span class="comment">% 战前的鲨鱼比例    </span></span><br><span class="line">past_rate=past_shark./(past_prey+past_shark);   <span class="comment">% 战后的鲨鱼比例</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(t1,pre_rate,<span class="string">&#x27;--r&#x27;</span>,t2,past_rate,<span class="string">&#x27;-b&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;战前的鲨鱼比例&#x27;</span>,<span class="string">&#x27;战后的鲨鱼比例&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 战后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dx</span>=<span class="title">past_war</span><span class="params">(t,x)</span></span></span><br><span class="line">    dx=<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>); </span><br><span class="line">    dx(<span class="number">1</span>)=x(<span class="number">1</span>)*(<span class="number">0.9</span><span class="number">-0.1</span>*x(<span class="number">2</span>));</span><br><span class="line">    dx(<span class="number">2</span>)=x(<span class="number">2</span>)*(<span class="number">-0.6</span>+<span class="number">0.02</span>*x(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% սǰ</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dx</span>=<span class="title">pre_war</span><span class="params">(t,x)</span></span></span><br><span class="line">    dx=<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>); </span><br><span class="line">    dx(<span class="number">1</span>)=x(<span class="number">1</span>)*(<span class="number">0.7</span><span class="number">-0.1</span>*x(<span class="number">2</span>));</span><br><span class="line">    dx(<span class="number">2</span>)=x(<span class="number">2</span>)*(<span class="number">-0.8</span>+<span class="number">0.02</span>*x(<span class="number">1</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="种群相互竞争模型"><a href="#种群相互竞争模型" class="headerlink" title="种群相互竞争模型"></a>种群相互竞争模型</h1><p><img src="/images/image-20240129150258790.png" alt="image-20240129150258790"></p><p><img src="/images/image-20240129150851048.png" alt="image-20240129150851048"></p><p><img src="/images/image-20240129151411054.png" alt="image-20240129151411054"></p><p><img src="/images/image-20240129151639245.png" alt="image-20240129151639245"></p><p><img src="/images/image-20240129151742576.png" alt="image-20240129151742576"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">clc;clear</span><br><span class="line"><span class="comment">%  Matlab求不出来解析解</span></span><br><span class="line"><span class="comment">% dsolve(&#x27;Dx1 = 0.5*x1*(1-x1/300-0.5*x2/500)&#x27;,&#x27;Dx2=0.5*x2*(1-x2/500-2*x1/300)&#x27;,&#x27;x1(0)=80,x2(0)=100&#x27;,&#x27;t&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面用ode45函数求数值解</span></span><br><span class="line"><span class="comment">% 自变量为时间t，范围为0-30； 甲乙两个种群的数量初始值为80，100（随便给的，大家可以调整来看结果的变化）</span></span><br><span class="line">[t,x]=ode45(<span class="string">&#x27;fun&#x27;</span>,[<span class="number">0</span> <span class="number">30</span>],[<span class="number">80</span> <span class="number">100</span>]); </span><br><span class="line"><span class="built_in">plot</span>(t,x(:,<span class="number">1</span>),<span class="string">&#x27;r-&#x27;</span>,t,x(:,<span class="number">2</span>),<span class="string">&#x27;b-&#x27;</span>)  <span class="comment">% x的第一列是甲种群数量，x的第二列是乙种群数量</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;种群甲&#x27;</span>,<span class="string">&#x27;种群乙&#x27;</span>)</span><br><span class="line"><span class="comment">% axis([0 30 0 500])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dx</span>=<span class="title">fun</span><span class="params">(t,x)</span>   % 大家可以修改里面的参数，来看结果的变化</span></span><br><span class="line">    r1=<span class="number">0.5</span>;  r <span class="number">2</span>=<span class="number">0.5</span>; <span class="comment">% 甲乙的增长率</span></span><br><span class="line"><span class="comment">%     r1=0.8;  r2=1; % 甲乙的增长率</span></span><br><span class="line">    N1=<span class="number">300</span>;   N2=<span class="number">500</span>;   <span class="comment">% 甲乙的最大数量</span></span><br><span class="line">    <span class="comment">% sigma1: 单位数量的乙种群(相对于N2)消耗的供养甲的食物量为单位数量的甲(相对于N1)消耗的供养甲的食物量的倍数。</span></span><br><span class="line">    <span class="comment">% sigma2: 单位数量的甲种群(相对于N1)消耗的供养乙的食物量为单位数量的乙(相对于N2)消耗的供养乙的食物量的倍数。</span></span><br><span class="line">    sigma1=<span class="number">0.5</span>;  sigma2=<span class="number">2</span>;   </span><br><span class="line"><span class="comment">%     sigma1=0.5;  sigma2=4;   </span></span><br><span class="line"><span class="comment">%     sigma1=0.4;  sigma2=0.2;</span></span><br><span class="line"><span class="comment">%   当sigma1和sigma2同时大于1时（这种现象本身在自然界就几乎不可能出现），得到的结果不稳定。</span></span><br><span class="line"><span class="comment">%     sigma1=3;  sigma2=2;   </span></span><br><span class="line"><span class="comment">%     sigma1=2.2;  sigma2=2;   </span></span><br><span class="line"></span><br><span class="line">    dx = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    dx(<span class="number">1</span>) = r1*x(<span class="number">1</span>)*(<span class="number">1</span>-x(<span class="number">1</span>)/N1-sigma1*x(<span class="number">2</span>)/N2);</span><br><span class="line">    dx(<span class="number">2</span>) = r2*x(<span class="number">2</span>)*(<span class="number">1</span>-x(<span class="number">2</span>)/N2-sigma2*x(<span class="number">1</span>)/N1);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="种群相互依存模型"><a href="#种群相互依存模型" class="headerlink" title="种群相互依存模型"></a>种群相互依存模型</h1><p><img src="/images/image-20240129152337478.png" alt="image-20240129152337478"></p><p><img src="/images/image-20240129152352501.png" alt="image-20240129152352501"></p><h2 id="情况一："><a href="#情况一：" class="headerlink" title="情况一："></a>情况一：</h2><p><img src="/images/image-20240129152422993.png" alt="image-20240129152422993"></p><h2 id="情况二："><a href="#情况二：" class="headerlink" title="情况二："></a>情况二：</h2><p><img src="/images/image-20240129152504494.png" alt="image-20240129152504494"></p><h2 id="情况三："><a href="#情况三：" class="headerlink" title="情况三："></a>情况三：</h2><p><img src="/images/image-20240129152541262.png" alt="image-20240129152541262"></p><h2 id="情况一图像："><a href="#情况一图像：" class="headerlink" title="情况一图像："></a>情况一图像：</h2><p><img src="/images/image-20240129152609368.png" alt="image-20240129152609368"></p><p><img src="/images/image-20240129152614946.png" alt="image-20240129152614946"></p><p><img src="/images/image-20240129152744579.png" alt="image-20240129152744579"></p><p><img src="/images/image-20240129152809888.png" alt="image-20240129152809888"></p><h2 id="情况二图像："><a href="#情况二图像：" class="headerlink" title="情况二图像："></a>情况二图像：</h2><p><img src="/images/image-20240129152835035.png" alt="image-20240129152835035"></p><h2 id="情况三图像："><a href="#情况三图像：" class="headerlink" title="情况三图像："></a>情况三图像：</h2><p><img src="/images/image-20240129153016550.png" alt="image-20240129153016550"></p><h2 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">clc;clear</span><br><span class="line"><span class="comment">% 情况一：甲可以独自生存，乙不能独自生存</span></span><br><span class="line">[t,x]=ode45(<span class="string">&#x27;fun1&#x27;</span>,[<span class="number">0</span> <span class="number">50</span>],[<span class="number">80</span> <span class="number">100</span>]); </span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">plot</span>(t,x(:,<span class="number">1</span>),<span class="string">&#x27;r-&#x27;</span>,t,x(:,<span class="number">2</span>),<span class="string">&#x27;b-&#x27;</span>)  <span class="comment">% x的第一列是甲种群数量，x的第二列是乙种群数量</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;种群甲&#x27;</span>,<span class="string">&#x27;种群乙&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 情况二：甲乙均可以独自生存</span></span><br><span class="line">[t,x]=ode45(<span class="string">&#x27;fun2&#x27;</span>,[<span class="number">0</span> <span class="number">50</span>],[<span class="number">80</span> <span class="number">100</span>]); </span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(t,x(:,<span class="number">1</span>),<span class="string">&#x27;r-&#x27;</span>,t,x(:,<span class="number">2</span>),<span class="string">&#x27;b-&#x27;</span>)  <span class="comment">% x的第一列是甲种群数量，x的第二列是乙种群数量</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;种群甲&#x27;</span>,<span class="string">&#x27;种群乙&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 情况三：甲乙均不能独自生存</span></span><br><span class="line">[t,x]=ode45(<span class="string">&#x27;fun3&#x27;</span>,[<span class="number">0</span> <span class="number">50</span>],[<span class="number">80</span> <span class="number">100</span>]); </span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(t,x(:,<span class="number">1</span>),<span class="string">&#x27;r-&#x27;</span>,t,x(:,<span class="number">2</span>),<span class="string">&#x27;b-&#x27;</span>)  <span class="comment">% x的第一列是甲种群数量，x的第二列是乙种群数量</span></span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;种群甲&#x27;</span>,<span class="string">&#x27;种群乙&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 情况一：甲可以独自生存，乙不能独自生存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dx</span>=<span class="title">fun1</span><span class="params">(t,x)</span>   % 大家可以修改里面的参数，来看结果的变化</span></span><br><span class="line">    r1=<span class="number">0.5</span>;  r2=<span class="number">0.5</span>; <span class="comment">% 甲的增长率和乙的死亡率</span></span><br><span class="line">    N1=<span class="number">300</span>;   N2=<span class="number">500</span>;   <span class="comment">% 甲乙的最大数量</span></span><br><span class="line">    <span class="comment">% sigma1: 单位数量的乙种群(相对于N2)提供的供养甲的食物量为单位数量的甲(相对于N1)消耗的供养甲的食物量的倍数。</span></span><br><span class="line">    <span class="comment">% sigma2: 单位数量的甲种群(相对于N1)提供的供养乙的食物量为单位数量的乙(相对于N2)消耗的供养乙的食物量的倍数。</span></span><br><span class="line">    sigma1=<span class="number">0.2</span>;  sigma2=<span class="number">2</span>;   </span><br><span class="line"><span class="comment">%     sigma1=0.2;  sigma2=0.8;</span></span><br><span class="line"><span class="comment">% 注意：当sigma1*sigma2&gt;1时，微分方程不稳定，matlab计算数值解时可能会报错，这时候需要调整计算的范围。</span></span><br><span class="line"><span class="comment">%     sigma1=3;  sigma2=3;   </span></span><br><span class="line">    dx = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    dx(<span class="number">1</span>) = r1*x(<span class="number">1</span>)*(<span class="number">1</span>-x(<span class="number">1</span>)/N1+sigma1*x(<span class="number">2</span>)/N2);</span><br><span class="line">    dx(<span class="number">2</span>) = r2*x(<span class="number">2</span>)*(<span class="number">-1</span>-x(<span class="number">2</span>)/N2+sigma2*x(<span class="number">1</span>)/N1);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 情况二：甲乙均可以独自生存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dx</span>=<span class="title">fun2</span><span class="params">(t,x)</span>   % 大家可以修改里面的参数，来看结果的变化</span></span><br><span class="line">    r1=<span class="number">0.5</span>;  r2=<span class="number">0.5</span>; <span class="comment">% 甲的增长率和乙的增长率</span></span><br><span class="line">    N1=<span class="number">300</span>;   N2=<span class="number">500</span>;   <span class="comment">% 甲乙的最大数量</span></span><br><span class="line">    <span class="comment">% sigma1: 单位数量的乙种群(相对于N2)提供的供养甲的食物量为单位数量的甲(相对于N1)消耗的供养甲的食物量的倍数。</span></span><br><span class="line">    <span class="comment">% sigma2: 单位数量的甲种群(相对于N1)提供的供养乙的食物量为单位数量的乙(相对于N2)消耗的供养乙的食物量的倍数。</span></span><br><span class="line">    sigma1=<span class="number">0.2</span>;  sigma2=<span class="number">2</span>;   </span><br><span class="line"><span class="comment">%     sigma1=0.2;  sigma2=0.8;</span></span><br><span class="line">    <span class="comment">% 注意：当sigma1*sigma2&gt;1时，微分方程不稳定，matlab计算数值解时可能会报错。</span></span><br><span class="line">    dx = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    dx(<span class="number">1</span>) = r1*x(<span class="number">1</span>)*(<span class="number">1</span>-x(<span class="number">1</span>)/N1+sigma1*x(<span class="number">2</span>)/N2);</span><br><span class="line">    dx(<span class="number">2</span>) = r2*x(<span class="number">2</span>)*(<span class="number">1</span>-x(<span class="number">2</span>)/N2+sigma2*x(<span class="number">1</span>)/N1);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 情况三：甲乙均不能独自生存</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dx</span>=<span class="title">fun3</span><span class="params">(t,x)</span>   % 大家可以修改里面的参数，来看结果的变化</span></span><br><span class="line">    r1=<span class="number">0.2</span>;  r2=<span class="number">0.2</span>; <span class="comment">% 甲的死亡率和乙的死亡率</span></span><br><span class="line">    N1=<span class="number">300</span>;   N2=<span class="number">500</span>;    <span class="comment">% 甲乙的最大数量</span></span><br><span class="line">    <span class="comment">% sigma1: 单位数量的乙种群(相对于N2)提供的供养甲的食物量为单位数量的甲(相对于N1)消耗的供养甲的食物量的倍数。</span></span><br><span class="line">    <span class="comment">% sigma2: 单位数量的甲种群(相对于N1)提供的供养乙的食物量为单位数量的乙(相对于N2)消耗的供养乙的食物量的倍数。</span></span><br><span class="line">    sigma1=<span class="number">0.2</span>;  sigma2=<span class="number">2</span>;   </span><br><span class="line"><span class="comment">%     sigma1=5;  sigma2=5; </span></span><br><span class="line"><span class="comment">%     sigma1=10;  sigma2=10;  % 这时候甲乙两个种群都能活下去了 </span></span><br><span class="line">    dx = <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">    dx(<span class="number">1</span>) = r1*x(<span class="number">1</span>)*(<span class="number">-1</span>-x(<span class="number">1</span>)/N1+sigma1*x(<span class="number">2</span>)/N2);</span><br><span class="line">    dx(<span class="number">2</span>) = r2*x(<span class="number">2</span>)*(<span class="number">-1</span>-x(<span class="number">2</span>)/N2+sigma2*x(<span class="number">1</span>)/N1);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab的符号运算</title>
      <link href="/2024/01/29/matlab%E7%9A%84%E7%AC%A6%E5%8F%B7%E8%BF%90%E7%AE%97/"/>
      <url>/2024/01/29/matlab%E7%9A%84%E7%AC%A6%E5%8F%B7%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h1 id="matlab的符号运算"><a href="#matlab的符号运算" class="headerlink" title="matlab的符号运算"></a>matlab的符号运算</h1><h2 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 符号变量的创建和简单运算</span></span><br><span class="line"><span class="comment">% 代码参考：我要自学网的龚飞老师《Matlab2016数值计算与智能算法》</span></span><br><span class="line">clear;clc</span><br><span class="line"></span><br><span class="line"><span class="comment">% 简单符号变量的创建</span></span><br><span class="line">syms x  <span class="comment">% 观察工作区， sym是symbolic的缩写</span></span><br><span class="line">syms a b c</span><br><span class="line"></span><br><span class="line"><span class="comment">% 符号方程的创建，两种方法</span></span><br><span class="line">syms a x</span><br><span class="line">y = a*x+x^<span class="number">2</span></span><br><span class="line"><span class="comment">% y = str2sym(&#x27;a*x+x^2&#x27;)  %Matlab 2017b 版本后推出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 符号矩阵</span></span><br><span class="line">syms alpha</span><br><span class="line">M = [<span class="built_in">cos</span>(alpha)  -<span class="built_in">sin</span>(alpha);</span><br><span class="line">       <span class="built_in">sin</span>(alpha)  <span class="built_in">cos</span>(alpha)]</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 简单运算</span></span><br><span class="line">syms a b c d e</span><br><span class="line">y = a + b</span><br><span class="line"><span class="comment">% a + b</span></span><br><span class="line">x = c - d</span><br><span class="line"><span class="comment">% c - d</span></span><br><span class="line">y1 = x*y</span><br><span class="line"><span class="comment">% (a + b)*(c - d)</span></span><br><span class="line">y2 = y1/y</span><br><span class="line"><span class="comment">% c - d</span></span><br><span class="line">y3 = y1^<span class="number">3</span></span><br><span class="line"><span class="comment">% (a + b)^3*(c - d)^3</span></span><br><span class="line">y4 = <span class="built_in">sqrt</span>(y3)   </span><br><span class="line"><span class="comment">% ((a + b)^3*(c - d)^3)^(1/2)</span></span><br><span class="line">y5 = <span class="built_in">exp</span>(y4)</span><br><span class="line"><span class="comment">% exp(((a + b)^3*(c - d)^3)^(1/2))</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 符号表达式的整理</span></span><br><span class="line">clear;clc</span><br><span class="line"></span><br><span class="line"><span class="comment">% 化简</span></span><br><span class="line">syms a</span><br><span class="line">y=(<span class="built_in">cot</span>(a/<span class="number">2</span>)-<span class="built_in">tan</span>(a/<span class="number">2</span>))*(<span class="number">1</span>+<span class="built_in">tan</span>(a)*<span class="built_in">tan</span>(a/<span class="number">2</span>))</span><br><span class="line">simplify(y)</span><br><span class="line"><span class="comment">% 2/sin(a)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 因式分解</span></span><br><span class="line"><span class="built_in">factor</span>(<span class="number">12</span>) <span class="comment">% 对常数进行因式分解 </span></span><br><span class="line"><span class="comment">%      2     2     3</span></span><br><span class="line">syms m n x</span><br><span class="line">y = <span class="number">-24</span>*m^<span class="number">2</span>*x<span class="number">-16</span>*n^<span class="number">2</span>*x</span><br><span class="line"><span class="built_in">factor</span>(y)</span><br><span class="line"><span class="comment">% [ -8, x, 3*m^2 + 2*n^2]</span></span><br><span class="line">y1=m^<span class="number">3</span>-n^<span class="number">3</span></span><br><span class="line"><span class="built_in">factor</span>(y1)</span><br><span class="line"><span class="comment">% [ m - n, m^2 + m*n + n^2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 多项式展开</span></span><br><span class="line">syms a x</span><br><span class="line">y = a*(x^<span class="number">2</span>-a)^<span class="number">2</span>+(x<span class="number">-2</span>)</span><br><span class="line">expand(y)</span><br><span class="line"><span class="comment">% a^3 - 2*a^2*x^2 + a*x^4 + x - 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 合并</span></span><br><span class="line">syms x y</span><br><span class="line">z = (x+y)^<span class="number">2</span>*y+<span class="number">5</span>*y*x<span class="number">-2</span>*x^<span class="number">3</span></span><br><span class="line"><span class="comment">% expand(z)   - 2*x^3 + x^2*y + 2*x*y^2 + 5*x*y + y^3</span></span><br><span class="line">collect(z,x)</span><br><span class="line"><span class="comment">% y*x^2 - 2*x^3 + (2*y^2 + 5*y)*x + y^3</span></span><br><span class="line">collect(z,y)</span><br><span class="line"><span class="comment">% y^3 + 2*x*y^2 + (x^2 + 5*x)*y - 2*x^3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 计算分子与分母</span></span><br><span class="line"><span class="comment">% [z1,z2] = numden(2.5)  % 会报错，因为numden的输入变量不能是数值，只能是符号变量</span></span><br><span class="line"><span class="comment">% ans = sym(2.5);  % sym函数可以将数值2.5转换为符号</span></span><br><span class="line">[z1,z2] = numden(sym(<span class="number">2.5</span>)) <span class="comment">% 对常数计算分子与分母</span></span><br><span class="line"><span class="comment">% z1 = 5</span></span><br><span class="line"><span class="comment">% z2 = 2</span></span><br><span class="line">syms x y</span><br><span class="line">z = <span class="number">1</span>/x*y+x/(x^<span class="number">2</span><span class="number">-2</span>*y)</span><br><span class="line">[z1,z2] = numden(z)  <span class="comment">%z1分子，z2分母</span></span><br><span class="line"><span class="comment">% z1 = - x^2*y - x^2 + 2*y^2</span></span><br><span class="line"><span class="comment">% z2 = x*(- x^2 + 2*y)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 让结果显示的更加自然</span></span><br><span class="line">syms x y</span><br><span class="line">M = (<span class="number">1</span>/x*y+x/(x^<span class="number">2</span><span class="number">-2</span>*y)-x^<span class="number">2</span>/(<span class="number">3</span>+y)^<span class="number">2</span>)^<span class="number">2</span>;</span><br><span class="line">expand(M)  </span><br><span class="line"><span class="comment">% y^2/x^2 + x^4/(y^4 + 12*y^3 + 54*y^2 + 108*y + 81) + (2*x^3)/(- x^2*y^2 - 6*x^2*y - 9*x^2 + 2*y^3 + 12*y^2 + 18*y) - (2*y)/(- x^2 + 2*y) + x^2/(x^4 - 4*x^2*y + 4*y^2) - (2*x*y)/(y^2 + 6*y + 9)</span></span><br><span class="line">mupad <span class="comment">% 未来的版本可能会移除这个工具箱，可以点击Matlab的主页，新建实时脚本</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 符号函数的求导</span></span><br><span class="line">clear;clc</span><br><span class="line"></span><br><span class="line"><span class="comment">% 一元函数的导数</span></span><br><span class="line">syms x</span><br><span class="line">y = x^<span class="number">4</span><span class="number">-5</span>*x^<span class="number">2</span>+<span class="number">6</span></span><br><span class="line">diff(y) <span class="comment">%求一阶导数</span></span><br><span class="line"><span class="comment">% 4*x^3 - 10*x</span></span><br><span class="line">diff(y,<span class="number">2</span>) <span class="comment">%求二阶导数</span></span><br><span class="line"><span class="comment">% 12*x^2 - 10</span></span><br><span class="line"></span><br><span class="line">y = <span class="built_in">cos</span>(x)*<span class="built_in">tan</span>(x)</span><br><span class="line">dy = diff(y,<span class="number">10</span>)  <span class="comment">%求十阶导数</span></span><br><span class="line">simplify(dy)</span><br><span class="line">y = <span class="built_in">sin</span>(x)*<span class="built_in">tan</span>(x)</span><br><span class="line">dy = diff(y,<span class="number">10</span>)  <span class="comment">%求十阶导数</span></span><br><span class="line">simplify(dy)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">% 多元函数的导数</span></span><br><span class="line">syms x1 x2 x3</span><br><span class="line">y1 = x1^<span class="number">5</span>*x2+x2*x3-x1^<span class="number">2</span>*x3</span><br><span class="line">py1 = diff(y1,x1,<span class="number">1</span>) <span class="comment">% 对x1求一阶偏导</span></span><br><span class="line"><span class="comment">% 5*x2*x1^4 - 2*x3*x1</span></span><br><span class="line">py2 = diff(y1,x1,<span class="number">2</span>) <span class="comment">% 对x1求二阶偏导</span></span><br><span class="line"><span class="comment">% 20*x2*x1^3 - 2*x3</span></span><br><span class="line">py3 = diff(y1,x1,x2) <span class="comment">% 先对x1求偏导，再对x2求偏导</span></span><br><span class="line"><span class="comment">% 5*x1^4</span></span><br><span class="line">py4 = diff(y1,x2,x1) <span class="comment">% 先对x2求偏导，再对x1求偏导</span></span><br><span class="line"><span class="comment">% 5*x1^4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 注意，如果diff函数作用的对象不是符号函数，而是矩阵，那么对应的功能是求差分。</span></span><br><span class="line">A=[<span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span>];</span><br><span class="line">diff(A)  <span class="comment">% 求向量A的一阶差分     1     1    -3    -1    -1</span></span><br><span class="line">diff(A,<span class="number">2</span>)  <span class="comment">% 在一阶差分的基础上再差分一次     0    -4     2     0</span></span><br><span class="line"></span><br><span class="line">A=[<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; </span><br><span class="line">     <span class="number">7</span> <span class="number">4</span> <span class="number">2</span>;</span><br><span class="line">     <span class="number">5</span> <span class="number">6</span> <span class="number">2</span>]</span><br><span class="line">A1=diff(A)  <span class="comment">% 下一行减去上一行求一阶差分</span></span><br><span class="line"><span class="comment">%      3    -1    -4</span></span><br><span class="line"><span class="comment">%     -2     2     0</span></span><br><span class="line">A2=diff(A,<span class="number">2</span>) <span class="comment">% 下一行减去上一行求二阶差分（在一阶差分的基础上再差分一次）</span></span><br><span class="line"><span class="comment">%     -5     3     4</span></span><br><span class="line">A3=diff(A,<span class="number">2</span>,<span class="number">1</span>) <span class="comment">% 最后面的1表示在行上进行差分（在列的方向上进行差分）</span></span><br><span class="line"><span class="comment">%     -5     3     4</span></span><br><span class="line">A4=diff(A,<span class="number">1</span>,<span class="number">2</span>)  <span class="comment">% 后一列减去前一列求一阶差分， 最后面的2表示在列上进行差分（在行的方向上进行差分）</span></span><br><span class="line"><span class="comment">%      1     1</span></span><br><span class="line"><span class="comment">%     -3    -2</span></span><br><span class="line"><span class="comment">%      1    -4</span></span><br><span class="line">A4=diff(A,<span class="number">2</span>,<span class="number">2</span>) <span class="comment">% 后一列减去前一列求二阶差分</span></span><br><span class="line"><span class="comment">%      0</span></span><br><span class="line"><span class="comment">%      1</span></span><br><span class="line"><span class="comment">%     -5</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="代码三"><a href="#代码三" class="headerlink" title="代码三"></a>代码三</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 不定积分</span></span><br><span class="line">clear;clc</span><br><span class="line"></span><br><span class="line">syms x</span><br><span class="line">y = x^<span class="number">2</span></span><br><span class="line">int(y,x)</span><br><span class="line"><span class="comment">% x^3/3 注意，Matlab计算时不会给我们加上常数C</span></span><br><span class="line"></span><br><span class="line">syms x</span><br><span class="line">y = <span class="number">1</span>/x</span><br><span class="line">int(y,x)</span><br><span class="line"><span class="comment">% log(x)  注意，Matlab计算1/x形式的不定积分时不会给我们加上绝对值~</span></span><br><span class="line"></span><br><span class="line">syms x</span><br><span class="line">y = x^<span class="number">2</span> / (<span class="number">1</span>+x^<span class="number">2</span>)</span><br><span class="line">int(y,x)</span><br><span class="line"><span class="comment">% x - atan(x)</span></span><br><span class="line"></span><br><span class="line">syms x</span><br><span class="line">y = <span class="number">1</span>/(<span class="built_in">exp</span>(x)+<span class="number">1</span>)</span><br><span class="line">int(y,x)</span><br><span class="line"><span class="comment">% x - log(exp(x) + 1)</span></span><br><span class="line"></span><br><span class="line">syms x a</span><br><span class="line">y = <span class="number">1</span>/<span class="built_in">sqrt</span>(x^<span class="number">2</span>-a^<span class="number">2</span>)</span><br><span class="line">int(y,x)</span><br><span class="line"><span class="comment">% log(x + (x^2 - a^2)^(1/2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 定积分</span></span><br><span class="line">syms x</span><br><span class="line">y = <span class="built_in">sin</span>(x)</span><br><span class="line">int(y,x,<span class="number">0</span>,<span class="built_in">pi</span>/<span class="number">2</span>) </span><br><span class="line"><span class="comment">% 1</span></span><br><span class="line"></span><br><span class="line">syms x a b</span><br><span class="line">y = <span class="built_in">exp</span>(x)</span><br><span class="line">int(y,x,a,b)</span><br><span class="line"><span class="comment">% exp(b) - exp(a)</span></span><br><span class="line"></span><br><span class="line">syms x</span><br><span class="line">y = (<span class="built_in">sin</span>(x))^<span class="number">2</span> / x^<span class="number">2</span></span><br><span class="line">b=int(y,x,<span class="number">0</span>,+<span class="built_in">inf</span>)</span><br><span class="line"><span class="comment">% pi/2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 注意，不是所有的函数都可以利用int函数计算出最后的结果，例如：</span></span><br><span class="line">syms x</span><br><span class="line">y = <span class="number">1</span> / <span class="built_in">exp</span>(x) * <span class="built_in">log</span>(x+<span class="number">2</span>*x^<span class="number">2</span>+<span class="built_in">sin</span>(x))</span><br><span class="line">int(y,x,<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">% int(exp(-x)*log(x + sin(x) + 2*x^2), x, 0, 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 我们可以计算数值积分：数值积分可用于求定积分的近似值。在数值分析中，数值积分是计算定积分数值的方法和理论。</span></span><br><span class="line"><span class="comment">% 在数学分析中，给定函数的定积分的计算不总是可行的，许多定积分不能用已知的积分公式得到精确值。</span></span><br><span class="line">y = @(x) <span class="number">1</span> ./ <span class="built_in">exp</span>(x) .* <span class="built_in">log</span>(x+<span class="number">2.</span>*x.^<span class="number">2</span>+<span class="built_in">sin</span>(x))  <span class="comment">% 注意，写成函数句柄时，要用点乘或者点除</span></span><br><span class="line">integral(y,<span class="number">0</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">xx = <span class="number">0</span>:<span class="number">0.1</span>:<span class="number">4</span>;</span><br><span class="line">yy = <span class="number">1</span> ./ <span class="built_in">exp</span>(xx) .* <span class="built_in">log</span>(xx+<span class="number">2</span>*xx.^<span class="number">2</span>+<span class="built_in">sin</span>(xx));</span><br><span class="line"><span class="built_in">plot</span>(xx,yy,<span class="string">&#x27;-&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="代码四"><a href="#代码四" class="headerlink" title="代码四"></a>代码四</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% matlab求解方程和方程组</span></span><br><span class="line"><span class="comment">% 不同的MATLAB版本之间的语法存在不兼容的情况：https://www.zhihu.com/question/360875116/answer/937256480</span></span><br><span class="line"><span class="comment">% 视频里面用到的是Matlab2017a版本，如果低版本版本可能会报错。</span></span><br><span class="line"><span class="comment">% 更多关于Matlab求方程的介绍可看这个博客：https://blog.csdn.net/weixin_30724853/article/details/99004382</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% solve函数</span></span><br><span class="line"><span class="comment">%% 例题1: 求解单变量方程</span></span><br><span class="line">clear;clc</span><br><span class="line">syms x</span><br><span class="line">answ = solve(<span class="built_in">sin</span>(x) == <span class="number">1</span>, x)  <span class="comment">% 注意：这里的等号一定要有两个，一个等号表示赋值，两个等号才表示左右两边相等</span></span><br><span class="line">answ = solve(<span class="built_in">sin</span>(x) == <span class="number">1</span>)  <span class="comment">% 只有一个符号变量x，所以可以不指定未知数</span></span><br><span class="line"><span class="comment">% 也可以这样写</span></span><br><span class="line">clear;clc</span><br><span class="line">syms x</span><br><span class="line">eqn = (<span class="built_in">sin</span>(x) == <span class="number">1</span>);  <span class="comment">% eqn = sin(x) == 1;  </span></span><br><span class="line">answ = solve(eqn, x)</span><br><span class="line"><span class="comment">% 因为三角函数是周期函数，如果要得到所有的解，则需要加上条件</span></span><br><span class="line">[answ, params, condions] = solve(eqn, x, <span class="string">&#x27;ReturnConditions&#x27;</span>, <span class="built_in">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题2: 多变量方程求解</span></span><br><span class="line">clear;clc</span><br><span class="line">syms a b c x</span><br><span class="line">eqn = (a*x^<span class="number">2</span> + b*x + c == <span class="number">0</span>);</span><br><span class="line">answ1 = solve(eqn, x)  <span class="comment">% 将x视为未知数求解 </span></span><br><span class="line"><span class="comment">%  -(b + (b^2 - 4*a*c)^(1/2))/(2*a)</span></span><br><span class="line"><span class="comment">%  -(b - (b^2 - 4*a*c)^(1/2))/(2*a)</span></span><br><span class="line">answ2 = solve(eqn, a) <span class="comment">% 将a视为未知数求解</span></span><br><span class="line"><span class="comment">% -(c + b*x)/x^2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题3：方程组求解</span></span><br><span class="line">clear;clc</span><br><span class="line">syms u v a</span><br><span class="line">eqn = [<span class="number">2</span>*u + v == a, u - v == <span class="number">1</span>];</span><br><span class="line">answ = solve(eqn, [u, v])</span><br><span class="line">answ.u</span><br><span class="line">answ.v</span><br><span class="line">[answ_u, answ_v] = solve(eqn, [u, v])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% solve 可能会警告</span></span><br><span class="line">syms x</span><br><span class="line">eqn = (<span class="built_in">sin</span>(x) == x^<span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">solve(eqn, x)  <span class="comment">% 警告: Cannot solve symbolically. Returning a numeric approximation instead. </span></span><br><span class="line"><span class="comment">% 画图看看 </span></span><br><span class="line">fplot(<span class="built_in">sin</span>(x), [<span class="number">-2</span> <span class="number">2</span>])  <span class="comment">% fplot函数可绘制表达式的图形</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">fplot(x^<span class="number">2</span> - <span class="number">1</span>, [<span class="number">-2</span> <span class="number">2</span>]) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% vpasolve函数求解</span></span><br><span class="line"><span class="comment">% 用vpasolve函数指定求[0 2]上的解</span></span><br><span class="line">syms x</span><br><span class="line">eqn = <span class="built_in">sin</span>(x) == x^<span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">vpasolve(eqn, x, [<span class="number">0</span> <span class="number">2</span>])</span><br><span class="line">vpasolve(eqn, x, [<span class="number">-1</span> <span class="number">0</span>])</span><br><span class="line">vpasolve(eqn, x, [<span class="number">-10</span> <span class="number">10</span>])</span><br><span class="line"><span class="comment">% vpasolve returns all solutions only for polynomial equations. </span></span><br><span class="line"><span class="comment">% For nonpolynomial equations, there is no general method of finding all solutions.</span></span><br><span class="line"><span class="comment">% When you look for numerical solutions of a nonpolynomial equation or system that has several solutions,</span></span><br><span class="line"><span class="comment">% then, by default, vpasolve returns only one solution, if any. </span></span><br><span class="line"><span class="comment">% To find more than just one solution, set random to true. </span></span><br><span class="line"><span class="comment">% Now, calling vpasolve repeatedly might return several different solutions.</span></span><br><span class="line">vpasolve(eqn, x, <span class="string">&#x27;random&#x27;</span>, <span class="built_in">true</span>) </span><br><span class="line">vpasolve(eqn, x, <span class="number">-5</span>)   <span class="comment">% 给定搜索的起始点</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 来看一个更复杂的例子</span></span><br><span class="line">syms x y</span><br><span class="line">eqn = [x^<span class="number">2</span> - <span class="number">2</span>*x - <span class="number">3</span>*x*y == <span class="number">10</span>, y^<span class="number">4</span> == <span class="built_in">exp</span>(<span class="number">-2</span>*x/<span class="number">3</span>*y)]</span><br><span class="line">[answ_x, answ_y] = vpasolve(eqn, [x, y], <span class="string">&#x27;random&#x27;</span>, <span class="built_in">true</span>)</span><br><span class="line"><span class="comment">% 画图看看</span></span><br><span class="line">ezplot(x^<span class="number">2</span> - <span class="number">2</span>*x - <span class="number">3</span>*x*y == <span class="number">10</span>, [<span class="number">-10</span> <span class="number">10</span>])</span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">ezplot(y^<span class="number">4</span> == <span class="built_in">exp</span>(<span class="number">-2</span>*x/<span class="number">3</span>*y), [<span class="number">-10</span> <span class="number">10</span>])</span><br><span class="line">close <span class="comment">% 关闭图形</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% ezplot函数比较鸡肋，下面这个函数比较厉害哦</span></span><br><span class="line">fimplicit(x^<span class="number">2</span> - <span class="number">2</span>*x - <span class="number">3</span>*x*y == <span class="number">10</span>, [<span class="number">-10</span> <span class="number">10</span>],<span class="string">&#x27;r&#x27;</span>)  <span class="comment">% R2016b版本之后才有</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line">fimplicit(y^<span class="number">4</span> == <span class="built_in">exp</span>(<span class="number">-2</span>*x/<span class="number">3</span>*y), [<span class="number">-10</span> <span class="number">10</span>],<span class="string">&#x27;b&#x27;</span>)  <span class="comment">% R2016b版本之后才有</span></span><br><span class="line">[answ_x, answ_y] = vpasolve(eqn, [x, y],[<span class="number">-4</span> <span class="number">-1</span>;<span class="number">1</span> <span class="number">5</span>])  <span class="comment">% 指定搜索的范围：x位于[-4 -1], y位于[1 5]</span></span><br><span class="line"><span class="built_in">hold</span> on</span><br><span class="line"><span class="built_in">plot</span>(answ_x, answ_y,<span class="string">&#x27;ko&#x27;</span>, <span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">10</span>)   </span><br><span class="line"><span class="comment">% plot(double(answ_x), double(answ_y),&#x27;ko&#x27;, &#x27;MarkerSize&#x27;,10)   % double可以将我们的符号变量转换为数值变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% fsolve函数（求解功能最为强大哦）</span></span><br><span class="line"><span class="comment">% fsolve是Matlab优化工具箱中的一个函数，可专门用来求解特别复杂的方程和方程组</span></span><br><span class="line">x0 = [<span class="number">0</span>,<span class="number">0</span>];  <span class="comment">% 初始值</span></span><br><span class="line">result_x = fsolve(@my_fun,x0)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 当然你也可以用vpasolve函数试试</span></span><br><span class="line">clear; clc</span><br><span class="line">syms x1 x2</span><br><span class="line">eqn =  [<span class="built_in">exp</span>(-<span class="built_in">exp</span>(-(x1+x2))) - x2*(<span class="number">1</span>+x1^<span class="number">2</span>) == <span class="number">0</span>, x1*<span class="built_in">cos</span>(x2) + x2*<span class="built_in">sin</span>(x1) - <span class="number">0.5</span> == <span class="number">0</span>]</span><br><span class="line">[answ_x1, answ_x2] = vpasolve(eqn, [x1, x2], [<span class="number">0</span> <span class="number">0</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span> = <span class="title">my_fun</span><span class="params">(x)</span></span></span><br><span class="line">    F(<span class="number">1</span>) = <span class="built_in">exp</span>(-<span class="built_in">exp</span>(-(x(<span class="number">1</span>)+x(<span class="number">2</span>)))) - x(<span class="number">2</span>)*(<span class="number">1</span>+x(<span class="number">1</span>)^<span class="number">2</span>);</span><br><span class="line">    F(<span class="number">2</span>) = x(<span class="number">1</span>)*<span class="built_in">cos</span>(x(<span class="number">2</span>)) + x(<span class="number">2</span>)*<span class="built_in">sin</span>(x(<span class="number">1</span>)) - <span class="number">0.5</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matlab的三维图绘制</title>
      <link href="/2024/01/29/matlab%E7%9A%84%E4%B8%89%E7%BB%B4%E5%9B%BE%E7%BB%98%E5%88%B6/"/>
      <url>/2024/01/29/matlab%E7%9A%84%E4%B8%89%E7%BB%B4%E5%9B%BE%E7%BB%98%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="matlab的三维图绘制"><a href="#matlab的三维图绘制" class="headerlink" title="matlab的三维图绘制"></a>matlab的三维图绘制</h1><blockquote><p>本章节主要以代码为主</p><p>—–引言</p></blockquote><h2 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% mesh函数：绘制出在某一区间内完整的网格图</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% mesh(X,Y,Z)的用法，其中X是n维向量,Y是m维向量，Z是m*n维的矩阵</span></span><br><span class="line">X = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]</span><br><span class="line">Y = [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">Z = [<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>;<span class="number">5</span>,<span class="number">9</span>,<span class="number">13</span>]</span><br><span class="line">mesh(X,Y,Z)  <span class="comment">% (X(j), Y(i), Z(i,j))是线框网格线的交点的坐标</span></span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line"><span class="comment">% 三维旋转和数据游标的使用，以及X-Y视图的切换（在三维旋转状态下点击鼠标右键）</span></span><br><span class="line"><span class="comment">% 数据游标默认只能添加一个，按住Alt键不动，可以添加多个数据游标</span></span><br><span class="line"><span class="comment">% 插入颜色栏，可显示色阶</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% mesh(Z)的用法，其中Z是m*n维的矩阵</span></span><br><span class="line">Z = [<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>;<span class="number">5</span>,<span class="number">9</span>,<span class="number">13</span>]</span><br><span class="line">mesh(Z)</span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line"><span class="comment">% 等价于</span></span><br><span class="line">X = <span class="number">1</span>:<span class="number">3</span></span><br><span class="line">Y = <span class="number">1</span>:<span class="number">2</span></span><br><span class="line">Z = [<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>;<span class="number">5</span>,<span class="number">9</span>,<span class="number">13</span>]</span><br><span class="line">mesh(X,Y,Z)</span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 思考：如果X中元素不是按照从小到大排序的，图像会是什么样子？</span></span><br><span class="line">X = [<span class="number">1</span>,<span class="number">10</span>,<span class="number">4</span>]</span><br><span class="line">Y = [<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">Z = [<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>;<span class="number">5</span>,<span class="number">9</span>,<span class="number">13</span>]</span><br><span class="line">mesh(X,Y,Z)</span><br><span class="line">hidden off  <span class="comment">% 可以看到背部的图像，不会遮挡（默认是看不到的）</span></span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line"><span class="comment">% 如果觉得背部的图像显示的颜色太深了，可以更改透明度</span></span><br><span class="line">mesh(X,Y,Z)</span><br><span class="line">alpha(<span class="number">0.8</span>)  <span class="comment">% 设置透明度为0.8，这时候隐隐约约能看到（透明度介于0-1之间，越大表示越透明）</span></span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%%  mesh(X,Y,Z)的用法，其中X、Y和Z都是m*n维的矩阵</span></span><br><span class="line">X = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>;<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]   </span><br><span class="line"><span class="comment">%  X = [1,2,4;1,2,5] </span></span><br><span class="line">Y = [<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>;<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]</span><br><span class="line">Z = [<span class="number">4</span>,<span class="number">8</span>,<span class="number">10</span>;<span class="number">5</span>,<span class="number">9</span>,<span class="number">13</span>]</span><br><span class="line">mesh(X,Y,Z) <span class="comment">% (X(i,j), Y(i,j), Z(i,j))是线框网格线的交点的坐标</span></span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题1：绘制 z = x^2 - y^2的图像 ，其中x和y都位于[0,5]之间</span></span><br><span class="line"><span class="comment">% linspace是Matlab中的一个函数，用于产生给定范围内指定数量的点数，相邻数据跨度相同，并返回一个行向量。</span></span><br><span class="line"><span class="comment">% 调用方法：linspace(x1,x2,N)</span></span><br><span class="line"><span class="comment">% 功能：用于产生x1，x2之间的N点行向量，相邻数据跨度相同。其中x1、x2、N分别为起始值、终止值、元素个数。</span></span><br><span class="line">n = <span class="number">11</span>;</span><br><span class="line">tem = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">5</span>,n);  <span class="comment">% 将[0,5]这个区间等分为n个点（等差数列的形式）</span></span><br><span class="line">x = <span class="built_in">repmat</span>(tem,n,<span class="number">1</span>);</span><br><span class="line">y = <span class="built_in">repmat</span>(tem&#x27;,<span class="number">1</span>,n);</span><br><span class="line">z = x.^<span class="number">2</span> - y.^<span class="number">2</span>;    <span class="comment">% 要使用点运算符号哦~</span></span><br><span class="line">mesh(x,y,z)</span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line">axis vis3d <span class="comment">% 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题2： 绘制 z = sin(sqrt(x^2+y^2))/sqrt(x^2+y^2) 的图形，其中x和y都位于[-5,5]之间</span></span><br><span class="line">[x,y] = <span class="built_in">meshgrid</span>(<span class="number">-5</span>:<span class="number">0.5</span>:<span class="number">5</span>);  <span class="comment">% 快速生成网格所需的数据</span></span><br><span class="line">tem = <span class="built_in">sqrt</span>(x.^<span class="number">2</span>+y.^<span class="number">2</span>)+<span class="number">1e-12</span>;   <span class="comment">% tem=sqrt(x.^2+y.^2);   % 在后面加上一个非常非常小的数字： 1e-12 = 10^(-12) ,当然你也可以单独找到值为0的地方对其修改</span></span><br><span class="line">z = <span class="built_in">sin</span>(tem)./tem;  <span class="comment">% 如果不对tem处理，那么z的最中间的一个值 0/0 = NaN</span></span><br><span class="line">mesh(x,y,z)</span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line">axis vis3d <span class="comment">% 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% meshc函数：除了mesh函数图形外，还在xy平面上绘制曲面的等高线</span></span><br><span class="line">meshc(x,y,z)</span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line">axis vis3d <span class="comment">% 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% meshz函数：除了mesh函数图形外，还在xy平面上绘制曲面的底座</span></span><br><span class="line">meshz(x,y,z)</span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line">axis vis3d <span class="comment">% 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>例题一</p><ol><li><p><code>n = 11;</code>: 将变量 <code>n</code> 的值设为11。</p></li><li><p><code>tem = linspace(0,5,n);</code>: 生成一个包含n个在0和5之间等间距点的行向量 <code>tem</code>。函数 <code>linspace</code> 用于创建线性间隔的向量。</p></li><li><p><code>x = repmat(tem,n,1);</code>: 通过在行方向（重复<code>n</code>次）和列方向（重复1次）复制向量 <code>tem</code>，创建矩阵 <code>x</code>。这形成一个矩阵，其中每一行都是向量 <code>tem</code> 的副本。</p></li><li><p><code>y = repmat(tem&#39;,1,n);</code>: 类似于第3行，通过在行方向（重复1次）和列方向（重复<code>n</code>次）复制向量 <code>tem</code> 的转置，创建矩阵 <code>y</code>。这形成一个矩阵，其中每一列都是转置向量 <code>tem</code> 的副本。</p></li><li><p><code>z = x.^2 - y.^2;</code>: 对矩阵 <code>x</code> 和 <code>y</code> 进行逐元素运算。<code>z</code> 的每个元素计算为相应的 <code>x</code> 元素的平方减去相应的 <code>y</code> 元素的平方。</p></li><li><p><code>mesh(x,y,z)</code>: 使用矩阵 <code>x</code>、<code>y</code> 和 <code>z</code> 中的值创建一个3D网格图。这将表示函数 z &#x3D; x^2 - y^2 的曲面图。</p></li><li><p><code>xlabel(&#39;x轴&#39;);  ylabel(&#39;y轴&#39;);  zlabel(&#39;z轴&#39;);</code>: 为图的x轴、y轴和z轴添加标签。</p></li><li><p><code>axis vis3d</code>: 将图的三个维度的纵横比设置为相等，使图在视觉上更加准确。这对于3D图来说尤为重要，以避免失真。</p></li></ol><p>总之，该代码在指定范围内使用由 <code>x</code> 和 <code>y</code> 定义的网格，生成函数 z &#x3D; x^2 - y^2 的3D曲面图。然后，图被标注为x轴、y轴和z轴的标签。</p></blockquote><h2 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% surf函数：绘制出在某一区间内完整的曲面图</span></span><br><span class="line"><span class="comment">% surf函数和mesh函数的的调用格式基本相同</span></span><br><span class="line"><span class="comment">% 两者的区别： mesh绘出彩色的线，surf绘出彩色的面</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题1的对比</span></span><br><span class="line">[x,y] = <span class="built_in">meshgrid</span>(<span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">5</span>,<span class="number">11</span>));</span><br><span class="line"><span class="comment">% [x,y] = meshgrid([0:0.5:5]);  或者直接写成[x,y] = meshgrid(0:0.5:5);</span></span><br><span class="line">z = x.^<span class="number">2</span> - y.^<span class="number">2</span>;</span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)  <span class="comment">% subplot(m,n,index)</span></span><br><span class="line">mesh(x,y,z)</span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line">axis vis3d <span class="comment">% 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line">title(<span class="string">&#x27;mesh(x,y,z)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">surf(x,y,z)  </span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line">axis vis3d <span class="comment">% 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line"><span class="comment">% axis([0,5,0,5,-inf,+inf])  % 设置坐标轴刻度范围</span></span><br><span class="line">title(<span class="string">&#x27;surf(x,y,z)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题2的对比</span></span><br><span class="line">[x,y] = <span class="built_in">meshgrid</span>(<span class="number">-5</span>:<span class="number">0.5</span>:<span class="number">5</span>);  <span class="comment">% 快速生成网格所需的数据</span></span><br><span class="line">tem = <span class="built_in">sqrt</span>(x.^<span class="number">2</span>+y.^<span class="number">2</span>)+<span class="number">1e-12</span>;   </span><br><span class="line">z = <span class="built_in">sin</span>(tem)./tem;  <span class="comment">% 如果不对tem处理，那么z的最中间的一个值 0/0 = NaN</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">mesh(x,y,z)</span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line">axis vis3d <span class="comment">% 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line">title(<span class="string">&#x27;mesh(x,y,z)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">surf(x,y,z)  <span class="comment">% (X(j), Y(i), Z(i,j))是线框网格线的交点</span></span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line">axis vis3d <span class="comment">% 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line">title(<span class="string">&#x27;surf(x,y,z)&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% surfc函数：除了surf函数图形外，还在xy平面上绘制曲面的等高线</span></span><br><span class="line">surfc(x,y,z)</span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line">axis vis3d <span class="comment">% 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% surfl函数：加上了灯光效果,看起来自然点</span></span><br><span class="line">surfl(x,y,z)</span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line">axis vis3d <span class="comment">% 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 设置色彩模式</span></span><br><span class="line"><span class="comment">% shading 是用来处理色彩效果的，分以下三种：</span></span><br><span class="line"><span class="comment">% shading faceted是默认的模式 </span></span><br><span class="line"><span class="comment">% shading flat 在faceted的基础上去掉图上的网格线</span></span><br><span class="line"><span class="comment">% shading interp 在flat的基础上进行色彩的插值处理，使色彩平滑过渡</span></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">surf(x,y,z)  <span class="comment">% (X(j), Y(i), Z(i,j))是线框网格线的交点</span></span><br><span class="line">shading faceted <span class="comment">% 默认的色彩模式</span></span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line">axis vis3d <span class="comment">% 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line">title(<span class="string">&#x27;shading faceted&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">surf(x,y,z)  <span class="comment">% (X(j), Y(i), Z(i,j))是线框网格线的交点</span></span><br><span class="line">shading flat <span class="comment">% 看起来光滑一点</span></span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line">axis vis3d <span class="comment">% 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line">title(<span class="string">&#x27;shading flat&#x27;</span>)</span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">surf(x,y,z)  <span class="comment">% (X(j), Y(i), Z(i,j))是线框网格线的交点</span></span><br><span class="line">shading interp <span class="comment">% 看起来最光滑</span></span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line">axis vis3d <span class="comment">% 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line">title(<span class="string">&#x27;shading interp&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p><code>subplot(m, n, index)</code> 是 MATLAB 中用于创建多个子图的函数，其中：</p><ul><li><code>m</code> 表示子图布局的行数（即总行数）。</li><li><code>n</code> 表示子图布局的列数（即总列数）。</li><li><code>index</code> 表示当前子图的索引，从左上角开始按行从左到右的顺序编号。</li></ul><p>在你提供的例子中，<code>subplot(1,2,1)</code> 表示将当前图形划分为1行2列的子图布局，并且当前绘图将位于第1个（左侧）子图位置。这意味着在当前图形中，你可以绘制两个子图，而当前命令将设置绘图环境为左侧的第一个子图，以便在此子图中进行绘图。</p><p>例如，你可以使用以下代码在两个子图中绘制不同的图形：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">% 在第一个子图中绘制图形</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">% 在第二个子图中绘制另一个图形</span></span><br></pre></td></tr></table></figure><p>这样可以方便地将多个相关的图形进行比较，而不必为每个图形创建一个新的图形窗口。</p></blockquote><h2 id="代码三"><a href="#代码三" class="headerlink" title="代码三"></a>代码三</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% contour函数: 绘制等高线图</span></span><br><span class="line"></span><br><span class="line">[x,y] = <span class="built_in">meshgrid</span>(<span class="number">-3</span>:<span class="number">0.1</span>:<span class="number">3</span>);  </span><br><span class="line"><span class="comment">% 一个语句太长时，可以加上三个点然后在下一行继续写</span></span><br><span class="line">z =  <span class="number">3</span>*(<span class="number">1</span>-x).^<span class="number">2.</span>*<span class="built_in">exp</span>(-(x.^<span class="number">2</span>) - (y+<span class="number">1</span>).^<span class="number">2</span>)...  </span><br><span class="line">    <span class="number">-10</span>* (x/<span class="number">5</span> - x.^<span class="number">3</span> - y.^<span class="number">5</span>).*<span class="built_in">exp</span>(-x.^<span class="number">2</span>-y.^<span class="number">2</span>) ...</span><br><span class="line">    - <span class="number">1</span>/<span class="number">3</span>*<span class="built_in">exp</span>(-(x+<span class="number">1</span>).^<span class="number">2</span> - y.^<span class="number">2</span>);  <span class="comment">% matlab中内置的peaks函数，常常作为演示使用</span></span><br><span class="line"><span class="comment">% edit peaks</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% contour(x,y,z) 在x-y平面绘制等高线图，Matlab会自动选择等高线的层级</span></span><br><span class="line">contour(x,y,z)</span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% contour(x,y,z,n) 在x-y平面绘制等高线图，n是一个标量，那么Matlab会将等高线的层数设置为n，且会自动选择层所在的高度。</span></span><br><span class="line">contour(x,y,z,<span class="number">5</span>)</span><br><span class="line">contour(x,y,z,<span class="number">5</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>)  <span class="comment">% 设置线的宽度为2</span></span><br><span class="line">contour(x,y,z,<span class="number">5</span>,<span class="string">&#x27;--&#x27;</span>)  <span class="comment">% 设置等高线为虚线</span></span><br><span class="line">contour(x,y,z,<span class="number">5</span>,<span class="string">&#x27;ShowText&#x27;</span>,<span class="string">&#x27;on&#x27;</span>)  <span class="comment">% 显示每一层的高度</span></span><br><span class="line">contour(x,y,z,<span class="number">5</span>,<span class="string">&#x27;--&#x27;</span>,<span class="string">&#x27;ShowText&#x27;</span>,<span class="string">&#x27;on&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">2</span>)  <span class="comment">% 可以组合起来使用</span></span><br><span class="line">colorbar <span class="comment">% 显示颜色栏，也可以手动插入</span></span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% contour(x,y,z,levels) 若想得到固定的n个高度的等高线，将levels可以设置为n元行向量，其中向量中的值为高度值。</span></span><br><span class="line">maxz = <span class="built_in">max</span>(<span class="built_in">max</span>(z))</span><br><span class="line">minz = <span class="built_in">min</span>(<span class="built_in">min</span>(z))</span><br><span class="line">levels = <span class="built_in">linspace</span>(minz,maxz,<span class="number">10</span>)  <span class="comment">% 从最小值到最大值，等分成10个点</span></span><br><span class="line">contour(x,y,z,levels,<span class="string">&#x27;ShowText&#x27;</span>,<span class="string">&#x27;on&#x27;</span>,<span class="string">&#x27;LineWidth&#x27;</span>,<span class="number">1</span>)  <span class="comment">% 最小值或者最大值可能显示不出来，因为Matlab会帮我们自动调整</span></span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 思考如果只想画出高度为3的单等高线怎么办?</span></span><br><span class="line">contour(x,y,z,[<span class="number">3</span> <span class="number">3</span>],<span class="string">&#x27;ShowText&#x27;</span>,<span class="string">&#x27;on&#x27;</span>) </span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% contourf函数：和contour函数类似，只不过画出来的等高线图有颜色填充</span></span><br><span class="line">contourf(x,y,z,levels,<span class="string">&#x27;ShowText&#x27;</span>,<span class="string">&#x27;on&#x27;</span>) </span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% contour3函数：3维等高线图，等高线不再投影到x-y平面</span></span><br><span class="line">contour3(x,y,z,levels,<span class="string">&#x27;ShowText&#x27;</span>,<span class="string">&#x27;on&#x27;</span>) </span><br><span class="line">xlabel(<span class="string">&#x27;x轴&#x27;</span>);  ylabel(<span class="string">&#x27;y轴&#x27;</span>);  zlabel(<span class="string">&#x27;z轴&#x27;</span>);  <span class="comment">% 加上坐标轴的标签</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="代码四"><a href="#代码四" class="headerlink" title="代码四"></a>代码四</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 符号函数的三维图形绘制</span></span><br><span class="line">clear;clc</span><br><span class="line"></span><br><span class="line"><span class="comment">%% plot3函数 (类似于plot函数，实际上可以认为画的是三维空间下的折线图）</span></span><br><span class="line"><span class="comment">% t = 0: 0.1: 4*pi;   % 符号是t，t从0变动到4pi，间隔设置为0.1</span></span><br><span class="line">t = <span class="built_in">linspace</span>(<span class="number">0</span>,<span class="number">4</span>*<span class="built_in">pi</span>,<span class="number">100</span>);  <span class="comment">% 符号是t，t从0变动到4pi，等分为100个点</span></span><br><span class="line">x = <span class="built_in">sin</span>(t)+<span class="number">1</span>; <span class="comment">% 利用t计算x的值</span></span><br><span class="line">y = <span class="built_in">cos</span>(t);  <span class="comment">% 利用t计算y的值</span></span><br><span class="line">z = t; <span class="comment">% 利用t计算z的值</span></span><br><span class="line"><span class="built_in">plot3</span>(x,y,z)  <span class="comment">% 绘制三维空间下的折线图</span></span><br><span class="line"><span class="built_in">plot3</span>(x,y,z,<span class="string">&#x27;r--&#x27;</span>) </span><br><span class="line"><span class="comment">% close  % 关闭图形</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% fplot3函数 (2016a版本推出的函数，老版本Matlab用的是ezplot3函数，未来版本可能会被淘汰）</span></span><br><span class="line">syms t  <span class="comment">% 符号是t</span></span><br><span class="line">x = <span class="built_in">sin</span>(t)+<span class="number">1</span>;</span><br><span class="line">y = <span class="built_in">cos</span>(t); </span><br><span class="line">z = t;</span><br><span class="line">fplot3(x,y,z) <span class="comment">% 默认t的变化范围为[-5 5]</span></span><br><span class="line">fplot3(x,y,z,[<span class="number">0</span> <span class="number">4</span>*<span class="built_in">pi</span>]) <span class="comment">% 修改t的变化范围为0至4pi</span></span><br><span class="line"><span class="comment">% close  % 关闭图形</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% fmesh 三维网格图 (2016a版本推出的函数，老版本Matlab用的是ezmesh函数，未来版本可能会被淘汰）</span></span><br><span class="line">syms x y </span><br><span class="line">z=x^<span class="number">2</span>+y^<span class="number">2</span>;</span><br><span class="line">fmesh(z) <span class="comment">% 默认x的变化范围和y的变化范围都是[-5 5]</span></span><br><span class="line">fmesh(z,[<span class="number">-2</span> <span class="number">2</span> <span class="number">-4</span> <span class="number">4</span>]) <span class="comment">% 修改x的变化范围和y的变化范围分别为[-2 2]和[-4 4]</span></span><br><span class="line"><span class="comment">% axis vis3d  % 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line"><span class="comment">% axis equal  % 设置屏幕高宽比，使得每个坐标轴的具有均匀的刻度间隔</span></span><br><span class="line">fmesh(z,[<span class="number">-2</span> <span class="number">2</span> <span class="number">-4</span> <span class="number">4</span>],<span class="string">&#x27;MeshDensity&#x27;</span>,<span class="number">11</span>)   <span class="comment">% 设置每个方向计算的点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 画一朵花花送给亲爱的Ta</span></span><br><span class="line">syms u v</span><br><span class="line">r = <span class="number">2</span> + <span class="built_in">sin</span>(<span class="number">7.</span>*u + <span class="number">5.</span>*v);</span><br><span class="line">x = r.*<span class="built_in">cos</span>(u).*<span class="built_in">sin</span>(v);</span><br><span class="line">y = r.*<span class="built_in">sin</span>(u).*<span class="built_in">sin</span>(v);</span><br><span class="line">z = r.*<span class="built_in">cos</span>(v);</span><br><span class="line"><span class="comment">% 可以直接用乘号</span></span><br><span class="line"><span class="comment">% r = 2 + sin(7*u + 5*v);</span></span><br><span class="line"><span class="comment">% x = r*cos(u)*sin(v);</span></span><br><span class="line"><span class="comment">% y = r*sin(u)*sin(v);</span></span><br><span class="line"><span class="comment">% z = r*cos(v);</span></span><br><span class="line">fmesh(x,y,z,[<span class="number">0</span> <span class="number">2</span>*<span class="built_in">pi</span> <span class="number">0</span> <span class="built_in">pi</span>])</span><br><span class="line">alpha(<span class="number">0.8</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% fsurf 三维曲面图 (2016a版本推出的函数，老版本Matlab用的是ezsurf函数，未来版本可能会被淘汰）</span></span><br><span class="line">syms x y </span><br><span class="line">z=x^<span class="number">2</span>+y^<span class="number">2</span>;</span><br><span class="line">fsurf(z) <span class="comment">% 默认x的变化范围和y的变化范围都是[-5 5]</span></span><br><span class="line">fsurf(z,[<span class="number">-2</span> <span class="number">2</span> <span class="number">-4</span> <span class="number">4</span>]) <span class="comment">% 修改x的变化范围和y的变化范围分别为[-2 2]和[-4 4]</span></span><br><span class="line"><span class="comment">% axis vis3d  % 冻结屏幕高宽比，使得一个三维对象的旋转不会改变坐标轴的刻度显示</span></span><br><span class="line"><span class="comment">% axis equal  % 设置屏幕高宽比，使得每个坐标轴的具有均匀的刻度间隔</span></span><br><span class="line">fsurf(z,[<span class="number">-2</span> <span class="number">2</span> <span class="number">-4</span> <span class="number">4</span>],<span class="string">&#x27;MeshDensity&#x27;</span>,<span class="number">11</span>)   <span class="comment">% 设置每个方向计算的点数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 画一朵花花送给亲爱的Ta</span></span><br><span class="line">syms u v</span><br><span class="line">r = <span class="number">2</span> + <span class="built_in">sin</span>(<span class="number">7.</span>*u + <span class="number">5.</span>*v);</span><br><span class="line">x = r.*<span class="built_in">cos</span>(u).*<span class="built_in">sin</span>(v);</span><br><span class="line">y = r.*<span class="built_in">sin</span>(u).*<span class="built_in">sin</span>(v);</span><br><span class="line">z = r.*<span class="built_in">cos</span>(v);</span><br><span class="line">fsurf(x,y,z,[<span class="number">0</span> <span class="number">2</span>*<span class="built_in">pi</span> <span class="number">0</span> <span class="built_in">pi</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">%% fcontour 绘制等高线 (2016a版本推出的函数，老版本Matlab用的是ezcontour函数，未来版本可能会被淘汰）</span></span><br><span class="line">syms x y </span><br><span class="line">z=x^<span class="number">2</span>+y^<span class="number">2</span>;</span><br><span class="line">fcontour(z) <span class="comment">% 默认x的变化范围和y的变化范围都是[-5 5]</span></span><br><span class="line">fcontour(z,[<span class="number">-2</span> <span class="number">2</span> <span class="number">-4</span> <span class="number">4</span>]) <span class="comment">% 修改x的变化范围和y的变化范围分别为[-2 2]和[-4 4]</span></span><br><span class="line">fcontour(z,<span class="string">&#x27;fill&#x27;</span>,<span class="string">&#x27;on&#x27;</span>) <span class="comment">% 在等高线线条间进行填充</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《青春简章》第二章</title>
      <link href="/2024/01/29/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/"/>
      <url>/2024/01/29/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第二章-中考后"><a href="#第二章-中考后" class="headerlink" title="第二章.中考后"></a>第二章.中考后</h1><blockquote><p>“为你唱这首歌”</p><p>“没有什么风格”</p><p>“它仅仅代表着”</p><p>“我想给你快乐”</p><p>三年前的夏天某日，不是宫崎骏动漫那样如诗如画，令人陶醉，太阳火辣，三四十度的天也是持续不断，即使是热衷于鸣叫的夏日使者似乎也感到疲倦，只在夜间尽力的演奏着一曲又一曲。</p><p>刚考完中考的苏瑾一身白衣拿着心爱的吉他弹奏，身材高瘦，细碎的额发半掩着眉毛，一双明澈的眼眸闪烁着光芒，脸部虽谈不上很帅气，但足够整洁干净，写满阳光，耳旁插着耳机，循环播放着周杰伦，许嵩，陶喆的音乐，尽情享受着中考后的宁静与欢愉。</p><p>出生在广东省一个落后地区沿海小镇的苏瑾，是一个普通的不能再普通的少年，不是天才儿童，既没有傲人的智商，也没几岁就报送某某大学的才华，对学业处于一个还算上心，能及时完成作业，取得一个较为可观的成绩，在年级还算前列的的状态。</p><p>至于生活，那可以说是白痴级别，对于认路那是一窍不通，去个十几次，恐怕还是会迷路，反应慢半拍也是常态，厨艺也仅仅掌握基本的蛋炒饭和煮一碗冒着热气的面，有时甚至还会忘记放盐，等到真正吃的时候再补上那么半勺，这时候往往又太咸了，少不了被老妈数落一顿呆子。</p><p>说起爱好，对音乐从小有兴趣的他，自学了一手吉他，弹得一手小曲，平常也喜欢唱歌，时而在洗澡或是兴致来时小声哼唱，纯当是闲暇时的爱好。</p><p>当然也有几个要好的朋友，拥有一些相同的兴趣爱好，也各有特点，谈不上指点江山，激扬文字，但也无话不谈，时常畅想未来，幻想能穿越某个时间段去挽回曾经的遗憾，又或是来到异世界大杀四方，但生活嘛，仍旧平凡，该怎么样就怎么样。</p><p>“叮咚”，手机的铃声响起，：“四点出来打球啊，都放假了，怎么还在宅家，”“奸笑”“奸笑”</p><p>苏瑾打开QQ，原来是是叶杨啊，这家伙可不得了，身材与苏瑾相似，一样高瘦，眉宇间透着一股难以掩饰的书卷之气，时常佩戴一副方形黑框眼镜，年级传说是也，次次霸榜年级第二，久居不下，至于第一，总是被一个女生占着，因此他也总是被调侃为万年老二，但其实人也不是那种一心只读圣贤书的书呆子，其人有些闷骚，酷爱篮球，二人也由一场球结识。</p><p>“确实中考后好久没打球了，就随你走一波“，苏瑾摘下耳机，下意识撩起头发喃喃自语道。</p><p>苏瑾打开聊天框飞速敲打着手机，“好嘞，顾青，慕白他们就交给你去叫了，待会见”，随即关闭手机，向卧室走去。</p><p>卧室，一只浑身雪白的猫从窗边懒洋洋起身，腰背拱起像一座小桥，长长打了个哈欠，随后从一米的窗台跳下，来到正在整理运动装的苏瑾面前，看着眼前的少年。</p><p>“格格米，过来”，</p><p>“喵呜，喵呜”</p><p>初三时候，一个下雨天，苏瑾在回家街道旁看到这只猫，毛发湿透，附着了一层灰尘，身体在淅淅沥沥的雨中瑟瑟发抖，发出“喵呜喵呜”的哀鸣，苏瑾觉得猫在那里淋雨，还不清楚有没有食物，心里一阵难受，便把它带回家。</p><p>可喜的是，苏瑾的家人并不排斥这只猫，反而被它的可爱慵懒所吸引，细心给它洗澡，并把当晚新鲜的鱼肉喂给它吃，给它起名叫格格米。这一洗，一喂，一声格格米就是一年，并且在不远的将永远陪伴着。</p><p>苏瑾将格格米抱起，猫咪也懂事的低下头，用它毛绒绒的脑袋轻轻的蹭苏瑾的胸口，享受着羽毛被抚摸的舒坦。</p><p>“格格米好好在家哈，我去打球了”</p><p>身着浅灰色衬衫，黑色短裤的苏瑾将猫咪轻轻放下，高举起手摆了摆，顺手拿起放在桌子上的车钥匙，小跑出了门，锁了门后开车向打篮球的秘密基地行驶而去。</p><p>究竟什么能代表青春呢，或许是十六岁少年奔跑时所引起的阵阵微风和开车时随风而飘的些许发丝吧。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>诗兴大发</title>
      <link href="/2024/01/29/%E8%AF%97%E5%85%B4%E5%A4%A7%E5%8F%91/"/>
      <url>/2024/01/29/%E8%AF%97%E5%85%B4%E5%A4%A7%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote><p>一时兴起，诗兴大发，与一友人共创《彩梦》《辰吟》诗篇10首，其余诗篇若干，词若干，姑且收录。</p></blockquote><h1 id="养生辰吟"><a href="#养生辰吟" class="headerlink" title="养生辰吟"></a>养生辰吟</h1><h3 id="早岁哪知养生重，"><a href="#早岁哪知养生重，" class="headerlink" title="早岁哪知养生重，"></a>早岁哪知养生重，</h3><h3 id="神散体衰悔不已。"><a href="#神散体衰悔不已。" class="headerlink" title="神散体衰悔不已。"></a>神散体衰悔不已。</h3><h3 id="庖丁解牛人人知，"><a href="#庖丁解牛人人知，" class="headerlink" title="庖丁解牛人人知，"></a>庖丁解牛人人知，</h3><h3 id="沉心养性安乐本。"><a href="#沉心养性安乐本。" class="headerlink" title="沉心养性安乐本。"></a>沉心养性安乐本。</h3><h1 id="读书彩梦"><a href="#读书彩梦" class="headerlink" title="读书彩梦"></a>读书彩梦</h1><h3 id="红袖添香常作伴，"><a href="#红袖添香常作伴，" class="headerlink" title="红袖添香常作伴，"></a>红袖添香常作伴，</h3><h3 id="坐怀不乱读书高。"><a href="#坐怀不乱读书高。" class="headerlink" title="坐怀不乱读书高。"></a>坐怀不乱读书高。</h3><h3 id="纵名未显心微暗，"><a href="#纵名未显心微暗，" class="headerlink" title="纵名未显心微暗，"></a>纵名未显心微暗，</h3><h3 id="只把孔孟作西昭。"><a href="#只把孔孟作西昭。" class="headerlink" title="只把孔孟作西昭。"></a>只把孔孟作西昭。</h3><h1 id="病痛辰吟"><a href="#病痛辰吟" class="headerlink" title="病痛辰吟"></a>病痛辰吟</h1><h3 id="病骨犹离人世间，"><a href="#病骨犹离人世间，" class="headerlink" title="病骨犹离人世间，"></a>病骨犹离人世间，</h3><h3 id="欲寝似梦夜难眠。"><a href="#欲寝似梦夜难眠。" class="headerlink" title="欲寝似梦夜难眠。"></a>欲寝似梦夜难眠。</h3><h3 id="生非容易死非甘，"><a href="#生非容易死非甘，" class="headerlink" title="生非容易死非甘，"></a>生非容易死非甘，</h3><h3 id="与我共听万古鸣。"><a href="#与我共听万古鸣。" class="headerlink" title="与我共听万古鸣。"></a>与我共听万古鸣。</h3><h1 id="清明辰吟"><a href="#清明辰吟" class="headerlink" title="清明辰吟"></a>清明辰吟</h1><h3 id="春去夏来不胜寒，"><a href="#春去夏来不胜寒，" class="headerlink" title="春去夏来不胜寒，"></a>春去夏来不胜寒，</h3><h3 id="东镜西放难遗忘。"><a href="#东镜西放难遗忘。" class="headerlink" title="东镜西放难遗忘。"></a>东镜西放难遗忘。</h3><h3 id="又是一年清明时，"><a href="#又是一年清明时，" class="headerlink" title="又是一年清明时，"></a>又是一年清明时，</h3><h3 id="归来仍问何处放。"><a href="#归来仍问何处放。" class="headerlink" title="归来仍问何处放。"></a>归来仍问何处放。</h3><h1 id="强国彩梦"><a href="#强国彩梦" class="headerlink" title="强国彩梦"></a>强国彩梦</h1><h3 id="梦回禹杭观红舫，"><a href="#梦回禹杭观红舫，" class="headerlink" title="梦回禹杭观红舫，"></a>梦回禹杭观红舫，</h3><h3 id="铭记微末成立党。"><a href="#铭记微末成立党。" class="headerlink" title="铭记微末成立党。"></a>铭记微末成立党。</h3><h3 id="放翁莫悲九州离，"><a href="#放翁莫悲九州离，" class="headerlink" title="放翁莫悲九州离，"></a>放翁莫悲九州离，</h3><h3 id="尔愿已为万人同。"><a href="#尔愿已为万人同。" class="headerlink" title="尔愿已为万人同。"></a>尔愿已为万人同。</h3><h1 id="向佛辰吟"><a href="#向佛辰吟" class="headerlink" title="向佛辰吟"></a>向佛辰吟</h1><h3 id="红尘旧梦念成空，"><a href="#红尘旧梦念成空，" class="headerlink" title="红尘旧梦念成空，"></a>红尘旧梦念成空，</h3><h3 id="自心不乱明镜台。"><a href="#自心不乱明镜台。" class="headerlink" title="自心不乱明镜台。"></a>自心不乱明镜台。</h3><h3 id="赏菊超然凡世外，"><a href="#赏菊超然凡世外，" class="headerlink" title="赏菊超然凡世外，"></a>赏菊超然凡世外，</h3><h3 id="不落红尘惹尘埃。"><a href="#不落红尘惹尘埃。" class="headerlink" title="不落红尘惹尘埃。"></a>不落红尘惹尘埃。</h3><h1 id="王者彩梦"><a href="#王者彩梦" class="headerlink" title="王者彩梦"></a>王者彩梦</h1><h3 id="漫漫七载王者路，"><a href="#漫漫七载王者路，" class="headerlink" title="漫漫七载王者路，"></a>漫漫七载王者路，</h3><h3 id="二十七次历死生。"><a href="#二十七次历死生。" class="headerlink" title="二十七次历死生。"></a>二十七次历死生。</h3><h3 id="笑叹满屏黑星布，"><a href="#笑叹满屏黑星布，" class="headerlink" title="笑叹满屏黑星布，"></a>笑叹满屏黑星布，</h3><h3 id="雄关长途犹可攀。"><a href="#雄关长途犹可攀。" class="headerlink" title="雄关长途犹可攀。"></a>雄关长途犹可攀。</h3><h1 id="夏日辰吟"><a href="#夏日辰吟" class="headerlink" title="夏日辰吟"></a>夏日辰吟</h1><h3 id="风起蝉鸣觉夏至，"><a href="#风起蝉鸣觉夏至，" class="headerlink" title="风起蝉鸣觉夏至，"></a>风起蝉鸣觉夏至，</h3><h3 id="红日覆天徒出浆。"><a href="#红日覆天徒出浆。" class="headerlink" title="红日覆天徒出浆。"></a>红日覆天徒出浆。</h3><h3 id="酉四归家天犹湛，"><a href="#酉四归家天犹湛，" class="headerlink" title="酉四归家天犹湛，"></a>酉四归家天犹湛，</h3><h3 id="昏黑欲寝蚊声雷。"><a href="#昏黑欲寝蚊声雷。" class="headerlink" title="昏黑欲寝蚊声雷。"></a>昏黑欲寝蚊声雷。</h3><h1 id="观景彩梦"><a href="#观景彩梦" class="headerlink" title="观景彩梦"></a>观景彩梦</h1><h3 id="随风入景见南山，"><a href="#随风入景见南山，" class="headerlink" title="随风入景见南山，"></a>随风入景见南山，</h3><h3 id="浮云掩盖盘龙旋。"><a href="#浮云掩盖盘龙旋。" class="headerlink" title="浮云掩盖盘龙旋。"></a>浮云掩盖盘龙旋。</h3><h3 id="独揽夜下萤火红，"><a href="#独揽夜下萤火红，" class="headerlink" title="独揽夜下萤火红，"></a>独揽夜下萤火红，</h3><h3 id="自然天成余幽静。"><a href="#自然天成余幽静。" class="headerlink" title="自然天成余幽静。"></a>自然天成余幽静。</h3><h1 id="励志彩梦"><a href="#励志彩梦" class="headerlink" title="励志彩梦"></a>励志彩梦</h1><h3 id="浮沉江湖疾风起，"><a href="#浮沉江湖疾风起，" class="headerlink" title="浮沉江湖疾风起，"></a>浮沉江湖疾风起，</h3><h3 id="壮心步坚战荆棘。"><a href="#壮心步坚战荆棘。" class="headerlink" title="壮心步坚战荆棘。"></a>壮心步坚战荆棘。</h3><h3 id="人生本是一纸白，"><a href="#人生本是一纸白，" class="headerlink" title="人生本是一纸白，"></a>人生本是一纸白，</h3><h3 id="纵使微末亦多彩。"><a href="#纵使微末亦多彩。" class="headerlink" title="纵使微末亦多彩。"></a>纵使微末亦多彩。</h3><h1 id="五一夏露"><a href="#五一夏露" class="headerlink" title="五一夏露"></a>五一夏露</h1><h3 id="久未见甘露，"><a href="#久未见甘露，" class="headerlink" title="久未见甘露，"></a>久未见甘露，</h3><h3 id="闲来宅家寒。"><a href="#闲来宅家寒。" class="headerlink" title="闲来宅家寒。"></a>闲来宅家寒。</h3><h3 id="寂寥盲耳目，"><a href="#寂寥盲耳目，" class="headerlink" title="寂寥盲耳目，"></a>寂寥盲耳目，</h3><h3 id="待坐心茫然。"><a href="#待坐心茫然。" class="headerlink" title="待坐心茫然。"></a>待坐心茫然。</h3><h1 id="仗剑走天涯"><a href="#仗剑走天涯" class="headerlink" title="仗剑走天涯"></a>仗剑走天涯</h1><h3 id="少年持一剑，"><a href="#少年持一剑，" class="headerlink" title="少年持一剑，"></a>少年持一剑，</h3><h3 id="逍遥走四方。"><a href="#逍遥走四方。" class="headerlink" title="逍遥走四方。"></a>逍遥走四方。</h3><h3 id="虽前路漫漫，"><a href="#虽前路漫漫，" class="headerlink" title="虽前路漫漫，"></a>虽前路漫漫，</h3><h3 id="但走是最好。"><a href="#但走是最好。" class="headerlink" title="但走是最好。"></a>但走是最好。</h3><h1 id="少年侠气"><a href="#少年侠气" class="headerlink" title="少年侠气"></a>少年侠气</h1><h3 id="少年有侠气，"><a href="#少年有侠气，" class="headerlink" title="少年有侠气，"></a>少年有侠气，</h3><h3 id="发耸为不平。"><a href="#发耸为不平。" class="headerlink" title="发耸为不平。"></a>发耸为不平。</h3><h3 id="一诺千金重，"><a href="#一诺千金重，" class="headerlink" title="一诺千金重，"></a>一诺千金重，</h3><h3 id="死生亦殊同。"><a href="#死生亦殊同。" class="headerlink" title="死生亦殊同。"></a>死生亦殊同。</h3><h1 id="六月七日观高考有感而作"><a href="#六月七日观高考有感而作" class="headerlink" title="六月七日观高考有感而作"></a>六月七日观高考有感而作</h1><h3 id="呼呼山雨窗外闹，"><a href="#呼呼山雨窗外闹，" class="headerlink" title="呼呼山雨窗外闹，"></a>呼呼山雨窗外闹，</h3><h3 id="潺潺细水街上漾。"><a href="#潺潺细水街上漾。" class="headerlink" title="潺潺细水街上漾。"></a>潺潺细水街上漾。</h3><h3 id="万家夜灯璀似曜，"><a href="#万家夜灯璀似曜，" class="headerlink" title="万家夜灯璀似曜，"></a>万家夜灯璀似曜，</h3><h3 id="未眠已是泪满霜。"><a href="#未眠已是泪满霜。" class="headerlink" title="未眠已是泪满霜。"></a>未眠已是泪满霜。</h3><h3 id="挥毫纸上迅灵妙，"><a href="#挥毫纸上迅灵妙，" class="headerlink" title="挥毫纸上迅灵妙，"></a>挥毫纸上迅灵妙，</h3><h3 id="灯灭梦中一草房。"><a href="#灯灭梦中一草房。" class="headerlink" title="灯灭梦中一草房。"></a>灯灭梦中一草房。</h3><h3 id="十载寒窗靡有朝，"><a href="#十载寒窗靡有朝，" class="headerlink" title="十载寒窗靡有朝，"></a>十载寒窗靡有朝，</h3><h3 id="书生意气貼金榜。"><a href="#书生意气貼金榜。" class="headerlink" title="书生意气貼金榜。"></a>书生意气貼金榜。</h3><h1 id="六月七日观高考有感而作-1"><a href="#六月七日观高考有感而作-1" class="headerlink" title="六月七日观高考有感而作"></a>六月七日观高考有感而作</h1><h3 id="晨光熹微，鸣鸡休憩，淅淅沥沥，万家灯火依如故。"><a href="#晨光熹微，鸣鸡休憩，淅淅沥沥，万家灯火依如故。" class="headerlink" title="晨光熹微，鸣鸡休憩，淅淅沥沥，万家灯火依如故。"></a>晨光熹微，鸣鸡休憩，淅淅沥沥，万家灯火依如故。</h3><h3 id="重云如盖，摩肩擦踵，希冀成光，千山万水只一步。"><a href="#重云如盖，摩肩擦踵，希冀成光，千山万水只一步。" class="headerlink" title="重云如盖，摩肩擦踵，希冀成光，千山万水只一步。"></a>重云如盖，摩肩擦踵，希冀成光，千山万水只一步。</h3><h3 id="疾风骤雨，紧锣密鼓，愁眉匪懈，执笔画墨终不悔。"><a href="#疾风骤雨，紧锣密鼓，愁眉匪懈，执笔画墨终不悔。" class="headerlink" title="疾风骤雨，紧锣密鼓，愁眉匪懈，执笔画墨终不悔。"></a>疾风骤雨，紧锣密鼓，愁眉匪懈，执笔画墨终不悔。</h3><h3 id="云雾拨开，响声清越，昂手阔步，有人欢喜有人愁。"><a href="#云雾拨开，响声清越，昂手阔步，有人欢喜有人愁。" class="headerlink" title="云雾拨开，响声清越，昂手阔步，有人欢喜有人愁。"></a>云雾拨开，响声清越，昂手阔步，有人欢喜有人愁。</h3><h3 id="十年寒窗苦读日，一朝尽撒书生气，洋洋洒洒千百字，-举首戴目金榜时。"><a href="#十年寒窗苦读日，一朝尽撒书生气，洋洋洒洒千百字，-举首戴目金榜时。" class="headerlink" title="十年寒窗苦读日，一朝尽撒书生气，洋洋洒洒千百字， 举首戴目金榜时。"></a>十年寒窗苦读日，一朝尽撒书生气，洋洋洒洒千百字， 举首戴目金榜时。</h3><h1 id="纪龙山一日游六月十六日"><a href="#纪龙山一日游六月十六日" class="headerlink" title="纪龙山一日游六月十六日"></a>纪龙山一日游六月十六日</h1><h3 id="因试逗留龙山一日，期间，天久未放晴。"><a href="#因试逗留龙山一日，期间，天久未放晴。" class="headerlink" title="因试逗留龙山一日，期间，天久未放晴。"></a>因试逗留龙山一日，期间，天久未放晴。</h3><h3 id="闲坐车上，可闻雨声潇潇，可闻风之呜呜，可视湖之清清，可感气之淳淳。"><a href="#闲坐车上，可闻雨声潇潇，可闻风之呜呜，可视湖之清清，可感气之淳淳。" class="headerlink" title="闲坐车上，可闻雨声潇潇，可闻风之呜呜，可视湖之清清，可感气之淳淳。"></a>闲坐车上，可闻雨声潇潇，可闻风之呜呜，可视湖之清清，可感气之淳淳。</h3><h3 id="耳边余音袅袅，缓缓枫叶，飘飘红雨，阴天搁浅，七号公园，扑火飞蛾，叫人忘忧。"><a href="#耳边余音袅袅，缓缓枫叶，飘飘红雨，阴天搁浅，七号公园，扑火飞蛾，叫人忘忧。" class="headerlink" title="耳边余音袅袅，缓缓枫叶，飘飘红雨，阴天搁浅，七号公园，扑火飞蛾，叫人忘忧。"></a>耳边余音袅袅，缓缓枫叶，飘飘红雨，阴天搁浅，七号公园，扑火飞蛾，叫人忘忧。</h3><h3 id="感概记之矣。"><a href="#感概记之矣。" class="headerlink" title="感概记之矣。"></a>感概记之矣。</h3><h1 id="江湖"><a href="#江湖" class="headerlink" title="江湖"></a>江湖</h1><h3 id="相忘于江湖肆意山水，快意恩仇。"><a href="#相忘于江湖肆意山水，快意恩仇。" class="headerlink" title="相忘于江湖肆意山水，快意恩仇。"></a>相忘于江湖肆意山水，快意恩仇。</h3><h3 id="一入江湖岁月催，不负人生一场醉。"><a href="#一入江湖岁月催，不负人生一场醉。" class="headerlink" title="一入江湖岁月催，不负人生一场醉。"></a>一入江湖岁月催，不负人生一场醉。</h3><h3 id="负剑狂歌，十步杀一人，千里不留行，-拔剑分了恩明怨，白骨皑皑鸟惊飞。"><a href="#负剑狂歌，十步杀一人，千里不留行，-拔剑分了恩明怨，白骨皑皑鸟惊飞。" class="headerlink" title="负剑狂歌，十步杀一人，千里不留行， 拔剑分了恩明怨，白骨皑皑鸟惊飞。"></a>负剑狂歌，十步杀一人，千里不留行， 拔剑分了恩明怨，白骨皑皑鸟惊飞。</h3><h3 id="举杯对饮，落拓不羁，图王霸业笑谈中。"><a href="#举杯对饮，落拓不羁，图王霸业笑谈中。" class="headerlink" title="举杯对饮，落拓不羁，图王霸业笑谈中。"></a>举杯对饮，落拓不羁，图王霸业笑谈中。</h3><h3 id="不希达荣，不畏权势，归去来兮仍江湖！"><a href="#不希达荣，不畏权势，归去来兮仍江湖！" class="headerlink" title="不希达荣，不畏权势，归去来兮仍江湖！"></a>不希达荣，不畏权势，归去来兮仍江湖！</h3><h1 id="六月二十五日酷暑而作"><a href="#六月二十五日酷暑而作" class="headerlink" title="六月二十五日酷暑而作"></a>六月二十五日酷暑而作</h1><h3 id="匆匆行过客，"><a href="#匆匆行过客，" class="headerlink" title="匆匆行过客，"></a>匆匆行过客，</h3><h3 id="折枝竹林中。"><a href="#折枝竹林中。" class="headerlink" title="折枝竹林中。"></a>折枝竹林中。</h3><h3 id="闲鱼钓作饵，"><a href="#闲鱼钓作饵，" class="headerlink" title="闲鱼钓作饵，"></a>闲鱼钓作饵，</h3><h3 id="悠悠心自空。"><a href="#悠悠心自空。" class="headerlink" title="悠悠心自空。"></a>悠悠心自空。</h3><h1 id="暑假前夕而作"><a href="#暑假前夕而作" class="headerlink" title="暑假前夕而作"></a>暑假前夕而作</h1><h3 id="丝竹悦于耳，"><a href="#丝竹悦于耳，" class="headerlink" title="丝竹悦于耳，"></a>丝竹悦于耳，</h3><h3 id="此心醉于书。"><a href="#此心醉于书。" class="headerlink" title="此心醉于书。"></a>此心醉于书。</h3><h3 id="煎茶沁于鼻，"><a href="#煎茶沁于鼻，" class="headerlink" title="煎茶沁于鼻，"></a>煎茶沁于鼻，</h3><h3 id="此心恬且静。"><a href="#此心恬且静。" class="headerlink" title="此心恬且静。"></a>此心恬且静。</h3>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学规划</title>
      <link href="/2024/01/29/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92/"/>
      <url>/2024/01/29/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h1 id="数学规划模型"><a href="#数学规划模型" class="headerlink" title="数学规划模型"></a>数学规划模型</h1><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><img src="/images/image-20240128212145083.png" alt="image-20240128212145083"></p><p><img src="/images/image-20240128212202777.png" alt="image-20240128212202777"></p><p><img src="/images/image-20240128212217297.png" alt="image-20240128212217297"></p><p><img src="/images/image-20240128212234617.png" alt="image-20240128212234617"></p><h1 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h1><p><img src="/images/image-20240128212439349.png" alt="image-20240128212439349"></p><p><img src="/images/image-20240128212611139.png" alt="image-20240128212611139"></p><p><img src="/images/image-20240128212925755.png" alt="image-20240128212925755"></p><h2 id="代码命令解释"><a href="#代码命令解释" class="headerlink" title="代码命令解释"></a>代码命令解释</h2><p><img src="/images/image-20240128213014243.png" alt="image-20240128213014243"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% Matlab求解线性规划</span></span><br><span class="line"><span class="comment">% [x fval] = linprog(c, A, b, Aeq, beq, lb,ub, x0)  </span></span><br><span class="line"><span class="comment">% c是目标函数的系数向量，A是不等式约束Ax&lt;=b的系数矩阵，b是不等式约束Ax&lt;=b的常数项</span></span><br><span class="line"><span class="comment">% Aeq是等式约束Aeq x=beq的系数矩阵，beq是等式约束Aeq x=beq的常数项</span></span><br><span class="line"><span class="comment">% lb是X的下限，ub是X的上限，X是向量[x1,x2,...xn]&#x27; , 即决策变量。</span></span><br><span class="line"><span class="comment">% 迭代的初始值为x0（一般不用给）</span></span><br><span class="line"><span class="comment">% 更多该函数的用法说明请看讲义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题1</span></span><br><span class="line">c = [<span class="number">-5</span> <span class="number">-4</span> <span class="number">-6</span>]&#x27;;  <span class="comment">% 加单引号表示转置</span></span><br><span class="line"><span class="comment">% c = [-5 -4 -6];  % 写成行向量也是可以的，不过不推荐，我们按照标准型来写看起来比较正规</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">-1</span> <span class="number">1</span>;</span><br><span class="line">        <span class="number">3</span> <span class="number">2</span> <span class="number">4</span>;</span><br><span class="line">        <span class="number">3</span> <span class="number">2</span> <span class="number">0</span>];</span><br><span class="line">b = [<span class="number">20</span> <span class="number">42</span> <span class="number">30</span>]&#x27;;   </span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]&#x27;; </span><br><span class="line">[x fval] = linprog(c, A, b, [], [], lb)  <span class="comment">% ub我们直接不写，则意味着没有上界的约束</span></span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">%    15.0000</span></span><br><span class="line"><span class="comment">%     3.0000</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%    -78</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题2</span></span><br><span class="line">c = [<span class="number">0.04</span> <span class="number">0.15</span> <span class="number">0.1</span> <span class="number">0.125</span>]&#x27;;  </span><br><span class="line">A = [<span class="number">-0.03</span> <span class="number">-0.3</span> <span class="number">0</span> <span class="number">-0.15</span>;</span><br><span class="line">        <span class="number">0.14</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.07</span>];</span><br><span class="line">b = [<span class="number">-32</span> <span class="number">42</span>]&#x27;;</span><br><span class="line">Aeq = [<span class="number">0.05</span> <span class="number">0</span> <span class="number">0.2</span> <span class="number">0.1</span>];</span><br><span class="line">beq = <span class="number">24</span>;</span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]&#x27;;</span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)</span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">%   106.6667</span></span><br><span class="line"><span class="comment">%   120.0000</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">% </span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%     28</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 这个题可能有多个解，即有多个x可以使得目标函数的最小值为28（不同的Matlab版本可能得到的x的值不同，但最后的最小值一定是28）</span></span><br><span class="line"><span class="comment">% 例如我们更改一个限定条件：令x1要大于0（注意Matlab中线性规划的标准型要求的不等式约束的符号是小于等于0）</span></span><br><span class="line"><span class="comment">% x1 &gt;0  等价于  -x1 &lt; 0，那么给定 -x1 &lt;= -0.1 (根据实际问题可以给一个略小于0的数-0.1)，这样能将小于号转换为小于等于号，满足Matlab的标准型</span></span><br><span class="line">c = [<span class="number">0.04</span> <span class="number">0.15</span> <span class="number">0.1</span> <span class="number">0.125</span>]&#x27;;  </span><br><span class="line">A = [<span class="number">-0.03</span> <span class="number">-0.3</span> <span class="number">0</span> <span class="number">-0.15</span>;</span><br><span class="line">        <span class="number">0.14</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0.07</span></span><br><span class="line">        <span class="number">-1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];</span><br><span class="line">b = [<span class="number">-32</span> <span class="number">42</span> <span class="number">-0.1</span>]&#x27;;</span><br><span class="line">Aeq = [<span class="number">0.05</span> <span class="number">0</span> <span class="number">0.2</span> <span class="number">0.1</span>];</span><br><span class="line">beq = <span class="number">24</span>;</span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]&#x27;;</span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)</span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%     0.1000</span></span><br><span class="line"><span class="comment">%   106.6567</span></span><br><span class="line"><span class="comment">%   119.9750</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%    28.0000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题3</span></span><br><span class="line">c = [<span class="number">-2</span> <span class="number">-3</span> <span class="number">5</span>]&#x27;;</span><br><span class="line">A = [<span class="number">-2</span> <span class="number">5</span> <span class="number">-1</span>;</span><br><span class="line">          <span class="number">1</span> <span class="number">3</span> <span class="number">1</span>];</span><br><span class="line">b = [<span class="number">-10</span> <span class="number">12</span>];</span><br><span class="line">Aeq = <span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">3</span>);</span><br><span class="line">beq = <span class="number">7</span>;</span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)</span><br><span class="line">fval = -fval <span class="comment">% 注意这个fval要取负号（原来是求最大值，我们添加负号变成了最小值问题）</span></span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%     6.4286</span></span><br><span class="line"><span class="comment">%     0.5714</span></span><br><span class="line"><span class="comment">%          0</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%   -14.5714</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%    14.5714</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 多个解的情况</span></span><br><span class="line"><span class="comment">% 例如 ： min z = x1 + x2   s.t.  x1 + x2 &gt;= 10</span></span><br><span class="line">c = [<span class="number">1</span> <span class="number">1</span>]&#x27;;   </span><br><span class="line">A = [<span class="number">-1</span> <span class="number">-1</span>];</span><br><span class="line">b = <span class="number">-10</span>;</span><br><span class="line">[x fval] = linprog(c, A, b)   <span class="comment">% Aeq, beq, lb和ub我们都没写，意味着没有等式约束和上下界约束</span></span><br><span class="line"><span class="comment">% x有多个解时，Matlab会给我们返回其中的一个解</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 不存在解的情况</span></span><br><span class="line"><span class="comment">% 例如 ： min z = x1 + x2   s.t.  x1 + x2 = 10 、 x1 + 2*x2 &lt;= 8、 x1 &gt;=0 ，x2 &gt;=0 </span></span><br><span class="line">c = [<span class="number">1</span> <span class="number">1</span>]&#x27;; </span><br><span class="line">A = [<span class="number">1</span> <span class="number">2</span>];</span><br><span class="line">b = <span class="number">8</span>;</span><br><span class="line">Aeq = [<span class="number">1</span> <span class="number">1</span>];</span><br><span class="line">beq = <span class="number">10</span>;</span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span>]&#x27;;</span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)  <span class="comment">% Linprog stopped because no point satisfies the constraints.（没有任何一个点满足约束条件）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="线性规划的典型例题"><a href="#线性规划的典型例题" class="headerlink" title="线性规划的典型例题"></a>线性规划的典型例题</h2><p><img src="/images/image-20240128213640923.png" alt="image-20240128213640923"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 生产决策问题</span></span><br><span class="line">format long g   <span class="comment">%可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"><span class="comment">% (1) 系数向量</span></span><br><span class="line">c = <span class="built_in">zeros</span>(<span class="number">9</span>,<span class="number">1</span>); <span class="comment">% 初始化目标函数的系数向量全为0</span></span><br><span class="line">c(<span class="number">1</span>) = <span class="number">1.25</span> <span class="number">-0.25</span> <span class="number">-300</span>/<span class="number">6000</span>*<span class="number">5</span>;  <span class="comment">% x1前面的系数是c1</span></span><br><span class="line">c(<span class="number">2</span>) = <span class="number">1.25</span> <span class="number">-0.25</span> <span class="number">-321</span>/<span class="number">10000</span>*<span class="number">7</span>;</span><br><span class="line">c(<span class="number">3</span>) = <span class="number">-250</span> / <span class="number">4000</span> * <span class="number">6</span>;</span><br><span class="line">c(<span class="number">4</span>)  = <span class="number">-783</span>/<span class="number">7000</span>*<span class="number">4</span>;</span><br><span class="line">c(<span class="number">5</span>) = <span class="number">-200</span>/<span class="number">4000</span> * <span class="number">7</span>;</span><br><span class="line">c(<span class="number">6</span>) = <span class="number">-300</span>/<span class="number">6000</span>*<span class="number">10</span>;</span><br><span class="line">c(<span class="number">7</span>) = <span class="number">-321</span> / <span class="number">10000</span> * <span class="number">9</span>;</span><br><span class="line">c(<span class="number">8</span>) = <span class="number">2</span><span class="number">-0.35</span><span class="number">-250</span>/<span class="number">4000</span>*<span class="number">8</span>;</span><br><span class="line">c(<span class="number">9</span>) = <span class="number">2.8</span><span class="number">-0.5</span><span class="number">-321</span>/<span class="number">10000</span>*<span class="number">12</span><span class="number">-783</span>/<span class="number">7000</span>*<span class="number">11</span>;</span><br><span class="line">c = -c;  <span class="comment">% 我们求的是最大值，所以这里需要改变符号</span></span><br><span class="line"><span class="comment">% (2) 不等式约束</span></span><br><span class="line">A = <span class="built_in">zeros</span>(<span class="number">5</span>,<span class="number">9</span>);</span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>) = <span class="number">5</span>;  A(<span class="number">1</span>,<span class="number">6</span>) = <span class="number">10</span>;</span><br><span class="line">A(<span class="number">2</span>,<span class="number">2</span>) = <span class="number">7</span>;  A(<span class="number">2</span>,<span class="number">7</span>) = <span class="number">9</span>; A(<span class="number">2</span>,<span class="number">9</span>) = <span class="number">12</span>;</span><br><span class="line">A(<span class="number">3</span>,<span class="number">3</span>) = <span class="number">6</span>;  A(<span class="number">3</span>,<span class="number">8</span>) = <span class="number">8</span>;</span><br><span class="line">A(<span class="number">4</span>,<span class="number">4</span>) = <span class="number">4</span>;  A(<span class="number">4</span>,<span class="number">9</span>) = <span class="number">11</span>;</span><br><span class="line">A(<span class="number">5</span>,<span class="number">5</span>) = <span class="number">7</span>;  </span><br><span class="line">b = [<span class="number">6000</span> <span class="number">10000</span> <span class="number">4000</span> <span class="number">7000</span> <span class="number">4000</span>]&#x27;;</span><br><span class="line"><span class="comment">% (3) 等式约束</span></span><br><span class="line">Aeq = [<span class="number">1</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">-1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">            <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">-1</span> <span class="number">0</span>];</span><br><span class="line">beq = [<span class="number">0</span> <span class="number">0</span>]&#x27;;</span><br><span class="line"><span class="comment">%（4）上下界</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">9</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% 进行求解</span></span><br><span class="line">[x fval] = linprog(c, A, b, Aeq, beq, lb)</span><br><span class="line">fval = -fval</span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%           1146.56650246305</span></span><br><span class="line"><span class="comment">%  注意，本题应该是一个整数规划的例子，我们在后面的整数规划部分再来重新求解。</span></span><br><span class="line">intcon = <span class="number">1</span>:<span class="number">9</span>;</span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,Aeq,beq,lb)</span><br><span class="line">fval = -fval</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="整数规划"><a href="#整数规划" class="headerlink" title="整数规划"></a>整数规划</h1><p><img src="/images/image-20240128214116824.png" alt="image-20240128214116824"></p><p><img src="/images/image-20240128214417024.png" alt="image-20240128214417024"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 线性整数规划问题</span></span><br><span class="line"><span class="comment">%% 例1</span></span><br><span class="line">c=[<span class="number">-20</span>,<span class="number">-10</span>]&#x27;;</span><br><span class="line">intcon=[<span class="number">1</span>,<span class="number">2</span>];  <span class="comment">% x1和x2限定为整数</span></span><br><span class="line">A=[<span class="number">5</span>,<span class="number">4</span>;</span><br><span class="line">      <span class="number">2</span>,<span class="number">5</span>];</span><br><span class="line">b=[<span class="number">24</span>;<span class="number">13</span>];</span><br><span class="line">lb=<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">1</span>);  </span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,[],[],lb)</span><br><span class="line">fval = -fval</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例2</span></span><br><span class="line">c=[<span class="number">18</span>,<span class="number">23</span>,<span class="number">5</span>]&#x27;;</span><br><span class="line">intcon=<span class="number">3</span>;  <span class="comment">% x3限定为整数</span></span><br><span class="line">A=[<span class="number">107</span>,<span class="number">500</span>,<span class="number">0</span>;</span><br><span class="line">      <span class="number">72</span>,<span class="number">121</span>,<span class="number">65</span>;</span><br><span class="line">      <span class="number">-107</span>,<span class="number">-500</span>,<span class="number">0</span>;</span><br><span class="line">      <span class="number">-72</span>,<span class="number">-121</span>,<span class="number">-65</span>];</span><br><span class="line">b=[<span class="number">50000</span>;<span class="number">2250</span>;<span class="number">-500</span>;<span class="number">-2000</span>];</span><br><span class="line">lb=<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,[],[],lb)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例3</span></span><br><span class="line">c=[<span class="number">-3</span>;<span class="number">-2</span>;<span class="number">-1</span>]; intcon=<span class="number">3</span>; <span class="comment">% x3限定为整数</span></span><br><span class="line">A=<span class="built_in">ones</span>(<span class="number">1</span>,<span class="number">3</span>); b=<span class="number">7</span>;</span><br><span class="line">Aeq=[<span class="number">4</span> <span class="number">2</span> <span class="number">1</span>]; beq=<span class="number">12</span>;</span><br><span class="line">lb=<span class="built_in">zeros</span>(<span class="number">3</span>,<span class="number">1</span>); ub=[+<span class="built_in">inf</span>;+<span class="built_in">inf</span>;<span class="number">1</span>]; <span class="comment">%x(3)为0-1变量</span></span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,Aeq,beq,lb,ub)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="背包问题"><a href="#背包问题" class="headerlink" title="背包问题"></a>背包问题</h2><p><img src="/images/image-20240128214732168.png" alt="image-20240128214732168"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 背包问题（货车运送货物的问题）</span></span><br><span class="line">c = -[<span class="number">540</span> <span class="number">200</span> <span class="number">180</span> <span class="number">350</span> <span class="number">60</span> <span class="number">150</span> <span class="number">280</span> <span class="number">450</span> <span class="number">320</span> <span class="number">120</span>];  <span class="comment">% 目标函数的系数矩阵(最大化问题记得加负号)</span></span><br><span class="line">intcon=[<span class="number">1</span>:<span class="number">10</span>];  <span class="comment">% 整数变量的位置(一共10个决策变量，均为0-1整数变量)</span></span><br><span class="line">A = [<span class="number">6</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">2</span>];  b = <span class="number">30</span>;   <span class="comment">% 线性不等式约束的系数矩阵和常数项向量（物品的重量不能超过30）</span></span><br><span class="line">Aeq = []; beq =[];  <span class="comment">% 不存在线性等式约束</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">10</span>,<span class="number">1</span>);  <span class="comment">% 约束变量的范围下限</span></span><br><span class="line">ub = <span class="built_in">ones</span>(<span class="number">10</span>,<span class="number">1</span>);  <span class="comment">% 约束变量的范围上限</span></span><br><span class="line"><span class="comment">%最后调用intlinprog()函数</span></span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,Aeq,beq,lb,ub)</span><br><span class="line">fval = -fval</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="指派问题"><a href="#指派问题" class="headerlink" title="指派问题"></a>指派问题</h2><p><img src="/images/image-20240128215024353.png" alt="image-20240128215024353"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 指派问题（选择队员去进行游泳接力比赛）</span></span><br><span class="line">clear;clc</span><br><span class="line">c = [<span class="number">66.8</span> <span class="number">75.6</span> <span class="number">87</span> <span class="number">58.6</span> <span class="number">57.2</span> <span class="number">66</span> <span class="number">66.4</span> <span class="number">53</span> <span class="number">78</span> <span class="number">67.8</span> <span class="number">84.6</span> <span class="number">59.4</span> <span class="number">70</span> <span class="number">74.2</span> <span class="number">69.6</span> <span class="number">57.2</span> <span class="number">67.4</span> <span class="number">71</span> <span class="number">83.8</span> <span class="number">62.4</span>]&#x27;;  <span class="comment">% 目标函数的系数矩阵（先列后行的写法）</span></span><br><span class="line">intcon = [<span class="number">1</span>:<span class="number">20</span>];  <span class="comment">% 整数变量的位置(一共20个决策变量，均为0-1整数变量)</span></span><br><span class="line"><span class="comment">% 线性不等式约束的系数矩阵和常数项向量（每个人只能入选四种泳姿之一，一共五个约束）</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">       <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">       <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">       <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">       <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% A = zeros(5,20);</span></span><br><span class="line"><span class="comment">% for i = 1:5</span></span><br><span class="line"><span class="comment">%     A(i, (4*i-3): 4*i) = 1;</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line">b = [<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>];</span><br><span class="line"><span class="comment">% 线性等式约束的系数矩阵和常数项向量 （每种泳姿有且仅有一人参加，一共四个约束）</span></span><br><span class="line">Aeq = [<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">          <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">          <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span>;</span><br><span class="line">          <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>];</span><br><span class="line"><span class="comment">% Aeq = [eye(4),eye(4),eye(4),eye(4),eye(4)];  % 或者写成 repmat(eye(4),1,5)  </span></span><br><span class="line">beq = [<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>;<span class="number">1</span>];</span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">20</span>,<span class="number">1</span>);  <span class="comment">% 约束变量的范围下限</span></span><br><span class="line">ub = <span class="built_in">ones</span>(<span class="number">20</span>,<span class="number">1</span>);  <span class="comment">% 约束变量的范围上限</span></span><br><span class="line"><span class="comment">%最后调用intlinprog()函数</span></span><br><span class="line">[x,fval] = intlinprog(c,intcon,A,b,Aeq,beq,lb,ub)</span><br><span class="line"><span class="comment">% reshape(x,4,5)&#x27;</span></span><br><span class="line"><span class="comment">%      0     0     0     1    甲自由泳</span></span><br><span class="line"><span class="comment">%      1     0     0     0    乙蝶泳</span></span><br><span class="line"><span class="comment">%      0     1     0     0    丙仰泳</span></span><br><span class="line"><span class="comment">%      0     0     1     0    丁蛙泳</span></span><br><span class="line"><span class="comment">%      0     0     0     0    戊不参加</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="钢管切割问题"><a href="#钢管切割问题" class="headerlink" title="钢管切割问题"></a>钢管切割问题</h1><p><img src="/images/image-20240128215414471.png" alt="image-20240128215414471"></p><p><img src="/images/image-20240128215510504.png" alt="image-20240128215510504"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 钢管切割问题</span></span><br><span class="line"><span class="comment">%% (1)枚举法找出同一个原材料上所有的切割方法</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">0</span>: <span class="number">2</span>  <span class="comment">% 2.9m长的圆钢的数量</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">0</span>: <span class="number">3</span>  <span class="comment">% 2.1m长的圆钢的数量</span></span><br><span class="line">        <span class="keyword">for</span> k = <span class="number">0</span>:<span class="number">6</span>   <span class="comment">% 1m长的圆钢的数量</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">2.9</span>*<span class="built_in">i</span>+<span class="number">2.1</span>*<span class="built_in">j</span>+<span class="number">1</span>*k &gt;= <span class="number">6</span> &amp;&amp; <span class="number">2.9</span>*<span class="built_in">i</span>+<span class="number">2.1</span>*<span class="built_in">j</span>+<span class="number">1</span>*k &lt;= <span class="number">6.9</span></span><br><span class="line">                <span class="built_in">disp</span>([<span class="built_in">i</span>, <span class="built_in">j</span>, k])</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">% 有同学使用比较老的MATLAB版本，会出现浮点数计算的误差</span></span><br><span class="line"><span class="comment">% 只需要将上面的if这一行进行适当的放缩即可。</span></span><br><span class="line"><span class="comment">% if 2.9*i+2.1*j+1*k &gt;= 6-0.0000001 &amp;&amp; 2.9*i+2.1*j+1*k &lt;= 6.9+0.0000001</span></span><br><span class="line"><span class="comment">% 有兴趣的同学可以百度下：浮点数计算误差</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% (2) 线性整数规划问题的求解</span></span><br><span class="line">c = <span class="built_in">ones</span>(<span class="number">7</span>,<span class="number">1</span>);  <span class="comment">% 目标函数的系数矩阵</span></span><br><span class="line">intcon=[<span class="number">1</span>:<span class="number">7</span>];  <span class="comment">%  整数变量的位置(一共7个决策变量，均为整数变量)</span></span><br><span class="line">A = -[<span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>;  </span><br><span class="line">         <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;</span><br><span class="line">         <span class="number">4</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">1</span>];  <span class="comment">% 线性不等式约束的系数矩阵</span></span><br><span class="line">b = -[<span class="number">100</span> <span class="number">100</span> <span class="number">100</span>]&#x27;; <span class="comment">%  线性不等式约束的常数项向量</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">7</span>,<span class="number">1</span>); <span class="comment">% 约束变量的范围下限</span></span><br><span class="line">[x,fval]=intlinprog(c,intcon,A,b,[],[],lb)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="非线性问题的求解"><a href="#非线性问题的求解" class="headerlink" title="非线性问题的求解"></a>非线性问题的求解</h1><p><img src="/images/image-20240128215640424.png" alt="image-20240128215640424"></p><p><img src="/images/image-20240128215838554.png" alt="image-20240128215838554"></p><p><img src="/images/image-20240128220006524.png" alt="image-20240128220006524"></p><h2 id="代码求解"><a href="#代码求解" class="headerlink" title="代码求解"></a>代码求解</h2><blockquote><p>可以先给定不同初始值，在里面找到最优解</p><p>也可以蒙特卡罗模拟找到一个蒙特卡罗解，再作为初始值进行求解。</p><p>min最小值</p><p>f函数</p><p>con约束</p><p>X0是一个初始值，线性规划里边初始值对于结果没影响，而非线性规划中x0的选取很关键，因为求出的是一个局部最优解。</p></blockquote><p><img src="/images/image-20240128221553606.png" alt="image-20240128221553606"></p><p>求解的方法有四种，可以提高结果的稳健性能。 </p><p><img src="/images/image-20240128221841171.png" alt="image-20240128221841171"></p><h1 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h1><h3 id="如果考察了，建议蒙特卡洛加上四种方法一起用，这样就稳啦"><a href="#如果考察了，建议蒙特卡洛加上四种方法一起用，这样就稳啦" class="headerlink" title="如果考察了，建议蒙特卡洛加上四种方法一起用，这样就稳啦"></a>如果考察了，建议蒙特卡洛加上四种方法一起用，这样就稳啦</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 非线性规划的函数</span></span><br><span class="line"><span class="comment">% [x,fval] = fmincon(@fun,x0,A,b,Aeq,beq,lb,ub,@nonlfun,option)</span></span><br><span class="line"><span class="comment">% x0表示给定的初始值（用行向量或者列向量表示），必须得写</span></span><br><span class="line"><span class="comment">% A b表示线性不等式约束</span></span><br><span class="line"><span class="comment">% Aeq beq 表示线性等式约束</span></span><br><span class="line"><span class="comment">% lb ub 表示上下界约束</span></span><br><span class="line"><span class="comment">% @fun表示目标函数</span></span><br><span class="line"><span class="comment">% @nonlfun表示非线性约束的函数</span></span><br><span class="line"><span class="comment">% option 表示求解非线性规划使用的方法</span></span><br><span class="line">clear;clc</span><br><span class="line">format long g   <span class="comment">%可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 例题1的求解</span></span><br><span class="line"><span class="comment">% max f(x) = x1^2 +x2^2 -x1*x2 -2x1 -5x2</span></span><br><span class="line"><span class="comment">% s.t. -(x1-1)^2 +x2 &gt;= 0 ;  2x1-3x2+6 &gt;= 0</span></span><br><span class="line">x0 = [<span class="number">0</span> <span class="number">0</span>];  <span class="comment">%任意给定一个初始值 </span></span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1)  <span class="comment">% 注意 fun1.m文件和nonlfun1.m文件都必须在当前文件夹目录下</span></span><br><span class="line">fval = -fval</span><br><span class="line"><span class="comment">% 一个值得讨论的地方，能不能把线性不等式约束Ax &lt;= b也写到nonlfun1函数中？</span></span><br><span class="line"><span class="comment">% 先把nonlfun1中的c改为下面这样：</span></span><br><span class="line"><span class="comment">% c = [(x(1)-1)^2-x(2); </span></span><br><span class="line"><span class="comment">%        -2*x(1)+3*x(2)-6];</span></span><br><span class="line"><span class="comment">%  [x,fval] = fmincon(@fun1,x0,[],[],[],[],[],[],@nonlfun1)</span></span><br><span class="line"><span class="comment">% 结果也是可以计算出来的，但并不推荐这样做~</span></span><br><span class="line"></span><br><span class="line">目标函数</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun1</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">% 注意：这里的f实际上就是目标函数，函数的返回值也是f</span></span><br><span class="line">    <span class="comment">% 输入值x实际上就是决策变量，由x1和x2组成的向量</span></span><br><span class="line">    <span class="comment">% fun1是函数名称，到时候会被fmincon函数调用, 可以任意取名</span></span><br><span class="line">    <span class="comment">% 保存的m文件和函数名称得一致，也要为fun1.m</span></span><br><span class="line"><span class="comment">%      max  f(x) = x1^2 +x2^2 -x1*x2 -2x1 -5x2</span></span><br><span class="line">    f = -x(<span class="number">1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)^<span class="number">2</span> +x(<span class="number">1</span>)*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>) ; </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">这是非线性约束</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[c,ceq]</span> = <span class="title">nonlfun1</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">% 注意：这里的c实际上就是非线性不等式约束，ceq实际上就是非线性等式约束</span></span><br><span class="line">    <span class="comment">% 输入值x实际上就是决策变量，由x1和x2组成的一个向量</span></span><br><span class="line">    <span class="comment">% 返回值有两个，一个是非线性不等式约束c，一个是非线性等式约束ceq</span></span><br><span class="line">    <span class="comment">% nonlfun1是函数名称，到时候会被fmincon函数调用, 可以任意取名，但不能和目标函数fun1重名</span></span><br><span class="line">    <span class="comment">% 保存的m文件和函数名称得一致，也要为nonlfun1.m</span></span><br><span class="line"><span class="comment">%     -(x1-1)^2 +x2 &gt;= 0 </span></span><br><span class="line">   c = [(x(<span class="number">1</span>)<span class="number">-1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)];   <span class="comment">% 千万別写成了: (x1-1)^2 -x2</span></span><br><span class="line">   ceq = [];  <span class="comment">% 不存在非线性等式约束，所以用[]表示</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 使用其他算法对例题1求解</span></span><br><span class="line"><span class="comment">% edit fmincon  % 查看fmincon的“源代码”</span></span><br><span class="line"><span class="comment">% Matlab2017a默认使用的算法是&#x27;interior-point&#x27; 内点法</span></span><br><span class="line"><span class="comment">% 使用interior point算法 （内点法）</span></span><br><span class="line">option = optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;interior-point&#x27;</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval</span><br><span class="line"><span class="comment">% 使用SQP算法 （序列二次规划法）</span></span><br><span class="line">option = optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;sqp&#x27;</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval   <span class="comment">%得到-4.358，远远大于内点法得到的-1,猜想是初始值的影响</span></span><br><span class="line"><span class="comment">% 改变初始值试试</span></span><br><span class="line">x0 = [<span class="number">1</span> <span class="number">1</span>];  <span class="comment">%任意给定一个初始值 </span></span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  <span class="comment">% 最小值为-1，和内点法相同（这说明内点法的适应性要好）</span></span><br><span class="line">fval = -fval  </span><br><span class="line"><span class="comment">% 使用active set算法 （有效集法）</span></span><br><span class="line">option = optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;active-set&#x27;</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)</span><br><span class="line">fval = -fval  </span><br><span class="line"><span class="comment">% 使用trust region reflective (信赖域反射算法)</span></span><br><span class="line">option = optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;trust-region-reflective&#x27;</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval  </span><br><span class="line"><span class="comment">% this algorithm does not solve problems with the constraints you have specified. </span></span><br><span class="line"><span class="comment">% 这说明这个算法不适用我们这个约束条件，所以以后遇到了不能求解的情况，记得更换其他算法试试！！！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 选取初始值得到的结果可能会不满足限定条件，出现了一个Bug 因此选择的初始值很重要</span></span><br><span class="line">x0 = [<span class="number">40.8</span>, <span class="number">10.8</span>];</span><br><span class="line">option = optimoptions(<span class="string">&#x27;fmincon&#x27;</span>,<span class="string">&#x27;Algorithm&#x27;</span>,<span class="string">&#x27;interior-point&#x27;</span>)</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option)  </span><br><span class="line">fval = -fval  </span><br><span class="line"><span class="comment">% https://cn.mathworks.com/help/optim/ug/fmincon.html</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 生成不同的随机初始值来优化代码，有一定几率会触发上面那个Bug，因此不推荐</span></span><br><span class="line">n = <span class="number">10</span>;  <span class="comment">% 重复n次</span></span><br><span class="line">Fval = +<span class="built_in">inf</span>; X = [<span class="number">0</span>,<span class="number">0</span>];  <span class="comment">%初始化最优的结果</span></span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    x0 = [<span class="built_in">rand</span>()*<span class="number">10</span> , <span class="built_in">rand</span>()*<span class="number">10</span>];  <span class="comment">%用随机数生成一个初始值（随机数的范围自己根据题目条件设置） </span></span><br><span class="line">    [x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1,option); <span class="comment">% 注意 fun1.m文件和nonlfun1.m文件都必须在当前文件夹目录下</span></span><br><span class="line">    <span class="keyword">if</span> fval &lt; Fval  <span class="comment">% 如果找到了更小的值，那么就代替最优的结果</span></span><br><span class="line">        Fval = fval;</span><br><span class="line">        X = x;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Fval = -Fval</span><br><span class="line">X</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 使用蒙特卡罗的方法来找初始值(推荐）</span></span><br><span class="line">clc,clear;</span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">-100</span>,<span class="number">100</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[-100,100]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2=unifrnd(<span class="number">-100</span>,<span class="number">100</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[-100,100]之间均匀分布的随机数组成的n行1列的向量构成x2</span></span><br><span class="line">fmin=+<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最小值为正无穷（后续只要找到一个比它小的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2]</span></span><br><span class="line">    <span class="keyword">if</span> ((x(<span class="number">1</span>)<span class="number">-1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)&lt;=<span class="number">0</span>)  &amp; (<span class="number">-2</span>*x(<span class="number">1</span>)+<span class="number">3</span>*x(<span class="number">2</span>)<span class="number">-6</span> &lt;= <span class="number">0</span>)     <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result = -x(<span class="number">1</span>)^<span class="number">2</span>-x(<span class="number">2</span>)^<span class="number">2</span> +x(<span class="number">1</span>)*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>) ;  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &lt; fmin  <span class="comment">% 如果这个函数值小于我们之前计算出来的最小值</span></span><br><span class="line">            fmin = result;  <span class="comment">% 那么就更新这个函数值为新的最小值</span></span><br><span class="line">            x0 = x;  <span class="comment">% 并且将此时的x1 x2更新为初始值</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;蒙特卡罗选取的初始值为：&#x27;</span>); <span class="built_in">disp</span>(x0)</span><br><span class="line">A = [<span class="number">-2</span> <span class="number">3</span>]; b = <span class="number">6</span>;</span><br><span class="line">[x,fval] = fmincon(@fun1,x0,A,b,[],[],[],[],@nonlfun1)</span><br><span class="line">fval = -fval  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 例题二的求解</span></span><br><span class="line">x0 = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];  <span class="comment">%任意给定一个初始值 </span></span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];  <span class="comment">% 决策变量的下界</span></span><br><span class="line">[x,fval] = fmincon(@fun2,x0,[],[],[],[],lb,[],@nonlfun2)  <span class="comment">% 注意 fun2.m文件和nonfun2.m文件都必须在当前文件夹目录下</span></span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%          0.552167405729277          1.20325915507969         0.947824046150443</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%           10.6510918606939</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 使用蒙特卡罗的方法来找初始值(推荐）</span></span><br><span class="line">clc,clear;</span><br><span class="line">n=<span class="number">1000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1= unifrnd(<span class="number">0</span>,<span class="number">2</span>,n,<span class="number">1</span>);   <span class="comment">% 生成在[0,2]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2 = <span class="built_in">sqrt</span>(<span class="number">2</span>-x1);  <span class="comment">% 根据非线性等式约束用x1计算出x2</span></span><br><span class="line">x3 = <span class="built_in">sqrt</span>((<span class="number">3</span>-x2)/<span class="number">2</span>); <span class="comment">% 根据非线性等式约束用x2计算出x3</span></span><br><span class="line">fmin=+<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最小值为正无穷（后续只要找到一个比它小的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>), x3(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2, x3]</span></span><br><span class="line">    <span class="keyword">if</span> (-x(<span class="number">1</span>)^<span class="number">2</span>+x(<span class="number">2</span>)-x(<span class="number">3</span>)^<span class="number">2</span>&lt;=<span class="number">0</span>) &amp; (x(<span class="number">1</span>)+x(<span class="number">2</span>)^<span class="number">2</span>+x(<span class="number">3</span>)^<span class="number">2</span><span class="number">-20</span>&lt;=<span class="number">0</span>)   <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result =sum(x.*x) + <span class="number">8</span> ;  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &lt; fmin  <span class="comment">% 如果这个函数值小于我们之前计算出来的最小值</span></span><br><span class="line">            fmin = result;  <span class="comment">% 那么就更新这个函数值为新的最小值</span></span><br><span class="line">            x0 = x;  <span class="comment">% 并且将此时的x1 x2 x3更新为初始值</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;蒙特卡罗选取的初始值为：&#x27;</span>); <span class="built_in">disp</span>(x0)</span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span>];  <span class="comment">% 决策变量的下界</span></span><br><span class="line">[x,fval] = fmincon(@fun2,x0,[],[],[],[],lb,[],@nonlfun2)  <span class="comment">% 注意 fun2.m文件和nonfun2.m文件都必须在当前文件夹目录下</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun2</span><span class="params">(x)</span></span></span><br><span class="line">    <span class="comment">%     f = x(1)^2+x(2)^2 +x(3)^2+8 ; </span></span><br><span class="line">    f = sum(x.*x) + <span class="number">8</span>;  <span class="comment">% 可别忘了x实际上是一个向量，我们可以使用矩阵的运算符号对其计算</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="例题三"><a href="#例题三" class="headerlink" title="例题三"></a>例题三</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 例题三的求解(蒙特卡罗模拟那一讲的例题)</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="comment">% 蒙特卡罗模拟得到的最大值为3445.6014</span></span><br><span class="line"><span class="comment">% 最大值处x1 x2 x3的取值为：</span></span><br><span class="line"><span class="comment">%           22.5823101903968          12.5823101903968          12.1265223966757</span></span><br><span class="line">A = [<span class="number">1</span> <span class="number">-2</span> <span class="number">-2</span>;  <span class="number">1</span> <span class="number">2</span> <span class="number">2</span>];  b = [<span class="number">0</span> <span class="number">72</span>];</span><br><span class="line">x0 = [ <span class="number">22.58</span>   <span class="number">12.58</span>  <span class="number">12.13</span>];</span><br><span class="line">Aeq = [<span class="number">1</span> <span class="number">-1</span> <span class="number">0</span>]; beq = <span class="number">10</span>;</span><br><span class="line">lb = [-<span class="built_in">inf</span> <span class="number">10</span> -<span class="built_in">inf</span>];  ub = [<span class="built_in">inf</span> <span class="number">20</span> <span class="built_in">inf</span>];  </span><br><span class="line">[x,fval] = fmincon(@fun3,x0,A,b,Aeq,beq,lb,ub,[])  <span class="comment">% 注意没有非线性约束，所以这里可以用[]替代，或者干脆不写</span></span><br><span class="line">fval = -fval</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun3</span><span class="params">(x)</span></span></span><br><span class="line">    f = -prod(x);  <span class="comment">% 可别忘了x实际上是一个向量（prod表示连乘符号，用法和sum类似）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="选址问题"><a href="#选址问题" class="headerlink" title="选址问题"></a>选址问题</h2><blockquote><p>背景</p></blockquote><p><img src="/2024/01/29/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92/image-20240129110524287.png" alt="image-20240129110524287"></p><p><img src="/2024/01/29/%E6%95%B0%E5%AD%A6%E8%A7%84%E5%88%92/image-20240129110713468.png" alt="image-20240129110713468"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 选址问题</span></span><br><span class="line">clear;clc</span><br><span class="line">format long g   <span class="comment">%可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"><span class="comment">% % (1) 系数向量（原来线性规划问题的写法,我们只需要在此基础上改动一点就可以了）</span></span><br><span class="line"><span class="comment">% a=[1.25  8.75  0.5  5.75  3  7.25];  % 工地的横坐标</span></span><br><span class="line"><span class="comment">% b=[1.25  0.75  4.755  6.5  7.25];   % 工地的纵坐标</span></span><br><span class="line"><span class="comment">% x = [5  2];  % 料场的横坐标</span></span><br><span class="line"><span class="comment">% y = [1  7];  % 料场的纵坐标</span></span><br><span class="line"><span class="comment">% c = [];  % 初始化用来保存工地和料场距离的向量 (这个向量就是我们的系数向量）</span></span><br><span class="line"><span class="comment">% for  j =1:2</span></span><br><span class="line"><span class="comment">%     for i = 1:6</span></span><br><span class="line"><span class="comment">%         c = [c;  sqrt( (a(i)-x(j))^2 + (b(i)-y(j))^2)];  % 每循环一次就在c的末尾插入新的元素</span></span><br><span class="line"><span class="comment">%     end</span></span><br><span class="line"><span class="comment">% end</span></span><br><span class="line"><span class="comment">% (2) 不等式约束</span></span><br><span class="line">A =<span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">16</span>);  <span class="comment">% 注意这里要改成16</span></span><br><span class="line">A(<span class="number">1</span>,<span class="number">1</span>:<span class="number">6</span>) = <span class="number">1</span>;</span><br><span class="line">A(<span class="number">2</span>,<span class="number">7</span>:<span class="number">12</span>) = <span class="number">1</span>;</span><br><span class="line">b = [<span class="number">20</span>,<span class="number">20</span>]&#x27;;</span><br><span class="line"><span class="comment">% (3) 等式约束</span></span><br><span class="line">Aeq = <span class="built_in">zeros</span>(<span class="number">6</span>,<span class="number">16</span>);  <span class="comment">% 注意这里要改成16</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">6</span></span><br><span class="line">    Aeq(<span class="built_in">i</span>,<span class="built_in">i</span>) = <span class="number">1</span>;  Aeq(<span class="built_in">i</span>,<span class="built_in">i</span>+<span class="number">6</span>) = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">beq = [<span class="number">3</span> <span class="number">5</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span> <span class="number">11</span>]&#x27;;  <span class="comment">% 每个工地的日需求量</span></span><br><span class="line"><span class="comment">%（4）上下界</span></span><br><span class="line">lb = <span class="built_in">zeros</span>(<span class="number">16</span>,<span class="number">1</span>);</span><br><span class="line"><span class="comment">% lb = [zeros(12,1); -inf*ones(4,1)];  两个新料场坐标的下界可以设为-inf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 进行求解</span></span><br><span class="line"><span class="comment">% 注意哦，这里我们只尝试了这一个初始值，大家可以试试其他的初始值，有可能能够找到更好的解。</span></span><br><span class="line"><span class="comment">% 未来我会在遗传算法中再来看这个例题。</span></span><br><span class="line">x0 = [<span class="number">3</span> <span class="number">5</span> <span class="number">0</span> <span class="number">7</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">6</span> <span class="number">10</span> <span class="number">5</span> <span class="number">1</span> <span class="number">2</span> <span class="number">7</span>];  <span class="comment">% 用第一问的结果作为初始值</span></span><br><span class="line">[x,fval] = fmincon(@fun5,x0,A,b,Aeq,beq,lb)  <span class="comment">% 注意没有非线性约束，所以这里可以用[]替代，或者干脆不写</span></span><br><span class="line"><span class="built_in">reshape</span>(x(<span class="number">1</span>:<span class="number">12</span>),<span class="number">6</span>,<span class="number">2</span>)  <span class="comment">% 将x的前12个元素变为6行2列便于观察（reshape函数是按照列的顺序进行转换的，也就是第一列读完，读第二列，即x1对应x_1,1，x2对应x_2,1）</span></span><br><span class="line"><span class="comment">% 新坐标（5.74，4.99） （7.25，7.25）</span></span><br><span class="line"><span class="comment">% fval =</span></span><br><span class="line"><span class="comment">%           89.9231692432933</span></span><br><span class="line"><span class="comment">% 第一问的fval =</span></span><br><span class="line"><span class="comment">%           135.281541790676</span></span><br><span class="line"><span class="number">135.281541790676</span> - <span class="number">89.9231692432933</span>  <span class="comment">%  45.3583725473827</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">fun5</span><span class="params">(xx)</span>  % 注意为了避免和下面的<span class="title">x</span>同号，我们把决策变量的向量符号用<span class="title">xx</span>表示（注意<span class="title">xx</span>的长度为16）</span></span><br><span class="line">    a=[<span class="number">1.25</span>  <span class="number">8.75</span>  <span class="number">0.5</span>  <span class="number">5.75</span>  <span class="number">3</span>  <span class="number">7.25</span>];  <span class="comment">% 工地的横坐标</span></span><br><span class="line">    b=[<span class="number">1.25</span>  <span class="number">0.75</span>  <span class="number">4.75</span><span class="number">5</span>  <span class="number">6.5</span>  <span class="number">7.25</span>];   <span class="comment">% 工地的纵坐标</span></span><br><span class="line">    x = [xx(<span class="number">13</span>)  xx(<span class="number">15</span>)];  <span class="comment">% 新料场的横坐标</span></span><br><span class="line">    y = [xx(<span class="number">14</span>)  xx(<span class="number">16</span>)];  <span class="comment">% 新料场的纵坐标</span></span><br><span class="line">    c = [];  <span class="comment">% 初始化用来保存工地和料场距离的向量 (这个向量就是我们的系数向量）</span></span><br><span class="line">    <span class="keyword">for</span>  <span class="built_in">j</span> =<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">6</span></span><br><span class="line">            c = [c;  <span class="built_in">sqrt</span>( (a(<span class="built_in">i</span>)-x(<span class="built_in">j</span>))^<span class="number">2</span> + (b(<span class="built_in">i</span>)-y(<span class="built_in">j</span>))^<span class="number">2</span>)];  <span class="comment">% 每循环一次就在c的末尾插入新的元素</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="comment">% 下面我们要求吨千米数，注意c是列向量，我们计算非线性规划时给定的初始值x0是行向量</span></span><br><span class="line">    f = xx(<span class="number">1</span>:<span class="number">12</span>) * c;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最大最小化模型"><a href="#最大最小化模型" class="headerlink" title="最大最小化模型"></a>最大最小化模型</h1><p><img src="/images/image-20240129005314765.png" alt="image-20240129005314765"></p><h2 id="典型例题"><a href="#典型例题" class="headerlink" title="典型例题"></a>典型例题</h2><p><img src="/images/image-20240129005430279.png" alt="image-20240129005430279"></p><h2 id="模型求解"><a href="#模型求解" class="headerlink" title="模型求解"></a>模型求解</h2><p><img src="/images/image-20240129005556115.png" alt="image-20240129005556115"> </p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 最大最小化模型  :   min&#123;max[f1,f2,···,fm]&#125;</span></span><br><span class="line">x0 = [<span class="number">6</span>, <span class="number">6</span>];      <span class="comment">% 给定初始值</span></span><br><span class="line">lb = [<span class="number">3</span>, <span class="number">4</span>];  <span class="comment">% 决策变量的下界</span></span><br><span class="line">ub = [<span class="number">8</span>, <span class="number">10</span>];  <span class="comment">% 决策变量的上界</span></span><br><span class="line">[x,feval] = fminimax(@Fun,x0,[],[],[],[],lb,ub)</span><br><span class="line"><span class="built_in">max</span>(feval)</span><br><span class="line"><span class="comment">% x =</span></span><br><span class="line"><span class="comment">%     8.0000    8.5000</span></span><br><span class="line"><span class="comment">% feval =</span></span><br><span class="line"><span class="comment">%    13.5000    5.5000    5.5000   12.5000    8.5000    8.5000    5.5000   13.5000    9.5000    0.5000</span></span><br><span class="line"><span class="comment">% 结论：</span></span><br><span class="line"><span class="comment">% 在坐标为(8,8.5)处建立供应中心可以使该点到各需求点的最大距离最小，最小的最大距离为13.5单位。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> = <span class="title">Fun</span><span class="params">(x)</span></span></span><br><span class="line">    a=[<span class="number">1</span> <span class="number">4</span> <span class="number">3</span> <span class="number">5</span> <span class="number">9</span> <span class="number">12</span> <span class="number">6</span> <span class="number">20</span> <span class="number">17</span> <span class="number">8</span>];</span><br><span class="line">    b=[<span class="number">2</span> <span class="number">10</span> <span class="number">8</span> <span class="number">18</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">10</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">    <span class="comment">%  函数向量</span></span><br><span class="line">    f=<span class="built_in">zeros</span>(<span class="number">10</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">10</span></span><br><span class="line">        f(<span class="built_in">i</span>) = <span class="built_in">abs</span>(x(<span class="number">1</span>)-a(<span class="built_in">i</span>))+<span class="built_in">abs</span>(x(<span class="number">2</span>)-b(<span class="built_in">i</span>));  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="comment">% f(1) = abs(x(1)-a(1))+abs(x(2)-b(1));  </span></span><br><span class="line"><span class="comment">% f(2) = abs(x(1)-a(2))+abs(x(2)-b(2));</span></span><br><span class="line"><span class="comment">% f(3) = abs(x(1)-a(3))+abs(x(2)-b(3));</span></span><br><span class="line"><span class="comment">% f(4) = abs(x(1)-a(4))+abs(x(2)-b(4));</span></span><br><span class="line"><span class="comment">% f(5) = abs(x(1)-a(5))+abs(x(2)-b(5));</span></span><br><span class="line"><span class="comment">% f(6) = abs(x(1)-a(6))+abs(x(2)-b(6));</span></span><br><span class="line"><span class="comment">% f(7) = abs(x(1)-a(7))+abs(x(2)-b(7));</span></span><br><span class="line"><span class="comment">% f(8) = abs(x(1)-a(8))+abs(x(2)-b(8));</span></span><br><span class="line"><span class="comment">% f(9) = abs(x(1)-a(9))+abs(x(2)-b(9));</span></span><br><span class="line"><span class="comment">% f(10) = abs(x(1)-a(10))+abs(x(2)-b(10));</span></span><br><span class="line"><span class="keyword">end</span> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="多目标规划问题"><a href="#多目标规划问题" class="headerlink" title="多目标规划问题"></a>多目标规划问题</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/images/image-20240129010114001.png" alt="image-20240129010114001"></p><p>可能标准化，正向化，还有权重</p><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><p><img src="/images/image-20240129010157820.png" alt="image-20240129010157820"></p><p><img src="/images/image-20240129010334935.png" alt="image-20240129010334935"></p><p><img src="/images/image-20240129010535787.png" alt="image-20240129010535787"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  多目标规划问题</span></span><br><span class="line">w1 = <span class="number">0.4</span>;  w2 = <span class="number">0.6</span>;  <span class="comment">% 两个目标函数的权重  x1 = 5  x2 = 2</span></span><br><span class="line">w1 = <span class="number">0.5</span>;  w2 = <span class="number">0.5</span>;  <span class="comment">% 两个目标函数的权重  x1 = 5  x2 = 2</span></span><br><span class="line">w1 = <span class="number">0.3</span>;  w2 = <span class="number">0.7</span>;  <span class="comment">% 两个目标函数的权重  x1 = 1  x2 = 6</span></span><br><span class="line">c = [w1/<span class="number">30</span>*<span class="number">2</span>+w2/<span class="number">2</span>*<span class="number">0.4</span> ;w1/<span class="number">30</span>*<span class="number">5</span>+w2/<span class="number">2</span>*<span class="number">0.3</span>];  <span class="comment">% 线性规划目标函数的系数</span></span><br><span class="line">A = [<span class="number">-1</span> <span class="number">-1</span>];  b = <span class="number">-7</span>; <span class="comment">% 不等式约束</span></span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span>]&#x27;; ub = [<span class="number">5</span> <span class="number">6</span>]&#x27;; <span class="comment">% 上下界</span></span><br><span class="line">[x,fval] = linprog(c,A,b,[],[],lb,ub)</span><br><span class="line">f1 = <span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>)</span><br><span class="line">f2 = <span class="number">0.4</span>*x(<span class="number">1</span>) + <span class="number">0.3</span>*x(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 敏感性分析 </span></span><br><span class="line">clear;clc</span><br><span class="line">W1 = <span class="number">0.1</span>:<span class="number">0.001</span>:<span class="number">0.5</span>;  W2 = <span class="number">1</span>- W1;  </span><br><span class="line">n =<span class="built_in">length</span>(W1);</span><br><span class="line">F1 = <span class="built_in">zeros</span>(n,<span class="number">1</span>);  F2 = <span class="built_in">zeros</span>(n,<span class="number">1</span>);   X1 = <span class="built_in">zeros</span>(n,<span class="number">1</span>);  X2 = <span class="built_in">zeros</span>(n,<span class="number">1</span>);   FVAL = <span class="built_in">zeros</span>(n,<span class="number">1</span>);</span><br><span class="line">A = [<span class="number">-1</span> <span class="number">-1</span>];  b = <span class="number">-7</span>; <span class="comment">% 不等式约束</span></span><br><span class="line">lb = [<span class="number">0</span> <span class="number">0</span>]; ub = [<span class="number">5</span> <span class="number">6</span>]; <span class="comment">% 上下界</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    w1 = W1(<span class="built_in">i</span>);  w2 = W2(<span class="built_in">i</span>);</span><br><span class="line">    c = [w1/<span class="number">30</span>*<span class="number">2</span>+w2/<span class="number">2</span>*<span class="number">0.4</span> ;w1/<span class="number">30</span>*<span class="number">5</span>+w2/<span class="number">2</span>*<span class="number">0.3</span>];  <span class="comment">% 线性规划目标函数的系数</span></span><br><span class="line">    [x,fval] = linprog(c,A,b,[],[],lb,ub);</span><br><span class="line">    F1(<span class="built_in">i</span>) = <span class="number">2</span>*x(<span class="number">1</span>)+<span class="number">5</span>*x(<span class="number">2</span>);</span><br><span class="line">    F2(<span class="built_in">i</span>) = <span class="number">0.4</span>*x(<span class="number">1</span>) + <span class="number">0.3</span>*x(<span class="number">2</span>);</span><br><span class="line">    X1(<span class="built_in">i</span>) = x(<span class="number">1</span>);</span><br><span class="line">    X2(<span class="built_in">i</span>) = x(<span class="number">2</span>);</span><br><span class="line">    FVAL(<span class="built_in">i</span>) = fval;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 「Matlab」“LaTex字符汇总”讲解：https://blog.csdn.net/Robot_Starscream/article/details/89386748</span></span><br><span class="line"><span class="comment">% 在图上可以加上数据游标，按住Alt加鼠标左键可以设置多个数据游标出来。</span></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>) </span><br><span class="line"><span class="built_in">plot</span>(W1,F1,W1,F2)</span><br><span class="line">xlabel(<span class="string">&#x27;f_&#123;1&#125;的权重&#x27;</span>) </span><br><span class="line">ylabel(<span class="string">&#x27;f_&#123;1&#125;和f_&#123;2&#125;的取值&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;f_&#123;1&#125;&#x27;</span>,<span class="string">&#x27;f_&#123;2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">plot</span>(W1,X1,W1,X2)</span><br><span class="line">xlabel(<span class="string">&#x27;f_&#123;1&#125;的权重&#x27;</span>) </span><br><span class="line">ylabel(<span class="string">&#x27;x_&#123;1&#125;和x_&#123;2&#125;的取值&#x27;</span>)</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&#x27;x_&#123;1&#125;&#x27;</span>,<span class="string">&#x27;x_&#123;2&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">plot</span>(W1,FVAL)  <span class="comment">% 看起来是两个直线组合起来的下半部分</span></span><br><span class="line">xlabel(<span class="string">&#x27;f_&#123;1&#125;的权重&#x27;</span>) </span><br><span class="line">ylabel(<span class="string">&#x27;综合指标的值&#x27;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="完结撒花"><a href="#完结撒花" class="headerlink" title="完结撒花"></a>完结撒花</h1>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>烧烤时刻</title>
      <link href="/2024/01/28/%E7%83%A7%E7%83%A4%E6%97%B6%E5%88%BB/"/>
      <url>/2024/01/28/%E7%83%A7%E7%83%A4%E6%97%B6%E5%88%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="游宴不知厌，杜陵狂少年。"><a href="#游宴不知厌，杜陵狂少年。" class="headerlink" title="游宴不知厌，杜陵狂少年。"></a>游宴不知厌，杜陵狂少年。</h1><h1 id="花时轻暖酒，春服薄装绵。"><a href="#花时轻暖酒，春服薄装绵。" class="headerlink" title="花时轻暖酒，春服薄装绵。"></a>花时轻暖酒，春服薄装绵。</h1><p><img src="/images/640.png" alt="图片"></p><p><img src="/images/985889beb186fe5c4d3fb22de6a98b13.png" alt="985889beb186fe5c4d3fb22de6a98b13"></p><p><img src="/images/b59e31cabf980c09d6fa1bc0dd97cee1.png" alt="b59e31cabf980c09d6fa1bc0dd97cee1"></p><p><img src="/images/c65948928d58c5af4a5055224a1ca105.png" alt="c65948928d58c5af4a5055224a1ca105"></p><p><img src="/images/image-20240128204059274.png" alt="image-20240128204059274"></p>]]></content>
      
      
      <categories>
          
          <category> 少年游 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模糊综合评价模型</title>
      <link href="/2024/01/28/%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/01/28/%E6%A8%A1%E7%B3%8A%E7%BB%BC%E5%90%88%E8%AF%84%E4%BB%B7%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="模糊综合评价模型"><a href="#模糊综合评价模型" class="headerlink" title="模糊综合评价模型"></a>模糊综合评价模型</h1><p>核心在于模糊的概念</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="数学归纳法"><a href="#数学归纳法" class="headerlink" title="数学归纳法"></a>数学归纳法</h2><p><img src="/images/image-20240128192713567.png" alt="image-20240128192713567"></p><h2 id="数学的量的划分"><a href="#数学的量的划分" class="headerlink" title="数学的量的划分"></a>数学的量的划分</h2><p>确定性</p><p>不确定性</p><p><img src="/images/image-20240128192829255.png" alt="image-20240128192829255"></p><h2 id="模糊数学"><a href="#模糊数学" class="headerlink" title="模糊数学"></a>模糊数学</h2><p><img src="/images/image-20240128192918227.png" alt="image-20240128192918227"></p><h1 id="经典集合和模糊集合的基本概念"><a href="#经典集合和模糊集合的基本概念" class="headerlink" title="经典集合和模糊集合的基本概念"></a>经典集合和模糊集合的基本概念</h1><p>经典集合</p><p><img src="/images/image-20240128193114838.png" alt="image-20240128193114838"></p><p>  模糊集合：描述模糊性概念的集合</p><p><img src="/images/image-20240128193422098.png" alt="image-20240128193422098"></p><p>表示方法</p><p><img src="/images/image-20240128193903017.png" alt="image-20240128193903017"></p><p><img src="/images/image-20240128194009677.png" alt="image-20240128194009677"></p><h1 id="隶属函数的三种确定方法"><a href="#隶属函数的三种确定方法" class="headerlink" title="隶属函数的三种确定方法"></a>隶属函数的三种确定方法</h1><h2 id="模糊统计法"><a href="#模糊统计法" class="headerlink" title="模糊统计法"></a>模糊统计法</h2><blockquote><p>用的比较少的模糊统计法</p><p>找特别多人</p></blockquote><p><img src="/images/image-20240128194409356.png" alt="image-20240128194409356"></p><h2 id="借助已有的客观尺度"><a href="#借助已有的客观尺度" class="headerlink" title="借助已有的客观尺度"></a>借助已有的客观尺度</h2><p>合适的指标，并能收集到数据</p><p><img src="/images/image-20240128194540182.png" alt="image-20240128194540182"></p><h1 id="指派法"><a href="#指派法" class="headerlink" title="指派法"></a>指派法</h1><p>有很多分布，主要是梯形分布</p><p><img src="/images/image-20240128195038097.png" alt="image-20240128195038097"></p><p><img src="/images/image-20240128195025001.png" alt="image-20240128195025001"></p><h2 id="例题一"><a href="#例题一" class="headerlink" title="例题一"></a>例题一</h2><p><img src="/images/image-20240128195203066.png" alt="image-20240128195203066"></p><h2 id="例题二"><a href="#例题二" class="headerlink" title="例题二"></a>例题二</h2><p><img src="/images/image-20240128195305070.png" alt="image-20240128195305070"></p><p>梯形分布</p><p><img src="/images/image-20240128195426402.png" alt="image-20240128195426402"></p><h1 id="应用：模糊综合评价"><a href="#应用：模糊综合评价" class="headerlink" title="应用：模糊综合评价"></a>应用：模糊综合评价</h1><p><img src="/images/image-20240128195517785.png" alt="image-20240128195517785"></p><h2 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h2><p>确定因素集：相关性之间要不太强</p><p>确定评语集：由于每个指标的评价值不同，形成不同的等级。</p><p><img src="/images/image-20240128195716703.png" alt="image-20240128195716703"></p><blockquote><p>确定权重：Delphi法，专家法。</p><p> 无数据：层次分析法</p><p>有数据：熵权法</p><p>权重也需要归一化，确定的时候注意</p></blockquote><p>模糊综合判断矩阵</p><p><img src="/images/image-20240128200100963.png" alt="image-20240128200100963"><img src="/images/image-20240128200131978.png" alt="image-20240128200131978"></p><p>解释：第一列表示各个指标对于评语1的隶属度</p><p><img src="/images/image-20240128200239957.png" alt="image-20240128200239957"></p><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><p><img src="/images/image-20240128200407651.png" alt="image-20240128200407651"></p><p> 层次分析法得到权重</p><p><img src="/images/image-20240128200513147.png" alt="image-20240128200513147"></p><p><img src="/images/image-20240128200537561.png" alt="image-20240128200537561"></p><h1 id="一级模糊综合评价模型例子"><a href="#一级模糊综合评价模型例子" class="headerlink" title="一级模糊综合评价模型例子"></a>一级模糊综合评价模型例子</h1><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p><img src="/images/image-20240128200742371.png" alt="image-20240128200742371"></p><p>SO2的隶属度计算</p><p><img src="/images/image-20240128200932155.png" alt="image-20240128200932155"></p><p>同理：</p><p><img src="/images/image-20240128201002529.png" alt="image-20240128201002529"></p><p>AR&#x3D;<img src="/images/image-20240128201019735.png" alt="image-20240128201019735"></p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p> <img src="/images/image-20240128201137546.png" alt="image-20240128201137546"></p><p><img src="/images/image-20240128201342001.png" alt="image-20240128201342001"></p><p><img src="/images/image-20240128201252683.png" alt="image-20240128201252683"></p><h1 id="多级模糊综合评价模型的引入"><a href="#多级模糊综合评价模型的引入" class="headerlink" title="多级模糊综合评价模型的引入"></a>多级模糊综合评价模型的引入</h1><p><img src="/images/image-20240128202425981.png" alt="image-20240128202425981"></p><p><img src="/images/image-20240128202456942.png" alt="image-20240128202456942"></p><p><img src="/images/image-20240128202620958.png" alt="image-20240128202620958"></p><p><img src="/images/image-20240128202637622.png" alt="image-20240128202637622"></p><p>重复1的步骤2遍即可</p><h2 id="三极模糊综合评价模型"><a href="#三极模糊综合评价模型" class="headerlink" title="三极模糊综合评价模型"></a>三极模糊综合评价模型</h2><p><img src="/images/image-20240128202134589.png" alt="image-20240128202134589"></p><p>同理</p><p><img src="/images/image-20240128203040666.png" alt="image-20240128203040666"></p><p><img src="/images/image-20240128203115836.png" alt="image-20240128203115836"></p><p><img src="/images/image-20240128203122965.png" alt="image-20240128203122965"></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蒙特卡罗算法</title>
      <link href="/2024/01/28/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%AE%97%E6%B3%95/"/>
      <url>/2024/01/28/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="蒙特卡罗算法"><a href="#蒙特卡罗算法" class="headerlink" title="蒙特卡罗算法"></a>蒙特卡罗算法</h1><blockquote><p>通过随机数获得结果的算法。</p><p>当一个问题无法通过数学推导，计算机无法在有限时间求解时候。</p><p>就需要考虑蒙特卡洛方法了。</p><p>当无法求得精确解时候，进行随机抽样，根据统计试验求近似解。</p><p>可行域过大，没有通用方法求出精确解。</p><p>主要关键词是：随机抽样，统计试验，求近似解，构成统计意义。</p><p><img src="/images/image-20240128162555647.png" alt="image-20240128162555647"></p><p><img src="/images/image-20240128162628728.png" alt="image-20240128162628728"></p></blockquote><p><img src="/images/b5ac8a465f3a409d977f12e09b595d09.png" alt="img"></p><p><img src="/images/c364e117826240e2895aa2cac6d4dbce.png" alt="img"></p><h2 id="布丰投针实验"><a href="#布丰投针实验" class="headerlink" title="布丰投针实验"></a>布丰投针实验</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗用于布丰投针实验</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">%  rand(m,n)函数产生由在[0,1]之间均匀分布的随机数组成的m行n列的矩阵（或称为数组）。</span></span><br><span class="line"><span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment">%     0.8300    0.1048    0.2396    0.4398</span></span><br><span class="line"><span class="comment">%     0.5663    0.1196    0.8559    0.5817</span></span><br><span class="line"><span class="comment">%     0.9281    0.2574    0.3013    0.9355</span></span><br><span class="line"><span class="comment">%     0.3910    0.3173    0.2108    0.1676</span></span><br><span class="line"><span class="comment">%     0.3645    0.4372    0.8819    0.9232</span></span><br><span class="line"><span class="built_in">rand</span>(<span class="number">3</span>) <span class="comment">% 若只给一个输入，则会生成一个方阵</span></span><br><span class="line"><span class="comment">%     0.1709    0.4951    0.0541</span></span><br><span class="line"><span class="comment">%     0.9374    0.8500    0.6155</span></span><br><span class="line"><span class="comment">%     0.2400    0.3156    0.5741</span></span><br><span class="line"><span class="comment">% a + rand(m,n)*(b-a) 可以输出在[a,b]之间均匀分布的随机数组成的m行n列的矩阵。</span></span><br><span class="line"><span class="number">-2</span> + <span class="built_in">rand</span>(<span class="number">3</span>,<span class="number">2</span>) * (<span class="number">2</span> - (<span class="number">-2</span>))  <span class="comment">% 输出在[-2,2]之间均匀分布的随机数组成的3行2列的矩阵。</span></span><br><span class="line"><span class="comment">%    -1.2743    0.6013</span></span><br><span class="line"><span class="comment">%    -1.3084    0.0766</span></span><br><span class="line"><span class="comment">%     1.5075    0.7563</span></span><br><span class="line"><span class="comment">% a + rand(m,n)*(b-a)等价于unifrnd(a,b,m,n)</span></span><br><span class="line">unifrnd(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码部分</span></span><br><span class="line">l =  <span class="number">0.520</span>;     <span class="comment">% 针的长度（任意给的）</span></span><br><span class="line">a = <span class="number">1.314</span>;    <span class="comment">% 平行线的宽度(大于针的长度l即可)</span></span><br><span class="line">n = <span class="number">1000000</span>;    <span class="comment">% 做n次投针试验，n越大求出来的pi越准确</span></span><br><span class="line">m = <span class="number">0</span>;    <span class="comment">% 记录针与平行线相交的次数</span></span><br><span class="line">x = <span class="built_in">rand</span>(<span class="number">1</span>, n) * a / <span class="number">2</span> ;   <span class="comment">% 在[0, a/2]内服从均匀分布随机产生n个数， x中每一个元素表示针的中点和最近的一条平行线的距离</span></span><br><span class="line">phi = <span class="built_in">rand</span>(<span class="number">1</span>, n) * <span class="built_in">pi</span>;    <span class="comment">% 在[0, pi]内服从均匀分布随机产生n个数，phi中的每一个元素表示针和最近的一条平行线的夹角</span></span><br><span class="line"><span class="comment">% axis([0,pi, 0,a/2]);   box on;  % 画一个坐标轴的框架，x轴位于0-pi，y轴位于0-a/2， 并打开图形的边框</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n  <span class="comment">% 开始循环，依次看每根针是否和直线相交</span></span><br><span class="line">    <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt;= l / <span class="number">2</span> * <span class="built_in">sin</span>(phi (<span class="built_in">i</span>))     <span class="comment">% 如果针和平行线相交</span></span><br><span class="line">        m = m + <span class="number">1</span>;    <span class="comment">% 那么m就要加1</span></span><br><span class="line"><span class="comment">%         plot(phi(i), x(i), &#x27;r.&#x27;)   % 模仿书上的那个图，横坐标为phi，纵坐标为x , 用红色的小点进行标记</span></span><br><span class="line"><span class="comment">%         hold on  % 在原来的图形上继续绘制</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">p = m / n;    <span class="comment">% 针和平行线相交出现的频率</span></span><br><span class="line">mypi = (<span class="number">2</span> * l) / (a * p);  <span class="comment">% 我们根据公式计算得到的pi</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到pi为：&#x27;</span>, num2str(mypi)])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （3） 由于一次模拟的结果具有偶然性，因此我们可以重复100次后再来求一个平均的pi</span></span><br><span class="line">result = <span class="built_in">zeros</span>(<span class="number">100</span>,<span class="number">1</span>);  <span class="comment">% 初始化保存100次结果的矩阵</span></span><br><span class="line">l =  <span class="number">0.520</span>;     a = <span class="number">1.314</span>;</span><br><span class="line">n = <span class="number">1000000</span>;    </span><br><span class="line"><span class="keyword">for</span> num = <span class="number">1</span>:<span class="number">100</span></span><br><span class="line">    m = <span class="number">0</span>;  </span><br><span class="line">    x = <span class="built_in">rand</span>(<span class="number">1</span>, n) * a / <span class="number">2</span> ;</span><br><span class="line">    phi = <span class="built_in">rand</span>(<span class="number">1</span>, n) * <span class="built_in">pi</span>;</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt;= l / <span class="number">2</span> * <span class="built_in">sin</span>(phi (<span class="built_in">i</span>))</span><br><span class="line">            m = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    p = m / n;</span><br><span class="line">    mypi = (<span class="number">2</span> * l) / (a * p);</span><br><span class="line">    result(num) = mypi;  <span class="comment">% 把求出来的myphi保存到结果矩阵中</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">mymeanpi = <span class="built_in">mean</span>(result);  <span class="comment">% 计算result矩阵中保存的100次结果的均值</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到pi为：&#x27;</span>, num2str(mymeanpi)])</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>这行代码生成一个大小为 5x4 的矩阵，其中的元素是在区间 [0, 1] 内均匀分布的随机数。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matlabCopy code</span><br><span class="line"><span class="built_in">rand</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>这行代码生成一个大小为 3x3 的方阵，其中的元素同样是在区间 [0, 1] 内均匀分布的随机数。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matlabCopy code</span><br><span class="line"><span class="number">-2</span> + <span class="built_in">rand</span>(<span class="number">3</span>,<span class="number">2</span>) * (<span class="number">2</span> - (<span class="number">-2</span>))</span><br></pre></td></tr></table></figure><p>这行代码生成一个大小为 3x2 的矩阵，其中的元素是在区间 [-2, 2] 内均匀分布的随机数。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matlabCopy code</span><br><span class="line">unifrnd(<span class="number">-2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>这是另一种生成大小为 3x2 的矩阵，元素在区间 [-2, 2] 内均匀分布的方法。</p><p>现在，我们来看实际的代码部分：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">matlabCopy codel = <span class="number">0.520</span>;     <span class="comment">% 针的长度</span></span><br><span class="line">a = <span class="number">1.314</span>;     <span class="comment">% 平行线的宽度（应大于针的长度）</span></span><br><span class="line">n = <span class="number">1000000</span>;   <span class="comment">% 投针实验的次数</span></span><br><span class="line">m = <span class="number">0</span>;         <span class="comment">% 记录针与平行线相交的次数</span></span><br><span class="line"></span><br><span class="line">x = <span class="built_in">rand</span>(<span class="number">1</span>, n) * a / <span class="number">2</span>;   <span class="comment">% 在 [0, a/2] 内生成 n 个随机数，表示针的中点距离最近平行线的距离</span></span><br><span class="line">phi = <span class="built_in">rand</span>(<span class="number">1</span>, n) * <span class="built_in">pi</span>;    <span class="comment">% 在 [0, pi] 内生成 n 个随机数，表示针与最近平行线的夹角</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 循环，检查每次实验中针是否与平行线相交</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    <span class="keyword">if</span> x(<span class="built_in">i</span>) &lt;= l / <span class="number">2</span> * <span class="built_in">sin</span>(phi(<span class="built_in">i</span>))</span><br><span class="line">        m = m + <span class="number">1</span>;  <span class="comment">% 如果相交，计数加一</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">p = m / n;    <span class="comment">% 针与平行线相交的概率</span></span><br><span class="line">mypi = (<span class="number">2</span> * l) / (a * p);  <span class="comment">% 使用蒙特卡罗方法估算 pi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的 pi 估计值：&#x27;</span>, num2str(mypi)])</span><br></pre></td></tr></table></figure><p>该代码模拟了布丰投针实验，其中一根长度为 <code>l</code> 的针被投在两条间距为 <code>a</code> 的平行线上。通过估算针与线相交的概率，利用蒙特卡罗方法估计 π 的值。</p><p>最后，代码对实验重复进行了 100 次，并计算了这些实验中 π 估计值的平均值，使用 <code>disp</code> 函数显示结果。</p><h1 id="三门问题"><a href="#三门问题" class="headerlink" title="三门问题"></a>三门问题</h1><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗用于模拟三门问题</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% randi([a,b],m,n)函数可在指定区间[a,b]内随机取出大小为m*n的整数矩阵</span></span><br><span class="line">randi([<span class="number">1</span>,<span class="number">5</span>],<span class="number">5</span>,<span class="number">8</span>) <span class="comment">%在区间[1,5]内随机取出大小为5*8的整数矩阵</span></span><br><span class="line"><span class="comment">%      2     5     4     5     3     1     4     2</span></span><br><span class="line"><span class="comment">%      3     3     1     5     4     2     1     2</span></span><br><span class="line"><span class="comment">%      4     1     3     3     2     2     5     1</span></span><br><span class="line"><span class="comment">%      5     3     3     4     4     5     4     4</span></span><br><span class="line"><span class="comment">%      4     2     3     4     2     4     2     4</span></span><br><span class="line">randi([<span class="number">1</span>,<span class="number">5</span>])   <span class="comment">%在区间[1,5]内随机取出1个整数</span></span><br><span class="line"><span class="comment">%     3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 字符串的连接方式：(1)[&#x27;字符串1&#x27;,&#x27;字符串2&#x27;] (2)strcat(&#x27;字符串1&#x27;,&#x27;字符串2&#x27;) （第一期视频第一讲）</span></span><br><span class="line">[<span class="string">&#x27;数学建模&#x27;</span>,<span class="string">&#x27;学习交流&#x27;</span>] </span><br><span class="line">strcat(<span class="string">&#x27;数学建模&#x27;</span>,<span class="string">&#x27;学习交流&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% num2str函数：将数值转换为字符串 （第一期视频第一讲）</span></span><br><span class="line">mystr = num2str(<span class="number">1224</span>)  <span class="comment">% 注意观察工作区的mystr这个变量的值</span></span><br><span class="line"><span class="built_in">disp</span>([num2str(<span class="number">1224</span>),<span class="string">&#x27;祝大家平安夜平平安安&#x27;</span>])  <span class="comment">% disp函数是输出函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码部分（在成功的条件下的概率）</span></span><br><span class="line">n = <span class="number">100000</span>;  <span class="comment">% n代表蒙特卡罗模拟重复次数</span></span><br><span class="line">a = <span class="number">0</span>;  <span class="comment">% a表示不改变主意时能赢得汽车的次数</span></span><br><span class="line">b = <span class="number">0</span>;  <span class="comment">% b表示改变主意时能赢得汽车的次数</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>= <span class="number">1</span> : n  <span class="comment">% 开始模拟n次</span></span><br><span class="line">    x = randi([<span class="number">1</span>,<span class="number">3</span>]);  <span class="comment">% 随机生成一个1-3之间的整数x表示汽车出现在第x扇门后</span></span><br><span class="line">    y = randi([<span class="number">1</span>,<span class="number">3</span>]);  <span class="comment">% 随机生成一个1-3之间的整数y表示自己选的门</span></span><br><span class="line">    <span class="comment">% 下面分为两种情况讨论：x=y和x~=y</span></span><br><span class="line">    <span class="keyword">if</span> x == y   <span class="comment">% 如果x和y相同，那么我们只有不改变主意时才能赢</span></span><br><span class="line">        a = a + <span class="number">1</span>;     b = b + <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">% x ~= y ，如果x和y不同，那么我们只有改变主意时才能赢</span></span><br><span class="line">        a = a + <span class="number">0</span>;     b = b +<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的不改变主意时的获奖概率为：&#x27;</span>, num2str(a/n)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的改变主意时的获奖概率为：&#x27;</span>, num2str(b/n)]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （3）考虑失败情况的代码(无条件概率)</span></span><br><span class="line">n = <span class="number">100000</span>;  <span class="comment">% n代表蒙特卡罗模拟重复次数</span></span><br><span class="line">a = <span class="number">0</span>;  <span class="comment">% a表示不改变主意时能赢得汽车的次数</span></span><br><span class="line">b = <span class="number">0</span>;  <span class="comment">% b表示改变主意时能赢得汽车的次数</span></span><br><span class="line">c = <span class="number">0</span>;  <span class="comment">% c表示没有获奖的次数</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>= <span class="number">1</span> : n  <span class="comment">% 开始模拟n次</span></span><br><span class="line">    x = randi([<span class="number">1</span>,<span class="number">3</span>]);  <span class="comment">% 随机生成一个1-3之间的整数x表示汽车出现在第x扇门后</span></span><br><span class="line">    y = randi([<span class="number">1</span>,<span class="number">3</span>]);  <span class="comment">% 随机生成一个1-3之间的整数y表示自己选的门</span></span><br><span class="line">    change = randi([<span class="number">0</span>, <span class="number">1</span>]); <span class="comment">% change =0  不改变主意，change = 1 改变主意</span></span><br><span class="line">    <span class="comment">% 下面分为两种情况讨论：x=y和x~=y</span></span><br><span class="line">    <span class="keyword">if</span> x == y   <span class="comment">% 如果x和y相同，那么我们只有不改变主意时才能赢</span></span><br><span class="line">        <span class="keyword">if</span> change == <span class="number">0</span>  <span class="comment">% 不改变主意</span></span><br><span class="line">        a = a + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">% 改变了主意</span></span><br><span class="line">            c= c+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">else</span>  <span class="comment">% x ~= y ，如果x和y不同，那么我们只有改变主意时才能赢</span></span><br><span class="line">         <span class="keyword">if</span> change == <span class="number">0</span>  <span class="comment">% 不改变主意</span></span><br><span class="line">        c = c + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">else</span>  <span class="comment">% 改变了主意</span></span><br><span class="line">            b= b + <span class="number">1</span>;</span><br><span class="line">         <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的不改变主意时的获奖概率为：&#x27;</span>, num2str(a/n)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的改变主意时的获奖概率为：&#x27;</span>, num2str(b/n)]);</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;蒙特卡罗方法得到的没有获奖的概率为：&#x27;</span>, num2str(c/n)]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="模拟排队问题"><a href="#模拟排队问题" class="headerlink" title="模拟排队问题"></a>模拟排队问题</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/images/image-20240128164023606.png" alt="image-20240128164023606"></p><h2 id="符号说明"><a href="#符号说明" class="headerlink" title="符号说明"></a>符号说明</h2><p><img src="/images/image-20240128164111990.png" alt="image-20240128164111990"></p><h2 id="概率论知识：指数分布"><a href="#概率论知识：指数分布" class="headerlink" title="概率论知识：指数分布"></a>概率论知识：指数分布</h2><p><img src="/images/image-20240128164257103.png" alt="image-20240128164257103"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗模拟排队问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% normrnd(MU,SIGMA):生成一个服从正态分布(MU参数代表均值,SIGMA参数代表标准差,方差开根号是标准差)的随机数</span></span><br><span class="line">normrnd(<span class="number">10</span>,<span class="number">2</span>)  <span class="comment">% 均值为10 标准差为2（方差为4）的正态分布随机数</span></span><br><span class="line"><span class="comment">% exprnd(M)表示生成一个均值为M的指数分布随机数(其对应的参数为1/M)</span></span><br><span class="line">exprnd(<span class="number">5</span>)  <span class="comment">% 均值为5的指数分布随机数（对应的参数为0.2）</span></span><br><span class="line"><span class="comment">% mean函数是用来求解均值的函数（第一期视频第五讲）</span></span><br><span class="line"><span class="built_in">mean</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">% tic函数和toc函数可以用来返回代码运行的时间，例如我们要计算一段代码的运行时间，就可以在这段代码前加上tic，在这段代码后加上toc (我的微信公众号&quot;数学建模学习交流&quot;中有一篇推送《为什么要对代码初始化》中使用过这对函数)</span></span><br><span class="line">tic</span><br><span class="line">a = <span class="number">2</span>^<span class="number">100</span></span><br><span class="line">toc</span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）模型中出现的变量的说明</span></span><br><span class="line"><span class="comment">% x(i)表示第i-1个客户和第i个客户到达的间隔时间，服从参数为0.1的指数分布</span></span><br><span class="line"><span class="comment">% y(i)表示第i个客户的服务持续时间，服从均值为10方差为4(标准差为2)的正态分布 (若小于1则按1计算)</span></span><br><span class="line"><span class="comment">% c(i)表示第i个客户的到达时间，那么c(i) = c(i-1) + x(i)，初始值c0=0</span></span><br><span class="line"><span class="comment">% b(i)表示第i个客户开始服务的时间</span></span><br><span class="line"><span class="comment">% e(i)表示第i个客户结束服务的时间，初始值e0=0</span></span><br><span class="line"><span class="comment">% 第i个客户结束服务的时间 = 第i个客户开始服务的时间 + 第i个客户的服务持续时间</span></span><br><span class="line"><span class="comment">% 即：e(i) = b(i) + y(i）</span></span><br><span class="line"><span class="comment">% 第i个客户开始服务的时间取决于该客户的到达时间和上一个客户结束服务的时间</span></span><br><span class="line"><span class="comment">% 即：b(i) = max(c(i),e(i-1))，初始值b1=c1;</span></span><br><span class="line"><span class="comment">% 第i个客户等待的时间 = 第i个客户开始服务的时间 - 第i个客户到达银行的时间</span></span><br><span class="line"><span class="comment">% 即：wait(i) = b(i) - c(i)</span></span><br><span class="line"><span class="comment">% w表示所有客户等待时间的总和</span></span><br><span class="line"><span class="comment">% 假设一天内银行最终服务了n个顾客，那么客户的平均等待时间t = w/n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （3）问题1的代码</span></span><br><span class="line">clear</span><br><span class="line">tic  <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line"><span class="built_in">i</span> = <span class="number">1</span>;  <span class="comment">% i表示第i个客户，最开始取i=1</span></span><br><span class="line">w = <span class="number">0</span>;  <span class="comment">% w用来表示所有客户等待的总时间，初始化为0</span></span><br><span class="line">e0 = <span class="number">0</span>;  c0 = <span class="number">0</span>;   <span class="comment">% 初始化e0和c0为0</span></span><br><span class="line">x(<span class="number">1</span>) = exprnd(<span class="number">10</span>);  <span class="comment">% 第0个客户(假想的)和第1个客户到达的时间间隔</span></span><br><span class="line">c(<span class="number">1</span>) = c0 + x(<span class="number">1</span>);  <span class="comment">% 第1个客户到达的时间</span></span><br><span class="line">b(<span class="number">1</span>) = c(<span class="number">1</span>); <span class="comment">% 第1个客户的开始服务的时间</span></span><br><span class="line"><span class="keyword">while</span> b(<span class="built_in">i</span>) &lt;= <span class="number">480</span>  <span class="comment">% 开始设置循环，只要第i个顾客开始服务的时间(时刻)小于480，就可以对其服务（银行每天工作8小时，折换为分钟就是480分钟）</span></span><br><span class="line">    y(<span class="built_in">i</span>) = normrnd(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">% 第i个客户的服务持续时间，服从均值为10方差为4(标准差为2)的正态分布</span></span><br><span class="line">    <span class="keyword">if</span> y(<span class="built_in">i</span>) &lt; <span class="number">1</span>  <span class="comment">% 根据题目的意思：若服务持续时间不足一分钟，则按照一分钟计算</span></span><br><span class="line">        y(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    e(<span class="built_in">i</span>) = b(<span class="built_in">i</span>) + y(<span class="built_in">i</span>); <span class="comment">% 第i个客户结束服务的时间 = 第i个客户开始服务的时间 + 第i个客户的服务持续时间</span></span><br><span class="line">    wait(<span class="built_in">i</span>) = b(<span class="built_in">i</span>) - c(<span class="built_in">i</span>); <span class="comment">% 第i个客户等待的时间 = 第i个客户开始服务的时间 - 第i个客户到达银行的时间</span></span><br><span class="line">    w = w + wait(<span class="built_in">i</span>); <span class="comment">% 更新所有客户等待的总时间</span></span><br><span class="line">    <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>; <span class="comment">% 增加一名新的客户</span></span><br><span class="line">    x(<span class="built_in">i</span>) = exprnd(<span class="number">10</span>); <span class="comment">% 这位新客户和上一个客户到达的时间间隔</span></span><br><span class="line">    c(<span class="built_in">i</span>) = c(<span class="built_in">i</span><span class="number">-1</span>) + x(<span class="built_in">i</span>); <span class="comment">% 这位新客户到达银行的时间 = 上一个客户到达银行的时间 + 这位新客户和上一个客户到达的时间间隔</span></span><br><span class="line">    b(<span class="built_in">i</span>) = <span class="built_in">max</span>(c(<span class="built_in">i</span>),e(<span class="built_in">i</span><span class="number">-1</span>)); <span class="comment">% 这个新客户开始服务的时间取决于其到达时间和上一个客户结束服务的时间</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">n = <span class="built_in">i</span><span class="number">-1</span>; <span class="comment">% n表示银行一天8小时一共服务的客户人数</span></span><br><span class="line">t = w/n; <span class="comment">% 客户的平均等待时间</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;银行一天8小时一共服务的客户人数为: &#x27;</span>,num2str(n)])</span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;客户的平均等待时间为: &#x27;</span>,num2str(t)])</span><br><span class="line">toc  <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （4）问题2的代码</span></span><br><span class="line">clear</span><br><span class="line">tic  <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line">day = <span class="number">100</span>;  <span class="comment">% 假设模拟100天</span></span><br><span class="line">n = <span class="built_in">zeros</span>(day,<span class="number">1</span>); <span class="comment">% 初始化用来保存每日接待客户数结果的矩阵</span></span><br><span class="line">t = <span class="built_in">zeros</span>(day,<span class="number">1</span>); <span class="comment">% 初始化用来保存每日客户平均等待时长的矩阵</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:day</span><br><span class="line">    <span class="built_in">i</span> = <span class="number">1</span>;  <span class="comment">% i表示第i个客户，最开始取i=1</span></span><br><span class="line">    w = <span class="number">0</span>;  <span class="comment">% w用来表示所有客户等待的总时间，初始化为0</span></span><br><span class="line">    e0 = <span class="number">0</span>;  c0 = <span class="number">0</span>;   <span class="comment">% 初始化e0和c0为0</span></span><br><span class="line">    x(<span class="number">1</span>) = exprnd(<span class="number">10</span>);  <span class="comment">% 第0个客户(假想的)和第1个客户到达的时间间隔</span></span><br><span class="line">    c(<span class="number">1</span>) = c0 + x(<span class="number">1</span>);  <span class="comment">% 第1个客户到达的时间</span></span><br><span class="line">    b(<span class="number">1</span>) = c(<span class="number">1</span>); <span class="comment">% 第1个客户的开始服务的时间</span></span><br><span class="line">    <span class="keyword">while</span> b(<span class="built_in">i</span>) &lt;= <span class="number">480</span>  <span class="comment">% 开始设置循环，只要第i个顾客开始服务的时间(时刻)小于480，就可以对其服务（银行每天工作8小时，折换为分钟就是480分钟）</span></span><br><span class="line">        y(<span class="built_in">i</span>) = normrnd(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">% 第i个客户的服务持续时间，服从均值为10方差为4(标准差为2)的正态分布</span></span><br><span class="line">        <span class="keyword">if</span> y(<span class="built_in">i</span>) &lt; <span class="number">1</span>  <span class="comment">% 根据题目的意思：若服务持续时间不足一分钟，则按照一分钟计算</span></span><br><span class="line">            y(<span class="built_in">i</span>) = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        e(<span class="built_in">i</span>) = b(<span class="built_in">i</span>) + y(<span class="built_in">i</span>); <span class="comment">% 第i个客户结束服务的时间 = 第i个客户开始服务的时间 + 第i个客户的服务持续时间</span></span><br><span class="line">        wait(<span class="built_in">i</span>) = b(<span class="built_in">i</span>) - c(<span class="built_in">i</span>); <span class="comment">% 第i个客户等待的时间 = 第i个客户开始服务的时间 - 第i个客户到达银行的时间</span></span><br><span class="line">        w = w + wait(<span class="built_in">i</span>); <span class="comment">% 更新所有客户等待的总时间</span></span><br><span class="line">        <span class="built_in">i</span> = <span class="built_in">i</span> + <span class="number">1</span>; <span class="comment">% 增加一名新的客户</span></span><br><span class="line">        x(<span class="built_in">i</span>) = exprnd(<span class="number">10</span>); <span class="comment">% 这位新客户和上一个客户到达的时间间隔</span></span><br><span class="line">        c(<span class="built_in">i</span>) = c(<span class="built_in">i</span><span class="number">-1</span>) + x(<span class="built_in">i</span>); <span class="comment">% 这位新客户到达银行的时间 = 上一个客户到达银行的时间 + 这位新客户和上一个客户到达的时间间隔</span></span><br><span class="line">        b(<span class="built_in">i</span>) = <span class="built_in">max</span>(c(<span class="built_in">i</span>),e(<span class="built_in">i</span><span class="number">-1</span>)); <span class="comment">% 这个新客户开始服务的时间取决于其到达时间和上一个客户结束服务的时间</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    n(k) = <span class="built_in">i</span><span class="number">-1</span>; <span class="comment">% n(k)表示银行第k天服务的客户人数</span></span><br><span class="line">    t(k) = w/n(k); <span class="comment">% t(k)表示该银行第k天客户的平均等待时间</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>([num2str(day),<span class="string">&#x27;个工作日中，银行每日平均服务的客户人数为: &#x27;</span>,num2str(<span class="built_in">mean</span>(n))])</span><br><span class="line"><span class="built_in">disp</span>([num2str(day),<span class="string">&#x27;个工作日中，银行每日客户的平均等待时间为: &#x27;</span>,num2str(<span class="built_in">mean</span>(t))])</span><br><span class="line">toc  <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br></pre></td></tr></table></figure><h1 id="有约束的非线性规划问题"><a href="#有约束的非线性规划问题" class="headerlink" title="有约束的非线性规划问题"></a>有约束的非线性规划问题</h1><p><img src="/images/image-20240128165151448.png" alt="image-20240128165151448"></p><h2 id="模拟过程"><a href="#模拟过程" class="headerlink" title="模拟过程"></a>模拟过程</h2><p><img src="/images/image-20240128165652066.png" alt="image-20240128165652066"></p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗求解有约束的非线性规划问题</span></span><br><span class="line"><span class="comment">% max f(x) = x1*x2*x3</span></span><br><span class="line"><span class="comment">% s.t.</span></span><br><span class="line"><span class="comment">% (1) -x1+2*x2+2*x3&gt;=0</span></span><br><span class="line"><span class="comment">% (2) x1+2*x2+2*x3&lt;=72</span></span><br><span class="line"><span class="comment">% (3) x2&lt;=20 &amp; x2&gt;=10</span></span><br><span class="line"><span class="comment">% (4) x1-x2 == 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">%  (1) format long g  可以将Matlab的计算结果显示为一般的长数字格式（默认会保留四位小数，或使用科学计数法）</span></span><br><span class="line"><span class="number">5</span>/<span class="number">7</span></span><br><span class="line"><span class="number">5895</span>*<span class="number">514100</span></span><br><span class="line">format long g</span><br><span class="line"><span class="comment">%改变显示方式</span></span><br><span class="line"><span class="number">5</span>/<span class="number">7</span></span><br><span class="line"><span class="number">5895</span>*<span class="number">514100</span></span><br><span class="line"><span class="comment">%  (2)unifrnd(a,b,m,n)可以输出在[a,b]之间均匀分布的随机数组成的m行n列的矩阵。(等价于 a + rand(m,n)*(b-a))</span></span><br><span class="line">unifrnd(<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment">%           4.07361843196589          3.16179623112705          4.78753417717149</span></span><br><span class="line"><span class="comment">%            4.5289596853781         0.487702024997048          4.82444267599638</span></span><br><span class="line"><span class="comment">%           0.63493408146753          1.39249109433524         0.788065408387741</span></span><br><span class="line"><span class="comment">%            4.5668792806951          2.73440759602492          4.85296390880308</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码部分</span></span><br><span class="line">clc,clear;</span><br><span class="line">tic <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">20</span>,<span class="number">30</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[20,30]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2=x1 - <span class="number">10</span>;</span><br><span class="line">x3=unifrnd(<span class="number">-10</span>,<span class="number">16</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[-10,16]之间均匀分布的随机数组成的n行1列的向量构成x3</span></span><br><span class="line">fmax=-<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最大值为负无穷（后续只要找到一个比它大的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>), x3(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2, x3]</span></span><br><span class="line">    <span class="keyword">if</span> (-x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)&gt;=<span class="number">0</span>)  &amp;  (x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)&lt;=<span class="number">72</span>)     <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result = x(<span class="number">1</span>)*x(<span class="number">2</span>)*x(<span class="number">3</span>);  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &gt; fmax  <span class="comment">% 如果这个函数值大于我们之前计算出来的最大值</span></span><br><span class="line">            fmax = result;  <span class="comment">% 那么就更新这个函数值为新的最大值</span></span><br><span class="line">            X = x;  <span class="comment">% 并且将此时的x1 x2 x3保存到一个变量中</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">&#x27;蒙特卡罗模拟得到的最大值为&#x27;</span>,num2str(fmax)))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最大值处x1 x2 x3的取值为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(X)</span><br><span class="line">toc <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%缩小范围了</span></span><br><span class="line"><span class="comment">%% （3）缩小范围重新模拟得到更加精确的取值</span></span><br><span class="line">clc,clear;</span><br><span class="line">tic <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line">n=<span class="number">10000000</span>; <span class="comment">%生成的随机数组数</span></span><br><span class="line">x1=unifrnd(<span class="number">22</span>,<span class="number">23</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[22,23]之间均匀分布的随机数组成的n行1列的向量构成x1</span></span><br><span class="line">x2=x1 - <span class="number">10</span>;</span><br><span class="line">x3=unifrnd(<span class="number">11</span>,<span class="number">13</span>,n,<span class="number">1</span>);  <span class="comment">% 生成在[11,13]之间均匀分布的随机数组成的n行1列的向量构成x3</span></span><br><span class="line">fmax=-<span class="built_in">inf</span>; <span class="comment">% 初始化函数f的最大值为负无穷（后续只要找到一个比它大的我们就对其更新）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n</span><br><span class="line">    x = [x1(<span class="built_in">i</span>), x2(<span class="built_in">i</span>), x3(<span class="built_in">i</span>)];  <span class="comment">%构造x向量, 这里千万别写成了：x =[x1, x2, x3]</span></span><br><span class="line">    <span class="keyword">if</span> (-x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)&gt;=<span class="number">0</span>)  &amp;  (x(<span class="number">1</span>)+<span class="number">2</span>*x(<span class="number">2</span>)+<span class="number">2</span>*x(<span class="number">3</span>)&lt;=<span class="number">72</span>)     <span class="comment">% 判断是否满足条件</span></span><br><span class="line">        result = x(<span class="number">1</span>)*x(<span class="number">2</span>)*x(<span class="number">3</span>);  <span class="comment">% 如果满足条件就计算函数值</span></span><br><span class="line">        <span class="keyword">if</span>  result  &gt; fmax  <span class="comment">% 如果这个函数值大于我们之前计算出来的最大值</span></span><br><span class="line">            fmax = result;  <span class="comment">% 那么就更新这个函数值为新的最大值</span></span><br><span class="line">            X = x;  <span class="comment">% 并且将此时的x1 x2 x3保存到一个变量中</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">disp</span>(strcat(<span class="string">&#x27;蒙特卡罗模拟得到的最大值为&#x27;</span>,num2str(fmax)))</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;最大值处x1 x2 x3的取值为：&#x27;</span>)</span><br><span class="line"><span class="built_in">disp</span>(X)</span><br><span class="line">toc <span class="comment">%计算tic和toc中间部分的代码的运行时间</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="书店买书问题（01规划问题）"><a href="#书店买书问题（01规划问题）" class="headerlink" title="书店买书问题（01规划问题）"></a>书店买书问题（01规划问题）</h1><p><img src="/images/image-20240128170255695.png" alt="image-20240128170255695"></p><p>哈希！</p><p>用来代表买不买哇</p><p><img src="/images/image-20240128170521256.png" alt="image-20240128170521256"></p><p><img src="/images/image-20240128170547061.png" alt="image-20240128170547061"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 书店买书问题的蒙特卡罗的模拟</span></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% (1)unique函数: 剔除一个矩阵或者向量的重复值，并将结果按照从小到大的顺序排列  </span></span><br><span class="line"><span class="comment">% adj.唯一的; 独一无二的   [ju&#x27;ni:k]</span></span><br><span class="line">unique([<span class="number">1</span> <span class="number">2</span> <span class="number">5</span>; <span class="number">6</span> <span class="number">8</span> <span class="number">9</span>;<span class="number">2</span> <span class="number">4</span> <span class="number">6</span>])   </span><br><span class="line">unique([<span class="number">5</span> <span class="number">6</span> <span class="number">8</span> <span class="number">8</span> <span class="number">4</span> <span class="number">1</span> <span class="number">6</span> <span class="number">2</span> <span class="number">2</span> <span class="number">4</span> <span class="number">8</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">% (2)randi([a,b],m,n)函数可在指定区间[a,b]内随机取出大小为m*n的整数矩阵</span></span><br><span class="line">randi([<span class="number">-5</span>,<span class="number">5</span>],<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码求解</span></span><br><span class="line">min_money = +Inf;  <span class="comment">% 初始化最小的花费为无穷大，后续只要找到比它小的就更新</span></span><br><span class="line">min_result = randi([<span class="number">1</span>, <span class="number">6</span>],<span class="number">1</span>,<span class="number">5</span>);  <span class="comment">% 初始化五本书都在哪一家书店购买，后续我们不断对其更新</span></span><br><span class="line"><span class="comment">%若min_result = [5 3 6 2 3]，则解释为：第1本书在第5家店买，第2本书在第3家店买，第3本书在第6家店买，第4本书在第2家店买，第5本书在第3家店买  </span></span><br><span class="line">n = <span class="number">100000</span>;  <span class="comment">% 蒙特卡罗模拟的次数</span></span><br><span class="line">M = [<span class="number">18</span> <span class="number">39</span><span class="number">29</span><span class="number">48</span><span class="number">59</span></span><br><span class="line">        <span class="number">24</span><span class="number">45</span><span class="number">23</span><span class="number">54</span><span class="number">44</span></span><br><span class="line">        <span class="number">22</span><span class="number">45</span><span class="number">23</span><span class="number">53</span><span class="number">53</span></span><br><span class="line">        <span class="number">28</span><span class="number">47</span><span class="number">17</span><span class="number">57</span><span class="number">47</span></span><br><span class="line">        <span class="number">24</span><span class="number">42</span><span class="number">24</span><span class="number">47</span><span class="number">59</span></span><br><span class="line">        <span class="number">27</span><span class="number">48</span><span class="number">20</span><span class="number">55</span><span class="number">53</span>];  <span class="comment">% m_ij  第j本书在第i家店的售价</span></span><br><span class="line">freight = [<span class="number">10</span> <span class="number">15</span> <span class="number">15</span> <span class="number">10</span> <span class="number">10</span> <span class="number">15</span>];  <span class="comment">% 第i家店的运费</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:n  <span class="comment">% 开始循环</span></span><br><span class="line">    result = randi([<span class="number">1</span>, <span class="number">6</span>],<span class="number">1</span>,<span class="number">5</span>); <span class="comment">% 在1-6这些整数中随机抽取一个1*5的向量，表示这五本书分别在哪家书店购买</span></span><br><span class="line">    index = unique(result);  <span class="comment">% 在哪些商店购买了商品，因为我们等下要计算运费</span></span><br><span class="line">    money = sum(freight(index)); <span class="comment">% 计算买书花费的运费</span></span><br><span class="line">    <span class="comment">% 计算总花费：刚刚计算出来的运费 + 五本书的售价</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">5</span>   </span><br><span class="line">        money = money + M(result(<span class="built_in">i</span>),<span class="built_in">i</span>);  </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> money &lt; min_money  <span class="comment">% 判断刚刚随机生成的这组数据的花费是否小于最小花费，如果小于的话</span></span><br><span class="line">        min_money = money  <span class="comment">% 我们更新最小的花费</span></span><br><span class="line">        min_result = result <span class="comment">% 用这组数据更新最小花费的结果</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">min_money   <span class="comment">% 18+39+48+17+47+20</span></span><br><span class="line">min_result</span><br></pre></td></tr></table></figure><h1 id="导弹追踪问题"><a href="#导弹追踪问题" class="headerlink" title="导弹追踪问题"></a>导弹追踪问题</h1><p><img src="/images/image-20240128171241188.png" alt="image-20240128171241188"></p><blockquote><p>时间t取得非常小就是离散化，可以近似为一个解</p></blockquote><p><img src="/images/image-20240128172137250.png" alt="image-20240128172137250"></p><p><img src="/images/image-20240128172400221.png" alt="image-20240128172400221"></p><p><img src="/images/image-20240128172409686.png" alt="image-20240128172409686"></p><p><img src="/images/image-20240128172419392.png" alt="image-20240128172419392"></p><h2 id="误差需要"><a href="#误差需要" class="headerlink" title="误差需要"></a>误差需要</h2><p><img src="/images/image-20240128172443691.png" alt="image-20240128172443691"></p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%%  蒙特卡罗用于模拟导弹追击问题</span></span><br><span class="line"><span class="comment">% 注意，模拟导弹追击问题更像是一种仿真模拟的方法。这里本质上没有用到随机数，因此严格意义上不能称为蒙特卡罗。</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="comment">% mod(m,n)表示求m/n的余数</span></span><br><span class="line"><span class="built_in">mod</span>(<span class="number">8</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">mod</span>(<span class="number">1000</span>,<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">% 设置横纵坐标的范围并标上字符</span></span><br><span class="line">x = <span class="number">1</span>:<span class="number">0.01</span>:<span class="number">3</span>;</span><br><span class="line">y = x .^  <span class="number">2</span>;</span><br><span class="line"><span class="built_in">plot</span>(x,y)  <span class="comment">% 画出x和y的图形</span></span><br><span class="line">axis([<span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">10</span>])  <span class="comment">% 设置横坐标范围为[0, 3] 纵坐标范围为[0, 10]</span></span><br><span class="line">pause(<span class="number">3</span>)  <span class="comment">% 暂停3秒后再继续接下来的命令</span></span><br><span class="line">text(<span class="number">2</span>,<span class="number">4</span>,<span class="string">&#x27;清风&#x27;</span>)  <span class="comment">% 在坐标为(2,4)的点上标上字符串：清风</span></span><br><span class="line">close <span class="comment">% 关闭图形窗口</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% (2) 代码求解 </span></span><br><span class="line"><span class="comment">% 1. 不画追击的示意图</span></span><br><span class="line">clear;clc</span><br><span class="line">v=<span class="number">200</span>; <span class="comment">% 任意给定B船的速度（后期我们可以再改的）</span></span><br><span class="line">dt=<span class="number">0.0000001</span>; <span class="comment">% 定义时间间隔</span></span><br><span class="line">x=[<span class="number">0</span>,<span class="number">20</span>]; <span class="comment">% 定义导弹和B船的横坐标分别为x(1)和x(2)</span></span><br><span class="line">y=[<span class="number">0</span>,<span class="number">0</span>]; <span class="comment">% 定义导弹和B船的纵坐标分别为y(1)和y(2)</span></span><br><span class="line">t=<span class="number">0</span>; <span class="comment">% 初始化导弹击落B船的时间</span></span><br><span class="line">d=<span class="number">0</span>; <span class="comment">% 初始化导弹飞行的距离</span></span><br><span class="line">m=<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>;   <span class="comment">% 将sqrt(2)/2定义为一个常量，使后面看起来很简洁</span></span><br><span class="line">dd=<span class="built_in">sqrt</span>((x(<span class="number">2</span>)-x(<span class="number">1</span>))^<span class="number">2</span>+(y(<span class="number">2</span>)-y(<span class="number">1</span>))^<span class="number">2</span>); <span class="comment">% 导弹与B船的距离</span></span><br><span class="line"><span class="keyword">while</span>(dd&gt;=<span class="number">0.001</span>)  <span class="comment">% 只要两者的距离足够大，就一直循环下去。（两者距离足够小时表示导弹击中，这里的临界值要结合dt来取，否则可能导致错过交界处的情况）</span></span><br><span class="line">    t=t+dt; <span class="comment">% 更新导弹击落B船的时间</span></span><br><span class="line">    d=d+<span class="number">3</span>*v*dt; <span class="comment">% 更新导弹飞行的距离</span></span><br><span class="line">    x(<span class="number">2</span>)=<span class="number">20</span>+t*v*m;  y(<span class="number">2</span>)=t*v*m;   <span class="comment">% 计算新的B船的位置 （注：m=sqrt(2)/2）</span></span><br><span class="line">    dd=<span class="built_in">sqrt</span>((x(<span class="number">2</span>)-x(<span class="number">1</span>))^<span class="number">2</span>+(y(<span class="number">2</span>)-y(<span class="number">1</span>))^<span class="number">2</span>);  <span class="comment">% 更新导弹与B船的距离</span></span><br><span class="line">    tan_alpha=(y(<span class="number">2</span>)-y(<span class="number">1</span>))/(x(<span class="number">2</span>)-x(<span class="number">1</span>));   <span class="comment">% 计算斜率，即tan(α)</span></span><br><span class="line">    cos_alpha=<span class="built_in">sqrt</span>(<span class="number">1</span>/(<span class="number">1</span>+tan_alpha^<span class="number">2</span>));   <span class="comment">% sec(α)^2 = (1+tan(α)^2)</span></span><br><span class="line">    sin_alpha=<span class="built_in">sqrt</span>(<span class="number">1</span>-cos_alpha^<span class="number">2</span>);  <span class="comment">% sin(α)^2 +cos(α)^2 = 1</span></span><br><span class="line">    x(<span class="number">1</span>)=x(<span class="number">1</span>)+<span class="number">3</span>*v*dt*cos_alpha;   y(<span class="number">1</span>)=y(<span class="number">1</span>)+<span class="number">3</span>*v*dt*sin_alpha; <span class="comment">% 计算新的导弹的位置</span></span><br><span class="line">    <span class="keyword">if</span> d&gt;<span class="number">50</span>  <span class="comment">% 导弹的有效射程为50个单位</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;导弹没有击中B船&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">% 退出循环</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> d&lt;=<span class="number">50</span> &amp; dd&lt;<span class="number">0.001</span>   <span class="comment">% 导弹飞行的距离小于50个单位且导弹和B船的距离小于0.001（表示击中）</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;导弹飞行&#x27;</span>,num2str(d),<span class="string">&#x27;单位后击中B船&#x27;</span>])</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;导弹飞行的时间为&#x27;</span>,num2str(t*<span class="number">60</span>),<span class="string">&#x27;分钟&#x27;</span>])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="画追击图的代码（高级）"><a href="#画追击图的代码（高级）" class="headerlink" title="画追击图的代码（高级）"></a>画追击图的代码（高级）</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 2. 画追击的示意图</span></span><br><span class="line">clear;clc</span><br><span class="line">v=<span class="number">200</span>; <span class="comment">% 任意给定B船的速度（后期我们可以再改的）</span></span><br><span class="line">dt=<span class="number">0.0000001</span>; <span class="comment">% 定义时间间隔</span></span><br><span class="line">x=[<span class="number">0</span>,<span class="number">20</span>]; <span class="comment">% 定义导弹和B船的横坐标分别为x(1)和x(2)</span></span><br><span class="line">y=[<span class="number">0</span>,<span class="number">0</span>]; <span class="comment">% 定义导弹和B船的纵坐标分别为y(1)和y(2)</span></span><br><span class="line">t=<span class="number">0</span>; <span class="comment">% 初始化导弹击落B船的时间</span></span><br><span class="line">d=<span class="number">0</span>; <span class="comment">% 初始化导弹飞行的距离</span></span><br><span class="line">m=<span class="built_in">sqrt</span>(<span class="number">2</span>)/<span class="number">2</span>;   <span class="comment">% 将sqrt(2)/2定义为一个常量，使后面看起来很简洁</span></span><br><span class="line">dd=<span class="built_in">sqrt</span>((x(<span class="number">2</span>)-x(<span class="number">1</span>))^<span class="number">2</span>+(y(<span class="number">2</span>)-y(<span class="number">1</span>))^<span class="number">2</span>); <span class="comment">% 导弹与B船的距离</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">    <span class="built_in">plot</span>(x(<span class="built_in">i</span>),y(<span class="built_in">i</span>),<span class="string">&#x27;.k&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">1</span>);  <span class="comment">% 画出导弹和B船所在的坐标，点的大小为1，颜色为黑色(k)，用小点表示</span></span><br><span class="line">    grid on;  <span class="comment">% 打开网格线</span></span><br><span class="line">    <span class="built_in">hold</span> on;  <span class="comment">% 不关闭图形，继续画图</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">axis([<span class="number">0</span> <span class="number">30</span> <span class="number">0</span> <span class="number">10</span>])  <span class="comment">% 固定x轴的范围为0-30  固定y轴的范围为0-10</span></span><br><span class="line">k = <span class="number">0</span>;  <span class="comment">% 引入一个变量  为了控制画图的速度（因为Matlab中画图的速度超级慢）</span></span><br><span class="line"><span class="keyword">while</span>(dd&gt;=<span class="number">0.001</span>)  <span class="comment">% 只要两者的距离足够大，就一直循环下去。（两者距离足够小时表示导弹击中，这里的临界值要结合dt来取，否则可能导致错过交界处的情况）</span></span><br><span class="line">    t=t+dt; <span class="comment">% 更新导弹击落B船的时间</span></span><br><span class="line">    d=d+<span class="number">3</span>*v*dt; <span class="comment">% 更新导弹飞行的距离</span></span><br><span class="line">    x(<span class="number">2</span>)=<span class="number">20</span>+t*v*m;  y(<span class="number">2</span>)=t*v*m;   <span class="comment">% 计算新的B船的位置 （注：m=sqrt(2)/2）</span></span><br><span class="line">    dd=<span class="built_in">sqrt</span>((x(<span class="number">2</span>)-x(<span class="number">1</span>))^<span class="number">2</span>+(y(<span class="number">2</span>)-y(<span class="number">1</span>))^<span class="number">2</span>);  <span class="comment">% 更新导弹与B船的距离</span></span><br><span class="line">    tan_alpha=(y(<span class="number">2</span>)-y(<span class="number">1</span>))/(x(<span class="number">2</span>)-x(<span class="number">1</span>));   <span class="comment">% 计算斜率，即tan(α)</span></span><br><span class="line">    cos_alpha=<span class="built_in">sqrt</span>(<span class="number">1</span>/(<span class="number">1</span>+tan_alpha^<span class="number">2</span>));   <span class="comment">% 利用公式：sec(α)^2 = (1+tan(α)^2)  计算出cos(α)</span></span><br><span class="line">    sin_alpha=<span class="built_in">sqrt</span>(<span class="number">1</span>-cos_alpha^<span class="number">2</span>);  <span class="comment">% 利用公式： sin(α)^2 +cos(α)^2 = 1  计算出sin(α)</span></span><br><span class="line">    x(<span class="number">1</span>)=x(<span class="number">1</span>)+<span class="number">3</span>*v*dt*cos_alpha;   y(<span class="number">1</span>)=y(<span class="number">1</span>)+<span class="number">3</span>*v*dt*sin_alpha;   <span class="comment">% 计算新的导弹的位置</span></span><br><span class="line">    k = k +<span class="number">1</span> ;  </span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">mod</span>(k,<span class="number">500</span>) == <span class="number">0</span>  <span class="comment">% 每刷新500次时间就画出下一个导弹和B船所在的坐标  mod(m,n )表示求m/n的余数</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">2</span></span><br><span class="line">            <span class="built_in">plot</span>(x(<span class="built_in">i</span>),y(<span class="built_in">i</span>),<span class="string">&#x27;.k&#x27;</span>,<span class="string">&#x27;MarkerSize&#x27;</span>,<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">hold</span> on; <span class="comment">% 不关闭图形，继续画图</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        pause(<span class="number">0.001</span>);  <span class="comment">% 暂停0.001s后再继续下面的操作</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> d&gt;<span class="number">50</span>  <span class="comment">% 导弹的有效射程为50个单位</span></span><br><span class="line">        <span class="built_in">disp</span>(<span class="string">&#x27;导弹没有击中B船&#x27;</span>);</span><br><span class="line">        <span class="keyword">break</span>;  <span class="comment">% 退出循环</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> d&lt;=<span class="number">50</span> &amp; dd&lt;<span class="number">0.001</span>   <span class="comment">% 导弹飞行的距离小于50个单位且导弹和B船的距离小于0.001（表示击中）</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;导弹飞行&#x27;</span>,num2str(d),<span class="string">&#x27;个单位后击中B船&#x27;</span>])</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;导弹飞行的时间为&#x27;</span>,num2str(t*<span class="number">60</span>),<span class="string">&#x27;分钟&#x27;</span>])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="最后一舞：旅行商问题"><a href="#最后一舞：旅行商问题" class="headerlink" title="最后一舞：旅行商问题"></a>最后一舞：旅行商问题</h1><h2 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h2><p><img src="/images/image-20240128173741617.png" alt="image-20240128173741617"></p><h2 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h2><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% TSP(旅行商问题)</span></span><br><span class="line"><span class="comment">%% （1）预备知识</span></span><br><span class="line"><span class="built_in">plot</span>([<span class="number">1</span>,<span class="number">2</span>],[<span class="number">5</span>,<span class="number">10</span>],<span class="string">&#x27;-o&#x27;</span>) <span class="comment">% 画出一条线段，x范围是[1, 2] ，y范围是[5,10]</span></span><br><span class="line">text(<span class="number">1.5</span>,<span class="number">7.5</span>,<span class="string">&#x27;清风&#x27;</span>) <span class="comment">% 在坐标(1.5,7.5)处标上文本：清风</span></span><br><span class="line">close</span><br><span class="line"></span><br><span class="line"><span class="comment">% randperm函数的用法</span></span><br><span class="line">randperm(<span class="number">5</span>)  <span class="comment">% 生成1-5组成的一个随机序列(类似于洗牌的操作)</span></span><br><span class="line"><span class="comment">%      3     5     1     2     4</span></span><br><span class="line"><span class="comment">%      1     4     5     3     2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">%% （2）代码求解</span></span><br><span class="line">clear;clc</span><br><span class="line"><span class="comment">% 只有10个城市的简单情况</span></span><br><span class="line"> coord =[<span class="number">0.6683</span> <span class="number">0.6195</span> <span class="number">0.4</span>    <span class="number">0.2439</span> <span class="number">0.1707</span> <span class="number">0.2293</span> <span class="number">0.5171</span> <span class="number">0.8732</span> <span class="number">0.6878</span> <span class="number">0.8488</span> ;</span><br><span class="line">               <span class="number">0.2536</span> <span class="number">0.2634</span> <span class="number">0.4439</span> <span class="number">0.1463</span> <span class="number">0.2293</span> <span class="number">0.761</span>  <span class="number">0.9414</span> <span class="number">0.6536</span> <span class="number">0.5219</span> <span class="number">0.3609</span>]&#x27; ;  <span class="comment">% 城市坐标矩阵，n行2列</span></span><br><span class="line"><span class="comment">% 38个城市，TSP数据集网站(http://www.tsp.gatech.edu/world/djtour.html) 上公测的最优结果6656。</span></span><br><span class="line"> <span class="comment">% coord = [11003.611100,42102.500000;11108.611100,42373.888900;11133.333300,42885.833300;11155.833300,42712.500000;11183.333300,42933.333300;11297.500000,42853.333300;11310.277800,42929.444400;11416.666700,42983.333300;11423.888900,43000.277800;11438.333300,42057.222200;11461.111100,43252.777800;11485.555600,43187.222200;11503.055600,42855.277800;11511.388900,42106.388900;11522.222200,42841.944400;11569.444400,43136.666700;11583.333300,43150.000000;11595.000000,43148.055600;11600.000000,43150.000000;11690.555600,42686.666700;11715.833300,41836.111100;11751.111100,42814.444400;11770.277800,42651.944400;11785.277800,42884.444400;11822.777800,42673.611100;11846.944400,42660.555600;11963.055600,43290.555600;11973.055600,43026.111100;12058.333300,42195.555600;12149.444400,42477.500000;12286.944400,43355.555600;12300.000000,42433.333300;12355.833300,43156.388900;12363.333300,43189.166700;12372.777800,42711.388900;12386.666700,43334.722200;12421.666700,42895.555600;12645.000000,42973.333300];</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">size</span>(coord,<span class="number">1</span>);  <span class="comment">% 城市的数目</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">figure</span>(<span class="number">1</span>)  <span class="comment">% 新建一个编号为1的图形窗口</span></span><br><span class="line"><span class="built_in">plot</span>(coord(:,<span class="number">1</span>),coord(:,<span class="number">2</span>),<span class="string">&#x27;o&#x27;</span>);   <span class="comment">% 画出城市的分布散点图</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    text(coord(<span class="built_in">i</span>,<span class="number">1</span>)+<span class="number">0.01</span>,coord(<span class="built_in">i</span>,<span class="number">2</span>)+<span class="number">0.01</span>,num2str(<span class="built_in">i</span>))   <span class="comment">% 在图上标上城市的编号（加上0.01表示把文字的标记往右上方偏移一点）</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="built_in">hold</span> on <span class="comment">% 等一下要接着在这个图形上画图的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">d = <span class="built_in">zeros</span>(n);   <span class="comment">% 初始化两个城市的距离矩阵全为0</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">2</span>:n  </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:<span class="built_in">i</span>  </span><br><span class="line">        coord_i = coord(<span class="built_in">i</span>,:);   x_i = coord_i(<span class="number">1</span>);     y_i = coord_i(<span class="number">2</span>);  <span class="comment">% 城市i的横坐标为x_i，纵坐标为y_i</span></span><br><span class="line">        coord_j = coord(<span class="built_in">j</span>,:);   x_j = coord_j(<span class="number">1</span>);     y_j = coord_j(<span class="number">2</span>);  <span class="comment">% 城市j的横坐标为x_j，纵坐标为y_j</span></span><br><span class="line">        d(<span class="built_in">i</span>,<span class="built_in">j</span>) = <span class="built_in">sqrt</span>((x_i-x_j)^<span class="number">2</span> + (y_i-y_j)^<span class="number">2</span>);   <span class="comment">% 计算城市i和j的距离</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">d = d+d&#x27;;   <span class="comment">% 生成距离矩阵的对称的一面</span></span><br><span class="line"></span><br><span class="line">min_result = +<span class="built_in">inf</span>;  <span class="comment">% 假设最短的距离为min_result，初始化为无穷大，后面只要找到比它小的就对其更新</span></span><br><span class="line">min_path = [<span class="number">1</span>:n];   <span class="comment">% 初始化最短的路径就是1-2-3-...-n</span></span><br><span class="line">N = <span class="number">10000000</span>;  <span class="comment">% 蒙特卡罗模拟的次数</span></span><br><span class="line"><span class="keyword">for</span> k = <span class="number">1</span>:N  <span class="comment">% 开始循环</span></span><br><span class="line">    result = <span class="number">0</span>;  <span class="comment">% 初始化走过的路程为0</span></span><br><span class="line">    path = randperm(n);  <span class="comment">% 生成一个1-n的随机打乱的序列</span></span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n<span class="number">-1</span>  </span><br><span class="line">        result = d(path(<span class="built_in">i</span>),path(<span class="built_in">i</span>+<span class="number">1</span>)) + result;  <span class="comment">% 按照这个序列不断的更新走过的路程这个值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result = d(path(<span class="number">1</span>),path(n)) + result;  <span class="comment">% 别忘了加上从最后一个城市返回到最开始那个城市的距离</span></span><br><span class="line">    <span class="keyword">if</span> result &lt; min_result  <span class="comment">% 判断这次模拟走过的距离是否小于最短的距离，如果小于就更新最短距离和最短的路径</span></span><br><span class="line">        min_path = path;</span><br><span class="line">        min_result = result</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">min_path</span><br><span class="line">min_path = [min_path,min_path(<span class="number">1</span>)];   <span class="comment">% 在最短路径的最后面加上一个元素，即第一个点（我们要生成一个封闭的图形）</span></span><br><span class="line">n = n+<span class="number">1</span>;  <span class="comment">% 城市的个数加一个（紧随着上一步）</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n<span class="number">-1</span> </span><br><span class="line">     <span class="built_in">j</span> = <span class="built_in">i</span>+<span class="number">1</span>;</span><br><span class="line">    coord_i = coord(min_path(<span class="built_in">i</span>),:);   x_i = coord_i(<span class="number">1</span>);     y_i = coord_i(<span class="number">2</span>); </span><br><span class="line">    coord_j = coord(min_path(<span class="built_in">j</span>),:);   x_j = coord_j(<span class="number">1</span>);     y_j = coord_j(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">plot</span>([x_i,x_j],[y_i,y_j],<span class="string">&#x27;-&#x27;</span>)    <span class="comment">% 每两个点就作出一条线段，直到所有的城市都走完</span></span><br><span class="line">    pause(<span class="number">0.5</span>)  <span class="comment">% 暂停0.5s再画下一条线段</span></span><br><span class="line">    <span class="built_in">hold</span> on</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正太分布均值的假设检验</title>
      <link href="/2024/01/28/%E6%AD%A3%E5%A4%AA%E5%88%86%E5%B8%83%E5%9D%87%E5%80%BC%E7%9A%84%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/"/>
      <url>/2024/01/28/%E6%AD%A3%E5%A4%AA%E5%88%86%E5%B8%83%E5%9D%87%E5%80%BC%E7%9A%84%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="正态分布均值的假设检验"><a href="#正态分布均值的假设检验" class="headerlink" title="正态分布均值的假设检验"></a>正态分布均值的假设检验</h1><h2 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h2><p><img src="/images/image-20240128152044412.png" alt="image-20240128152044412"></p><blockquote><p>原假设</p><p>备择假设</p><p>四大分布：正态分布，卡方分布，t分布，f分布</p><p>接下来用已知样本数据代入统计量</p><p>再用置信水平得到一个接受域的区间，来判断是否接受原假设</p><p>是否落在接受区域内，如果落在就成立，否则不成立，说明原假设不成立，这个时候就拒绝原假设。</p><p>p&lt;0.05就成功</p></blockquote><h1 id="例题一："><a href="#例题一：" class="headerlink" title="例题一："></a>例题一：</h1><h2 id="Z检验"><a href="#Z检验" class="headerlink" title="Z检验"></a>Z检验</h2><p><img src="/images/image-20240128152417000.png" alt="image-20240128152417000"></p><p><img src="/images/image-20240128152808372.png" alt="image-20240128152808372"></p><p><img src="/images/image-20240128152830058.png" alt="image-20240128152830058"></p><p><img src="/images/image-20240128152852676.png" alt="image-20240128152852676"></p><p><img src="/images/image-20240128152925849.png" alt="image-20240128152925849"></p><p> <img src="/images/image-20240128152941529.png" alt="image-20240128152941529"></p><h1 id="例题二："><a href="#例题二：" class="headerlink" title="例题二："></a>例题二：</h1><p><img src="/images/image-20240128153055626.png" alt="image-20240128153055626"></p><h1 id="从Z检验到t检验"><a href="#从Z检验到t检验" class="headerlink" title="从Z检验到t检验"></a>从Z检验到t检验</h1><p>Z检验的核心是总体服从正态分布</p><p>均值为止，方差已知</p><p><img src="/images/image-20240128153150807.png" alt="image-20240128153150807"></p><p><img src="/images/image-20240128153255255.png" alt="image-20240128153255255"></p><h1 id="两个正态分布均值差的检验"><a href="#两个正态分布均值差的检验" class="headerlink" title="两个正态分布均值差的检验"></a>两个正态分布均值差的检验</h1><p><img src="/images/image-20240128153355517.png" alt="image-20240128153355517"></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h1><p><img src="/images/image-20240128153436106.png" alt="image-20240128153436106"></p><h1 id="例题四："><a href="#例题四：" class="headerlink" title="例题四："></a>例题四：</h1><p><img src="/images/image-20240128153521733.png" alt="image-20240128153521733"></p><h1 id="例题五："><a href="#例题五：" class="headerlink" title="例题五："></a>例题五：</h1><p> <img src="/images/image-20240128153708358.png" alt="image-20240128153708358"></p><p>解决方法：做差</p><p>为什么不用上述方法：因为不服从同一分布</p><p><img src="/images/image-20240128153837124.png" alt="image-20240128153837124"></p><p><img src="/images/image-20240128153932304.png" alt="image-20240128153932304"></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARCH与GARCH模型</title>
      <link href="/2024/01/28/ARCH%E5%92%8CGARCH%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/01/28/ARCH%E5%92%8CGARCH%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="ARCH和GARCH模型"><a href="#ARCH和GARCH模型" class="headerlink" title="ARCH和GARCH模型"></a>ARCH和GARCH模型</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/images/image-20240128143332960.png" alt="image-20240128143332960"></p><p><img src="/images/image-20240128143501537.png" alt="image-20240128143501537"></p><p>长期来看稳</p><p>短期存在异方差</p><p>称为条件异方差</p><p><img src="/images/image-20240128143658853.png" alt="image-20240128143658853"></p><p>一般用第二种</p><p><img src="/images/image-20240128143902003.png" alt="image-20240128143902003"></p><p><img src="/images/image-20240128143933989.png" alt="image-20240128143933989"></p><p><img src="/images/image-20240128144016953.png" alt="image-20240128144016953"></p><p>总结</p><p><img src="/images/image-20240128144106033.png" alt="image-20240128144106033"></p><p>一点没看懂……</p><p>还是直接应用罢</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p><img src="/images/image-20240128144339640.png" alt="image-20240128144339640"></p><p><img src="/images/image-20240128144326544.png" alt="image-20240128144326544"></p><h2 id="单位根检验"><a href="#单位根检验" class="headerlink" title="单位根检验"></a>单位根检验</h2><blockquote><p>平稳</p><p>ARMA</p><p>否则ARIMA</p></blockquote><p><img src="/images/image-20240128144507721.png" alt="image-20240128144507721"></p><p>因此要确定p,q。</p><h2 id="画出ACF和PCF图"><a href="#画出ACF和PCF图" class="headerlink" title="画出ACF和PCF图"></a>画出ACF和PCF图</h2><p><img src="/images/image-20240128144825398.png" alt="image-20240128144825398"></p><blockquote><p>只考虑比较显著的</p><p>然后构造四个模型</p></blockquote><h2 id="比较AIC和BIC值"><a href="#比较AIC和BIC值" class="headerlink" title="比较AIC和BIC值"></a>比较AIC和BIC值</h2><p><img src="/images/image-20240128145026619.png" alt="image-20240128145026619"></p><p><img src="/images/image-20240128145117733.png" alt="image-20240128145117733"></p><p><img src="/images/image-20240128145230698.png" alt="image-20240128145230698"></p><p><img src="/images/image-20240128145358019.png" alt="image-20240128145358019"></p><p><img src="/images/image-20240128145410001.png" alt="image-20240128145410001"></p><p><img src="/images/image-20240128145513605.png" alt="image-20240128145513605"></p><p><img src="/images/image-20240128145627687.png" alt="image-20240128145627687"></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">clear</span>  <span class="comment">// 清空变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">* (1) 导入数据并生成时间序列  (*和//都可以用来注释一行)</span></span><br><span class="line">  <span class="keyword">insheet</span> using <span class="string">&quot;Bindex.csv&quot;</span>  <span class="comment">//导入位于和代码同一文件夹下的csv数据文件</span></span><br><span class="line">  <span class="keyword">gen</span> datevar = <span class="built_in">date</span>(date,<span class="string">&quot;YMD&quot;</span>)   <span class="comment">// 将csv中的变量date转换为stata能识别的时间数据datevar</span></span><br><span class="line">  <span class="keyword">format</span> datevar %td <span class="comment">// 对datevar的展示格式进行转换，转换后以:日月年 显示</span></span><br><span class="line">  <span class="keyword">label</span> variable datevar <span class="string">&quot;日期&quot;</span>  <span class="comment">// 设置datevar的标签为日期，主要用于画图时的展示</span></span><br><span class="line">  <span class="keyword">tsset</span> datevar   <span class="comment">// 定义datevar是一个时间序列数据</span></span><br><span class="line">  <span class="keyword">gen</span> time=_n  <span class="comment">// 定义一个从1到n的time序列，n是观测值的个数，系统自动在后台记录的</span></span><br><span class="line">  <span class="keyword">tsset</span> time   <span class="comment">// 将time这个序列定义为时间序列，后续滞后算子时需要用到</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 画深成B指的时间序列图</span></span><br><span class="line"><span class="keyword">line</span> index datevar   </span><br><span class="line"><span class="keyword">graph</span> export <span class="string">&quot;深成B指的时间序列图.png&quot;</span>, <span class="keyword">as</span>(png) <span class="keyword">replace</span>   <span class="comment">// 导出图片到本地文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算日收益率数据</span></span><br><span class="line"><span class="keyword">gen</span> r=100*(index-<span class="keyword">L</span>.index)/<span class="keyword">L</span>.index   <span class="comment">//（今天的收盘价-昨天的收盘价）/昨天的收盘价   L是lag的缩写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对日收益率r进行描述性统计</span></span><br><span class="line"><span class="keyword">summarize</span> r  </span><br><span class="line"></span><br><span class="line"><span class="comment">// 做出日收益率的时间序列图</span></span><br><span class="line"><span class="keyword">line</span> r datevar</span><br><span class="line"><span class="keyword">graph</span> export <span class="string">&quot;深成B指日收益率的时间序列图.png&quot;</span>, <span class="keyword">as</span>(png) <span class="keyword">replace</span>   <span class="comment">// 导出图片到本地文件夹</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验收益率序列r是否为单位根,检验方法是ADF检验(原假设：是单位根序列，备择假设：是平稳序列)</span></span><br><span class="line"><span class="keyword">dfuller</span> r</span><br><span class="line"><span class="comment">// MacKinnon approximate p-value for Z(t) = 0.0000  p值为0意味着拒绝原假设，所以我们认为r序列平稳</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 观察acf图与pacf图 ，判断AMRA模型的阶数</span></span><br><span class="line"><span class="keyword">ac</span> r,lags(20)   <span class="comment">// 自相关系数图，滞后20期</span></span><br><span class="line"><span class="keyword">graph</span> export <span class="string">&quot;自相关系数图.png&quot;</span>, <span class="keyword">as</span>(png) <span class="keyword">replace</span>   <span class="comment">// 导出图片到本地文件夹</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pac</span> r,lags(20)  <span class="comment">// 偏自相关系数图，滞后20期</span></span><br><span class="line"><span class="keyword">graph</span> export <span class="string">&quot;偏自相关系数图.png&quot;</span>, <span class="keyword">as</span>(png) <span class="keyword">replace</span>   <span class="comment">// 导出图片到本地文件夹</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据acf和pacf图，初步判断使用四个备选的ARMA模型来拟合</span></span><br><span class="line"><span class="keyword">set</span> matsize 1500  <span class="comment">// 把计算时支持的最大矩阵大小设置的大一点，否则计算机性能较差的电脑可能在计算中会报错</span></span><br><span class="line"><span class="keyword">arima</span> r,<span class="keyword">arima</span>(3,0,3)   <span class="comment">// 用ARIMA(3,0,3)模型对r进行估计</span></span><br><span class="line"><span class="keyword">estat</span> ic   <span class="comment">// 得到AIC和BIC，用于选择合适的模型（选小原则，详见第十一讲）</span></span><br><span class="line"><span class="keyword">arima</span> r,<span class="keyword">arima</span>(8,0,8)</span><br><span class="line"><span class="keyword">estat</span> ic</span><br><span class="line"><span class="keyword">arima</span> r,<span class="keyword">arima</span>(3,0,8)</span><br><span class="line"><span class="keyword">estat</span> ic</span><br><span class="line"><span class="keyword">arima</span> r,<span class="keyword">arima</span>(8,0,3)</span><br><span class="line"><span class="keyword">estat</span> ic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ARIMA(3,0,3)模型的AIC值和BIC值的平均值最小，所以下面我们使用这个模型进行估计 </span></span><br><span class="line"><span class="keyword">arima</span> r,<span class="keyword">arima</span>(3,0,3)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到残差的预测值并生成残差分布直方图图</span></span><br><span class="line"><span class="keyword">predict</span> residess, residuals   <span class="comment">// 保存残差</span></span><br><span class="line"><span class="keyword">hist</span> residess,norm freq  <span class="comment">// norm freq表示加上标准正态分布的概率密度函数</span></span><br><span class="line"><span class="keyword">graph</span> export <span class="string">&quot;残差分布直方图.png&quot;</span>, <span class="keyword">as</span>(png) <span class="keyword">replace</span>   <span class="comment">// 导出图片到本地文件夹</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检验残差是否为白噪声序列，检验方法为Q检验：原假设是白噪声，备择假设不是白噪声</span></span><br><span class="line"><span class="keyword">wntestq</span> residess, lag(12)   <span class="comment">// 对残差序列进行白噪声检验</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成残差的平方，并进行Q检验</span></span><br><span class="line"><span class="keyword">gen</span> ressq = residess^2   <span class="comment">// 生成残差平方序列ressq</span></span><br><span class="line"><span class="keyword">wntestq</span> ressq, lag(12) <span class="comment">// 对残差平方序列ressq进行白噪声检验</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// LM检验：是否存在ARCH误差</span></span><br><span class="line"><span class="keyword">reg</span> ressq <span class="keyword">l</span>.ressq l2.ressq l3.ressq l4.ressq l5.ressq  <span class="comment">// 将残差平方项对其滞后项回归</span></span><br><span class="line"><span class="keyword">gen</span> LM_STAT=<span class="built_in">e</span>(<span class="keyword">N</span>)*<span class="built_in">e</span>(r2) <span class="comment">// 计算LM统计量</span></span><br><span class="line"><span class="keyword">display</span> LM_STAT  <span class="comment">// 输出LM统计量</span></span><br><span class="line"><span class="keyword">display</span> chiprob(<span class="built_in">e</span>(df_m),LM_STAT) <span class="comment">// 计算p值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用AIC BIC选择合适的模型进行估计 </span></span><br><span class="line"><span class="comment">// 注意：扰动项的分布在金融数据中常服从t分布</span></span><br><span class="line"><span class="comment">// 正态分布下GARCH(1,1)估计</span></span><br><span class="line"><span class="keyword">arch</span> r,<span class="keyword">arima</span>(3 0 3) <span class="keyword">arch</span>(1) garch(1)</span><br><span class="line"><span class="keyword">estat</span> ic</span><br><span class="line"><span class="comment">// t分布下GARCH(1,1)估计</span></span><br><span class="line"><span class="keyword">arch</span> r,<span class="keyword">arima</span>(3 0 3) <span class="keyword">arch</span>(1) garch(1) distribution(t 3)  <span class="comment">// 自由度为3的t分布</span></span><br><span class="line"><span class="keyword">estat</span> ic</span><br><span class="line"><span class="comment">// 正态分布下GARCH(2,2)估计</span></span><br><span class="line"><span class="keyword">arch</span> r,<span class="keyword">arima</span>(3 0 3) <span class="keyword">arch</span>(2) garch(2)</span><br><span class="line"><span class="keyword">estat</span> ic</span><br><span class="line"><span class="comment">// t分布下GARCH(2,2)估计</span></span><br><span class="line"><span class="keyword">arch</span> r,<span class="keyword">arima</span>(3 0 3) <span class="keyword">arch</span>(2) garch(2) distribution(t 3)</span><br><span class="line"><span class="keyword">estat</span> ic</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到拟合结果，并进行预测</span></span><br><span class="line"><span class="keyword">arch</span> r,<span class="keyword">arima</span>(3 0 3) <span class="keyword">arch</span>(1) garch(1) distribution(t 3)</span><br><span class="line"><span class="keyword">tsappend</span> ,add(10)  <span class="comment">// 将时间延长10期</span></span><br><span class="line"><span class="keyword">predict</span> result <span class="comment">// 对数据进行预测</span></span><br><span class="line"><span class="keyword">tsline</span> result r, legend(<span class="keyword">label</span>(1 <span class="string">&quot;预测值&quot;</span>)  <span class="keyword">label</span>(2 <span class="string">&quot;真实值&quot;</span>))   <span class="comment">// 绘制拟合图</span></span><br><span class="line"><span class="keyword">graph</span> export <span class="string">&quot;预测结果图.png&quot;</span>, <span class="keyword">as</span>(png) <span class="keyword">replace</span>   <span class="comment">// 导出图片到本地文件夹</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Floyd算法</title>
      <link href="/2024/01/28/Floyd%E7%AE%97%E6%B3%95/"/>
      <url>/2024/01/28/Floyd%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="最短路径：Floyd算法"><a href="#最短路径：Floyd算法" class="headerlink" title="最短路径：Floyd算法"></a>最短路径：Floyd算法</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><p><img src="/images/image-20240128141559426.png" alt="image-20240128141559426"></p><h2 id="代码思想"><a href="#代码思想" class="headerlink" title="代码思想"></a>代码思想</h2><p><img src="/images/image-20240128141708252.png" alt="image-20240128141708252"></p><p><img src="/images/image-20240128141726879.png" alt="image-20240128141726879"></p><p>优化：记录点</p><p><img src="/images/image-20240128141816124.png" alt="image-20240128141816124"></p><p>代码：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[dist,path]</span> = <span class="title">Floyd_algorithm</span><span class="params">(D)</span></span></span><br><span class="line"><span class="comment">%% 该函数用于求解一个权重邻接矩阵任意两个节点之间的最短路径</span></span><br><span class="line"><span class="comment">% 输入：</span></span><br><span class="line"><span class="comment">%        D是权重邻接矩阵</span></span><br><span class="line"><span class="comment">% 输出：</span></span><br><span class="line"><span class="comment">%        dist是最短距离矩阵，其元素dist_ij表示表示i,j两个节点的最短距离</span></span><br><span class="line"><span class="comment">%        path是路径矩阵，其元素path_ij表示起点为i，终点为j的两个节点之间的最短路径要经过的节点</span></span><br><span class="line"></span><br><span class="line">n = <span class="built_in">size</span>(D,<span class="number">1</span>);  <span class="comment">% 计算节点的个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 初始化dist矩阵</span></span><br><span class="line">dist = D;</span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面我们来初始化path矩阵</span></span><br><span class="line">path = <span class="built_in">zeros</span>(n);</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:n</span><br><span class="line">    path(:,<span class="built_in">j</span>) = <span class="built_in">j</span>;   <span class="comment">% 将第j列的元素变为j</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    path(<span class="built_in">i</span>,<span class="built_in">i</span>) = <span class="number">-1</span>;  <span class="comment">% 将主对角线元素变为-1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 下面开始三个循环</span></span><br><span class="line"><span class="keyword">for</span> k=<span class="number">1</span>:n    <span class="comment">% 中间节点k从1- n 循环</span></span><br><span class="line">   <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:n     <span class="comment">% 起始节点i从1- n 循环</span></span><br><span class="line">      <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n    <span class="comment">% 终点节点j从1-n 循环</span></span><br><span class="line">          <span class="keyword">if</span> dist(<span class="built_in">i</span>,<span class="built_in">j</span>)&gt;dist(<span class="built_in">i</span>,k)+dist(k,<span class="built_in">j</span>)  <span class="comment">% 如果i,j两个节点间的最短距离大于i和k的最短距离+k和j的最短距离</span></span><br><span class="line">             dist(<span class="built_in">i</span>,<span class="built_in">j</span>)=dist(<span class="built_in">i</span>,k)+dist(k,<span class="built_in">j</span>);  <span class="comment">% 那么我们就令这两个较短的距离之和取代i,j两点之间的最短距离</span></span><br><span class="line">             path(<span class="built_in">i</span>,<span class="built_in">j</span>)=path(<span class="built_in">i</span>,k);   <span class="comment">% 起点为i，终点为j的两个节点之间的最短路径要经过的节点更新为path(i,k)</span></span><br><span class="line">             <span class="comment">% 注意，上面一行语句不能写成path(i,j) = k; 这是网上很多地方都容易犯的错误，在PPT11页中会告诉大家为什么不能这么写</span></span><br><span class="line">          <span class="keyword">end</span></span><br><span class="line">      <span class="keyword">end</span></span><br><span class="line">   <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>例子</p><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% PPT第七页的例子</span></span><br><span class="line"><span class="comment">%% 首先将图转换为权重邻接矩阵D</span></span><br><span class="line">n = <span class="number">5</span>;  <span class="comment">%一共五个节点</span></span><br><span class="line">D = <span class="built_in">ones</span>(n) ./ <span class="built_in">zeros</span>(n);  <span class="comment">% 全部元素初始化为Inf</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    D(<span class="built_in">i</span>,<span class="built_in">i</span>) = <span class="number">0</span>;  <span class="comment">% 主对角线元素为0</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">D(<span class="number">1</span>,<span class="number">2</span>) = <span class="number">3</span>;</span><br><span class="line">D(<span class="number">1</span>,<span class="number">3</span>) = <span class="number">8</span>;</span><br><span class="line">D(<span class="number">1</span>,<span class="number">5</span>) = <span class="number">-4</span>;</span><br><span class="line">D(<span class="number">2</span>,<span class="number">5</span>) = <span class="number">7</span>;</span><br><span class="line">D(<span class="number">2</span>,<span class="number">4</span>) = <span class="number">1</span>;</span><br><span class="line">D(<span class="number">3</span>,<span class="number">2</span>) = <span class="number">4</span>;</span><br><span class="line">D(<span class="number">4</span>,<span class="number">3</span>) = <span class="number">-5</span>;</span><br><span class="line">D(<span class="number">5</span>,<span class="number">4</span>) = <span class="number">6</span>;</span><br><span class="line">D(<span class="number">4</span>,<span class="number">1</span>) = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 调用Floyd_algorithm函数求解</span></span><br><span class="line">[dist,path] = Floyd_algorithm(D)</span><br><span class="line"></span><br><span class="line">print_path(path,dist,<span class="number">1</span>,<span class="number">5</span>)</span><br><span class="line">print_path(path,dist,<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">print_path(path,dist,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">clc</span><br><span class="line"><span class="built_in">disp</span>(<span class="string">&#x27;下面我们打印任意两点之间的最短距离：&#x27;</span>)</span><br><span class="line">print_all_path(D)</span><br></pre></td></tr></table></figure><h3 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 思考题的参考答案</span></span><br><span class="line"><span class="comment">%% 首先将图转换为权重邻接矩阵D</span></span><br><span class="line">n = <span class="number">9</span>;  <span class="comment">%一共九个节点</span></span><br><span class="line">D = <span class="built_in">zeros</span>(n);  <span class="comment">% 全部元素初始化为0, 等会你们就知道为什么这样设置啦</span></span><br><span class="line"><span class="comment">% 因为是无向图，所以权重邻接矩阵是一个对称矩阵</span></span><br><span class="line">D(<span class="number">1</span>,<span class="number">2</span>) = <span class="number">4</span>; D(<span class="number">1</span>,<span class="number">8</span>) = <span class="number">8</span>; </span><br><span class="line">D(<span class="number">2</span>,<span class="number">8</span>) = <span class="number">3</span>; D(<span class="number">2</span>,<span class="number">3</span>) = <span class="number">8</span>;</span><br><span class="line">D(<span class="number">8</span>,<span class="number">9</span>) = <span class="number">1</span>; D(<span class="number">8</span>,<span class="number">7</span>) = <span class="number">6</span>; </span><br><span class="line">D(<span class="number">9</span>,<span class="number">7</span>) = <span class="number">6</span>; D(<span class="number">9</span>,<span class="number">3</span>) = <span class="number">2</span>;</span><br><span class="line">D(<span class="number">7</span>,<span class="number">6</span>) = <span class="number">2</span>; D(<span class="number">3</span>,<span class="number">4</span>) = <span class="number">7</span>; </span><br><span class="line">D(<span class="number">3</span>,<span class="number">6</span>) = <span class="number">4</span>; D(<span class="number">6</span>,<span class="number">4</span>) = <span class="number">14</span>;</span><br><span class="line">D(<span class="number">4</span>,<span class="number">5</span>) = <span class="number">9</span>; D(<span class="number">6</span>,<span class="number">5</span>) = <span class="number">10</span>;</span><br><span class="line">D = D+D&#x27;;   <span class="comment">% 这个操作可以得到对称矩阵的另一半</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span> = <span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">i</span> ~= <span class="built_in">j</span>) &amp;&amp; (D(<span class="built_in">i</span>,<span class="built_in">j</span>) == <span class="number">0</span>)  </span><br><span class="line">            D(<span class="built_in">i</span>,<span class="built_in">j</span>) = Inf;   <span class="comment">% 将非主对角线上的0元素全部变为Inf</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 调用Floyd_algorithm函数求解</span></span><br><span class="line">[dist,path] = Floyd_algorithm(D)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="打印"><a href="#打印" class="headerlink" title="打印"></a>打印</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">function [] = <span class="built_in">print_all_path</span>(D)</span><br><span class="line">%% 该函数的作用是求解一个权重邻接矩阵任意两个节点之间的最短路径,并打印所有的结果出来</span><br><span class="line">% 输入：</span><br><span class="line">%        D是权重邻接矩阵</span><br><span class="line">% 输出：无</span><br><span class="line"></span><br><span class="line">[dist,path] = <span class="built_in">Floyd_algorithm</span>(D);   % 调用之前的Floyd_algorithm函数</span><br><span class="line">n = <span class="built_in">size</span>(D,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> n == <span class="number">1</span></span><br><span class="line">    <span class="built_in">warning</span>(<span class="string">&#x27;请输入至少两阶以上的权重邻接矩阵&#x27;</span>)   % 在屏幕中提示警告信息</span><br><span class="line">    <span class="keyword">return</span>;   % 不运行下面的语句，直接退出函数</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>:n</span><br><span class="line">    <span class="keyword">for</span> j = <span class="number">1</span>:n</span><br><span class="line">        <span class="keyword">if</span> i ~= j  % 不等号用~=表示</span><br><span class="line">            <span class="built_in">print_path</span>(path,dist,i,j);   % 调用之前的print_path函数</span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;-------------------------------------------&#x27;</span>)</span><br><span class="line">            <span class="built_in">disp</span>(<span class="string">&#x27;  &#x27;</span>)</span><br><span class="line">        end</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="params">[]</span> = <span class="title">print_path</span><span class="params">(path,dist,i,j)</span></span></span><br><span class="line"><span class="comment">%% 该函数的作用是打印从i到j经过的最短路径</span></span><br><span class="line"><span class="comment">% 输入：</span></span><br><span class="line"><span class="comment">%        path是使用floyd算法求出来的路径矩阵</span></span><br><span class="line"><span class="comment">%        dist是使用floyd算法求出来的最短距离矩阵</span></span><br><span class="line"><span class="comment">%        i是起始节点的编号</span></span><br><span class="line"><span class="comment">%        j是终点节点的编号</span></span><br><span class="line"><span class="comment">% 输出：无</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">i</span> == <span class="built_in">j</span></span><br><span class="line">    warning(<span class="string">&#x27;起点和终点相同，请检查后重新输入&#x27;</span>)  <span class="comment">% 在屏幕中提示警告信息</span></span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">% 不运行下面的语句，直接退出函数</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">if</span> path(<span class="built_in">i</span>,<span class="built_in">j</span>) == <span class="built_in">j</span>   <span class="comment">% 如果path(i,j) = j，则有两种可能：</span></span><br><span class="line"><span class="comment">% （1）如果dist(i,j) 为 Inf , 则说明从i到j没有路径可以到达</span></span><br><span class="line">    <span class="keyword">if</span> dist(<span class="built_in">i</span>,<span class="built_in">j</span>) == Inf</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;从&#x27;</span>,num2str(<span class="built_in">i</span>),<span class="string">&#x27;到&#x27;</span>,num2str(<span class="built_in">j</span>),<span class="string">&#x27;没有路径可以到达&#x27;</span>])</span><br><span class="line"><span class="comment">% （2）如果dist(i,j) 不为 Inf , 则说明从i到j可直接到达，且为最短路径</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;从&#x27;</span>,num2str(<span class="built_in">i</span>),<span class="string">&#x27;到&#x27;</span>,num2str(<span class="built_in">j</span>),<span class="string">&#x27;的最短路径为&#x27;</span>])</span><br><span class="line">        <span class="built_in">disp</span>([num2str(<span class="built_in">i</span>),<span class="string">&#x27; ---&gt; &#x27;</span>,num2str(<span class="built_in">j</span>)])</span><br><span class="line">        <span class="built_in">disp</span>([<span class="string">&#x27;最短距离为&#x27;</span>,num2str(dist(<span class="built_in">i</span>,<span class="built_in">j</span>))])</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">else</span>  <span class="comment">% 如果path(i,j) ~= j，则说明中间经过了其他节点：</span></span><br><span class="line">    k = path(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">    result = [num2str(<span class="built_in">i</span>),<span class="string">&#x27; ---&gt; &#x27;</span>];  <span class="comment">% 初始化要打印的这个字符串</span></span><br><span class="line">    <span class="keyword">while</span> k ~= <span class="built_in">j</span>  <span class="comment">% 只要k不等于j, 就一直循环下去</span></span><br><span class="line">        result = [result , num2str(k) , <span class="string">&#x27; ---&gt; &#x27;</span> ];  <span class="comment">% i先走到k这个节点处</span></span><br><span class="line">        k = path(k,<span class="built_in">j</span>);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    result = [result , num2str(k)];</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;从&#x27;</span>,num2str(<span class="built_in">i</span>),<span class="string">&#x27;到&#x27;</span>,num2str(<span class="built_in">j</span>),<span class="string">&#x27;的最短路径为&#x27;</span>])</span><br><span class="line">    <span class="built_in">disp</span>(result)</span><br><span class="line">    <span class="built_in">disp</span>([<span class="string">&#x27;最短距离为&#x27;</span>,num2str(dist(<span class="built_in">i</span>,<span class="built_in">j</span>))])</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>灰色关联分析</title>
      <link href="/2024/01/28/%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/"/>
      <url>/2024/01/28/%E7%81%B0%E8%89%B2%E5%85%B3%E8%81%94%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="灰色关联分析"><a href="#灰色关联分析" class="headerlink" title="灰色关联分析"></a>灰色关联分析</h1><h2 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h2><p>系统分析：什么变量影响一个系统。</p><p><img src="/images/image-20240128135832491.png" alt="image-20240128135832491"></p><p>综合评价</p><p>（之前学习过层次分析法，topsisi+熵权法）</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p><img src="/images/image-20240128135910463.png" alt="image-20240128135910463"></p><p>因此</p><p><img src="/images/image-20240128140000796.png" alt="image-20240128140000796"></p><blockquote><p>基本思想：根据序列曲线几何形状的相似程度来判断其联系是否紧密</p></blockquote><h1 id="第一步：画统计图"><a href="#第一步：画统计图" class="headerlink" title="第一步：画统计图"></a>第一步：画统计图</h1><blockquote><p>得出一些易得的结论</p></blockquote><p><img src="/images/image-20240128140247004.png" alt="image-20240128140247004"></p><h1 id="第二步；确定分析序列"><a href="#第二步；确定分析序列" class="headerlink" title="第二步；确定分析序列"></a>第二步；确定分析序列</h1><blockquote><p>确定母序列</p><p>确定子序列</p></blockquote><p><img src="/images/image-20240128140319784.png" alt="image-20240128140319784"></p><p>一般y是母序列</p><h1 id="第三步：预处理"><a href="#第三步：预处理" class="headerlink" title="第三步：预处理"></a>第三步：预处理</h1><blockquote><p>去量纲，然后缩小范围</p><p>除以均值（约定俗称）</p></blockquote><p><img src="/images/image-20240128140443321.png" alt="image-20240128140443321"></p><h1 id="第四步：计算子序列各个指标与母序列的关联系数"><a href="#第四步：计算子序列各个指标与母序列的关联系数" class="headerlink" title="第四步：计算子序列各个指标与母序列的关联系数"></a>第四步：计算子序列各个指标与母序列的关联系数</h1><blockquote><p>得到两级最小差</p><p>两级最大差</p></blockquote><p><img src="/images/image-20240128140623802.png" alt="image-20240128140623802"></p><h2 id="关联系数的计算"><a href="#关联系数的计算" class="headerlink" title="关联系数的计算"></a>关联系数的计算</h2><p><img src="/images/image-20240128140722801.png" alt="image-20240128140722801"></p><h2 id="结论：比较灰色关联度"><a href="#结论：比较灰色关联度" class="headerlink" title="结论：比较灰色关联度"></a>结论：比较灰色关联度</h2><p><img src="/images/image-20240128140934037.png" alt="image-20240128140934037"></p><p>参加美赛不用灰色关联分析，用回归分析</p><p>所以就更新到这罢</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lasso回归</title>
      <link href="/2024/01/28/Lasso%E5%9B%9E%E5%BD%92/"/>
      <url>/2024/01/28/Lasso%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h1 id="lasso回归"><a href="#lasso回归" class="headerlink" title="lasso回归"></a>lasso回归</h1><blockquote><p>LASSO 回归也叫套索回归，是通过生成一个惩罚函数是回归模型中的变量系数进行压缩，达到防止过度拟合，解决严重共线性的问题，LASSO 回归最先由英国人Robert Tibshirani提出，目前在预测模型中应用非常广泛。在新格兰文献中，有大牛提出，对于变量过多而且变量数较少的模型拟合，首先要考虑使用LASSO 惩罚函数。</p></blockquote><blockquote><p>变量过多会导致多重共线性问题造成回归系数不显著，甚至导致ols估计失效。</p></blockquote><p><img src="/images/image-20240128130519231.png" alt="image-20240128130519231"></p><h2 id="Lasso回归的原理"><a href="#Lasso回归的原理" class="headerlink" title="Lasso回归的原理"></a>Lasso回归的原理</h2><p><img src="/images/image-20240128132142605.png" alt="image-20240128132142605"></p><h2 id="使用lasso回归分析"><a href="#使用lasso回归分析" class="headerlink" title="使用lasso回归分析"></a>使用lasso回归分析</h2><p><img src="/images/image-20240128132556845.png" alt="image-20240128132556845"></p><p><img src="/images/image-20240128132542976.png" alt="image-20240128132542976"></p><p><img src="/images/image-20240128132709587.png" alt="image-20240128132709587"></p><h2 id="什么时候使用lasso回归"><a href="#什么时候使用lasso回归" class="headerlink" title="什么时候使用lasso回归"></a>什么时候使用lasso回归</h2><p><img src="/images/image-20240128132838334.png" alt="image-20240128132838334"></p><h2 id="代码学习与实现："><a href="#代码学习与实现：" class="headerlink" title="代码学习与实现："></a>代码学习与实现：</h2><h4 id="Stata：拉索开心读懂-Lasso入门-lianxh-cn"><a href="#Stata：拉索开心读懂-Lasso入门-lianxh-cn" class="headerlink" title="Stata：拉索开心读懂-Lasso入门 (lianxh.cn)"></a><a href="https://www.lianxh.cn/news/c15e828b678e6.html">Stata：拉索开心读懂-Lasso入门 (lianxh.cn)</a></h4>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>因子模型</title>
      <link href="/2024/01/28/%E5%9B%A0%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
      <url>/2024/01/28/%E5%9B%A0%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="因子分析模型"><a href="#因子分析模型" class="headerlink" title="因子分析模型"></a>因子分析模型</h1><blockquote><p>通过研究变量之间的相关系数矩阵，把这些变量错综复杂的关系归结为几个综合因子。</p><p>降维，可以很好替换主成分分析。</p><p>可以更好的解释，因此可以用主成分分析可以用因子分析，所以先选择因子分析。</p></blockquote><p><img src="/images/image-20240128115840861.png" alt="image-20240128115840861"></p><p>各因子的线性组合构成了原始的指标</p><p>因子分析只知道因变量，要我们寻找自变量。 </p><h2 id="因子分析的原理"><a href="#因子分析的原理" class="headerlink" title="因子分析的原理"></a>因子分析的原理</h2><p><img src="/images/image-20240128115900209.png" alt="image-20240128115900209"></p><p>因此需要计算出A矩阵，公共因子f矩阵。</p><p><img src="/images/image-20240128115914823.png" alt="image-20240128115914823"></p><blockquote><p>f的协方差矩阵是单位矩阵。</p></blockquote><blockquote><p>也就是说公因子彼此不相关，且具有单位方差。</p></blockquote><blockquote><p>公共因子与特殊因子也应该彼此不相关。</p></blockquote><h1 id="因子分析模型的性质"><a href="#因子分析模型的性质" class="headerlink" title="因子分析模型的性质"></a>因子分析模型的性质</h1><p><img src="/images/image-20240128115934113.png" alt="image-20240128115934113"></p><h1 id="因子载荷矩阵的统计意义"><a href="#因子载荷矩阵的统计意义" class="headerlink" title="因子载荷矩阵的统计意义"></a>因子载荷矩阵的统计意义</h1><p>因子载荷不分析实际上是因为任意×于一个正交矩阵进行变换。</p><p>这样就可以更容易解释。</p><p><img src="/images/image-20240128115949236.png" alt="image-20240128115949236"></p><p><img src="/images/image-20240128120005073.png" alt="image-20240128120005073"></p><h2 id="参数估计"><a href="#参数估计" class="headerlink" title="参数估计"></a>参数估计</h2><p><img src="/images/image-20240128120014862.png" alt="image-20240128120014862"></p><h1 id="因子旋转的方法"><a href="#因子旋转的方法" class="headerlink" title="因子旋转的方法"></a>因子旋转的方法</h1><p><img src="/images/image-20240128120028580.png" alt="image-20240128120028580"></p><h1 id="因子得分"><a href="#因子得分" class="headerlink" title="因子得分"></a>因子得分</h1><p><img src="/images/image-20240128120047449.png" alt="image-20240128120047449"></p><h1 id="例题讲解"><a href="#例题讲解" class="headerlink" title="例题讲解"></a>例题讲解</h1><p><img src="/images/image-20240128120057063.png" alt="image-20240128120057063"></p><p><img src="/images/image-20240128120104369.png" alt="image-20240128120104369"></p><h3 id="两个检验"><a href="#两个检验" class="headerlink" title="两个检验"></a>两个检验</h3><p>会有结果的</p><p>巴特利球形检验：原来假设：不适合做因子分析，相关性太差，不适合降维</p><p>如果p&lt;0.05就适合作因子分析</p><p><img src="/images/image-20240128120112763.png" alt="image-20240128120112763"></p><p><img src="/images/image-20240128120121296.png" alt="image-20240128120121296"></p><p>非常适合。</p><h1 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h1><p><img src="/images/image-20240128120133272.png" alt="image-20240128120133272"></p><p>用什么方法其实无所谓，因为要进行旋转。</p><p><img src="/images/image-20240128120141207.png" alt="image-20240128120141207"></p><p><img src="/images/image-20240128120149028.png" alt="image-20240128120149028"></p><h1 id="第一次分析"><a href="#第一次分析" class="headerlink" title="第一次分析"></a>第一次分析</h1><h2 id="首先进行检验"><a href="#首先进行检验" class="headerlink" title="首先进行检验"></a>首先进行检验</h2><p><img src="/images/image-20240128120159778.png" alt="image-20240128120159778"></p><h1 id="确定因子的数目（和特征值大于85有点像）"><a href="#确定因子的数目（和特征值大于85有点像）" class="headerlink" title="确定因子的数目（和特征值大于85有点像）"></a>确定因子的数目（和特征值大于85有点像）</h1><p><img src="/images/image-20240128120210029.png" alt="image-20240128120210029"></p><p>主要提取陡峭的部分。</p><h1 id="第二次分析"><a href="#第二次分析" class="headerlink" title="第二次分析"></a>第二次分析</h1><p><img src="/images/image-20240128120220312.png" alt="image-20240128120220312"></p><p>对结果的分析</p><p>对行元素平方和，两个因子可以反映出百分之95的信息。</p><p>公因子很好的解释。</p><p><img src="/images/image-20240128120228253.png" alt="image-20240128120228253"></p><h2 id="总方差解释表"><a href="#总方差解释表" class="headerlink" title="总方差解释表"></a>总方差解释表</h2><p><img src="/images/image-20240128120238424.png" alt="image-20240128120238424"></p><h1 id="成分矩阵"><a href="#成分矩阵" class="headerlink" title="成分矩阵"></a>成分矩阵</h1><p><img src="/images/image-20240128120248032.png" alt="image-20240128120248032"></p><p>可以用易于解释的说法。</p><p><img src="/images/image-20240128120257649.png" alt="image-20240128120257649"></p><h1 id="因子得分-1"><a href="#因子得分-1" class="headerlink" title="因子得分"></a>因子得分</h1><p>标准化符号</p><p><img src="/images/image-20240128120307686.png" alt="image-20240128120307686"></p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模Excel绘制</title>
      <link href="/2024/01/28/%E7%94%A8exel%E7%BB%98%E5%88%B6%E7%BB%9F%E8%AE%A1%E5%9B%BE/"/>
      <url>/2024/01/28/%E7%94%A8exel%E7%BB%98%E5%88%B6%E7%BB%9F%E8%AE%A1%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="用exel绘制统计图"><a href="#用exel绘制统计图" class="headerlink" title="用exel绘制统计图"></a>用exel绘制统计图</h1><p>饼图，饼状图，条形图，直方图，折线图，散点图，箱型图。</p><h1 id="饼图："><a href="#饼图：" class="headerlink" title="饼图："></a>饼图：</h1><p>适合只有一个数据系列</p><p>任何数据值大于0</p><p>类别不超过7个</p><p>划分的类别完整</p><p>类别过多可以用复合饼图</p><p>类别只有两个别用</p><h1 id="内容："><a href="#内容：" class="headerlink" title="内容："></a>内容：</h1><p>选中两列，点击插入即可有饼图，一般不在图中放标题</p><h4 id="位置要求："><a href="#位置要求：" class="headerlink" title="位置要求："></a>位置要求：</h4><p>图的标题放在下面</p><p>分类放在右边</p><p>图中要有数据：点击图，点击右上角的加号有一个数据标签，</p><p>点击标签，数据标签可以有更多选项，标签可以包含引导线之类的，可以进行调整。</p><p>至于填充颜色之类的，做到精美就行了</p><p>边框设置为无线条比较好。</p><p>要有区分度，注意明暗的感觉，不要太花里胡哨。</p><p>选中图表，图表工具，设计，选择明暗的颜色，这种比较好。</p><h2 id="类别比较多的话，饼图已经不适应了"><a href="#类别比较多的话，饼图已经不适应了" class="headerlink" title="类别比较多的话，饼图已经不适应了"></a>类别比较多的话，饼图已经不适应了</h2><h2 id="这个时候用柱状图"><a href="#这个时候用柱状图" class="headerlink" title="这个时候用柱状图"></a>这个时候用柱状图</h2><p>还有一种情况也不行，注意不要忽略饼图的边缘，比如其他，这可能是题目数据每考虑的情况</p><p>所以说饼图最好全集是1</p><p>饼图之后还是进行排序比较好</p><p>第一种：</p><p>排序，复制后变成表格，然后可以选择升序</p><p>第二种：</p><p>或者直接排序，就开始，排序</p><p>多组数据有时候可以选择复合饼图</p><h1 id="直方图（包含一部分柱状图）"><a href="#直方图（包含一部分柱状图）" class="headerlink" title="直方图（包含一部分柱状图）"></a>直方图（包含一部分柱状图）</h1><h2 id="直方图是显示数据频数或频率的柱状图"><a href="#直方图是显示数据频数或频率的柱状图" class="headerlink" title="直方图是显示数据频数或频率的柱状图"></a>直方图是显示数据频数或频率的柱状图</h2><p>落在区间里有几个数字。</p><p>例子：</p><p>第一列：姓名</p><p>第二列：体重</p><p>这时候不需要第一列来绘制直方图</p><p>加一些标签，坐标轴标题之类的</p><p>还有点击到坐标轴选择，可以设置箱子的个数，找到横轴的整数。</p><p>箱子的宽度是组距。组距越大就数量越少</p><h2 id="直方图的直观作用：可以看数据分布状况"><a href="#直方图的直观作用：可以看数据分布状况" class="headerlink" title="直方图的直观作用：可以看数据分布状况"></a>直方图的直观作用：可以看数据分布状况</h2><blockquote><p>究竟是对称的，还是有偏的。</p></blockquote><h1 id="与柱状图的对比"><a href="#与柱状图的对比" class="headerlink" title="与柱状图的对比"></a>与柱状图的对比</h1><blockquote><p>直方图展示数据的分布，柱状图比较数据的大小关系</p><p>直方图x轴为定量数据，一个个区间，柱状图则为分类数据</p><p>直方图y轴要么是频率要么是频数，柱状图y轴为数据大小</p></blockquote><p>可以选择二位柱状图的，如果有两列数据，如果太紧凑的话，下移到折线图或者修改间距</p><h1 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h1><h2 id="如果数据是时间序列数据可以考虑折线图。"><a href="#如果数据是时间序列数据可以考虑折线图。" class="headerlink" title="如果数据是时间序列数据可以考虑折线图。"></a>如果数据是时间序列数据可以考虑折线图。</h2><p>带有数据标签的折线图</p><p>带有数据标签的堆积折线图，有点前缀和，就是求和，因此很少用的。</p><p>一般会把我们要的x轴弄成折线图，所以要把第一列设为文本格式（不过有些还是不行的，要换解决方法）</p><p>在前面加入单引号，也可以转为文本格式。</p><p>再进行折线图的绘制即可。</p><p>小技巧：crtl shirt 向下即可到达底部</p><p>两个的话放到次坐标轴，点击折线即可。</p><p>所以说得先弄第一列为文本。</p><h1 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h1><p>看两个变量之间相互影响的趋势。</p><p>注意横轴的上下界设置和标题设置</p><p>趋势线也可以加入，回归出线性预测</p><p>也可以显示R的平方。</p><p>删除分类的部分。进行两次绘制</p><p>身高</p><p>体重</p><p>性别</p><p>性别那一列就各自删除，另成一列</p><p>有些为空格进行绘制。</p><h1 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h1><p>配合定性变量画分组箱型图，作比较，如果只有一个定量变量，很少用一个箱线图去展示其分布，更多选择直方图，箱线图更有效的作比较。</p><p>箱线图要比较男女生的身高，用什么工具？</p><p>箱线图！</p><p>用于反映一组或多组连续型定量数据分布的中心位置和散布范围。</p><p>需要一些数据：上四分位数，下四分位数，异常值（超过上四分，低于下四分），极端异常值：超过三倍，温和：低于3倍。</p><p>主要用于 比较</p><p>完结撒花。</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数学建模论文</title>
      <link href="/2024/01/28/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/"/>
      <url>/2024/01/28/%E6%95%B0%E5%AD%A6%E5%BB%BA%E6%A8%A1%E8%AE%BA%E6%96%87%E5%86%99%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="数学建模论文写作"><a href="#数学建模论文写作" class="headerlink" title="数学建模论文写作"></a>数学建模论文写作</h1><h1 id="数学建模"><a href="#数学建模" class="headerlink" title="数学建模"></a>数学建模</h1><h2 id="论文方面："><a href="#论文方面：" class="headerlink" title="论文方面："></a>论文方面：</h2><blockquote><p>题目：掌握固定模型</p><p>基于——————模型————研究与分析</p></blockquote><blockquote><p>摘要，关键词</p><p>总结归纳能力，看高水平论文</p></blockquote><blockquote><p>问题重述</p><p>简短拆解，描述复杂的精炼</p></blockquote><blockquote><p>问题假设</p><p>明确假设点</p></blockquote><blockquote><p>问题分析</p><p>将问题定性，说明如何求解</p></blockquote><blockquote><p>符号说明</p><p>文中的符号说明清楚，用希腊字母</p></blockquote><blockquote><p>模型建立</p><p>将常用模型进行归纳整理，形成算法库</p></blockquote><blockquote><p>模型求解</p><p>编程语言</p></blockquote><blockquote><p>模型优缺点评价</p><p>对模型的不足提前掌握</p></blockquote><blockquote><p>参考文献</p></blockquote><h2 id="数学建模的六个步骤"><a href="#数学建模的六个步骤" class="headerlink" title="数学建模的六个步骤"></a>数学建模的六个步骤</h2><blockquote><p>一.模型准备，连接问题的实际背景，明确实际意义，掌握对象的各种信息，以数学思路解释问题</p><p>二.模型假设，根据实际对象的特征和建模的目的，对问题进行必要的简化，用精确的语言提出一些恰当的假设，对涉及的变量，变量的单位和相关假设进行定义，用表达式表达。</p><p>三.模型建立，在假设的基础上，利用适当数学工具来划分变量常量的数学关系，建立相应数学结构，选择建模方法，进一步转化为函数。</p><p>四.模型求解，利用获取的数据资料，对模型的所有参数做出计算，推导模型的公式，将数学表达式变形为建模方法的标准形式，利用数学软件进行计算。</p><p>五.模型分析，对建立模型的思路进行阐述，对所得结果进行数学上的分析，包括误差分析，数据稳定性分析。</p><p>六.模型检验：用非技术性的语言回答实际问题，将分析结果和实际比较，验证模型的准确性，合理性，适用性，如果吻合，对计算结果给出实际含义，进行解释。如果吻合差，则修改假设，再次重复建模。</p></blockquote><p>建模员：</p><blockquote><p>模型的功能</p><p>模型的适用场景</p><p>模型实现的条件</p><p>模型的缺点和不足</p><p>模型如何改进</p></blockquote><p>程序员</p><blockquote><p>掌握编程基础</p><p>熟练实现各种常见算法（各种程序包）</p><p>修正bug</p><p>能够熟练利用编程或软件制作精美图片</p></blockquote><p>写作员</p><blockquote><p>能够掌握学术语言规范</p><p>明白论文各模块写作要求</p><p>排版</p><p>翻译检查</p></blockquote><p>备战流程</p><blockquote><p>学习基础知识</p><p>学习算法知识</p><p>学习优秀论文</p><p>学习编程知识</p><p>调用常用模型</p><p>复现优秀论文</p><p>掌握写作要求</p><p>掌握学术语言</p><p>掌握排版技巧</p></blockquote><p>赛题类型</p><blockquote><p>一.预测类：分析已有的数据或现象，分析内在规律，对未来情形进行预测</p><p>小样本内部预测</p><p>大样本内部预测</p><p>解决方法</p><p>1.确定预测目标</p><p>2.收集，分析资料</p><p>3.选择合适的预测方法</p><p>4.分析评价预测方法和结果</p><p>5.修正预测结果</p><p>6.给出预测结果</p><p>相关算法</p><p>插值与拟合方法：小样本</p><p>回归分析法：中大</p><p>灰色预测方法：小样本的未来预测，有固定趋势</p><p>时间序列方法：适合中，大样本的随机因素或周期特征的未来趋势未来预测</p><p>神经网络方法：适合大（特大）样本预测</p></blockquote><blockquote><p>二.评价类</p><p>按照事物的发展或者现状进行划分的过程，主要体现在生态环境，社会建设，方案策略进行评价，没有明确指标体系，往往需要查阅各种资料，因此没明确类方法。</p><p>解决评价类的关键是指标体系的构建，构建后选择和平的评价方法即可，体系应全面，准确，独立。</p><p>解决评价类的一般步骤：</p><p>1.明确评价目的</p><p>2.确定被评价对象</p><p>3.建立评价指标体系</p><p>4.确定各指标对应的权重系数</p><p>5.选择或构造综合评价模型</p><p>6.计算各系统的综合评价值</p><p>7.给出综合评价值</p></blockquote><blockquote><p>三.机理分析类</p><p>基于现实对象特性，分析因果，找出反映内部机理的规律。一般是物理，化学，经济知识，然后对数据或现象作必要假设，最后通过构建合适的方程或关系式进行数值表达。</p><p>赛题分析：机理分析立足于建立事物内部的规律。需要诸多关联知识。</p></blockquote><blockquote><p>四.优化类题</p><p>指在现有条件固定的情况下，如何使得目标效果达到最佳。优化类问题往往需要分析三个关键因素，目标函数，决策变量和约束条件，三者往往缺一不可。</p><p>解决问题的一半步骤：</p><p>1.确定优化目标</p><p>2.确定决策变量</p><p>3.构建目标函数</p><p>4.根据已知条件构建约束条件</p><p>5.选择合适的方法求解目标函数</p><p>6.给出优化结果</p></blockquote><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><h2 id="论文标题"><a href="#论文标题" class="headerlink" title="论文标题"></a>论文标题</h2><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>摘要是论文内容不加注释和评论的简短陈述，其作用是使读者不阅读论文全文即能获得必要的信息。</p><p>一般说来，摘要应包含以下五个方面的内容：</p><p>①研究的主要问题；</p><p>②建立的什么模型；</p><p>③用的什么求解方法；</p><p>④主要结果（简单、主要的）；</p><p>⑤自我评价和推广。</p><p>  摘要中尽量不要有数学表达式。</p><p>数学建模竞赛章程规定，对竞赛论文的评价应以：</p><p>①假设的合理性</p><p>②建模的创造性</p><p>③结果的正确性</p><p>④文字表述的清晰性为主要标准。</p><p>所以论文中应努力反映出这些特点。</p><p>一、  <strong>问题的重述</strong></p><p>数学建模竞赛要求解决给定的问题，所以一般应以“问题的重述”开始。</p><p>此部分的目的是要吸引读者读下去，所以文字不可冗长，内容选择不要过于分散、琐碎，措辞要精练。</p><p>这部分的内容是将原问题进行整理，将已知和问题明确化即可。</p><p>注意：</p><p>在写这部分的内容时，绝对不可照抄原题！</p><p>应为：在仔细理解了问题的基础上，用自己的语言重新将问题描述一篇。应尽量简短，没有必要像原题一样面面俱到。</p><p><strong>二、</strong> <strong>模型假设</strong></p><p>作假设时需要注意的问题：</p><ol><li>对问题有帮助的所有假设都应该在此出现，包括题目中给出的假设！</li><li>问题重述不能代替假设！也就是说，虽然你可能在你的问题重述中已经叙述了某个假设，但在这里仍然要再次叙述！</li><li>与题目无关的假设，就不必在此写出了。</li></ol><p><strong>三、 变量说明</strong></p><p>为了使读者能更充分的理解你所做的工作，</p><p>对你的模型中所用到的变量，应一一加以说明，变量的输入请使用公式编辑器。</p><p><a href="https://www.bilibili.com/video/BV1qt411G7Bv?p=11">https://www.bilibili.com/video/BV1qt411G7Bv?p=11</a></p><p>注意：</p><ol><li>变量说明要尽量全，即是说，在后面模型建立模型求解过程中使用到的所有重要的变量，都应该在此加以说明。</li><li>要与数学中的习惯相符，不要使用程序中变量的写法</li></ol><p><strong>四、模型的建立与求解</strong></p><p>这一部分是文章的重点，要特别突出你的创造性的工作。在这部分写作需要注意的事项有：</p><p>①一定要有分析，而且分析应在所建立模型的前面；</p><p>②一定要有明确的模型，不要让别人在你的文章中去找你的模型；</p><p>③关系式一定要明确；思路要清晰，易读易懂。</p><p>④建模与求解一定要截然分开；</p><p>⑤结果不能代替求解过程：必须要有必要的求解过程和步骤！最好能像写算法一样，一步一步的写出其步骤；</p><p>⑥结果必须放在这一部分的结果中，不能放在附录里。</p><p>⑦结果一定要全，题目中涉及到的所有问题必须都有详细的结果和必须的中间结果！</p><p>⑧程序不能代替求解过程和结果！</p><p>⑨非常明显、显而易见的结果也必须明确、清晰的写在你的结果中！</p><p>⑩每个问题和问题之间以及5个小点之间都必须空一行。</p><p><strong>问题一：</strong></p><p>1.建模思路：</p><p>①对问题的详尽分析；</p><p>②对模型中参数的现实解释；这有助于我们抓住问题的本质特征，同时也会使数学公式充满生气，不再枯燥无味</p><p>③完成内容阐述所必需的公式推导、图表等</p><p>2.模型建立：</p><p>建立模型并对模型作出必要的解释</p><p>对于你所建立的模型，最好能对其中的每个式子都给出文字解释。</p><p>3.求解方法：</p><p>给出你的求解思路，最好能想写算法一样，写出你的算法。</p><p>4.求解结果：</p><p>你的求解结果必须精心设计（最好使用表格的形式），使人一目了然。</p><p>结果必须要全，对于你求解的一些必须的中间结果，也必须在这里反映出来。</p><p>5.模型的分析与检验</p><p>在计算出相应的结果之后，你必须对你的结果做出相应的解释。</p><p>因为你的结果往往是数学的结果，一般人无法理解。</p><p>你必须归纳出你的结论和建议。</p><p>这里主要应包括：</p><p>①这个结果说明了什么问题？</p><p>②是否达到了建模目的？</p><p>③模型的适用范围怎样？</p><p>④模型的稳定性与可靠性如何？</p><p><strong>问题二：</strong></p><p><strong>问题三：</strong></p><p><strong>问题四：</strong></p><p><strong>问题五：</strong></p><p><strong>五、模型的评价与推广</strong></p><p>这一部分应包括：</p><p>①你的模型完成了什么工作？达到了什么目的？得出了什么规律？</p><p>②你的建模方法是否有创造性？为今后的工作提供了什么思路？结果有什么理论或实际用途？</p><p>③模型中有何不足之处？有何改进建议？</p><p>④模型中有何遗留未解决的问题？以及解决这些问题可能的关键点和方向。</p><p>这一部分一定要有！</p><p><strong>六、参考文献</strong></p><p>引用别人的成果或其他公开的资料(包括网上查到的资料)必须按照规定的参考文献的表述方式在正文引用处和参考文献中均明确列出。正文引用处用方括号标示参考文献的编号，如[1][3]等；引用书籍还必须指出页码。参考文献按正文中的引用次序列出，其中</p><p>书籍的表述方式为：</p><p>[编号] 作者，书名，出版地：出版社，出版年。</p><p>参考文献中期刊杂志论文的表述方式为：</p><p>[编号] 作者，论文名，杂志名，卷期号：起止页码，出版年。</p><p>参考文献中网上资源的表述方式为：</p><p>[编号] 作者，资源标题，网址，访问时间（年月日）。</p><p><strong>七、附录</strong></p><p>不便于编入正文的资料都收集在这里。</p><p>  可以包括：</p><p>① 某一问题的详细证明或求解过程；</p><p>② 比较大的流程图；</p><p>③ 计算机的源程序及结果（或者使用傻瓜式操作软件的截图，例如SPSS）；</p><p>④ 较繁杂的图表或计算结果（一般结果只要不超过A4一页，尽量都放在正文中）。</p><p>从论文写作时间上来看，比赛题目给出之后，最好要在两三个小时内选定题目（当然不要急着去官网选题，等十分确定之后再去选），三人商量选定题目之后，负责论文写作的人就可以立即着手去写问题重述并给出论文的大体格式即若干个大标题。(提醒一下：问题重述一定要用自己的话简练的去说，切忌照抄问题，这样会导致查重时被认为是抄袭直接枪毙掉)干完这些之后，负责写论文的需要投入建模过程中，跟上负责建模的人的思路，并可以给出若干建议。在与建模同学的交流过程中可以写出符号说明、模型假设（这个最好是建模的人给出）。此后基本上是依次写模型建立与求解，问题分析，模型检验与改进（模型验证，误差分析，灵敏度分析），模型评价（模型优缺点），摘要，关键字，参考文献，附录，题目。</p><p>从论文写作的格式上来看，有如下几点需要注意：</p><p>（1） 论文中的符号一律要用公式编辑器打出来，不要简单地斜体或者直接就是印刷体；</p><p>（2） 论文的公式要有编号，编号要对上下对齐；</p><p>（3） 论文里的图表要分开标注，从图1到图N，表1到表N，文字说明图在下，表在上 （也可以图1.1，表2.3这样标注，不过不提倡)；</p><p>（4） 论文里的空行要按照统一标准，大标题下空几行，小标题下空几行，图表上空一行，图表下空一行，有时为了美观，需要适当删掉空行，这个要自己斟酌；</p><p>（5） 论文里的图里要有图标，方便别人观看；</p><p>（6） 论文里的符号要清晰有序，不要前后重复造成混乱；</p><p>（7） 具体的字体行间距论文架构需要谨慎参考当年的比赛通知；</p><p>总体上来说，论文的写作要贯穿三天，而且最好有一个人主要负责，论文的写作言语上尽量简练易懂。调论文的格式往往需要好几个小时，不要低估了这个工作量。虽然论文格式规定上只占5分，但实际上给评委的印象分可能占到很多，所以说格式很重要。</p>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机概论综述</title>
      <link href="/2024/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA%E7%BB%BC%E8%BF%B0/"/>
      <url>/2024/01/28/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%A6%82%E8%AE%BA%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Ch01"><a href="#Ch01" class="headerlink" title="Ch01"></a>Ch01</h1><p>计算机系统 计算系统 计算机是一台设备。<br>计算系统是动态的.用于解决问题以及与它所处的环境进行交互。<br>计算系统是通过交互解决问题的计算机硬件，软件和数据。<br>计算系统由硬件、软件和它们管理的数据组成。<br>硬件：计算系统的物理元件（打印机、电路板、电线、键盘等）<br>软件：提供计算机执行的指令的程序<br>计算系统分层：通信层、应用层、操作系统层、程序设计层、硬件层、信息层（从外到内）<br>抽象：删除了复杂细节的心理模型<br>信息隐藏：一种使程序段独立的技术，通过削减一个代码段的功能，来获取其他代码段的信息。<br>一些科学家：Pascal：可以执行整数的加法和减法运算<br>Gottfried Wihelm vor Leibniz第一台能够进行四种整数运算的机械设备<br>Joseqh Jacquared发明织布机，利用穿孔卡片<br>Babbage提出分析机，有内存概念，也采取穿孔卡片<br>Ada优化分析机，提出循环概念<br>Turing 图灵机<br>Hollerith发明机电式制表机，并用来人口普查<br>George Sitbitz发明二进制机器，使用继电器<br>Konrad Zuse 发明第一台二进制可编程计算机<br>ENIAC世界上第一台全可编程的数字计算机，采用十进制<br>后来是EDVAC采取二进制<br>第一代计算机：真空管存储信息，主存储器是磁鼓，二级存储设备是磁带，输入设备是读卡机，可以阅读IBM卡片，输出设备是穿孔卡片或行式打印机。<br>第二代计算机：晶体管存储信息，主存储器时磁芯，二级存储设备时磁盘，地址概念出现，磁盘上的数据的位置标识符。<br>第三代计算机：集成电路，终端（输入&#x2F;输出设备，如键盘）也出现。<br>第四代计算机：大规模集成电路<br>摩尔定律：芯片的集成度每18个月增长一倍<br>并行计算：依靠互相连接的中央处理器，所有处理器共享同一个存储单元<br>第一代软件：机器语言，汇编语言（使用助记忆码表示每条机器语言指令。<br>第二代软件：高级语言<br>第三代:操作系统，分时概念（每个用户被分配到一小段中央处理器时间） </p><h1 id="Ch02"><a href="#Ch02" class="headerlink" title="Ch02"></a>Ch02</h1><p>数字，自然数，负数，整数，有理数（两个整数的商）<br>基数：记数系统的基本数值，规定了这个系统中使用的数字量和数位位置的值。<br>位置计数法：一种表达数字的系统，数位按顺序排列，每个数位有一个位值，数字的值时每个数位和位值得乘积之和。<br>位值是基数的幂<br>二进制数字：二进制计数系统的一位数字，可以是0或1<br>位：二进制数字的简称<br>字节：八个二进制位<br>字：一个或多个字节<br>计算机硬件采取的是二进制数，高电平代表1，低电平代表0<br>二进制，八进制，十进制，十六进制的相互转化</p><h1 id="Ch03"><a href="#Ch03" class="headerlink" title="Ch03"></a>Ch03</h1><p>数据：基本值或者事实<br>信息：用有效的方式组织或处理过的数据。<br>计算机是一台多媒体设备，可以处理各种各样的信息。计算机可以存储、表示和帮助我们修<br>改各种类型的数据<br>多媒体：几种不同的媒体类型<br>Numbers 数字<br>Text 文本<br>Audio 音频<br>Images and graphics 图像和图形<br>Video 视频<br>数据压缩：减少存储一段数据所需的空间。<br>压缩率：说明压缩的程度，是压缩后的数据大小除以原始数据大小的值。<br>数据压缩技术：<br>无损压缩，即提取的数据没有丢失任何原始信息<br>有损压缩，即在压缩过程中将丢失一些信息<br>带宽：在固定时间从一个地方到另一个地方的最大位数或字节数<br>模拟信息：用连续形式表示的信息<br>数字信息：用离散形式表示的信息<br>数字化：把信息分割为离散的片段<br>高低两个状态，易于维护（二进制）<br>脉冲编码调制：在两个极端之间跳跃的信号的变化<br>重新记时间：在信号降级太多之前重新插入原数字的行为<br>负数表示法，二进制表示法：<br>符号数值表示法 [原码] 符号表示数所属的分类（正数或负数），值表示数的量值<br>（解决正 0 和负 0）保持所有的数作为整数值，可以用一半数表示正数，另一半表示负数，<br>符号由数的量值决定<br>使用两个十进制数 让 1 至 49 表示正数 1 至 49，用 50 至 99 表示负数-50 至-1<br>在这种模式下执行加法，只需要对两个数求和，然后舍弃进位即可。<br>A- B&#x3D;A+(-B) 等价于给第一个数加上第二个数的负数<br>这种负数表示法称为十进制补码<br>（k 为数字个数）<br>负数用10的K次方减去I表示<br>二进制补码<br>为了便于查看长的二进制数，我们把实数直线绘制成垂直的<br>二进制补码加法和减法同十进制补码运算法则一样<br>数字溢出（overflow）<br>当我们分配给结果的位数存不下计算出的值时，将发生溢出<br>溢出是把无限的世界映射到有限的机器上会发生的典型问题。<br>实数表示法<br>实数具有整数部分和小数部分 小数点右侧的位置是十分位、百分位。<br>二进制实数表示法采用的是同十进制相同的规则 十进制数的点实际上相当于小数点（分割为整数和小数部分的点）<br>小数点右侧的位置是二分位、四分位、八分位。<br>十进制实数值可以用下列公式来表示[sign:符号，mantissa:尾数，exp:指数]<br>这种表示法称为浮点表示法，因为数字的个数是固定的，但是小数点却是浮动的。<br>下面的公式定义了一个二进制浮点值：<br>sign * mantissa * 2^exp（次方）<br>文本表示法<br>要表示的字符数是有限的。一种表示字符的普通方法是列出所有字符，然后赋予每个字符一<br>个二进制字符串。<br>字符集只是字符和表示它们的代码的清单。计算机制造商赞同字符集标准化<br>ASCII 是美国信息交换标准代码 最初，ASCII 字符集采用 7 位每个字符，可以表示 128 个不<br>同的字符 之后，ASCII 字符集进化了，用 8 位表示每个字符<br>扩展 ASCII 无法满足国际需要 一般情况下，每个字符的编码使用 16 位 Unicode 被设计为<br>ASCII 的超集 前 256 个字符与扩展 ASCII 字符集中的完全一样<br>文本压缩：<br>在一个文档中，每个字符分配 16 位，可能占用太多的文件空间 我们需要更有效率的方法来<br>存储和传输文本。 文本压缩技术<br>keyword encoding 关键字编码<br>run-length encoding 行程长度编码<br>Huffman encoding 赫夫曼编码<br>关键字编码：它用单个字符代替常用的单词<br>行程长度编码：一个字符可能在一个长序列中反复出现（把一系重复字符替换为他们出现的次数，2和3不要用）<br>赫夫曼编码 用变长的二进制串表示字符。使常用的字符具有较短的编码。<br>赫夫曼编码的一个重要特性是用于表示一个字符的位串不会是表示另一个字符的位串的前<br>缀。 从左到右扫描一个位串时，每当发现一个位串对应一个于一个字符，那么这个位位串<br>就一定表示这个字符，该位串不可能是更长位串的前缀。<br>音频数据表示法：<br>一个立体声系统通过把电信号发达到一个扬声器来制造声音。<br>这种信号是声波的模拟表示法。<br>信号中的电压按声波的正比例变化。<br>通过采样来数字化：<br>周期性地测量信号的电压 记录合适的值。<br>光滑激光的反射强烈，反之则反之。<br>音频格式：<br>WAV, AU, AIFF, VQF, and MP3 MP3 (MPEG-2, audio layer 3 file) is dominant<br>图像与图形表示法<br>在计算机中，颜色通常用 RGB（红-绿-蓝）值表示，这其实是三个数字，说明了每种原色<br>的相对份额。RGB 值（255，255，0）最大化了红色和绿色的份额，最小化了蓝色的份额，<br>结果生成立了嫩黄色。<br>色深度：用于表示颜色的数据量称为色深度，通常用表示颜色的位数表示<br>（Highcolor）增强彩色：把色深度为 16 位的颜色，RGB 值中的每个数字由 5 位表示，剩下的<br>一位有时用于表示透明度。<br>TrueColor 真彩色：指色深度为 24 位的颜色，RGB 值中的每个数字由 8 位表示。<br>数字化一幅图像：是把它表示为一个独立的点集，这些点称为像素。<br>分辨率：用于表示图像的像素个数。<br>光栅图形格式：逐个像素存储图像信息的格式。<br>Bitmap (BMP), GIF, JPEG, and PNG are raster-grahics formats<br>图形的矢量表示法：<br>矢量图形：用线段和几何形表示图像的方法。<br>矢量图形是一系列描述线段的方法、线宽和颜色的命令。<br>由于不必记录所有的像素，所以采用这种格式的文件一般比较小。<br>矢量图形可以通过数学计算调整大小，这些改变可以根据需要动态地计算。<br>但是矢量图形不适用于表示真实世界的图像<br> JPEG是首选<br>有两种是主流，一种是ADobe flash,一种是SVG<br>视频表示法：<br>视频编译码器：指用于缩减电影大小的方法，使电影能够在计算机或者网络上播放。<br>几乎所有的视频编译码器都采用有损压缩，以最小化与视频相关的数据量。<br>时间压缩：根据连续帧之间的差别压缩电影的技术<br>空间压缩：基于静态图像的压缩技术的电影压缩技术    </p><h1 id="Ch04"><a href="#Ch04" class="headerlink" title="Ch04"></a>Ch04</h1><p>门：对电信号执行基本运算的设备，接受一个或多个输入信号，生成一个输出信号。<br>电路：是由门组合而成的，可以执行更加复杂的任务。<br>布尔表达式：表示二值逻辑函数的数学表示方法<br>逻辑框图：是电路的图形化表示。每种类型的门由一个特定的图形符号表示。<br>真值表：列出了一种门可能遇到的所有输入组合和相应的输出。<br>晶体管：作为导线或电阻器的设备，由输入信号的电平决定他的作用。<br>半导体：既不是良导体，也不是绝缘体的材料。<br>晶体管相当于非门。<br>组合电路:输出仅由输入值决定的电路<br>时序电路：输出是输入值和电路当前状态的函数的电路<br>电路等价：对应每个输入值组合，两个电路都生成完全相同的输出<br>布尔代数的一大优点，它们利用可以证明的数学法则来设计逻辑电路<br>在数字逻辑层，加法是用二进制执行的。<br>这些加法运算是由专用电路加法器执行的。<br>加法器：对二进制值执行加法运算的电路<br>半加器：计算两个数位的和并（生成）正确进位的电路。<br>sum &#x3D; A  B carry &#x3D; AB<br>全加器：计算两个数位的和，并（考虑）进位输入的电路<br>多路复用器：使用一些输入控制信决定用那一条输入数据线发出输出信号的线路<br>多路分配器：是执行相反操作的电路，也就是说它只有一个输入，根据n条控制线的值，这个输入信号会发送出2的n次方个信号<br>集成电路：又称芯片，即是嵌入了多个门的硅片</p><h1 id="cho5略"><a href="#cho5略" class="headerlink" title="cho5略"></a>cho5略</h1><h1 id="Ch06"><a href="#Ch06" class="headerlink" title="Ch06"></a>Ch06</h1><p>计算机是能够存储、检索和处理数据的可编程电子设备<br>数据和操作数据的指令逻辑上是相同的，它们存储在相同的地方。<br>内存单元，控制单元，算术逻辑单元，输入单元，输出单元<br>可编址性：内存中每个可编址位置存储的位数<br>算术逻辑单元：执行算术运算和逻辑运算的计算机部件<br>寄存器：CPU的一小块存储区域，用于村吹中间值或特殊数据<br>输入单元：接受要存储在内存中数据的设备<br>输出单元：一种设备，用于把存储在内存中的数据打印或显示出来，或者把存储在内存或其他设备中的信息制作成一个永久副本。<br>控制单元：控制其他部件的动作，从而执行指令序列的计算机部件。<br>指令寄存器：存放当前正在执行的指令的寄存器<br>程序寄存器：存放下一条要执行的指令的地址的寄存器。<br>中央处理器：算术逻辑单元和控制单元的结合，是计算机用于解释和执行指令的大脑。<br>总线宽度：可以在总线上并行传输的位数<br>缓存：一种用于存储常用数据的小型告诉存储器<br>流水线：一种将指令分解为可以重叠执行的小步骤的技术<br>主板：个人计算机的主电路板<br>读取-执行周期：<br>读取下一条指令<br>译解指令<br>如果需要，获取数据<br>执行指令<br>RAM随机存取存储器<br>ROM：只读存储器<br>当不再处理程序和数据或关机时，可把数据和程序保存起来，这些类型的存储设备称为二级存储设备。<br>磁道：磁道表面的同心圆<br>扇区：磁道的一个区<br>块：存储在扇区的信息<br>寻道时间：读&#x2F;写头定位到定的磁道所花费的时间<br>等待时间：把指定的扇区定位到读&#x2F;写头之下所花费的时间<br>存取时间：即是寻道时间和等待时间之和<br>传送速率：数据从磁盘到内存的速率<br>柱面：所有磁盘表面的同心磁道的集合<br>同步处理：多处理器将将同一个程序应用于多个数据集<br>共享内存处理器：多个处理器共享整体内存的情况<br>虚拟机：为了模拟真实机器的重要特征而设计的假想的机器<br>指令说明符：说明要执行什么操作和如何解释操作数的位置<br>操作说明符：存放的是操作数本身：立即寻址，如果存放的是：直接寻址<br>机器语言：由计算机直接使用的二进制编码指令构成的语言。<br>汇编语言：一种低级语言，用助记码表示特定计算机的机器语言指令。<br>汇编器：把汇编语言程序翻译成机器代码的程序。<br>汇编器指令：翻译程序使用的指令<br>注释：为程序读者提供的解释性文字<br>分支：指出执行下一条指令的指令<br>标签：对内存位置起的名字，可以将这个名字当作操作数<br>算法：解决方案的计划或概要，或解决问题的逻辑步骤顺序<br>伪代码：表达算法的语言<br>布尔表达式：评价为真或假的表达式<br>桌面检查：在纸上走查整一个设计、<br>测试计划：说明如何测试程序的文档<br>代码覆盖测试（明箱）：通过执行代码中的所有语句测试程序或子程序的测试方法<br>数据覆盖测试（暗箱）：将代码作为一个暗箱，基于所有可能的输入数据测试程序或子程序的测试方法<br>测试计划实现：用测试计划中规定的测试样例验证程序是否输出预期结果。<br>算法: 解决方案的计划或概要, 或解决问题的逻辑步骤顺序. 伪代码中没有语法规则,不考虑大小写</p><h1 id="Ch07"><a href="#Ch07" class="headerlink" title="Ch07"></a>Ch07</h1><p>嵌套结构：控制结构嵌入另一个控制结构的结构，又称为嵌套逻辑，<br>问题求解：为一个令人困惑、苦恼、烦恼或未决的问题找到解决办法的行为。<br>如何解决它这个列表是普通适用的。虽然是在解决数学问题这个背景下编写的 我们可以用<br>来解决与计算机相关问题。<br>如何解决问题：<br>Understand the problem 理解问题<br>Devise a plan 制订一个方案<br>Carry out the plan 执行方案<br>Look back 分析得到的解决方案<br>计算机解决问题过程<br>Analysis and Specification Phase 分析和说明阶段<br>Analyze 分析 【理解（定义）问题】<br>Specification 说明【说明程序要解决的问题】<br>Algorithm Development Phase 算法开发阶段<br>Develop algorithm 开发算法【开发用于解决问题的逻辑步骤序列】<br>Test algorithm 测试算法【执行列出的步骤，看它们是否能真正地解决问题】<br>Implementation Phase 实现阶段<br>Code 编码【用程序设计语言翻译算法（通用解决方案）】<br>Test 测试【让计算机执行指令序列。检查结果，修改程序，直到得到正确的答案】<br>Maintenance Phase 维护阶段<br>Use 使用 【使用程序】<br>Maintain 维护 【修改程序，使它满足改变了的要求，或者纠正其中的错误】<br>方法总结：<br>Analyze the Problem 分析问题<br>Understand the problem!! 理解问题<br>Develop a plan of attack 开发一个通用的方案<br>List the Main Tasks (becomes Main Module) 列出主要任务（成为主要模块）<br>Restate problem as a list of tasks (modules) 以任务列表（模块）的方式重新描述问题<br>Give each task a name 给每个任务命名<br>Write the Remaining Modules 编写其余模块<br>Restate each abstract module as a list of tasks 重申每个抽象模块作为一个任务列表<br>Give each task a name 给每个任务命名<br>Re-sequence and Revise as Necessary 根据需要进行重组和改写<br>Process ends when all steps (modules) are concrete 过程结束时，所有的步骤（模块）是具体的<br>算法：解决问题的逻辑步骤序列，在有限的时间内用有限的数据解决问题或者子问题的明确指令集合<br>抽象步骤：含有不明细节的算法步骤<br>具体步骤：细节完全明确的算法步骤<br>开发算法 计算机解决问题方法：<br>自顶向下设计聚焦要完成的任务<br>面向对象设计着重于解决方案中涉及的数据<br>计数控制循环可以指定过程重复的次数，这个循环的机制是简单记录过程重复的次数，且在<br>重复再次开始前检测循环是否已经结束。<br>事件控制循环是由循环体自身内发生的事件控制的循环。<br>复合数据类型<br>记录:是异构项目的有名集合,可以通过名字单独访问其中的项目<br>数组:是同构项目的有名集合,可以通过单个项目在集合中的位置访问它们. 项目在集合中的<br>位置叫做索引. 无序数组中顺序搜索：<br>顺序搜索依次查找每一个元素并将其与我们需要的元素进行比较. 如果匹配,则找到了这个元素.如果不匹配,则继续找下一个元素. 当我们发现了元素或者是查找所有的元素后都没有找到匹配项就停止. 这听起来象是一个有两个结束条件的循环<br>顺序搜索算法<br>布尔运算<br>有序数组：所谓排序，就是使一串记录，按照其中的某个或某些关键字的大小，递增或递减<br>的排列起来的操作。<br>有序数组中顺序搜索：如果知道数组中的项目是有序的,那么在查找时,如果我们所需要的项<br>目在数组中,到了这个数可能在数组中的位置时就可以停止查找了. 二分检索：<br>顺序检索:在数组开头开始,直到找到匹配项或者整个数组中都没有匹配项.<br>二分检索(要检索的数组是有序的):是从数组中间开始，之后决定你要查找的单词在左手部分或者是右手部分，找到正确的部分后再重复这个过程。<br>排序 排序算法 选择排序 冒泡排序 插入排序<br>当数组在排序之前有序时，冒泡排序算法较好<br>子程序语句：我们可以给一段代码一个名称，然后程序另一部分的一个语句使用这个名称。<br>遇到这个名称时，这个进程的其他部分将会终止，等待这个命名代码被执行。<br>形式参数 实际参数<br>递归：<br>递归：算法调用它本身的能力<br>基本情况：是答案已知的情况<br>一般情况：是调用自身来解决问题的更小版本的解决方案<br>数据抽象：将数据的逻辑视图于它的实现分离开来<br>过程抽象：把动作的逻辑视图与他的实现分离开来<br>控制抽象：把控制结构的逻辑实现与他的实现分离开来<br>控制结构：用于改变正常的顺序控制流的语句    </p><h1 id="Ch08"><a href="#Ch08" class="headerlink" title="Ch08"></a>Ch08</h1><p>抽象数据类型:属性(数据与操作)明确地与特定实现分离的数据类型. 设计的目标是通过抽象减少复杂度. 复合数据类型<br>数据结构:一种抽象数据类型中的复合数据域的实现<br>容器:存放和操作其他对象的对象<br>容器的两种逻辑实现<br>基于数组的实现 基于链式的实现<br>堆栈是一种抽象复合结构,只能从一端访问堆栈中的元素 LIFO Push Pop<br>队列:队列是一种抽象结构,队列中的项目从一端入,从另一端出.FIFO<br>列表<br>链式结构篇：一个将数据项和找到下一项位置的信息保存到同一容器的实现方法<br>从文件中读取值,将值放到列表中,之后输出列表<br>树：<br>像列表,堆栈和队列这样的抽象结构本质上都是线性的,只模拟了一种数据关系. 更复杂的关系需要更复杂的结构来表示.<br>二叉树:具有唯一起始节点(根节点)的抽象复合结构,其中每个节点可以有两个子女节点,根节点和每个节点之间都有具有一条路径.<br>根：树中唯一的开始结点<br>叶结点：没有子女的树节点<br>二叉检索树 BST:二叉检索树具有二叉树的形状属性,也就是说,二叉检索树中的节点可以具有0 个,1 个或者 2 个子女.此外,二叉检索树还具有语义属性来刻画树中节点的值,即任何节点的值都要大于它的左子树中的所有节点的值,并且要小于它的右子树中的所有节点的值.<br>图:由一组节点和一组把节点相互连接起来的边构成的数据结构、<br>顶点：图中的结点<br>边：表示图中两个结点的连接的顶点对<br>无向图 :其中的边没有方向的图<br>有向图:其中的边是从一个顶点指向另一个顶点(或同一个顶点)的图<br>邻结点：通过边连接起来的两个结点<br>路径：连接图中两个结点的一系列顶点<br>参数列表：程序中两部分之间的通信机制1<br>形参：列在子程序名后的括号的标识符、<br>实参：子程序中调用中列在括号中的标识符、<br>值参：由调用参数传入实参的副本的形参<br>引用参数：由调用参数传入实参的地址的形参   </p><h1 id="Ch09"><a href="#Ch09" class="headerlink" title="Ch09"></a>Ch09</h1><p>面向对象的设计方法是用叫做对象的独立实体生成解决方案的问题求解方法.<br>对象:在问题背景中相关的事物或实体<br>对象类或者类:一组具有相似的属性和行为的对象的描述<br>字段：表示类的属性<br>方法:定义了类的一种行为的特定算法<br>类包含 Properties 属性 behaviors 行为(responsibilities 责任)<br>自顶向下设计 面向对象设计 任务 对象合作<br>面向对象<br>头脑风暴找到可能的类[与此问题相关的事物或者实体]<br>过滤重复的类或删除不必要的类<br>场景 责任算法<br>编译器:把用高级语言编写的程序翻译成机器码的程序<br>解释器:输入用高级语言编写的程序,指导计算机执行每个语句指定的动作的程序<br>解释器在翻译过程语句之后会立即执行这个语句<br>虚拟器<br>Java<br>Java 虚拟机 字节码 可移植性<br>可移植性: 一个程序运行在不同的机器上的能力<br>编译器（字节码）的可移植性<br>面向对象语言的功能性<br>封装:实施信息隐藏的语言特性,把数据和动作集中在一起，使得数据和动作的逻辑属性与他们的实现相互分离<br>继承:类获取其他类的属性(数据域和方法)的机制<br>多态:一种语言的继承体系结构中具有两个同名方法且能够根据对象应用合适的方法的能力<br>控制结构：确定程序中的其他指令的执行顺序的指令<br>异步：不与计算中的其他操作同时发生，换句话说，与程序的操作的不同步<br>实例化：创建类的对象 </p><h1 id="Ch10与11"><a href="#Ch10与11" class="headerlink" title="Ch10与11"></a>Ch10与11</h1><p>应用软件：是为了满足特定需要——解决现实世界中的问题——而编写的<br>系统软件：管理计算机系统，并与硬件进行交互的程序<br>操作系统是最重要的系统软件，负责管理计算机的资源，如内存和输入输出设备，并为系统交互提供界面<br>操作系统的各种角色通常都围绕着一个中心思想“良好的共享”<br>操作系统负责管理资源，而这些资源通常是由使用它们的程序共享的资源管理<br>多道程序设计：同时在主存中驻留多个程序，由它们竞争 CPU 的技术<br>内存管理：了解主存中载有多少个程序以及它们的动作<br>进程：程序正在执行过程中的动态表示法<br>进程管理：跟踪进程的进展以及所有中间状态<br>CPU 调度：确定主存中的哪个进程可以访问 CPU 以便执行的动作<br>操作员会把来自多个用户的作业组织成分批。<br>一个分批包含一组需要相同或相似资源的作业。<br>分时共享系统：允许多个用户同时与计算机进行交互。<br>虚拟机：分时共享系统创建的每个用户都有专有机器的假象<br>主机：一个大型的多用户计算机，通常与早期的分时系统相关。<br>哑铃端：在早期的分时系统中用户用于访问主机的一套显示器与键盘<br>实时系统：应用程序的特性决定了响应时间至关重要的系统<br>响应时间：收到信号和生成响应之间的延迟时间<br>设备驱动程序：针对特定设备的一个小程序，它负责这个设备的信息接收和发送<br>内存管理<br>跟踪一个程序驻留在内存的什么位置以及是如何驻留的 把逻辑程序地址转换成实际的内存<br>地址<br>逻辑地址：对一个存储值的引用，是相对于引用它的程序的<br>物理地址：主存储设备中的真实地址<br>地址联编：逻辑地址和物理地址之间的映射<br>内存中只有两个程序——操作系统和要执行的程序。这种方法称为单块内存管理、<br>把内存载入一段连续的内存区域的内存管理方法<br>在这种内存管理机制中，逻辑地址只是一个相对于程序起始位置的整数值。要生成物理地址，<br>只要用逻辑地址加上程序在存中的起始地址就可以了。<br>分区内存管理内存中只同时存在操作系统和一个其他的应用程序<br>分区内存管理中有操作系统以及任意数目的其他程序同时驻留在内存中<br>固定分区法：把内存分成特定数目的分区以载入程序的内存管理方法<br>动态分区法：根据容纳程序的需要对内存分区的内存管理方法<br>内存被划分为一组分区，有些是空的，有些分配给了程序<br>基址寄存器：存放当前分区的起始地址的寄存器<br>界限寄存器：存放当前分区的长度的寄存器<br>分区选择算法<br>最先匹配：即把第一个足够容纳程序的分区分配给它<br>最佳匹配：即把最小的能够容纳程序的分区分配给它<br>最差匹配：即把最大的能够容纳的分区分配给它<br>页式内存管理<br>把进程划分为大小固定的页，载入内存时候存储在帧的内存管理方法<br>帧：大小固定的一部分主存，用于存放进程页。<br>页：大小固定的一部分进程，存储在内存帧中<br>页编号：用页面大小除逻辑地址得到的商<br>偏移值：用页面大小除逻辑地址得到的余数<br>页映射表 PMP：操作系统用于记录页和帧之间的关系的表<br>请求分页：页式内存管理法的扩展，只有当页面被引用（请求）时才会被载入内存<br>页面交换：把一个页面从二级存储设备载入内存，通常会使另一个页面从内存中删除<br>虚拟内存：由于整个程序不必同时处于内存而造成的小没有限制的假象<br>系统颠簸：频繁的页面交换造成的低效处理<br>进程管理:单个进程使用 CPU 的管理动作<br>进程状态：操作系统下，进程经历的概念性阶段<br>创建，准备就绪，运行，等待，终止。<br>PCB 进程控制块：操作系统管理进程信息使用的数据结构，包括程序计数器的当前值 进程在其他所有 CPU 寄存器中的值 基址寄存器和界限寄存器的值（或页表） 帐户信息<br>每个状态由一个 PCB 列表表示，处于该状态的每个进程对应一个 PCB<br>只有一个 CPU，因此只有一套 CPU 寄存器。<br>这些寄存器存放的是当前执行的进程的值。<br>当一个进程移出CPU，另一个进程取代它时候发生的寄存器信息<br>这种信息交换叫作上下文切换<br>CPU 调度：确定把哪个处于准备就绪状态的进程移入运行状态<br>可能有很多进程同时处于准备就绪状态<br>在任意一个时刻，只一个进程可以进入运行状态<br>非抢先调度:当当前执行的进程自愿放弃了 CPU 时发生的 CPU 调度<br>抢先调度:当操作系统决定照顾别一个进程而抢占当前执行进程的CPU 资源时发生的 CPU 调度<br>周转时间:从进程进入准备就绪状态到它最终完成之间的时间间隔,是评估CPU调度算法的标准<br>CPU 调度算法<br>先到先服务:进程按照它们到达运行状态的顺序转移到 CPU<br>最短作业优先:CPU 调度算法将查看所有处于准备就绪状态的进程,并分派一个具有最短服务时间的进程<br>轮询法:将把处理时间平均分配给所有准备就绪的进程，每个进程同等对待<br>时间片(量):在CPU轮询算法中分配给每个进程的时间量<br>文件：数据的有名集合，用于组织二级存储设备<br>文件系统：操作系统为它管理的文件提供的逻辑视图<br>目录：文件的有名分组<br>文本文件：数据字节是 ASCII 或 Unicode 字符集中的字符<br>二进制文件：包含特定格式的数据的文件，要求给位串一个特定的解释<br>文件类型：文件中存放的关于类型的信息。<br>大多数文件都包含有特定类型的信息<br>文件扩展名：文件名中说明文件类型的部分<br>文件名通常分为二个部分 文件名.文件扩展名<br>文件执行的操作<br>创建文件&#x2F;删除文件<br>打开文件&#x2F;关闭文件<br>从文件中读取数据&#x2F;把数据写入文件<br>删减文件(删除它的内容)<br>重定位当前文件指针&#x2F;把数据附加到文件结尾<br>重新命名文件&#x2F;复制文件<br>文件访问<br>顺序文件：以线性方式访问文件中数据的方法。为了得到最后的纪录，你必须读完所有的记<br>录<br>直接访问：文件中的数据会被概念性地划分为带编号的逻辑记录，通过指定逻辑记录编号直<br>接访问的数据的方法<br>文件保护 ：限制文件访问的过程<br>在多用户系统中，文件保护的重要性居于首要地位<br>除非是特许的，否则我们不想让一个用户访问另一个用户的文件<br>文件保护机制都决定了谁可以使用文件，以及为什么目的而使用文件<br>目录是文件的有名集合。一个目录还可以包含另一个目录<br>父目录：包含其他目录的目录<br>子目录：被包含的目录<br>目录树：展示文件系统的嵌套目录组织的结构<br>根目录：最高级的目录<br>无论何时，你都可以认为自己在文件系统中的某个特定位置（即特定的子目录）工作<br>工作目录：当前活动的子目录<br>路径：文件或子目录在文件系统中的位置的文本名称<br>绝对路径：从根目录开始，包括所有后继子目录的目录<br>相对路径：从当前工作目录开始的路径<br>磁盘调度：操作系统用于决定先满足哪个磁盘I&#x2F;O的方法<br>在计算机同时处理多个中时，将建立一个访问磁盘的请求列表<br>FCFS 先到先服务：按照请求到达的顺序处理它们，并不考虑读写头的当前位置<br>SSTF 最短寻道时间优先磁盘调度法：将通过尽可能少的读写头移动满足所有未解决的请求<br>SCAN 磁盘调度算法的工作方式与之类似，只是在磁盘调度算法中没有上下移动，而是读写<br>头向轴心移动，然后再向盘片边缘移动，就这样在轴心和盘片边缘之间来回移动。</p><h1 id="Ch12"><a href="#Ch12" class="headerlink" title="Ch12"></a>Ch12</h1><p>信息系统：帮助我们组织和分析数据的软件<br>电子制表软件：允许用户用单元格组织和分析的数据<br>单元格：电子数据表中用于存放数据或公式的元素<br>信息管理：<br>电子数据制表函数：电子制表软件提供的可用于公式的计算函数<br>范围：用端点指定的一组连续单元格<br>循环引用：在计算结果时错误的彼此依赖的一组公式<br>模拟假设分析：修改电子数据表中假设的值，以观察假设的变化对相关数据有什么影响<br>电子表格和数据库管理系统 :允许用户用不同的方式来组织、管理和分析数据的软件工具. 电子制表软件 : 是一种软件应用程序,它允许用户用带标签的单元格组织和分析数据<br>电子数据表中用于存放数据或公式的元素. 存储在单元格中的数据既可以是文本,也可以是其他特殊的数据(如日期). 可以用行列标号引用电子数据表格中的单元格<br>电子表格公式<br>电子数据表的这种能力源于我们创建并存储在单元格中的公式】<br>把公式存储在一个单元格中，这个单元格就会显示该公司的结果<br>电子数据表函数：电子制表软件提供的可用于公式的计算函数。<br>范围：用端点指定的一组连续单元格<br>数据库：结构化的数据集合。<br>数据库管理系统：由物理数据库、数据库引擎和数据库模式构成的软件和数据的组合<br>物理数据库：存放数据的文件的集合<br>数据库引擎：支持对数据库内容的访问和修改的软件<br>数据库模式：存储在数据库中的数据的逻辑结构的规约。<br>数据库查询：从数据库检索数据的请求。<br>关系型数据库管理系统：用表组织数据和数据之间的关系<br>表：数据库纪录的集合<br>记录（对象，实体）：构成一个数据库实体的相关的域的集合。<br>字段或属性：数据库记录中的一个值。<br>键（关键字）：在表的所有记录中唯一标识一个数据库记录的一个或多个域<br>关系<br>SQL 结构化查询语言：用于管理和查询数据的综合性关系数据库语言<br>修改数据库内容<br>数据库设计：。<br>实体关系 ER 建模：设计关系数据库的常用方法。<br>ER 图：ER 图形化表示<br>基数约束：在 ER 图中，一次可以存在于实体间折关系数量<br>大数据：不能够使用传统的数据管理方法（如电子表格和数据库）处理的大数据集    </p><h1 id="Ch13与14"><a href="#Ch13与14" class="headerlink" title="Ch13与14"></a>Ch13与14</h1><p>人工智能:研究对人类思想建模和应用人类智能的计算机系统的学科<br>例如,写一个程序在一幅图片中识别一个物体<br>图灵测试:根据经验来判断一台计算机是否达到了智能化<br>弱等价性: 两个系统基于其结果的等价性, 但实现这种结果的方式不同.<br>强等价性:两个系统基于其结果和实现这种结果的处理方法的等价性.<br>罗布纳奖: 正式的图灵测试.每年举行一次.<br>聊天机器人: 用于执行人机对话的程序.<br>Aspects of AI 人工智能问题的各个方面<br>Knowledge representation 知识表示<br>Expert systems 专家系统<br>Neural networks 神经网络<br>Natural language processing 自然语言处理<br>Robotics 机器人学<br>知识表示<br>我们想独立于数据的底层实现来创建它的逻辑视图,以便能用特定的方式处理数据<br>自然语言的说明性很强,但它不容易处理<br>语义网和检索树是很有前途的知识表示技术<br>语义网:是一种知识表示法,重点在于对象之间的关系. 表示语义网的是有向图<br>检索树: 表示对抗性情况(如博弈)中的所有选择的结构<br>在检索树中,一条路径表示玩家做出的一系列决定<br>深度优先：优先沿着树的路径向下检索<br>广度优先：优先横向检索树的每层<br>专家系统<br>基于知识的系统:使用特定信息集合的软件,可以从中提取和处理特定的片段<br>专家系统:基于人类专家的知识的软件系统<br>它是一个基于规则的系统:基于一套 if-then 规则的软件系统<br>推理机:处理规则以得出结论的软件<br>人工神经网络:尝试模拟人体神经网络的计算机知识表示法<br>神经网络路径中的流量是稳定的<br>在我们学习新事物时,大脑中将构成新强神经路径<br>人工神经网络中的每个处理元素都类似于一个生物神经元<br>一个元素接受一定数量的输入值,生成一个输出值 0 或者 1<br>每个输入值有一个数字权<br>元素的有效权：是所有输入值与它的权的乘积之和<br>v1 * w1 + v2 * w2 + v3 * w3<br>每个元素都有一个数字阈值<br>如果有效权大于阈值,这个元素将生成 1<br>如果有效权小于等于阈值,该元素将生成 0<br>训练：调整神经网络中的权和阈值以实现想要的结果的过程<br>训练一个神经网络去找出一幅相片中的猫：每个像素对应一个输出值,训练网络来对属于猫<br>的每一个像素产生值为 1,对每一个不属于猫的像素产生值为 0<br>自然语言处理：<br>人机语音交互过程中的三种基本处理类型<br>语音合成:用计算机制造出人类的语言<br>语音识别:用计算机来识别人类所讲的话<br>自然语言：人们1用于交流的语言，如英语<br>音素：任何指定语言中的基本声音单元的集合<br>声波纹：表示人声随着时间推移的频率变化的图<br>自然语言理解:用计算机对人类传达的信息做出合理的解释<br>词法二义性：由于单词具有多种含义而造成的二义性<br>句法二义性：由于句子的构造方式有多种而造成的二义性<br>指代二义性：由于代词可以指代多个对象而造成的二义性</p><h1 id="Ch15"><a href="#Ch15" class="headerlink" title="Ch15"></a>Ch15</h1><p>计算机网络：是为了通信和共享资源而以各种方式连接在一起的一组计算设备<br>无线连接：没有物理电线的网络连接<br>节点：网络中任何可以寻址的设备<br>计算设备之间的连接可以使用物理电线或电缆，也可以使用无线电波或红外信号<br>计算机网络开创了一个新的计算领域——客户&#x2F;服务器模型<br>协议：定义如何在网络上格式化和处理数据的一组规则。<br>客户&#x2F;服务器：客户对服务器发出的要求，服务器做出的响应的分布式的方法<br>文件&#x2F;服务器：专门为网络用户存储和管理文件的计算机<br>P2P模型：在许多“伙伴”中共享资源与责任的一种分散的方法<br>LAN 局域网：连接较小地理的少量计算机的网络<br>环形拓扑：把所有节点连接成一个封闭的环，消息在环中沿着一个方向传播。<br>星形拓扑：以一个节点为中心，其他节点都中心节点上，所有消息都经过中心节点发送。<br>总线拓扑：所有节点都一条通信线上，消息可以在上双向传播。<br>被称为以太网的总线技术已经成为局域网的业界标准<br>WAN 广域网：是连接两个或者多个相距较远的局域网的网络<br>MAN 城域网：为大城市开发的网络基础设施<br>网关：处理它的 LAN 和其他网络之间通信的节点<br>互联网：跨越地球的广域网<br>包交换：<br>包:在网络上传输的数据单位<br>路由器: 指导包在网络上向最终目的地传输的网络设备<br>中继器：在较长的通信线路上加强和传播信号的网络设备<br>消息被分割为大小固定,有编号的包.每个包将独立在网上传输,直到到达目的地,它们将在此<br>被重新组合为原始的消息. 这种方法叫作包交换.<br>开放系统 专有系统（使用特定销售商的私有技术的系统） 互通性（多台机器上的来自多个销售商的软件和硬件互相通信的能力）<br>开放系统（以网络系统结构的通用模型为基础并且伴有一组协议的系统）<br>应用层<br>表示层<br>会话层<br>传输层<br>网络层<br>数据链路层<br>物理层<br>网络协议<br>每一层都能依靠自己的基础协议<br>有时叫作协议栈<br>延迟：发送请求和接收相应的时间<br>Internet：承载internet通信的一组高速网络<br>ISP：提供网络访问的公司<br>电话调制解制器：把计算机数据转换为模拟音频信号，然后再把模拟音频信号转化为计算机数据的设备<br>数字用户电路：DSL,用常规的额电话线传输数字信号的internet连接方式<br>线缆调制调节器：使用家庭的有线电路网路进行计算机网络通信的设备<br>宽带：提供的数据传输率大于25Mb的网络技术<br>以太网：集中在大多数个人九四u安吉中的网络通信协议<br>协议栈：彼此依托的协议分层<br>TCP 传输控制协议: 把消息分割成包,在目的地把包重新组装成消息,并负责处理错误的网络协议.<br>IP 网际协议: 处理包通过互相连接的网络传送到最终目的地的路由选择.<br>TCP&#x2F;IP：一组支持低层网络通信的协议和程序<br>UDP 用户数据报协议 UDP: 牺牲一定可靠性实现较高传输速率的网络协议,是 TCP 的替代者<br>Ping: 用于测试一台特定的网络计算机量否是活动的以及是否可到达的程序.<br>跟踪路由程序:用于展示包在到达目的节点的过程中经过的路线的程序.<br>高层协议<br>Simple Mail Transfer Protocol (SMTP) File Transfer Protocol (FTP) Telnet Hyper Text<br>Transfer Protocol (http)<br>端口：特定高层协议的数字标号<br>MIME类型：定义电子邮件附件或网站文件的格式的标准<br>防火墙：一台网关机器,它的软件通过过滤网络通信来保护网络<br>访问控制策略: 一个组织建立的一组规则,规定了接受和拒绝什么类型的网络通信.<br>主机名：由点号分隔得单词构成的名字，唯一的标识了internet的机器，每个主机名对应一个特定IP地址<br>IP地址：由点号分割的四个数值得构成得地址，唯一得表示了internet的机器<br>顶级域名：域名中的最后一部分，声明了组织的类型和所属国家<br>域名抢注<br>域名系统：管理主机名解析的分布式系统<br>域名服务器：把主机名翻译成IP地址的计算机<br>区块链：不会被改变的交易公开分类账<br>云计算：提供存储空间和互联网上其他资源的服务. 公有云:允许任何订阅用户访问<br>私有云:专门为一个特定的组或组织建立,并限制在该组织团体内访问. 社区云:在拥有相似需求的多个组织之间进行云共享<br>混合云:上述云服务类型的一些组合.<br>万维网：信息和用来访问信息的网络软件的基础设施<br>web页：包含或引用各种类型文档的数据的文挡<br>链接：两个web页的连接<br>网站：一组相关的web页<br>web浏览器：获取并显示web页的软件工具<br>web服务器：用于响应web页请求的计算机<br>统一资源定位符：URL 说明web地址的标准方式<br>即时消息：实时发送消息的技术<br>超文本标记语言：HTML：用于创建web页的元素<br>标记语言：使用标记来注释文档中信息的语言<br>标记：标记语言中用于说明如何展示信息的语法元素<br>属性：标记中用于提供有关元素的额外信息的部分<br>JAVa小程序：对嵌入HTML文档而设计的程序，能够通过web传输，在浏览器中执行<br>JSP小脚本：嵌在HTML文档中用于给web页提供动态内容的代码片段<br>可扩展标记语言：XML:允许用户描述文档内容的语言<br>元语言：用于定义其他语言的语言<br>文档定义类型：DTD:XML文档结构的规约<br>可扩展样式表语言：XSL定义XML文档到其他输出格式之间可转换的语言    </p><h1 id="软件工程概论"><a href="#软件工程概论" class="headerlink" title="软件工程概论"></a>软件工程概论</h1><p>System 相互关联的 互相依赖的 协作的 software 预先决定 software engineering<br>软件生命周期 软件开发生命周期<br>• Waterfall Model 瀑布模型<br>• Phased Prototype Model 阶段性原型模型<br>• Iterative Development Model 迭代开发模型<br>• Rapid Prototype Model 快速原型模型<br>• Agile Development Model 敏捷开发模型<br>计算机软件未来前景<br>Maintainability 可维护性: How easily maintained is the software?<br>This will depend on the quality of the design as well as the documentation.<br>• Documentation 文档: How well documented is the system?<br>• Efficiency 效率: How efficiently are certain core operations carried out? Of importance are<br>the response time and the system throughput.<br>User Friendliness 用户友好性: How well designed is the user interface? How easy is it to learn<br>and use the system?<br>• Compatibility 兼容性: with existing software products.<br>• Security安全性: Are there mechanisms to protect and promote confidentiality and proper<br>access control?<br>• Integrity 完整一致性: What is the quality of data validation methods?<br>• Reliability 可靠性: Will the software perform according to requirements at all times?<br>• Growth potential(增长潜力,可扩展性): What is the storage capacity? What is the capacity<br>for growth in data storage?<br>Functionality and Flexibility( 功 能 性 和 灵 活 性 ): Does the software provide the essential<br>functional features required for the problem domain? Are there alternate ways of doing<br>things?<br>• Differentiation(差异化): What is unique about the software?<br>• Adaptability(适应性): How well are unanticipated situations handled?<br>• Productivity(生产力): How will productivity be affected by the software system?<br>• Comprehensive Coverage (综合保障): Is the problem comprehensively and appropriately<br>addressed?<br>软件质量</p>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类与对象学习</title>
      <link href="/2024/01/28/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/01/28/%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="类和对象的学习"><a href="#类和对象的学习" class="headerlink" title="类和对象的学习"></a>类和对象的学习</h1><h2 id="1-静态成员static"><a href="#1-静态成员static" class="headerlink" title="1.静态成员static"></a>1.静态成员static</h2><p>共享一份</p><p>类内声明，类外初始化，不属于某一个对象上，所有对象都共享同一份数据</p><p>因此静态成员有两种访问方式</p><p>1.通过对象来访问，同下即可</p><p>2.通过类名来访问</p><p>同时静态成员变量也是有访问权限的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_c;</span><br><span class="line">    <span class="comment">//静态成员函数</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> func</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I love you&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同样可以通过对象和类名进行访问</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> m_b;</span><br><span class="line">    <span class="comment">//类外不能访问</span></span><br><span class="line"><span class="comment">//所有对象共享一份数据</span></span><br><span class="line"><span class="comment">//编译期间分配内存</span></span><br><span class="line"><span class="comment">//类内声明，类外初始化</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person:: m_a = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> Person:: m_b=<span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//m_c=100;</span></span><br><span class="line">    <span class="comment">//静态成员函数不能访问非静态成员变量</span></span><br><span class="line">    <span class="comment">//不知道这个变量</span></span><br><span class="line">Person p1;</span><br><span class="line">cout &lt;&lt; p1.m_a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">Person p2;</span><br><span class="line">p2.m_a = <span class="number">200</span>;</span><br><span class="line">cout &lt;&lt; p1.m_a &lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;Person::m_a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;  </span><br><span class="line">    <span class="comment">//cout&lt;&lt;Person::m_b&lt;&lt;&#x27;\n&#x27;;//这是错误的</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//通过对象访问</span></span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">func</span>();</span><br><span class="line">    <span class="comment">//通过类名访问</span></span><br><span class="line">    Person::<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//一些基础的赋值操作和析构函数和构造函数的先后顺序问题</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Phone</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Phone</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;手机被赋初值了&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">m_pname = name;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Phone</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数的调用&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">string m_pname;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(string name, string pname) :<span class="built_in">m_name</span>(name), <span class="built_in">m_phone</span>(pname)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;人被赋初值了&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;人析构函数的调用&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">string m_name;</span><br><span class="line">Phone m_phone;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;张三&quot;</span>, <span class="string">&quot;华为&quot;</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; p.m_name &lt;&lt; <span class="string">&quot;拿着&quot;</span> &lt;&lt; p.m_phone.m_pname&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-成员变量和成员函数"><a href="#2-成员变量和成员函数" class="headerlink" title="2.成员变量和成员函数"></a>2.成员变量和成员函数</h2><p>成员变量和成员函数分开存储</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//成员变量和成员函数分开存储</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> m_a;<span class="comment">//非静态成员变量</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_b;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员函数和成员变量是分开存储的</span></span><br><span class="line">    <span class="comment">//具体区分见下一节课</span></span><br><span class="line">    <span class="type">static</span> <span class="type">void</span> func</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//同理也不会</span></span><br><span class="line">    <span class="comment">//综上所诉，只有非静态成员变量才在类的对象上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> Person::m_b=<span class="number">100</span>;</span><br><span class="line"><span class="comment">//但不属于类的对象上</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of p=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       Person p;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;size of p=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(p) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//test01();</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>test 01()</p><p>代码展示结果</p><p>空对象占用内存空间是1</p><p>&#x2F;&#x2F;C++编译器给每个空对象也分配一个字节空间</p><p>&#x2F;&#x2F;是为了区分空对象占用的内存位置</p><p>&#x2F;&#x2F;主要是为了区分</p><p>&#x2F;&#x2F;size of p&#x3D;1</p><p>&#x2F;&#x2F;答案会是1</p></blockquote><blockquote><p>test 02()</p><p>代码展示结果</p><p>非静态成员变量属于类的对象上</p><p>size of p&#x3D;4</p></blockquote><h1 id="3-this-指针"><a href="#3-this-指针" class="headerlink" title="3. this  指针"></a>3. this  指针</h1><p>上一节课遗留的问题，成员函数要怎么调呢？</p><p>this指针指向被调用的成员函数所属的对象</p><p>this指针不需要定义</p><p>this指针隐含每一个非静态成员</p><p>作用</p><p>1.解决名称冲突</p><p>2.返回对象本身用* this</p><p>错误代码示范</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">this</span>-&gt;age = age;</span><br><span class="line">        <span class="comment">//age=age是错误的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Personaddage</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age+=p.age;<span class="comment">//自身的年林加自己的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//因为是void，我们只能调用一次</span></span><br><span class="line">    <span class="comment">//如果要调用多次的话，我们需要一个return</span></span><br><span class="line">      <span class="function">Person&amp; <span class="title">Personaddage</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;age+=p.age;<span class="comment">//自身的年林加自己的</span></span><br><span class="line">          <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">          <span class="comment">//this是指向p2的指针，而this*是p2的本体</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是传引用，那就是拷贝构造了</span></span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">18</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; p.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">    p2.<span class="built_in">Personaddage</span>(p1);</span><br><span class="line">      p2.<span class="built_in">Personaddage</span>(p1).<span class="built_in">Personaddage</span>(p1);</span><br><span class="line">    <span class="comment">//链式编程思想</span></span><br><span class="line">    cout&lt;&lt;p2.age&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//输出结果是30，非常好用</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//test01()</span></span><br><span class="line">    <span class="built_in">test02</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>会有一个奇怪的输出结果</p><p>我们从来没有改变我们的属性里的age，始终是第一个age.</p><p>解决方法：</p><p>​    1.编码规范，加一个m_age</p><ol start="2"><li><p>this 指针(如上)</p><p>终上所述，This可以解决编码规范问题，并且可以传this *指向本体，但要注意传的是&amp;</p><h1 id="4-空指针访问成员函数"><a href="#4-空指针访问成员函数" class="headerlink" title="4.空指针访问成员函数"></a>4.空指针访问成员函数</h1><p>如果是空指针需要预先说一下，避免程序崩溃</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;I love you&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showage</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>==<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;your age is&quot;</span> &lt;&lt; m_age &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="comment">//报错原因是空指针指向了对象的属性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person* p = <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;<span class="built_in">show</span>();</span><br><span class="line">    p-&gt;<span class="built_in">showage</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-const修饰成员函数"><a href="#5-const修饰成员函数" class="headerlink" title="5.const修饰成员函数"></a>5.const修饰成员函数</h1><p>成员函数加上Const之后就是常函数</p><p>同理也有常对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="type">const</span> <span class="comment">//不加这个的话可以修改值const，否则不可以修改值</span></span></span><br><span class="line"><span class="function">        <span class="comment">//在成员函数后面加上const本质上就是修饰this指针</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//由于表达式必须是可修改的左值因此无法进行修改</span></span><br><span class="line">        <span class="comment">//this指针的本质是指针常量，指针的指向不可修改</span></span><br><span class="line">        <span class="comment">//m_a=100;</span></span><br><span class="line">        <span class="comment">//this-&gt;m_a=100;错误的</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;m_b=<span class="number">1000</span>;</span><br><span class="line">        <span class="comment">//这句就对了</span></span><br><span class="line">        <span class="comment">//mutable  </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> m_b;</span><br><span class="line">    <span class="comment">//这样就可以修改m_b了</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p;</span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> Person P;</span><br><span class="line">   <span class="comment">//属性不允许修改 p.m_a=100;</span></span><br><span class="line">    p.m_b=<span class="number">100</span>;</span><br><span class="line">    <span class="comment">//可以修改</span></span><br><span class="line">    <span class="comment">//常对象只能调用常函数</span></span><br><span class="line">    p.<span class="built_in">showPerson</span>();</span><br><span class="line">    <span class="comment">//而不能调用普通的函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="6-友元"><a href="#6-友元" class="headerlink" title="6.友元"></a>6.友元</h1><p>在程序里，有些私有属性让类外的特殊函数和特殊的类访问，就需要用到友元</p><p>友元的目的就是为了让一个函数或者一个类访问另一个类的私有成员</p><p>友元的关键字为friend</p><h2 id="1-全局函数做友元"><a href="#1-全局函数做友元" class="headerlink" title="1.全局函数做友元"></a>1.全局函数做友元</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Buliding</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="function"><span class="keyword">friend</span>  <span class="type">void</span> <span class="title">goodgay</span><span class="params">(Buliding* building)</span></span>;</span><br><span class="line">    <span class="comment">//意味着全局函数goodgay是他的朋友可以访问私有成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">Buliding</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_keting = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        m_woshi = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">       <span class="comment">//初始化，一经过创建就已经初始化了</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_keting;</span><br><span class="line">    <span class="comment">//公共</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_woshi;</span><br><span class="line">    <span class="comment">//私有</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodgay</span><span class="params">(Buliding* building)</span></span></span><br><span class="line"><span class="function">    <span class="comment">//以指针的方式进行创建</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;访问中&quot;</span> &lt;&lt; building-&gt;m_keting &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//原本就能访问呢</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;访问中&quot;</span> &lt;&lt; building-&gt;m_woshi &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//加了Friend才能访问</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Buliding building;</span><br><span class="line">    <span class="built_in">goodgay</span>(&amp;building);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="2，类做友元"><a href="#2，类做友元" class="headerlink" title="2，类做友元"></a>2，类做友元</h2><p>同样也是把那一句话加上 frirnd 放在函数里面</p><blockquote><p>有一个新知识点，就是如果要类外初始化的话，我们需要在类内想进行声明，在类外加上：：这个后才可以进行</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">friend</span> <span class="keyword">class</span> <span class="title class_">goodgay</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">//类内初始化</span></span><br><span class="line">    <span class="built_in">Building</span>() </span><br><span class="line">    &#123;</span><br><span class="line">        m_keting = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        m_woshi = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_keting;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_woshi;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodgay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">goodgay</span>();</span><br><span class="line"><span class="comment">//如果想要类外初始化的话类内必须先进行声明</span></span><br><span class="line">   <span class="comment">//参观函数访问Building public和private</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">    Building* buliding;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//类外初始化</span></span><br><span class="line"><span class="comment">/*Building::Building()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    m_keting = &quot;客厅&quot;;</span></span><br><span class="line"><span class="comment">    m_woshi = &quot;卧室&quot;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//类外初始化</span></span><br><span class="line"><span class="comment">//new出一个Building</span></span><br><span class="line">goodgay::<span class="built_in">goodgay</span>()</span><br><span class="line">&#123;</span><br><span class="line">    buliding = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodgay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;正在访问&quot;</span> &lt;&lt; buliding-&gt;m_keting &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; buliding-&gt;m_woshi;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    goodgay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="3-成员函数做友元"><a href="#3-成员函数做友元" class="headerlink" title="3.成员函数做友元"></a>3.成员函数做友元</h2><blockquote><p>成员函数做友元的时候，那个不做友元的类需要事先声明，然后再进行那个友元的构建，其他和上面两种一样。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">goodgay</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">goodgay</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">visit</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//去访问</span></span><br><span class="line">   <span class="comment">// void visit2();</span></span><br><span class="line">    <span class="comment">//不可以访问</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Building* buliding;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Building</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="type">void</span> <span class="title">goodgay::visit</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Building</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        m_keting = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">        m_woshi = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string m_keting;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_woshi;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">goodgay::<span class="built_in">goodgay</span>()</span><br><span class="line">&#123;</span><br><span class="line">    buliding = <span class="keyword">new</span> Building;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">goodgay::visit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;正在访问&quot;</span> &lt;&lt; buliding-&gt;m_keting &lt;&lt; <span class="string">&quot; &quot;</span> ;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;正在访问&quot;</span> &lt;&lt; buliding-&gt;m_woshi&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*void goodgay::visit2()</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  //错误的</span></span><br><span class="line"><span class="comment">  //cout &lt;&lt; &quot;正在访问&quot; &lt;&lt; building-&gt;m_keting &lt;&lt;&quot; &quot;&lt;&lt; building-&gt;m_woshi&lt;&lt;&#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    goodgay gg;</span><br><span class="line">    gg.<span class="built_in">visit</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="7-运算符重载"><a href="#7-运算符重载" class="headerlink" title="7.运算符重载"></a>7.运算符重载</h1><h2 id="1-加号运算符重载"><a href="#1-加号运算符重载" class="headerlink" title="1,加号运算符重载"></a>1,加号运算符重载</h2><blockquote><p>引言：对于内置运算符，编译器知道如何运算，而其他数据类型呢？</p><p>我们有两种方法：成员函数重载在内部，需要用this，全局函数就可以不用This了，直接传入两个Person就可以了</p><p>总结1：对于内置数据类型的表达式的运算符是不可以重载的</p><p>总结2：不可以滥用运算符，增加代码可行性</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//成员函数重载运算符</span></span><br><span class="line"> <span class="comment">/*   Person operator+(Person&amp; p)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        Person temp;</span></span><br><span class="line"><span class="comment">        temp.m_a = this-&gt;m_a + p.m_a;</span></span><br><span class="line"><span class="comment">        temp.m_b = this-&gt;m_b + p.m_b;</span></span><br><span class="line"><span class="comment">        return temp;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    //成员函数的本质Person p3=p1.operstoor+(p2)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//全局函数重载运算符</span></span><br><span class="line"><span class="comment">//全局函数的本质就是operator+(p1,p2)</span></span><br><span class="line">Person <span class="keyword">operator</span>+ (Person p1,Person p2)</span><br><span class="line">&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_a = p1.m_a + p2.m_a;</span><br><span class="line">    temp.m_b = p1.m_b + p2.m_b;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Person <span class="keyword">operator</span>+ (Person p1, <span class="type">int</span> num)</span><br><span class="line">&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_a = p1.m_a + num;</span><br><span class="line">    temp.m_b = p1.m_b + num;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数重载的,比较方便</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Person p1;</span><br><span class="line">    p1.m_a = <span class="number">10</span>;</span><br><span class="line">    p1.m_b = <span class="number">10</span>;</span><br><span class="line">    Person p2;</span><br><span class="line">    p2.m_a = <span class="number">10</span>;</span><br><span class="line">    p2.m_b = <span class="number">20</span>;</span><br><span class="line">    Person p3 = p1 + p2;</span><br><span class="line">    cout &lt;&lt; p3.m_a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; p3.m_b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    Person p4 = p1 + <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; p4.m_a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    cout &lt;&lt; p4.m_b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//没有重载运算符 Person p3=p1+p2;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-左移运算符重载"><a href="#2-左移运算符重载" class="headerlink" title="2.左移运算符重载"></a>2.左移运算符重载</h2><p>采取全局函数的重载方法，其次我们需要ostream，作为一个重载的工具。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Person&amp; p);</span><br><span class="line">    <span class="comment">//全局函数做友元</span></span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">int</span> a,<span class="type">int</span> b)</span><br><span class="line">    &#123;</span><br><span class="line">        m_a = a;</span><br><span class="line">        m_b = b;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//只能利用全局函数来重载左移运算符</span></span><br><span class="line">ostream &amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;cout, Person &amp;p)<span class="comment">//operator&lt;&lt;(cout,p)</span></span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m_a=&quot;</span> &lt;&lt; p.m_a &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;m_b=&quot;</span> &lt;&lt; p.m_b &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> cout;</span><br><span class="line">    <span class="comment">//可以把cout随便换，因为引用只是起一个别名</span></span><br><span class="line">    <span class="comment">//链式编程思想</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要用标准输出流</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="number">10</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; p&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//往后追加输入不能用链式法则，不能继续调用</span></span><br><span class="line">    <span class="comment">//内置数据类型</span></span><br><span class="line">   <span class="comment">// cout &lt;&lt; p;</span></span><br><span class="line">    <span class="comment">//没有与这些操作匹配的运算符</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-递增运算符重载"><a href="#3-递增运算符重载" class="headerlink" title="3.递增运算符重载"></a>3.递增运算符重载</h2><p>前置递增返回引用</p><p>后置递增返回值</p><p>因为局部变量的引用不能返回</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载递增运算符</span></span><br><span class="line"><span class="comment">//自定义整型变量</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Myinteger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//加上友元</span></span><br><span class="line"> <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Myinteger&amp; myhint);</span><br><span class="line"><span class="built_in">Myinteger</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载++运算符</span></span><br><span class="line"><span class="comment">//重载分为两种</span></span><br><span class="line"><span class="comment">//第一种是前置++运算符</span></span><br><span class="line"><span class="comment">//第二种是后置++运算符</span></span><br><span class="line">Myinteger &amp; <span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">m_num ++;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"><span class="comment">//先加加再将自身返回</span></span><br><span class="line"><span class="comment">//由于我们要输出的是对象，所以我们要返回自身</span></span><br><span class="line"><span class="comment">//而自身就是* this</span></span><br><span class="line"><span class="comment">//如果我们不返回引用的话，那我们就会出现递增一次后实际上会出现不变的情况</span></span><br><span class="line"><span class="comment">//返回引用是为了一直对一个数据进行递增操作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回值是不可以作为重载条件</span></span><br><span class="line">Myinteger  <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//int 代表的是一个占用参数</span></span><br><span class="line"><span class="comment">//可以用来区分前置和后置</span></span><br><span class="line"><span class="comment">//这样我们就可以认为他是后置运算符</span></span><br><span class="line"><span class="comment">//先记录一下当时的结果</span></span><br><span class="line"><span class="comment">//后递增</span></span><br><span class="line"><span class="comment">//后将记录的结果进行返回</span></span><br><span class="line">Myinteger temp = *<span class="keyword">this</span>;</span><br><span class="line">m_num++;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重载左移</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; cout, Myinteger &amp;myhint)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; myhint.m_num;</span><br><span class="line"><span class="keyword">return</span> cout;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Myinteger myint;</span><br><span class="line">cout &lt;&lt; ++(++myint);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Myinteger myint;</span><br><span class="line">cout&lt;&lt; ++myint;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-赋值运算符重载"><a href="#4-赋值运算符重载" class="headerlink" title="4.赋值运算符重载"></a>4.赋值运算符重载</h2><blockquote><p>C++编译器会给一个类添加四个函数‘</p><p>第一个是构造函数，无参</p><p>第二个是析构函数，无参</p><p>第三个是拷贝构造函数，对属性进行值拷贝</p><p>第四个是赋值运算符 operator &#x3D; 对属性进行值拷贝</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Person</span>(<span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line">m_age = <span class="keyword">new</span> <span class="built_in">int</span>(age);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">Person</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_age;</span><br><span class="line">m_age = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//堆区内存重复释放</span></span><br><span class="line"><span class="comment">//解决方案：深拷贝-&gt;浅拷贝</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>=(Person&amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_age != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> m_age;</span><br><span class="line">m_age = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_age = <span class="keyword">new</span> <span class="built_in">int</span>(*p.m_age);</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span>* m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">19</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">20</span>)</span></span>;</span><br><span class="line">p2 = p1;</span><br><span class="line">cout &lt;&lt; *p1.m_age&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; *p2.m_age;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们传入一个指针，然后在堆区我们开辟了内存</span></span><br><span class="line"><span class="comment">//用指针接收刚刚好</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-关系运算符重载"><a href="#5-关系运算符重载" class="headerlink" title="5.关系运算符重载"></a>5.关系运算符重载</h2><blockquote><p>可以让两个自定义类型进行比较</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//==号的重载，就一般设置一下就行了。</span></span><br><span class="line"><span class="comment">//注意返回的是void</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">string m_name;</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line"><span class="built_in">Person</span>(string name, <span class="type">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line">m_name = name;</span><br><span class="line">m_age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="keyword">operator</span>==(Person &amp;p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_name == p.m_name &amp;&amp; <span class="keyword">this</span>-&gt;m_age== p.m_age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person  <span class="title">p1</span><span class="params">(<span class="string">&quot;汤姆&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;汤姆&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (p1 == p2)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;p1和p2是相等的&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;不相等&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-函数调用运算符重载"><a href="#6-函数调用运算符重载" class="headerlink" title="6.函数调用运算符重载"></a>6.函数调用运算符重载</h2><blockquote><p>函数调用运算符（）也可以重载1</p><p>由于重载后的方式非常像函数的调用，称为仿函数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myprint</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; test &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">myadd</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">myadd add;</span><br><span class="line"><span class="type">int</span> x=<span class="built_in">add</span>(<span class="number">199</span>, <span class="number">199</span>);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    <span class="comment">//匿名函数对象</span></span><br><span class="line">    cout&lt;&lt;<span class="built_in">myadd</span>()(<span class="number">100</span>,<span class="number">100</span>);</span><br><span class="line">   <span class="comment">// 表达式的前半部分创建匿名对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">myprint my;</span><br><span class="line"><span class="built_in">my</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br><span class="line"><span class="comment">//由于使用后非常像一个函数因此被称为仿函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="8-继承"><a href="#8-继承" class="headerlink" title="8.继承"></a>8.继承</h1><blockquote><p>有些类指尖存在继承的关系，因此定义这些类的时候，下级别的成员除了拥有上一级的共性还有自己的特性。</p><p>这个时候可以用继承的方式减少重复代码</p><p>&#x2F;&#x2F;基本实现方式在Public后面加上 public :base (继承的类)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//普通实现页面</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">header</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;首页公开登录注册&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">footer</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;帮助中心，交流合作&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">left</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;jave,pythhon&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">java</span>:<span class="keyword">public</span> bage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;java学科视屏&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">python</span> :<span class="keyword">public</span> bage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">content</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;python学科视屏&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//继承的好处，减少重复代码</span></span><br><span class="line"><span class="comment">//语法clss子类</span></span><br><span class="line"><span class="comment">//继承方式父类</span></span><br><span class="line"><span class="comment">//子类也称为派生</span></span><br><span class="line"><span class="comment">//父类被称为基类</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">java ja;</span><br><span class="line">ja.<span class="built_in">header</span>();</span><br><span class="line">ja.<span class="built_in">footer</span>();</span><br><span class="line">ja.<span class="built_in">left</span>();</span><br><span class="line">ja.<span class="built_in">content</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">python py;</span><br><span class="line">py.<span class="built_in">header</span>();</span><br><span class="line">py.<span class="built_in">footer</span>();</span><br><span class="line">py.<span class="built_in">left</span>();</span><br><span class="line">py.<span class="built_in">content</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>继承方式有三种</p><p>1.公共继承</p><p>2.保护继承</p><p>3.私有继承</p><p>每一个子类都无法访问父类的私有成员，然后相关的继承方式决定了继承后的成员</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">bage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> bage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_a = <span class="number">100</span>;<span class="comment">//公共</span></span><br><span class="line">m_b = <span class="number">100</span>;<span class="comment">//保护</span></span><br><span class="line"><span class="comment">//m_c = 100;</span></span><br><span class="line"><span class="comment">//私有访问不到</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">son a;</span><br><span class="line">a.m_a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//a.m_b = 100;</span></span><br><span class="line"><span class="comment">//a.m_c = 100;</span></span><br><span class="line"><span class="comment">//保护和私有类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son1</span> :<span class="keyword">protected</span> bage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_a = <span class="number">100</span>;<span class="comment">//公共</span></span><br><span class="line">m_b = <span class="number">100</span>;<span class="comment">//保护</span></span><br><span class="line"><span class="comment">//m_c = 100;</span></span><br><span class="line"><span class="comment">//私有访问不到</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">son1 a1;</span><br><span class="line"><span class="comment">//a1.m_a = 100;</span></span><br><span class="line"><span class="comment">// 变成保护了</span></span><br><span class="line"><span class="comment">//a.m_b = 100;</span></span><br><span class="line"><span class="comment">//a.m_c = 100;</span></span><br><span class="line"><span class="comment">//保护和私有类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son1</span> :<span class="keyword">private</span> bage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">m_a = <span class="number">100</span>;<span class="comment">//公共</span></span><br><span class="line">m_b = <span class="number">100</span>;<span class="comment">//保护</span></span><br><span class="line"><span class="comment">//m_c = 100;</span></span><br><span class="line"><span class="comment">//私有访问不到</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">son1 a1;</span><br><span class="line"><span class="comment">//a1.m_a = 100;</span></span><br><span class="line"><span class="comment">// 变成私有了</span></span><br><span class="line"><span class="comment">//a.m_b = 100;</span></span><br><span class="line"><span class="comment">//a.m_c = 100;</span></span><br><span class="line"><span class="comment">//保护和私有类外访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="存储规则"><a href="#存储规则" class="headerlink" title="存储规则"></a>存储规则</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="type">int</span> m_b;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> m_c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> bage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="keyword">sizeof</span> son;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>输出结果是16</p></blockquote><h2 id="继承中构造和析构的顺序"><a href="#继承中构造和析构的顺序" class="headerlink" title="继承中构造和析构的顺序"></a>继承中构造和析构的顺序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">bage</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;构造&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">bage</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> bage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;son的构造&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">son</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;son的析构&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">son p1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输出结果:</p><p>构造<br>son的构造<br>son的析构<br>析构</p><p>顺序如下：先构造父类，再子类，析构相反</p></blockquote><h2 id="继承同名成员的处理方式"><a href="#继承同名成员的处理方式" class="headerlink" title="继承同名成员的处理方式"></a>继承同名成员的处理方式</h2><blockquote><p>当子类与父类出现同名成员，如何通过子类对象，访问子类或父类中同名的成员</p><p>访问子类同名成员：直接访问</p><p>访问父类成员：需要加作用域</p></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line"><span class="built_in">bage</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_a = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> bage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_a = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">son s;</span><br><span class="line">cout &lt;&lt; s. m_a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; s.bage::m_a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="继承同名静态成员的处理方式"><a href="#继承同名静态成员的处理方式" class="headerlink" title="继承同名静态成员的处理方式"></a>继承同名静态成员的处理方式</h2><blockquote><p>与非静态成员处理方式一致</p><p>访问子类：直接访问</p><p>父类：需要作用域</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bage</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> bage::m_a = <span class="number">100</span>;</span><br><span class="line"><span class="comment">//类内声明，类外初始化</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> bage</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> son::m_a = <span class="number">200</span>;</span><br><span class="line"><span class="comment">//同名静态成员属性</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1.通过对象访问呢</span></span><br><span class="line">son s;</span><br><span class="line">cout &lt;&lt; s.m_a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; s.bage::m_a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="comment">//2.通过类名访问</span></span><br><span class="line">cout &lt;&lt; son::m_a &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; son::bage::m_a;</span><br><span class="line"><span class="comment">//两层</span></span><br><span class="line"><span class="comment">//第一个是通过类名方式访问，第二种是访问父类作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多继承语法"><a href="#多继承语法" class="headerlink" title="多继承语法"></a>多继承语法</h2><blockquote><p>作用域也需要</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bage1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="built_in">bage1</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_a = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">bage2</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">bage2</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_a = <span class="number">200</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_a;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> :<span class="keyword">public</span> bage1, <span class="keyword">public</span> bage2</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">son</span>()</span><br><span class="line">&#123;</span><br><span class="line">m_c = <span class="number">100</span>;</span><br><span class="line">m_d = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_c;</span><br><span class="line"><span class="type">int</span> m_d;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">son s;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(s)&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; s.bage1::m_a&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; s.bage2::m_a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="comment">/*int a = 100;</span></span><br><span class="line"><span class="comment">int &amp;y = a;//引用</span></span><br><span class="line"><span class="comment">int* p = &amp;a;//指针</span></span><br><span class="line"><span class="comment">int* p2 = &amp;y;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; p &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; p2;</span></span><br><span class="line"><span class="comment">//一个是有自己的内存空间，一个没有</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">菱形继承的概念：两个派生类继承同一个基类，又有某个类同时继承两个派生类，因此被称为菱形继承或者钻石继承</span><br><span class="line">但是这样的继承往往会造成二义性和资源浪费，于是就有虚继承，解决二义性问题，相当于继承了一份</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">sheep</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yang</span> :<span class="keyword">virtual</span> <span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">yangtuo</span> : <span class="keyword">public</span> yang, <span class="keyword">public</span> sheep</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">yangtuo yangtuoo;</span><br><span class="line">yangtuoo.m_age = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; yangtuoo.m_age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="9-多态"><a href="#9-多态" class="headerlink" title="9.多态"></a>9.多态</h1><blockquote><p>多态是C++面向对象三大特性之一</p><p>分为静态多态和动态多态</p><p>静态多态：函数重载，运算符重载，复用函数名</p><p>动态多态:派生类，虚函数</p><p>二者的区别是</p><p>静态多态：编译阶段就确定函数地址</p><p>动态多态：运行阶段确定函数地址</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//虚函数是必须的</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;动物在说话&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span>  <span class="title class_">Cat</span> :<span class="keyword">public</span> Animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;小猫在说话&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dospeak</span><span class="params">(Animal&amp; animal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal.<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Cat cat;</span><br><span class="line"><span class="built_in">dospeak</span>(cat);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态优势"><a href="#多态优势" class="headerlink" title="多态优势"></a>多态优势</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//普通和多态</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">calculateor</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getresulr</span><span class="params">(string oper)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oper == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_num1 + m_num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_num1 - m_num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> m_num1 *m_num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//每一次都要修改源码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> m_num1;</span><br><span class="line"><span class="type">int</span> m_num2;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">calculateor c;</span><br><span class="line">c.m_num1 = <span class="number">1</span>;</span><br><span class="line">c.m_num2 = <span class="number">2</span>;</span><br><span class="line">cout &lt;&lt; c.m_num1 &lt;&lt; <span class="string">&quot;+&quot;</span> &lt;&lt; c.m_num2 &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; c.<span class="built_in">getresulr</span>(<span class="string">&quot;+&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; c.m_num1 &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; c.m_num2 &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; c.<span class="built_in">getresulr</span>(<span class="string">&quot;-&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout &lt;&lt; c.m_num1 &lt;&lt; <span class="string">&quot;*&quot;</span> &lt;&lt; c.m_num2 &lt;&lt; <span class="string">&quot;=&quot;</span> &lt;&lt; c.<span class="built_in">getresulr</span>(<span class="string">&quot;*&quot;</span>) &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算机抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">abstrat</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">int</span> m_num1;</span><br><span class="line"><span class="type">int</span> m_num2;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">addcalculator</span> :<span class="keyword">public</span> abstrat</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_num1 + m_num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">jiancalculator</span> :<span class="keyword">public</span> abstrat</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_num1 - m_num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">chencalculator</span> :<span class="keyword">public</span> abstrat</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getresult</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_num1 * m_num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//多态使用条件</span></span><br><span class="line"><span class="comment">//父类指针或引用指向子类对象</span></span><br><span class="line">abstrat* abc=<span class="keyword">new</span> addcalculator;</span><br><span class="line">abc-&gt;m_num1 = <span class="number">10</span>;</span><br><span class="line">abc-&gt;m_num2 = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; abc-&gt;<span class="built_in">getresult</span>()&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="built_in">test02</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h2><blockquote><p>多态中，父类是无用的，是子类发挥作用，因此可以把virtual写成纯虚函数</p><p>抽象类无法实例化对象</p><p>如果写了抽象类，子类需要重写抽象类的纯虚函数，不然也是抽象类</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="comment">//首先要是virtual</span></span><br><span class="line"><span class="comment">//抽象类</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">son</span> : <span class="keyword">public</span> base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i love you&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//base b;</span></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="comment">//new base</span></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line"><span class="comment">//son s;</span></span><br><span class="line"><span class="comment">//报错</span></span><br><span class="line">son s;</span><br><span class="line"><span class="comment">//不报错</span></span><br><span class="line">base* basg = <span class="keyword">new</span> son;</span><br><span class="line">basg-&gt;<span class="built_in">func</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态案例"><a href="#多态案例" class="headerlink" title="多态案例"></a>多态案例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">abstractdrinking</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//煮水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pour</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">putsome</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//制作饮品</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makedrink</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">boil</span>();</span><br><span class="line"><span class="built_in">brew</span>();</span><br><span class="line"><span class="built_in">pour</span>();</span><br><span class="line"><span class="built_in">putsome</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">caffee</span>:<span class="keyword">public</span> abstractdrinking</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//煮水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮农夫山泉&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡咖啡&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pour</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;倒入杯中&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">putsome</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入糖和牛奶&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">tea</span> :<span class="keyword">public</span> abstractdrinking</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//煮水</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">boil</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;煮开水&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">brew</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;冲泡茶叶&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//倒入杯中</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">pour</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;倒入杯中&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//加入辅料</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">putsome</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;加入柠檬枸杞&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dowork</span><span class="params">(abstractdrinking *abs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">abs-&gt;<span class="built_in">makedrink</span>();</span><br><span class="line"><span class="keyword">delete</span> abs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//制作咖啡</span></span><br><span class="line"><span class="built_in">dowork</span>(<span class="keyword">new</span> caffee);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;-------------&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="built_in">dowork</span>(<span class="keyword">new</span> tea);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="虚析构和纯虚析构"><a href="#虚析构和纯虚析构" class="headerlink" title="虚析构和纯虚析构"></a>虚析构和纯虚析构</h2><blockquote><p>多态使用时，如果子类种有属性开辟到堆区，那么父类指针在释放时候无法调用到子类的析构代码。</p><p>解决方法：将父类的析构函数改成虚析构或者纯虚析构</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//虚析构和纯虚析构</span></span><br><span class="line"><span class="comment">//共性：可以解决父类指针释放子类对象</span></span><br><span class="line"><span class="comment">//都需要有具体的函数实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="built_in">animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;animal的构造函数&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;animal的析构函数&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建在堆区</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> :<span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;cat的构造函数&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">m_name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">cat</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_name != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数的调用&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> m_name;</span><br><span class="line">m_name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt;*m_name&lt;&lt; <span class="string">&quot;笑猫在说话&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">string* m_name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal* animal = <span class="keyword">new</span> <span class="built_in">cat</span>(<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line">    <span class="comment">//父类指针在析构的时候不会调用子类的析构函数，会造成内存的泄露</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码没有走子类的析构代码，所以有问题。</p><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animal的构造函数</span><br><span class="line">cat的构造函数</span><br><span class="line">汤姆笑猫在说话</span><br><span class="line">animal的析构函数</span><br></pre></td></tr></table></figure></blockquote><h3 id="解决方案一：虚析构"><a href="#解决方案一：虚析构" class="headerlink" title="解决方案一：虚析构"></a>解决方案一：虚析构</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//虚析构和纯虚析构</span></span><br><span class="line"><span class="comment">//共性：可以解决父类指针释放子类对象</span></span><br><span class="line"><span class="comment">//都需要有具体的函数实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="built_in">animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;animal的构造函数&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//解决方案就是加一个虚析构</span></span><br><span class="line"><span class="comment">//重点virtual</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;animal的析构函数&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建在堆区</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> :<span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;cat的构造函数&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">m_name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">cat</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_name != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数的调用&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> m_name;</span><br><span class="line">m_name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt;*m_name&lt;&lt; <span class="string">&quot;笑猫在说话&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">string* m_name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal* animal = <span class="keyword">new</span> <span class="built_in">cat</span>(<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决方案二：纯虚析构"><a href="#解决方案二：纯虚析构" class="headerlink" title="解决方案二：纯虚析构"></a>解决方案二：纯虚析构</h2><blockquote><p>需要声明也需要实现</p><p>有了纯虚析构，也属于抽象类，无法实例化对象</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//虚析构和纯虚析构</span></span><br><span class="line"><span class="comment">//共性：可以解决父类指针释放子类对象</span></span><br><span class="line"><span class="comment">//都需要有具体的函数实现</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//纯虚函数</span></span><br><span class="line"><span class="built_in">animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;animal的构造函数&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//纯虚析构</span></span><br><span class="line"><span class="comment">//但不能只声明</span></span><br><span class="line"><span class="keyword">virtual</span> ~<span class="built_in">animal</span>() = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//创建在堆区</span></span><br><span class="line">&#125;;</span><br><span class="line">animal:: ~<span class="built_in">animal</span>()</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;纯虚析构&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cat</span> :<span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">cat</span>(string name)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;cat的构造函数&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">m_name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">cat</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_name != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;析构函数的调用&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">delete</span> m_name;</span><br><span class="line">m_name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt;*m_name&lt;&lt; <span class="string">&quot;笑猫在说话&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">string* m_name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">animal* animal = <span class="keyword">new</span> <span class="built_in">cat</span>(<span class="string">&quot;汤姆&quot;</span>);</span><br><span class="line">animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多态案例：纯虚析构"><a href="#多态案例：纯虚析构" class="headerlink" title="多态案例：纯虚析构"></a>多态案例：纯虚析构</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//案例三：电脑组装</span></span><br><span class="line"><span class="comment">//每个零件有不同的基类，三台不同的电脑</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">cpu</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">videocard</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">meomry</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">store</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">computer</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//接收函数</span></span><br><span class="line"><span class="built_in">computer</span>(cpu *_cpu1,videocard *_vc,meomry *_meo)</span><br><span class="line">&#123;</span><br><span class="line">cpu1 = _cpu1;</span><br><span class="line">vc1 = _vc;</span><br><span class="line">meo = _meo;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工作函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cpu1-&gt;<span class="built_in">calculate</span>();</span><br><span class="line">vc1-&gt;<span class="built_in">display</span>();</span><br><span class="line">meo-&gt;<span class="built_in">store</span>();</span><br><span class="line">&#125;</span><br><span class="line">~<span class="built_in">computer</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (cpu1 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> cpu1;</span><br><span class="line">cpu1 = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (vc1 != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> vc1;</span><br><span class="line">vc1 = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (meo != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> meo;</span><br><span class="line">meo = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">cpu* cpu1;</span><br><span class="line">videocard* vc1;</span><br><span class="line">meomry* meo;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//具体</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">intelcpu</span> :<span class="keyword">public</span> cpu</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">calculate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;intel的cpu开始工作了&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">intelvideo</span> :<span class="keyword">public</span> videocard</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;intel的显卡开始工作了&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">intelmeomry</span> :<span class="keyword">public</span> meomry</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">store</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;intel的显卡开始工作了&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cpu* m_intelcpu = <span class="keyword">new</span> intelcpu;</span><br><span class="line">videocard* m_intelcard = <span class="keyword">new</span> intelvideo;</span><br><span class="line">meomry* m_intelme = <span class="keyword">new</span> intelmeomry;</span><br><span class="line">computer* computer1 = <span class="keyword">new</span> <span class="built_in">computer</span>(m_intelcpu, m_intelcard, m_intelme);</span><br><span class="line">computer1-&gt;<span class="built_in">work</span>();</span><br><span class="line"><span class="keyword">delete</span> computer1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><blockquote><p>程序产生的数据都属于临时数据，程序一旦运行起来都会被释放，通过文件可以将数据持久化</p><p>C++文件对文件操作需要饱<fstream>.</fstream></p><p>文件类型分为两种</p><p>第一种是文本文件，文件以文本的 ASCLL 的形式存储在计算机种</p><p>第二种是二进制文件，以二进制文件存储在计算机种，用户一般不能直接读懂他们</p><p>操作文件有三大类：</p><ol><li><ofstream> :写</ofstream></li><li><ifstream>：读</ifstream></li><li><fstream>：读写操作</fstream></li></ol></blockquote><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">写文件操作：</span><br><span class="line"><span class="number">1.</span>包含头文件</span><br><span class="line"></span><br><span class="line">&lt;fstream&gt;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>创建流对象</span><br><span class="line">ofstream ofs</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>打开文件</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;文件路径&quot;</span>,打开方式)</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>写数据</span><br><span class="line">ofs&lt;&lt;<span class="string">&quot;写入的数据&quot;</span>；</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>关闭文件</span><br><span class="line">off.<span class="built_in">close</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">文件打开方式</span><br><span class="line"><span class="number">1.</span>ios::in 读</span><br><span class="line"><span class="number">2.</span>ios::out 写</span><br><span class="line"><span class="number">3.</span>ios:: ate 文件尾部</span><br><span class="line"><span class="number">4.</span>ios::app 追加方式</span><br><span class="line"><span class="number">4.</span>ios::tunc 如果文件存在先删除,再创建</span><br><span class="line"><span class="number">5.</span>ios::binary 二进制方式</span><br><span class="line">注意可以配合使用，使用|即可</span><br></pre></td></tr></table></figure></blockquote><h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件"></a>写文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//1.包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建流对象</span></span><br><span class="line">ofstream ofs;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.指定打开方式</span></span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.写内容</span></span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.关闭</span></span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果不指定</span></span><br></pre></td></tr></table></figure><h2 id="读文件"><a href="#读文件" class="headerlink" title="读文件"></a>读文件</h2><blockquote><p>读文件与写文件相似，读取方式相对多样</p><p>读文件的步骤如下：：</p><p>1.包含头文件：#include<fstream></fstream></p><p>2.创建流对象</p><p>3.打开文件，并判断文件是否打开成功</p><p>4.读数据</p><p>4种方式进行读取</p><p>5.关闭文件</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ostream&gt;</span></span></span><br><span class="line"><span class="comment">//1.包含头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//2.创建流对象</span></span><br><span class="line">    <span class="comment">//3.打开文件，判断</span></span><br><span class="line">    <span class="comment">//4.读数据</span></span><br><span class="line">   <span class="comment">// 5.关闭文件</span></span><br><span class="line">    ofstream ofs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.指定打开方式</span></span><br><span class="line">    ofs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.写内容</span></span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;姓名：张三&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    ofs &lt;&lt; <span class="string">&quot;年龄：18&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.关闭</span></span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">    ifstream ifs;</span><br><span class="line">    ifs.<span class="built_in">open</span>(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line">   <span class="keyword">if</span> (!ifs.<span class="built_in">is_open</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    char buf[1024] = &#123; 0 &#125;;</span></span><br><span class="line"><span class="comment">    while (ifs &gt;&gt; buf)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; buf &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    ifs.close();*/</span></span><br><span class="line">    <span class="comment">//第二种</span></span><br><span class="line">   <span class="comment">/* char buf[1023] = &#123;0&#125;;</span></span><br><span class="line"><span class="comment">    while (ifs.getline(buf, sizeof(buf)))</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        cout &lt;&lt; buf &lt;&lt; &#x27;\n&#x27;;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">//第三种</span></span><br><span class="line">   string buf;</span><br><span class="line">   <span class="keyword">while</span> ( <span class="built_in">getline</span>(ifs,buf) )</span><br><span class="line">   &#123;</span><br><span class="line">       cout &lt;&lt; buf;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//第四种</span></span><br><span class="line">   <span class="type">char</span> c;</span><br><span class="line">   <span class="comment">//一个一个字符的读</span></span><br><span class="line">   <span class="comment">//放到c里面</span></span><br><span class="line">   <span class="keyword">while</span>((c=ifs.<span class="built_in">get</span>())!=EOF)</span><br><span class="line">   &#123;</span><br><span class="line">   cout&lt;&lt;c;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第四种不推荐用</span></span><br><span class="line"><span class="comment">//EOF指的是文件的尾部，效率慢</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">test01</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制写文件"><a href="#二进制写文件" class="headerlink" title="二进制写文件"></a>二进制写文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二进制文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//打开方式要指定为ios::binary</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//包含头文件</span></span><br><span class="line"><span class="comment">//创建流对象</span></span><br><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"><span class="comment">//写文件</span></span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>,ios::out|ios::binary);</span><br><span class="line">Person p=&#123;<span class="string">&quot;张三&quot;</span>,<span class="number">19</span>&#125;;</span><br><span class="line">ofs.<span class="built_in">write</span>((<span class="type">const</span> <span class="type">char</span> *)&amp;p,<span class="built_in">sizeof</span>(Person));</span><br><span class="line">ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制读文件"><a href="#二进制读文件" class="headerlink" title="二进制读文件"></a>二进制读文件</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二进制文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">//打开方式要指定为ios::binary</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">char</span> m_name[<span class="number">64</span>];</span><br><span class="line"><span class="type">int</span> m_age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.<span class="built_in">open</span>(<span class="string">&quot;person.txt&quot;</span>,ios::in|ios::binary);</span><br><span class="line"><span class="keyword">if</span>(!(ifs.<span class="built_in">is_open</span>()))</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;打开失败了&quot;</span>&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">Person p;</span><br><span class="line">ifs.<span class="built_in">read</span>((<span class="type">char</span> *)&amp;p,<span class="built_in">sizeof</span>(Person));</span><br><span class="line">cout&lt;&lt;p.m_name&lt;&lt;<span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">cout&lt;&lt;p.m_age;</span><br><span class="line">ifs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">test01</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>起点！《青春简章第一章》</title>
      <link href="/2024/01/28/%E8%B5%B7%E7%82%B9%EF%BC%81%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/"/>
      <url>/2024/01/28/%E8%B5%B7%E7%82%B9%EF%BC%81%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<p>姑且作为博客的第一篇文学时刻吧。</p><p>一直都有写小说的想法，也因此写了一点，但也半途而废，愿我借由创建博客重新拾起那份记忆的精华，弥补心中的遗憾罢。</p><p>既然是属于我们的青春，书名就叫：</p><p>《青春简章》。</p><p>纪念我永不凋零的青春！</p><p>简介：时光的沙漏里，细沙流走的是光阴。幽静的小道里，枫叶寄托的是思念。我在三年后的夏日黄昏写下一封信，折成纸飞机，携着落日的余晖和三年的温情，寄给三年前夏日前的你，愿日后的你，永远保持一份童真，一份对事物的好奇，一份对美好的向往，一份对家人的幼稚，一份对生活的热忱，一份对未来的期许。……</p><h1 id="第一章-最后的考试"><a href="#第一章-最后的考试" class="headerlink" title="第一章.   最后的考试"></a>第一章.   最后的考试</h1><p>在沿海城镇的江南中学，来往车辆依旧络绎不绝，但却一反常态的没有鸣笛，风吹树叶的沙沙声彷佛也意识到什么，极力压制着自我，发出的声响也不同于往日.</p><p>落日余晖下，街道上的交警正在指挥熙熙攘攘的人群，放眼看去，人群竟是由一个个家庭所组成，天真烂漫的小孩手捧束束鲜花，身旁站着神色紧张的父母，齐刷刷望着校门口，等待着今天的主角们——一批高考生……</p><p>夏天很独特，也很奇妙，几乎成年前的所有重大事件和转折，都发生在夏天，这个蝉鸣不止的季节。</p><p>中考，高考，毕业，告别，无处可藏的炎热，恰恰意味着过往的终结与新生活的开始，对成熟与长大毫无准备的我们，携带着那份美好和童真，便被岁月裹挟着前行。</p><p>6月9日，黄昏，神圣的高考即将拉下帷幕。在江南中学的某个试室内，一位奋笔疾书的少年微微呼气，停下手中的钢笔，迅速翻回生物答题卡第一页。答题卡左上角，赫然写着，姓名：苏瑾，准考证号1058557345，考生号26。</p><p>虽是意料之中，但真正到来时候却往往措不及防，高中三年，要轻描淡写的在这张生物试卷终止了。</p><p>一个声音从苏瑾内心升起，我是否还有遗憾呢?</p><p>思绪被提示铃声打断，距离考试结束还有15分钟，请考生注意时间“。苏瑾扶了扶黑色镜框，抬头看了看钟表，”15分钟啊，最后的15分钟了“，还不等他感叹，理智告诉他，刚答完的试题还未检查过，如果不检查或许遗憾要加一了，至于眼下的遗憾什么的还是日后再提。</p><p>一个个熟悉的身影在苏瑾脑海浮现，现在可不是伤感的时候，毕竟外面还有想见的人等着呢，想罢他又埋头进试卷中集中精力核查一道道题目。</p><p>集中精力检查了两遍，可考试总不能一帆风顺，即使强如清北大佬，也总得有拦路虎的出现，对于苏瑾，还是有那两道题不确定，明明改后的答案更加合理，却又碍于第一印象迟迟不敢下笔，笔尖悬停在半空，未曾动弹。</p><p>何不自信一点，我可是超过了她的男人。苏瑾会心一笑，拿起橡皮擦改了两道选择题后，一颗悬着的心终于缓缓下落。</p><p>望向墙上的钟表，只剩最后两分钟了，时光河入海流，终归也要流到了尽头，脑海中不自觉响起熟悉的旋律，</p><p>“再给我两分钟”</p><p>“让我把记忆结成冰”。</p><p>苏瑾已无心于再次检查或是纠结于题目了，十年磨一剑，一朝试锋芒，千山万水只一步，执笔画墨终不悔，苏瑾已无愧于自己，这便是最好。</p><p>因所坐位置靠窗，他得以欣赏窗外的景色：</p><p>溪流从山上缓缓流淌而下，穿过村庄流经湖边。清澈见底的溪水中生活着各种小鱼和生灵，它们在水中嬉戏玩耍，为这个夏天的景象增添了一抹生机和趣味。</p><p>溪水旁是一片茂密的竹林，竹叶随风轻摇发出沙沙声，自然的乐曲，让人心旷神怡，叫人忘忧。</p><p>远方的房屋在落日照耀下闪闪发光，温柔的晚风轻轻拂动脸颊，苏瑾嘴唇微微颤抖，没有发出声音。</p><p>要结束了吗，真是毫无准备呢，真的要像书中所描述的那样“聚似飞霜不肯融，散如尘埃各西东”了。</p><p>“铃—铃—铃，考试结束，请考生停止答题”。</p><p>苏瑾长出一口气，十二载书生意气，一朝吐尽。收拾笔袋，手习惯性撩了撩略显凌乱的发型，苏瑾迈步走出考场，脚步很轻，每步却厚实的踩在了地上，日光照耀，洒满金光。</p><p>​                               </p><p>熟悉的小道，两旁的香樟，微风的柔软，野花的微香，怅然的少年走着那一年的校园路，很长很长，铺满缤纷彩叶，少年的思绪顺着这条路，绵延到三年前的夏日： </p><p>是盛夏白瓷梅子汤，碎冰碰壁当啷响，</p><p>是水晶帘动微风起，满架蔷薇一院香，</p><p>是阳光，溪流，燥热，琐碎，迷茫，</p><p>是青春，活力，温情，刻骨，勇敢，</p><p>是无微不至的父母，</p><p>是一群无话不谈的好友，</p><p>是稍稍挑逗面红不已的少女。</p><p>人情暖人心，重走来时路，随我启程，细看三年风雨……</p>]]></content>
      
      
      <categories>
          
          <category> 文学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 兴趣 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>洛谷刷题</title>
      <link href="/2024/01/26/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98/"/>
      <url>/2024/01/26/%E6%B4%9B%E8%B0%B7%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>力扣100题计划</title>
      <link href="/2024/01/26/%E5%8A%9B%E6%89%A3%E6%9A%91%E5%81%87%E5%88%B7%E9%A2%98/"/>
      <url>/2024/01/26/%E5%8A%9B%E6%89%A3%E6%9A%91%E5%81%87%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">       map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">      </span><br><span class="line">            <span class="keyword">auto</span> it = m.<span class="built_in">find</span>(target-nums[i]);</span><br><span class="line">            <span class="comment">//定义迭代器，如果指向end就是没找到，否则就是找到了，并存下下标</span></span><br><span class="line">            <span class="keyword">if</span>(it!=m.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                ret.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                ret.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                m.<span class="built_in">insert</span>(&#123;nums[i],i&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//哈希做法</span></span><br></pre></td></tr></table></figure><h1 id="字母异位词分组"><a href="#字母异位词分组" class="headerlink" title="字母异位词分组"></a>字母异位词分组</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本题依然是哈希的思路，如果两个字串乘积相同就放在一起</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m[<span class="number">26</span>] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">37</span>, <span class="number">41</span>, <span class="number">43</span>, <span class="number">47</span>, <span class="number">53</span>, <span class="number">59</span>, <span class="number">61</span>, <span class="number">67</span>, <span class="number">71</span>, <span class="number">73</span>, <span class="number">79</span>, <span class="number">83</span>, <span class="number">89</span>, <span class="number">97</span>, <span class="number">101</span>&#125;;</span><br><span class="line">    <span class="comment">//质数解决哈希冲突</span></span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        vector&lt;string&gt; res[strs.<span class="built_in">size</span>()];</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map;<span class="comment">//&lt;编码值，res下标&gt;</span></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>, mod = <span class="number">1e9</span>+<span class="number">7</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;s : strs)&#123;<span class="comment">//排序</span></span><br><span class="line">            <span class="type">long</span> v = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span> &amp;c : s)&#123;</span><br><span class="line">                v *= m[c-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">                v %= mod;<span class="comment">//取模防止溢出</span></span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span>(!map.<span class="built_in">count</span>(v))&#123;</span><br><span class="line">                res[cnt].<span class="built_in">push_back</span>(s);</span><br><span class="line">                map[v] = cnt++;</span><br><span class="line">            &#125;<span class="keyword">else</span>   res[map[v]].<span class="built_in">push_back</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;res, res + cnt&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最长连续序列"><a href="#最长连续序列" class="headerlink" title="最长连续序列"></a>最长连续序列</h1><p>这实际上是集合的应用了，算是哈希表的一种了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestConsecutive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; uset;</span><br><span class="line">        <span class="comment">//将数组中的值加入到哈希表中，便于查找，顺带降重，提高查找效率</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num:nums)</span><br><span class="line">            uset.<span class="built_in">insert</span>(num);</span><br><span class="line">        <span class="comment">//遍历哈希表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> x:uset)&#123;</span><br><span class="line">            <span class="comment">//从连续序列的第一个数开始查找</span></span><br><span class="line">            <span class="keyword">if</span>(!uset.<span class="built_in">count</span>(x - <span class="number">1</span>))&#123; <span class="comment">//如果x前一位数不存在，则说明x是连续序列的第一个数</span></span><br><span class="line">                <span class="type">int</span> y = x;</span><br><span class="line">                <span class="comment">//这里直接在哈希表中查找y+1，当y+1不存在时，说明正好查找到了y</span></span><br><span class="line">                <span class="keyword">while</span>(uset.<span class="built_in">count</span>(y+<span class="number">1</span>))&#123;</span><br><span class="line">                    y++;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res,y-x+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="移动0"><a href="#移动0" class="headerlink" title="移动0"></a>移动0</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开两个下标，如果数组遍历不等于0，则往前挪，等于0则不操作，最后补齐0即可。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span> ;</span><br><span class="line">        <span class="type">int</span> indexNum = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">while</span> ( indexNum &lt; nums.<span class="built_in">size</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( nums[indexNum] != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                nums[index] = nums[indexNum] ;</span><br><span class="line">                index ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            indexNum ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到不为0，直接记录</span></span><br><span class="line">        <span class="keyword">while</span> ( index &lt; nums.<span class="built_in">size</span>() )</span><br><span class="line">        &#123;</span><br><span class="line">            nums[index] = <span class="number">0</span> ;</span><br><span class="line">            index ++ ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//接下来就是填补0的过程</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="盛最多水的容器"><a href="#盛最多水的容器" class="headerlink" title="盛最多水的容器"></a>盛最多水的容器</h1><p>暴力做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.<span class="built_in">size</span>()&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> chang=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> kuan=height[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> s=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;height.<span class="built_in">size</span>();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;height.<span class="built_in">size</span>();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                kuan=<span class="built_in">min</span>(height[i],height[j]);</span><br><span class="line">                chang++;</span><br><span class="line">                <span class="keyword">if</span>(s&lt;chang*kuan)</span><br><span class="line">                &#123;</span><br><span class="line">                    s=chang*kuan;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            chang=<span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//两层循环枚举进行，这样实际上必定超时，不然对不起中等</span></span><br></pre></td></tr></table></figure><p>于是采取双指针加贪心的思路进行求解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(height.<span class="built_in">size</span>()&lt;<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right=height.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> s=<span class="number">0</span>;   </span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> tmp=<span class="built_in">min</span>(height[left],height[right]);</span><br><span class="line">            s=<span class="built_in">max</span>((right-left)*tmp,s);</span><br><span class="line">            <span class="keyword">if</span>(height[left]&gt;height[right])</span><br><span class="line">            &#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//直接从两边没枚举，每次记录答案，如果左边高度高，我们自然想办法保存，于是右边左移，反之则同理</span></span><br></pre></td></tr></table></figure><h1 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h1><p>暴力做法依然时间不够</p><p>三层循环不够的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;vector&lt;<span class="type">int</span>&gt;&gt; s;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = j + <span class="number">1</span>; k &lt; len; k++)</span><br><span class="line">                    <span class="keyword">if</span> (nums[i] + nums[j] + nums[k] == <span class="number">0</span>) &#123;</span><br><span class="line">                        vector&lt;<span class="type">int</span>&gt; v = &#123; nums[i], nums[j], nums[k] &#125;;</span><br><span class="line">                        s.<span class="built_in">insert</span>(v);</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; v : s) ans.<span class="built_in">push_back</span>(v);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>哈希表勉强可以过关</p><p>两层循环，一层用哈希表优化了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 跳过i代表的重复数字</span></span><br><span class="line">            unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m.<span class="built_in">count</span>(-nums[i] - nums[j])) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123; nums[i], nums[j], -nums[i] - nums[j] &#125;);</span><br><span class="line">                    <span class="keyword">while</span> (j + <span class="number">1</span> &lt; len &amp;&amp; nums[j] == nums[j + <span class="number">1</span>]) j++; <span class="comment">// 跳过j代表的重复数字</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="type">int</span>&gt;(nums[j], j)); <span class="comment">// 我们是在nums[i]后面的数字寻找nums[j]和nums[k]（即-nums[i] - nums[j]），所以这里存储nums[j]</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>双指针法：</p><p>详细介绍一下，我们枚举一重循环，定义两个指针，一个从i+1开始，一个从len-1开始，如果&#x3D;&#x3D;0，就记录，并且一个加加，一个减减，进行逼近，如果大于0，明显我们排完序后的话右指针要减减，如果小于0我们左指针要加加。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> left = i + <span class="number">1</span>, right = len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) <span class="keyword">continue</span>; <span class="comment">// 跳过nums[i]所表示的重复数字</span></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] == <span class="number">0</span>) &#123;</span><br><span class="line">                    ans.<span class="built_in">push_back</span>(&#123; nums[i], nums[left], nums[right] &#125;);</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left - <span class="number">1</span>]) left++; <span class="comment">// 跳过左边界重复数字</span></span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right + <span class="number">1</span>]) right--; <span class="comment">// 跳过右边界重复数字</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>) right--;</span><br><span class="line">                <span class="keyword">else</span> left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="接雨水"><a href="#接雨水" class="headerlink" title="接雨水"></a>接雨水</h1><p>本题实际上就是个单调栈，找到左边第一个比他大的，找到右边第一个比他大的，然后求解即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; height.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (!st.<span class="built_in">empty</span>() &amp;&amp; height[st.<span class="built_in">top</span>()] &lt; height[i]) &#123;</span><br><span class="line"><span class="type">int</span> bottom = st.<span class="built_in">top</span>(); <span class="comment">//取底</span></span><br><span class="line">st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (st.<span class="built_in">empty</span>()) <span class="comment">//发现没有左边界</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> left = st.<span class="built_in">top</span>();</span><br><span class="line"><span class="type">int</span> right = i;</span><br><span class="line"><span class="type">int</span> h = <span class="built_in">min</span>(height[left], height[right]) - height[bottom];</span><br><span class="line">ans += h * (right - left - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">st.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="最长不含重复字符的子字符串"><a href="#最长不含重复字符的子字符串" class="headerlink" title="最长不含重复字符的子字符串"></a>最长不含重复字符的子字符串</h1><p>请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度</p><p>好像还是哈希表的应用，但要加一个指针的思想罢了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        set&lt;<span class="type">char</span>&gt; count_ch;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(count_ch.<span class="built_in">count</span>(s[i]) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                count_ch.<span class="built_in">erase</span>(s[begin++]);</span><br><span class="line">            &#125;</span><br><span class="line">            count_ch.<span class="built_in">insert</span>(s[i]);</span><br><span class="line">            end++;</span><br><span class="line">            res = <span class="built_in">max</span>(end - begin, res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="无重复字符的最长子串C"><a href="#无重复字符的最长子串C" class="headerlink" title="无重复字符的最长子串C++"></a>无重复字符的最长子串C++</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">findAnagrams</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;   </span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() &lt; p.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> plen = p.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vp</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span>, <span class="title">vtmp</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;<span class="comment">//初始化数组长度为26，每个下标值对应小写字母的ASCII码值-&#x27;a&#x27;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : p)</span><br><span class="line">            vp[x - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= plen)<span class="comment">//超过p的长度开始，i-plen的字符从滑动窗口删除</span></span><br><span class="line">                vtmp[s[i - plen] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            vtmp[s[i] - <span class="string">&#x27;a&#x27;</span>]++;<span class="comment">//每次滑动窗口向右滑动一个字符</span></span><br><span class="line">            <span class="keyword">if</span>(vtmp == vp)</span><br><span class="line">                res.<span class="built_in">push_back</span>(i - plen + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="和为k的子数组C"><a href="#和为k的子数组C" class="headerlink" title="和为k的子数组C++"></a>和为k的子数组C++</h1><p>前缀和加暴力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sum</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++) sum[i]=sum[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(sum[j+<span class="number">1</span>]-sum[i]==k) count+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>前缀和加哈希</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; m;</span><br><span class="line">        m[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            sum+=nums[i];</span><br><span class="line">            res+=m[sum-k];</span><br><span class="line">            m[sum]+=<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h1><p>实际上就是一个单调队列，维护一个单调递减的就行了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> nums;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; arr;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; dq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; nums[i] &gt; nums[dq.<span class="built_in">back</span>()]) dq.<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">if</span>(!dq.<span class="built_in">empty</span>() &amp;&amp; dq.<span class="built_in">front</span>() &lt;= (i - k)) dq.<span class="built_in">pop_front</span>();</span><br><span class="line">            dq.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>) arr.<span class="built_in">push_back</span>(nums[dq.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="LeetCode-76-最小覆盖子串"><a href="#LeetCode-76-最小覆盖子串" class="headerlink" title="LeetCode 76. 最小覆盖子串"></a>LeetCode 76. 最小覆盖子串</h1><p>依然滑动窗口，满足就收缩</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; hs, ht;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c: t) ht[c] ++ ;</span><br><span class="line"></span><br><span class="line">        string res;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i ++ ) &#123;</span><br><span class="line">            hs[s[i]] ++ ;</span><br><span class="line">            <span class="keyword">if</span> (hs[s[i]] &lt;= ht[s[i]]) cnt ++ ;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (hs[s[j]] &gt; ht[s[j]]) hs[s[j ++ ]] -- ;</span><br><span class="line">            <span class="keyword">if</span> (cnt == t.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (res.<span class="built_in">empty</span>() || i - j + <span class="number">1</span> &lt; res.<span class="built_in">size</span>())</span><br><span class="line">                    res = s.<span class="built_in">substr</span>(j, i - j + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最大子数组和"><a href="#最大子数组和" class="headerlink" title="最大子数组和"></a>最大子数组和</h1><p>暴力解法自然是不能少</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MaxSumOfSub1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> res=-INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=cnt;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=cnt;j++)&#123;</span><br><span class="line">            <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&lt;=j;k++)</span><br><span class="line">                sum+=nums[k];</span><br><span class="line">            res=<span class="built_in">max</span>(res,sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>前缀和做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.length;</span><br><span class="line">    <span class="type">int</span> res = Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            res = Math.<span class="built_in">max</span>(res, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面两种应该会被卡，还是康康正解罢</p><p>动态规划</p><p>如果加上这个数字比这个数字还小，为什么要加呢？（核心）</p><p>除此之外就是记录答案</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pre = <span class="number">0</span>, maxAns = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;x: nums) &#123;</span><br><span class="line">            pre = <span class="built_in">max</span>(pre + x, x);</span><br><span class="line">            maxAns = <span class="built_in">max</span>(maxAns, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxAns;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">。</span><br></pre></td></tr></table></figure><h1 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h1><p>官方题解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//空集</span></span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; merged;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; intervals.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> L = intervals[i][<span class="number">0</span>], R = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!merged.<span class="built_in">size</span>() || merged.<span class="built_in">back</span>()[<span class="number">1</span>] &lt; L) &#123;</span><br><span class="line">                merged.<span class="built_in">push_back</span>(&#123;L, R&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                merged.<span class="built_in">back</span>()[<span class="number">1</span>] = <span class="built_in">max</span>(merged.<span class="built_in">back</span>()[<span class="number">1</span>], R);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> merged;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//排序加贪心而已，排序左端点，贪心右端点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="轮转数组"><a href="#轮转数组" class="headerlink" title="轮转数组"></a>轮转数组</h1><p>第一种方法：暴力做法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> temp[n];</span><br><span class="line">        <span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">        k %= n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i++)&#123;</span><br><span class="line">        temp[i] = nums[n-k+i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k;i &lt; n;i++)&#123;</span><br><span class="line">        temp[i] = nums[i-k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        nums[i] = temp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>翻转数组的思路，加上位运算交换，肯定更快了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        k %= n;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, <span class="number">0</span>, k - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">reverse</span>(nums, k, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverse</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            nums[l] = nums[l] ^ nums[r];</span><br><span class="line">            nums[r] = nums[l] ^ nums[r];</span><br><span class="line">            nums[l] = nums[l] ^ nums[r];</span><br><span class="line">            l++;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//reverse部分的重写</span></span><br><span class="line"><span class="comment">/*void reverse(vector&lt;int&gt;&amp;nums,int l,int r)&#123;</span></span><br><span class="line"><span class="comment">        while (l &lt; r) &#123;</span></span><br><span class="line"><span class="comment">            nums[l] = nums[l] + nums[r];</span></span><br><span class="line"><span class="comment">            nums[r] = nums[l] - nums[r];</span></span><br><span class="line"><span class="comment">            nums[l] = nums[l] - nums[r];</span></span><br><span class="line"><span class="comment">            l++;</span></span><br><span class="line"><span class="comment">            r--;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="除自身以外数组的乘积-C"><a href="#除自身以外数组的乘积-C" class="headerlink" title="除自身以外数组的乘积(C++)"></a>除自身以外数组的乘积(C++)</h1><p>前缀和的另一种模式前缀积</p><p>？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">productExceptSelf</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">answer</span><span class="params">(length)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// answer[i] 表示索引 i 左侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 因为索引为 &#x27;0&#x27; 的元素左侧没有元素， 所以 answer[0] = 1</span></span><br><span class="line">        answer[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">            answer[i] = nums[i - <span class="number">1</span>] * answer[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// R 为右侧所有元素的乘积</span></span><br><span class="line">        <span class="comment">// 刚开始右边没有元素，所以 R = 1</span></span><br><span class="line">        <span class="type">int</span> R = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R</span></span><br><span class="line">            answer[i] = answer[i] * R;</span><br><span class="line">            <span class="comment">// R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上</span></span><br><span class="line">            R *= nums[i];<span class="comment">//其实就是等到i-1轮的时候用的</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> answer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="Leetcode-41：缺失的第一个正数"><a href="#Leetcode-41：缺失的第一个正数" class="headerlink" title="Leetcode 41：缺失的第一个正数"></a>Leetcode 41：缺失的第一个正数</h1><p>讲述一下解法，既然不能开空间，就要想办法（好像是废话）</p><p>由于我们如果有 1 2 3 4 ，那么我们未尝不可以就是交换1到num[0],2到num[1]，这样使得每一个数在自己的位置，然后遍历完就可以</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[i] &gt; <span class="number">0</span> &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[i] != nums[nums[i]<span class="number">-1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[nums[i] - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]!=i+<span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n+<span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>矩阵置0</p><p>有点暴力好像是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i=matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> j=matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">hang</span><span class="params">(i)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">lie</span><span class="params">(j)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>;m&lt;i;m++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;j;n++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!matrix[m][n])&#123;             <span class="comment">//找出0元素所在的行和列</span></span><br><span class="line">                    hang[m]=lie[n]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> m=<span class="number">0</span>;m&lt;i;m++)&#123;                 <span class="comment">//使对应行和列的元素均设为0</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> n=<span class="number">0</span>;n&lt;j;n++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(hang[m] || lie[n])</span><br><span class="line">                matrix[m][n]=<span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这种就更暴力了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">arr</span>(matrix);                 <span class="comment">//将原矩阵进行复制</span></span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> i = matrix.<span class="built_in">size</span>(), j = matrix[<span class="number">0</span>].<span class="built_in">size</span>();  <span class="comment">//const保证变量值不被改变</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> m = <span class="number">0</span>; m &lt; i; m++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> n = <span class="number">0</span>; n &lt; j; n++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[m][n] == <span class="number">0</span>) &#123;                   <span class="comment">//找到0元素所在位置</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; j; k++) &#123;</span><br><span class="line">                        matrix[m][k] = <span class="number">0</span>;               <span class="comment">//使0所在的一列元素均为0</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> t = <span class="number">0</span>; t &lt; i; t++) &#123;</span><br><span class="line">                        matrix[t][n] = <span class="number">0</span>;               <span class="comment">//使0所在的一行元素均为0</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(matrix.<span class="built_in">empty</span>()) <span class="keyword">return</span> ans; <span class="comment">//若数组为空，直接返回答案</span></span><br><span class="line">        <span class="type">int</span> u = <span class="number">0</span>; <span class="comment">//赋值上下左右边界</span></span><br><span class="line">        <span class="type">int</span> d = matrix.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> r = matrix[<span class="number">0</span>].<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= r; ++i) ans.<span class="built_in">push_back</span>(matrix[u][i]); <span class="comment">//向右移动直到最右</span></span><br><span class="line">            <span class="keyword">if</span>(++ u &gt; d) <span class="keyword">break</span>; <span class="comment">//重新设定上边界，若上边界大于下边界，则遍历遍历完成，下同</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = u; i &lt;= d; ++i) ans.<span class="built_in">push_back</span>(matrix[i][r]); <span class="comment">//向下</span></span><br><span class="line">            <span class="keyword">if</span>(-- r &lt; l) <span class="keyword">break</span>; <span class="comment">//重新设定有边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = r; i &gt;= l; --i) ans.<span class="built_in">push_back</span>(matrix[d][i]); <span class="comment">//向左</span></span><br><span class="line">            <span class="keyword">if</span>(-- d &lt; u) <span class="keyword">break</span>; <span class="comment">//重新设定下边界</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = d; i &gt;= u; --i) ans.<span class="built_in">push_back</span>(matrix[i][l]); <span class="comment">//向上</span></span><br><span class="line">            <span class="keyword">if</span>(++ l &gt; r) <span class="keyword">break</span>; <span class="comment">//重新设定左边界</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//右下左上的一个思路，然后重新设定边界</span></span><br></pre></td></tr></table></figure><p>旋转矩阵</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">                <span class="type">int</span> temp = matrix[i][j];</span><br><span class="line">                matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">                matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">                matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">                matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//交换四个值的方法</span></span><br><span class="line"><span class="comment">//可以画一个正方形对角线分成四部分进行理解。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="搜索二维矩阵-II"><a href="#搜索二维矩阵-II" class="headerlink" title="搜索二维矩阵 II"></a>搜索二维矩阵 II</h1><blockquote><p>编写一个高效的算法来搜索 m x n 矩阵 <a href="https://so.csdn.net/so/search?q=matrix&spm=1001.2101.3001.7020">matrix</a> 中的一个目标值 target 。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p></blockquote><p>初始值在左下角，大于target向上移动，小于target向右移动。</p><p>给我一种双指针的美感</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> xloc = matrix.<span class="built_in">size</span>() - <span class="number">1</span>, yloc = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (yloc &lt; matrix[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; xloc &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[xloc][yloc] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(matrix[xloc][yloc] &gt; target)&#123;</span><br><span class="line">                xloc--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                yloc++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="搜索插入位置"><a href="#搜索插入位置" class="headerlink" title="搜索插入位置"></a>搜索插入位置</h1><p>二分方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*如果目标值大于 nums 里的最大值，则将其插入到数组的末尾*/</span> </span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[n<span class="number">-1</span>]) <span class="keyword">return</span> n;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*将在区间 [0, n - 1] 内查找目标索引*/</span> </span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; </span><br><span class="line">    <span class="keyword">if</span> (target &gt; nums[mid]) &#123; <span class="comment">//严格小于 target 的元素一定不是解 </span></span><br><span class="line">    <span class="comment">//下一轮搜索区间是 [mid + 1, right] </span></span><br><span class="line">    left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//严格大于等于 target 的元素有可能是解</span></span><br><span class="line"><span class="comment">//下一轮搜索区间是 [left, mid] </span></span><br><span class="line">    right = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>搜索二维矩阵</p><h3 id="将二维下标转换为一维下标，相当于在一维数组上做二分查找（推荐）"><a href="#将二维下标转换为一维下标，相当于在一维数组上做二分查找（推荐）" class="headerlink" title="将二维下标转换为一维下标，相当于在一维数组上做二分查找（推荐）"></a>将二维下标转换为一维下标，相当于在<a href="https://so.csdn.net/so/search?q=%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">一维数组</a>上做二分查找（推荐）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>, high = m * n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (high - low) / <span class="number">2</span> + low;</span><br><span class="line">            <span class="type">int</span> x = matrix[mid / n][mid % n];</span><br><span class="line">            <span class="keyword">if</span> (x &lt; target) &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x &gt; target) &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一次二分的机会</span></span><br><span class="line"><span class="comment">//就是转换</span></span><br></pre></td></tr></table></figure><h1 id="在排序数组中查找元素的第一个和最后一个位置"><a href="#在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="在排序数组中查找元素的第一个和最后一个位置"></a>在排序数组中查找元素的第一个和最后一个位置</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        ans[<span class="number">0</span>] = <span class="built_in">getleftposition</span>(nums, target);</span><br><span class="line">        ans[<span class="number">1</span>] = <span class="built_in">getrightposition</span>(nums, target);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getleftposition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//规定：左闭右闭区间 </span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[mid]) &#123;</span><br><span class="line">                <span class="comment">//target在mid值右侧，缩小左半区间</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// target == nums[mid]</span></span><br><span class="line">                <span class="comment">// 缩小右半区间，在左半区间继续寻找是否存在target</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(left == nums.<span class="built_in">size</span>() || nums[left] != target)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getrightposition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(target &lt; nums[mid]) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (target == nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// 往右边区间继续找是不是最后一个target</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// target &gt; nums[mid]</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(right == - <span class="number">1</span> || nums[right] != target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= nums[mid]) &#123;</span><br><span class="line">                <span class="comment">// left 到 mid 是顺序区间</span></span><br><span class="line">                (target &gt;= nums[left] &amp;&amp; target &lt; nums[mid]) ? right = mid - <span class="number">1</span> : left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// mid 到 right 是顺序区间</span></span><br><span class="line">                (target &gt; nums[mid] &amp;&amp; target &lt;= nums[right]) ? left = mid + <span class="number">1</span> : right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定理一：只有在顺序区间内才可以通过区间两端的数值判断target是否在其中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定理二：判断顺序区间还是乱序区间，只需要对比 left 和 right 是否是顺序对即可，left &lt;= right，顺序区间，否则乱序区间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">定理三：每次二分都会至少存在一个顺序区间。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">通过不断的用Mid二分，根据定理二，将整个数组划分成顺序区间和乱序区间，然后利用定理一判断target是否在顺序区间，如果在顺序区间，下次循环就直接取顺序区间，如果不在，那么下次循环就取乱序区间。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="寻找旋转排序数组的最小值"><a href="#寻找旋转排序数组的最小值" class="headerlink" title="寻找旋转排序数组的最小值"></a>寻找旋转排序数组的最小值</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> low = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> high = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="type">int</span> pivot = low + (high - low) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[pivot] &lt; nums[high]) &#123;</span><br><span class="line">                high = pivot;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                low = pivot + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 如果s的长度为奇数，一定不符合要求</span></span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;&#123;&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>) st.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">            <span class="comment">// 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号 return false</span></span><br><span class="line">            <span class="comment">// 第二种情况：遍历字符串匹配的过程中，发现栈里没有我们要匹配的字符。所以return false</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (st.<span class="built_in">empty</span>() || st.<span class="built_in">top</span>() != s[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">else</span> st.<span class="built_in">pop</span>(); <span class="comment">// st.top() 与 s[i]相等，栈弹出元素</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 第一种情况：此时我们已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配，所以return false，否则就return true</span></span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最小栈"><a href="#最小栈" class="headerlink" title="最小栈"></a>最小栈</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; x_stack;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; min_stack;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        min_stack.<span class="built_in">push</span>(INT_MAX);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">push</span>(x);</span><br><span class="line">        min_stack.<span class="built_in">push</span>(<span class="built_in">min</span>(min_stack.<span class="built_in">top</span>(), x));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        x_stack.<span class="built_in">pop</span>();</span><br><span class="line">        min_stack.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min_stack.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="字符串解码C"><a href="#字符串解码C" class="headerlink" title="字符串解码C++"></a>字符串解码C++</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">decodeString</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">        <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">        stack&lt;string&gt; st;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                num = <span class="number">10</span> * num + s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>) || (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nums.<span class="built_in">push</span>(num);</span><br><span class="line">                num = <span class="number">0</span>;</span><br><span class="line">                st.<span class="built_in">push</span>(tmp);</span><br><span class="line">                tmp.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> cnt = nums.<span class="built_in">top</span>();</span><br><span class="line">                nums.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; cnt; j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    st.<span class="built_in">top</span>() += tmp;</span><br><span class="line">                &#125;</span><br><span class="line">                tmp = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h1><p>一眼单调栈啊</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = temperatures.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s.<span class="built_in">empty</span>() &amp;&amp; temperatures[i] &gt; temperatures[s.<span class="built_in">top</span>()]) &#123;<span class="comment">//循环，如果找到了最近的较高温度，出栈</span></span><br><span class="line">                <span class="type">int</span> previousIndex = s.<span class="built_in">top</span>();</span><br><span class="line">                ans[previousIndex] = i - previousIndex;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="柱状图中最大的矩形C"><a href="#柱状图中最大的矩形C" class="headerlink" title="柱状图中最大的矩形C++"></a>柱状图中最大的矩形C++</h1><p>还是单调栈嘛</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        heights.<span class="built_in">insert</span>(heights.<span class="built_in">begin</span>(), <span class="number">0</span>); <span class="comment">// 数组头部加入元素0</span></span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>); <span class="comment">// 数组尾部加入元素0</span></span><br><span class="line">        st.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; heights.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (heights[i] &lt; heights[st.<span class="built_in">top</span>()]) &#123;</span><br><span class="line">                <span class="type">int</span> mid = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> w = i - st.<span class="built_in">top</span>() - <span class="number">1</span>;</span><br><span class="line">                <span class="type">int</span> h = heights[mid];</span><br><span class="line">                result = <span class="built_in">max</span>(result, w * h);</span><br><span class="line">            &#125;</span><br><span class="line">            st.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数组中第k个最大元素"><a href="#数组中第k个最大元素" class="headerlink" title="数组中第k个最大元素"></a>数组中第k个最大元素</h1><p>大根堆啦</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;<span class="type">int</span>&gt;&gt; maxHeap;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums)</span><br><span class="line">            maxHeap.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> _ = <span class="number">0</span>; _ &lt; k - <span class="number">1</span>; _ ++)</span><br><span class="line">            maxHeap.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> maxHeap.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="数组中前k个高频元素"><a href="#数组中前k个高频元素" class="headerlink" title="数组中前k个高频元素"></a>数组中前k个高频元素</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度：O(nlogk)</span></span><br><span class="line"><span class="comment">// 空间复杂度：O(n)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 小顶堆</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">mycomparison</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; lhs, <span class="type">const</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&amp; rhs)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lhs.second &gt; rhs.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 要统计元素出现频率</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; map; <span class="comment">// map&lt;nums[i],对应出现的次数&gt;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            map[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对频率排序</span></span><br><span class="line">        <span class="comment">// 定义一个小顶堆，大小为k</span></span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;, mycomparison&gt; pri_que;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用固定大小为k的小顶堆，扫面所有频率的数值</span></span><br><span class="line">        <span class="keyword">for</span> (unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = map.<span class="built_in">begin</span>(); it != map.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">            pri_que.<span class="built_in">push</span>(*it);</span><br><span class="line">            <span class="keyword">if</span> (pri_que.<span class="built_in">size</span>() &gt; k) &#123; <span class="comment">// 如果堆的大小大于了K，则队列弹出，保证堆的大小一直为k</span></span><br><span class="line">                pri_que.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出前K个高频元素，因为小顶堆先弹出的是最小的，所以倒序来输出到数组</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(k)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] = pri_que.<span class="built_in">top</span>().first;</span><br><span class="line">            pri_que.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="只出现一次的数字"><a href="#只出现一次的数字" class="headerlink" title="只出现一次的数字"></a>只出现一次的数字</h1><blockquote><p>异或性质</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">singleNumber</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> e: nums) ret ^= e;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="多数元素"><a href="#多数元素" class="headerlink" title="多数元素"></a>多数元素</h1><p>第一种哈希</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; counts;</span><br><span class="line">        <span class="type">int</span> majority = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num: nums) &#123;</span><br><span class="line">            ++counts[num];</span><br><span class="line">            <span class="keyword">if</span> (counts[num] &gt; cnt) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                cnt = counts[num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>第二种哈希</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.<span class="built_in">size</span>() / <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="颜色分类"><a href="#颜色分类" class="headerlink" title="颜色分类"></a>颜色分类</h1><p>直接开始循环就行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sortColors</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> ptr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ptr; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[ptr]);</span><br><span class="line">                ++ptr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h1><p>不讲武德的方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>讲武德的方法</p><p>先找到逆序的</p><p>再找到第一个比他大的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="买卖股票的最佳时机"><a href="#买卖股票的最佳时机" class="headerlink" title="买卖股票的最佳时机"></a>买卖股票的最佳时机</h1><p>暴力</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = (<span class="type">int</span>)prices.<span class="built_in">size</span>(), ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>贪心做法</p><p>记录历史最低，每次思考从最低开始买</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> inf = <span class="number">1e9</span>;</span><br><span class="line">        <span class="type">int</span> minprice = inf, maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price: prices) &#123;</span><br><span class="line">            maxprofit = <span class="built_in">max</span>(maxprofit, price - minprice);</span><br><span class="line">            minprice = <span class="built_in">min</span>(price, minprice);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="跳跃游戏"><a href="#跳跃游戏" class="headerlink" title="跳跃游戏"></a>跳跃游戏</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canJump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cover = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 只有一个元素，就是能达到</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= cover; i++) &#123; <span class="comment">// 注意这里是小于等于cover</span></span><br><span class="line">            cover = <span class="built_in">max</span>(i + nums[i], cover);</span><br><span class="line">            <span class="keyword">if</span> (cover &gt;= nums.<span class="built_in">size</span>() - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 说明可以覆盖到终点了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//主要是覆盖范围，如果覆盖范围足够就没问题了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="跳跃游戏2"><a href="#跳跃游戏2" class="headerlink" title="跳跃游戏2"></a>跳跃游戏2</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> begin = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end  = <span class="number">0</span>;    </span><br><span class="line">        <span class="comment">//[begin, end]</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(end &lt; nums.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = begin; i &lt;= end; i++)&#123;</span><br><span class="line">                temp = <span class="built_in">max</span>(nums[i]+i, temp);</span><br><span class="line">            &#125;</span><br><span class="line">            begin = end+<span class="number">1</span>;</span><br><span class="line">            end = temp;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h1><p>找到最远边界的过程，然后放进去即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string S)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">27</span>] = &#123;<span class="number">0</span>&#125;; <span class="comment">// i为字符，hash[i]为字符出现的最后位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); i++) &#123; <span class="comment">// 统计每一个字符最后出现的位置</span></span><br><span class="line">            hash[S[i] - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; S.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            right = <span class="built_in">max</span>(right, hash[S[i] - <span class="string">&#x27;a&#x27;</span>]); <span class="comment">// 找到字符出现的最远边界</span></span><br><span class="line">            <span class="keyword">if</span> (i == right) &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(right - left + <span class="number">1</span>);</span><br><span class="line">                left = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="动态规划篇"><a href="#动态规划篇" class="headerlink" title="动态规划篇"></a>动态规划篇</h1><h1 id="爬楼梯"><a href="#爬楼梯" class="headerlink" title="爬楼梯"></a>爬楼梯</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 版本一</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n; <span class="comment">// 因为下面直接对dp[2]操作了，防止空指针</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123; <span class="comment">// 注意i是从3开始的</span></span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//优化后</span></span><br><span class="line">    <span class="comment">// 版本二</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">        <span class="type">int</span> dp[<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = dp[<span class="number">1</span>] + dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">1</span>] = dp[<span class="number">2</span>];</span><br><span class="line">            dp[<span class="number">2</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"># 杨辉三角</span><br><span class="line"></span><br><span class="line">如此经典的动态规划</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; ret(numRows);</span><br><span class="line">        for (int i = 0; i &lt; numRows; ++i) &#123;</span><br><span class="line">            ret[i].resize(i + 1);</span><br><span class="line">            ret[i][0] = ret[i][i] = 1;</span><br><span class="line">            //边界条件</span><br><span class="line">            for (int j = 1; j &lt; i; ++j) &#123;</span><br><span class="line">                ret[i][j] = ret[i - 1][j] + ret[i - 1][j - 1];</span><br><span class="line">                //递推公式挺好</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="打家劫舍"><a href="#打家劫舍" class="headerlink" title="打家劫舍"></a>打家劫舍</h1><p>动态规划的的四个解题步骤是：</p><blockquote><ul><li>定义子问题</li><li>写出子问题的递推关系</li><li>确定 DP 数组的计算顺序</li></ul></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; dp = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(size, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="built_in">max</span>(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; size; i++) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">2</span>] + nums[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[size - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="完全平方数"><a href="#完全平方数" class="headerlink" title="完全平方数"></a>完全平方数</h1><blockquote><p>刚看到是不是有一点小懵逼</p><p>实际上想想01背包</p><p>不就是装满吗</p><p>但又想到样例12&#x3D;4+4+4</p><p>明显是完成背包</p><p>因此两重正序循环即可</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numSquares</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> minn = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j * j &lt;= i; j++) &#123;</span><br><span class="line">                minn = <span class="built_in">min</span>(minn, f[i - j * j]);</span><br><span class="line">            &#125;</span><br><span class="line">            f[i] = minn + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h1><p>依然是完全背包的变式</p><p>只是最后需要特判一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> Max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(amount + <span class="number">1</span>, Max)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)coins.<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (coins[j] &lt;= i) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">min</span>(dp[i], dp[i - coins[j]] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h1><p>最长上升子序列</p><p>这个还是弱了点</p><p>实际上可以二分优化，队列优化</p><p>然而这样写就可以了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = (<span class="type">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">                    dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(dp.<span class="built_in">begin</span>(), dp.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="乘积最大子数组"><a href="#乘积最大子数组" class="headerlink" title="乘积最大子数组"></a>乘积最大子数组</h1><p>这道题不是那么简单</p><p>因为最优解不一定是由前一个最优解转移过来，而可能由最差解转移过来，考虑负数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProduct</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        vector &lt;<span class="type">int</span>&gt; <span class="built_in">maxF</span>(nums), <span class="built_in">minF</span>(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            maxF[i] = <span class="built_in">max</span>(maxF[i - <span class="number">1</span>] * nums[i], <span class="built_in">max</span>(nums[i], minF[i - <span class="number">1</span>] * nums[i]));</span><br><span class="line">            minF[i] = <span class="built_in">min</span>(minF[i - <span class="number">1</span>] * nums[i], <span class="built_in">min</span>(nums[i], maxF[i - <span class="number">1</span>] * nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="built_in">max_element</span>(maxF.<span class="built_in">begin</span>(), maxF.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="分割等和子集"><a href="#分割等和子集" class="headerlink" title="分割等和子集"></a>分割等和子集</h1><p>一眼01背包，acmer太熟悉了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canPartition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>(), m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums) m += x;</span><br><span class="line">        <span class="keyword">if</span> (m &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m /= <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> x : nums)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = m; j &gt;=x ; j --)</span><br><span class="line">                f[j] = <span class="built_in">max</span>(f[j], f[j - x] + x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f[m] == m;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="不同路径"><a href="#不同路径" class="headerlink" title="不同路径"></a>不同路径</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int uniquePaths(int m, int n) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; f(m, vector&lt;int&gt;(n));</span><br><span class="line">        for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">            f[i][0] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">            f[0][j] = 1;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 1; i &lt; m; ++i) &#123;</span><br><span class="line">            for (int j = 1; j &lt; n; ++j) &#123;</span><br><span class="line">                f[i][j] = f[i - 1][j] + f[i][j - 1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[m - 1][n - 1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最小路径和"><a href="#最小路径和" class="headerlink" title="最小路径和"></a>最小路径和</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 5. 动态规划：从起始点到终点</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态定义：dp[i][j] 表示从 [0,0] 到 [i,j] 的最小路径和</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态初始化</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) &#123; <span class="comment">//第一行</span></span><br><span class="line">                    dp[i][j] = grid[i][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123; <span class="comment">// 第一列</span></span><br><span class="line">                    dp[i][j] = grid[i][j] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; j != <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = grid[i][j] + <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h1><p>经典</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = text1.<span class="built_in">length</span>(), n = text2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="type">char</span> c1 = text1.<span class="built_in">at</span>(i - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="type">char</span> c2 = text2.<span class="built_in">at</span>(j - <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h1><p>更经典了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(word1.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(word2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; dp[<span class="number">0</span>].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; dp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; dp[i].<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j - <span class="number">1</span>], <span class="built_in">min</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>])) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (word1[i - <span class="number">1</span>] == word2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.<span class="built_in">back</span>().<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h1><p>库函数大大滴好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            result.<span class="built_in">emplace_back</span>(nums);</span><br><span class="line">        &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>正经回溯步骤</p><blockquote><p>首先，如果我们需要输出搜素中我们的选择，这时候我们可能需要传入一个表示当前走到哪里的参数，第二个，如果我们需要计算出和最大或者是最小问题，我们可能传入一个参数，用来表示他们的和，第三个参数，也就是我们经常说的步数，我们可能要记录我们走了多少步，所以我们往往需要一个step的参数，来表示我们走了多少步，又或者，我们需要选完这个数后，我们要选比这个数大的数，我们此时也需要记录我们当前的数。</p><p>初步谈完了关于参数的传入，我们来谈谈关于终止条件，为什么要有终止条件呢，这是很重要的，不然我们的搜索不会停止，无法得到我们需要的结构，搜说条件往往是我们已经遇到死胡同了，接下来没有路可以走了，或者是说，我们已经收集好我们要的东西了，我们不需要再进行搜素了，这些都是需要我们进行终止的，而往往伴随着终止的是一个更新，我们需要更新我们最大值啊1，或是更新我们的最小值啊，又或者进行输出啊，当然是满足我们终止的条件下进行的啦，然后别忘了，我们在终止完后要return哦，不然你搜完第一次就卡在那里了，哪里能达到我们搜索的目的呢，你说是吧。</p><p>再来谈谈我们搜说的核心部分，首先我们要试探一下，试探这个点的下一个点有没有被搜索过，也就是说我们在前面要有一个东西，也就是一个判断的数组，来表示我们的下一个东西有没有被搜索过，如果有，可以continue，如果没有，那就标记下一个点为被搜索的状态，并进行递归调用我们的dfs，传入我们的下一个搜索点，注意参数往往要改变，也许是步数的加一，也许是和的加，也可以是下一个点的值，都要结合题目要求具体分析，然后也是比较重要的一点，我们需要进行清理现场，就是说我们要把我们前面标记的拿掉，让他可选择，这样我们就完成了整个dfs的搜索过程</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt; nums, <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x == nums.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(nums);      <span class="comment">// 添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[x]);   <span class="comment">// 交换，将 nums[i] 固定在第 x 位</span></span><br><span class="line">            <span class="built_in">dfs</span>(nums, x + <span class="number">1</span>);         <span class="comment">// 开启固定第 x + 1 位元素</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[x]);   <span class="comment">// 恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="子集"><a href="#子集" class="headerlink" title="子集"></a>子集</h1><p>围绕选与不选进行深度优先搜索</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        t.<span class="built_in">push_back</span>(nums[cur]);</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">        t.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">dfs</span>(cur + <span class="number">1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="电话号码的字母组合"><a href="#电话号码的字母组合" class="headerlink" title="电话号码的字母组合"></a>电话号码的字母组合</h1><p>首先使用哈希表存储每个数字对应的所有可能的字母，然后进行回溯操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    string path = <span class="string">&quot;&quot;</span>;  <span class="comment">//利用该字符串记录每次数据</span></span><br><span class="line">    vector&lt;string&gt; ans; <span class="comment">//利用该数组记录每次path保存的数据</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>,string&gt; dic&#123;   <span class="comment">//将数字和字母对应</span></span><br><span class="line">        &#123;<span class="string">&#x27;2&#x27;</span>,<span class="string">&quot;abc&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;3&#x27;</span>,<span class="string">&quot;def&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;4&#x27;</span>,<span class="string">&quot;ghi&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;5&#x27;</span>,<span class="string">&quot;jkl&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;6&#x27;</span>,<span class="string">&quot;mno&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;7&#x27;</span>,<span class="string">&quot;pqrs&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;8&#x27;</span>,<span class="string">&quot;tuv&quot;</span>&#125;,</span><br><span class="line">        &#123;<span class="string">&#x27;9&#x27;</span>,<span class="string">&quot;wxyz&quot;</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> index,string digits)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == digits.<span class="built_in">length</span>())&#123;  <span class="comment">//index代表是digits中第几个数字下标</span></span><br><span class="line">            ans.<span class="built_in">push_back</span>(path);</span><br><span class="line">        &#125;</span><br><span class="line">        string str = dic[digits[index]];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;str.<span class="built_in">length</span>();i++)&#123;  <span class="comment">// 回溯算法的递归嵌套</span></span><br><span class="line">            path += str[i];  <span class="comment">//将这层数据保存</span></span><br><span class="line">            <span class="built_in">dfs</span>(index+<span class="number">1</span>,digits); <span class="comment">//深层进入</span></span><br><span class="line">            path.<span class="built_in">pop_back</span>();  <span class="comment">// 恢复现场</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">empty</span>())&#123; <span class="comment">//若为空需要进行特殊处理，因为全局变量path初始化为&quot;&quot;，若不进行该处理，则最终为空的结果为[&quot;&quot;],而不是[]</span></span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,digits);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="组合总和"><a href="#组合总和" class="headerlink" title="组合总和"></a>组合总和</h1><p>隐含了一个剪枝</p><p>剪去了一个和大于目标值的情况</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; ans, vector&lt;<span class="type">int</span>&gt;&amp; combine, <span class="type">int</span> idx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (idx == candidates.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="number">0</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">emplace_back</span>(combine);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 直接跳过</span></span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, ans, combine, idx + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 选择当前数</span></span><br><span class="line">        <span class="keyword">if</span> (target - candidates[idx] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            combine.<span class="built_in">emplace_back</span>(candidates[idx]);</span><br><span class="line">            <span class="built_in">dfs</span>(candidates, target - candidates[idx], ans, combine, idx);</span><br><span class="line">            combine.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; candidates, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; combine;</span><br><span class="line">        <span class="built_in">dfs</span>(candidates, target, ans, combine, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="string">&quot;&quot;</span>, n, n);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> string&amp; str, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span> || left &gt; right)  <span class="comment">// 出现类似 ()) )) 这种格式都是错误的不用再继续了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(str + <span class="string">&#x27;(&#x27;</span>, left - <span class="number">1</span>, right);</span><br><span class="line">        <span class="built_in">dfs</span>(str + <span class="string">&#x27;)&#x27;</span>, left, right - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="链表相关题目"><a href="#链表相关题目" class="headerlink" title="链表相关题目"></a>链表相关题目</h1><blockquote><p>下面有关于列表的概要讲述。</p><p>有两种常用的列表实现，分别为数组列表和链表。如果我们想在列表中存储值，它们是如何实现的呢？</p><p>数组列表底层是使用数组存储值，我们可以通过索引在 O(1)的时间访问列表任何位置的值，这是由基于内存寻址的方式。<br>链表存储的是称为节点的对象，每个节点保存一个值和指向下一个节点的指针。访问某个特定索引的节点需要 O(n)的时间，因为要通过指针获取到下一个位置的节点。</p><p>总结一下数组的优缺点：</p><ul><li>优点：可以根据偏移实现快速的随机读写。</li><li>缺点：扩容，增删元素极慢。</li></ul><p>面试问题总结<br>无法高效获取长度，无法根据偏移快速访问元素，是链表的两个劣势。然而面试的时候经常碰见诸如获取倒数第k个元素，获取中间位置的元素，判断链表是否存在环，判断环的长度等和长度与位置有关的问题。这些问题都可以通过灵活运用双指针来解决。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        ListNode *A = headA, *B = headB;</span><br><span class="line">        <span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">            A = A != <span class="literal">nullptr</span> ? A-&gt;next : headB;</span><br><span class="line">            B = B != <span class="literal">nullptr</span> ? B-&gt;next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//两个结点指针分别走，根据数学推导实际上只需要走对方的一部分，走两次就可以走到同一个点</span></span><br></pre></td></tr></table></figure><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr) &#123;</span><br><span class="line">            ListNode* next = curr-&gt;next;</span><br><span class="line">            curr-&gt;next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要记录，不然无法进行</span></span><br></pre></td></tr></table></figure><h1 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h1><p>题解真的是天才，竟然把链表弄成数组，我这个nt还想着反转一次链表逐个比对，乐。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; vals;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vals.<span class="built_in">emplace_back</span>(head-&gt;val);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = (<span class="type">int</span>)vals.<span class="built_in">size</span>() - <span class="number">1</span>; i &lt; j; ++i, --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vals[i] != vals[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h1><p>应该不难想，快慢指针各自移动，有环你两肯定遇上，没有就不好说了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="环形链表II"><a href="#环形链表II" class="headerlink" title="环形链表II"></a>环形链表II</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">解题思路：</span></span><br><span class="line"><span class="comment">这类链表题目一般都是使用双指针法解决的，例如寻找距离尾部第 K 个节点、寻找环入口、寻找公共尾部入口等。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">在本题的求解过程中，双指针会产生两次“相遇”。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    f=2s （快指针每次2步，路程刚好2倍）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">f = s + nb (相遇时，刚好多走了n圈）</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">推出：s = nb</span></span><br><span class="line"><span class="comment">  从head结点走到入环点需要走 ： a + nb， 而slow已经走了nb，那么slow再走a步就是入环点了。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如何知道slow刚好走了a步？ 从head开始，和slow指针一起走，相遇时刚好就是a步 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (fast == slow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure><h1 id="合并两个有序链表·"><a href="#合并两个有序链表·" class="headerlink" title="合并两个有序链表·"></a>合并两个有序链表·</h1><p>双指针写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* list1, ListNode* list2)</span> </span>&#123;</span><br><span class="line">        ListNode* dum = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* cur = dum;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//找到比较小的接上即可，注意链表要移动</span></span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="comment">//现在这个也需要移动</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = list1 != <span class="literal">nullptr</span> ? list1 : list2;</span><br><span class="line">        <span class="comment">//有一个是空的话直接接上就可以了</span></span><br><span class="line">        <span class="keyword">return</span> dum-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这种方法比较好理解</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>递归写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">，两个链表头部值较小的一个节点与剩下元素的 merge 操作结果合并。</span></span><br><span class="line"><span class="comment">我们直接将以上递归过程建模，同时需要考虑边界情况。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果 l1 或者 l2 一开始就是空链表 ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个链表的头节点的值更小，然后递归地决定下一个添加到结果里的节点。如果两个链表有一个为空，递归结束。</span></span><br><span class="line"><span class="comment">返回值：每一层调用都返回排序好的链表头</span></span><br><span class="line"><span class="comment">O(m+n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l1 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt;= l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = <span class="built_in">mergeTwoLists</span>(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125;</span><br><span class="line">        l2-&gt;next = <span class="built_in">mergeTwoLists</span>(l1, l2-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="两数相加"><a href="#两数相加" class="headerlink" title="两数相加"></a>两数相加</h1><p>对齐的方法题解大大的好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len1=<span class="number">1</span>;<span class="comment">//记录l1的长度</span></span><br><span class="line">        <span class="type">int</span> len2=<span class="number">1</span>;<span class="comment">//记录l2的长度</span></span><br><span class="line">        ListNode* p=l1;</span><br><span class="line">        ListNode* q=l2;</span><br><span class="line">        <span class="keyword">while</span>(p-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//获取l1的长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            len1++;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q-&gt;next!=<span class="literal">NULL</span>)<span class="comment">//获取l2的长度</span></span><br><span class="line">        &#123;</span><br><span class="line">            len2++;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len1&gt;len2)<span class="comment">//l1较长，在l2末尾补零</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len1-len2;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                q-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                q=q-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//l2较长，在l1末尾补零</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len2-len1;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">                p=p-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        p=l1;</span><br><span class="line">        q=l2;</span><br><span class="line">        <span class="type">bool</span> count=<span class="literal">false</span>;<span class="comment">//记录进位</span></span><br><span class="line">        ListNode* l3=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);<span class="comment">//存放结果的链表</span></span><br><span class="line">        ListNode* w=l3;<span class="comment">//l3的移动指针</span></span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;<span class="comment">//记录相加结果</span></span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;q!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            i=count+p-&gt;val+q-&gt;val;</span><br><span class="line">            w-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(i%<span class="number">10</span>);</span><br><span class="line">            count=i&gt;=<span class="number">10</span>?<span class="literal">true</span>:<span class="literal">false</span>;</span><br><span class="line">            w=w-&gt;next;</span><br><span class="line">            p=p-&gt;next;</span><br><span class="line">            q=q-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count)<span class="comment">//若最后还有进位</span></span><br><span class="line">        &#123;</span><br><span class="line">            w-&gt;next=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">            w=w-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l3-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="删除链表的倒数第N个结点"><a href="#删除链表的倒数第N个结点" class="headerlink" title="删除链表的倒数第N个结点"></a>删除链表的倒数第N个结点</h1><p>暴力？好像是</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getLength</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">int</span> length = <span class="built_in">getLength</span>(head);</span><br><span class="line">        ListNode* cur = dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">        ListNode* ans = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummy;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="两两交换链表中的节点"><a href="#两两交换链表中的节点" class="headerlink" title="两两交换链表中的节点"></a>两两交换链表中的节点</h1><p>还是迭代法比较好理解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* dummyHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        dummyHead-&gt;next = head;</span><br><span class="line">        ListNode* temp = dummyHead;</span><br><span class="line">        <span class="keyword">while</span> (temp-&gt;next != <span class="literal">nullptr</span> &amp;&amp; temp-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            ListNode* node1 = temp-&gt;next;</span><br><span class="line">            ListNode* node2 = temp-&gt;next-&gt;next;</span><br><span class="line">            <span class="comment">//分别赋值node 1,node 2</span></span><br><span class="line">        </span><br><span class="line">            temp-&gt;next = node2;</span><br><span class="line">            <span class="comment">//指向node2</span></span><br><span class="line">            node1-&gt;next = node2-&gt;next;</span><br><span class="line">            <span class="comment">//node 1指向node 2的下一个</span></span><br><span class="line">            node2-&gt;next = node1;</span><br><span class="line">            <span class="comment">//这样node 2才能指向node 1</span></span><br><span class="line">            temp = node1;</span><br><span class="line">            <span class="comment">//最后重新更新temp</span></span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* ans = dummyHead-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> dummyHead;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二叉树世界"><a href="#二叉树世界" class="headerlink" title="二叉树世界"></a>二叉树世界</h1><p>一般是递归写法，毕竟树很难离得开递归。</p><h1 id="二叉树的中序遍历"><a href="#二叉树的中序遍历" class="headerlink" title="二叉树的中序遍历"></a>二叉树的中序遍历</h1><p>按照访问左子树——根节点——右子树的方式遍历这棵树</p><ul><li>前序遍历：打印 - 左 - 右</li><li>中序遍历：左 - 打印 - 右</li><li>后序遍历：左 - 右 - 打印</li><li>终止条件：当前节点为空时</li><li>函数内：递归的调用左节点，打印当前节点，再递归调用右节点</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">inorder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h1><p>知识前置</p><p> 3 个树的重要概念：层次、深度、高度。</p><p>二叉树的层次是从根节点算起，根节点是第一层，依次往下类推。</p><p>二叉树的高度是从叶子节点算起，叶子节点高度是 1，依次往上类推。可以看成是高楼，从下往上看，也就是自底向上看。</p><p>通过图，也可以看出，二叉树的深度和层次是完全对应的，最大深度为最大层次数。二叉树的深度和高度正好相反。</p><h4 id="1-自顶向下"><a href="#1-自顶向下" class="headerlink" title="(1) 自顶向下"></a>(1) <strong>自顶向下</strong></h4><p>自顶向下，就是从根节点递归到叶子节点，计算这一条路径上的深度，并更新维护最大深度。</p><p>这个是正儿八经的求深度。每次先维护根节点的深度，再递归左子树、右子树。</p><h4 id="2-自底向上"><a href="#2-自底向上" class="headerlink" title="(2) 自底向上"></a><strong>(2) 自底向上</strong></h4><p>自底向上，从叶子节点开始，一层一层的向上，最终汇集在根节点。</p><p>总结：dfs</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left), <span class="built_in">maxDepth</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h1><p>好精美的图，偷了</p><p><img src="https://pic.leetcode-cn.com/0f91f7cbf5740de86e881eb7427c6c3993f4eca3624ca275d71e21c5e3e2c550-226_2.gif" alt="226_2.gif"></p><p>交换一下左右节点，然后再递归的交换左节点，右节点</p><p>显然，我们从根节点开始，递归地对树进行遍历，并从叶子节点先开始翻转。如果当前遍历到的节点 root的左右两棵子树都已经翻转，那么我们只需要交换两棵子树的位置，即可完成以 root为根节点的整棵子树的翻转。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* left = <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        TreeNode* right = <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        root-&gt;left = right;</span><br><span class="line">        root-&gt;right = left;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h1><p>根据题目的描述，镜像对称，就是左右两边相等，也就是左子树和右子树是相当的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> root == <span class="literal">nullptr</span> || <span class="built_in">recur</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recur</span><span class="params">(TreeNode* L, TreeNode* R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (L == <span class="literal">nullptr</span> &amp;&amp; R == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//如果都是空并且都成立就没问题了</span></span><br><span class="line">        <span class="keyword">if</span> (L == <span class="literal">nullptr</span> || R == <span class="literal">nullptr</span> || L-&gt;val != R-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//有一个提前为空，或者比较的时候不等于了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recur</span>(L-&gt;left, R-&gt;right) &amp;&amp; <span class="built_in">recur</span>(L-&gt;right, R-&gt;left);</span><br><span class="line">        <span class="comment">//比较左子树的左和右子树的右</span></span><br><span class="line">        <span class="comment">//比较左子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="二叉树的直径"><a href="#二叉树的直径" class="headerlink" title="二叉树的直径"></a>二叉树的直径</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> ans;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">depth</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> L = <span class="built_in">depth</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> R = <span class="built_in">depth</span>(root-&gt;right);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, L + R + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(L, R) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        ans = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">depth</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h1><p>为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 111，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 111 都会被重新标记为 000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">int</span> r, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (r - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r<span class="number">-1</span>][c] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, r - <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (r + <span class="number">1</span> &lt; nr &amp;&amp; grid[r+<span class="number">1</span>][c] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, r + <span class="number">1</span>, c);</span><br><span class="line">        <span class="keyword">if</span> (c - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; grid[r][c<span class="number">-1</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, r, c - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; nc &amp;&amp; grid[r][c+<span class="number">1</span>] == <span class="string">&#x27;1&#x27;</span>) <span class="built_in">dfs</span>(grid, r, c + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> nr = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (!nr) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> nc = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> num_islands = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> r = <span class="number">0</span>; r &lt; nr; ++r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; nc; ++c) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[r][c] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    ++num_islands;</span><br><span class="line">                    <span class="built_in">dfs</span>(grid, r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> num_islands;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="腐烂的橘子"><a href="#腐烂的橘子" class="headerlink" title="腐烂的橘子"></a>腐烂的橘子</h1><p>我认为还是一眼Bfs的</p><p>这图好牛，偷了</p><p>附上链接：<a href="https://leetcode.cn/problems/rotting-oranges/solutions/129542/yan-du-you-xian-sou-suo-python3-c-by-z1m/?envType=study-plan-v2&envId=top-100-liked">994. 腐烂的橘子 - 力扣（LeetCode）</a></p><p><img src="https://pic.leetcode-cn.com/aec044437ac27b8e23ba0d8f07daac230e6e0c0671fcd6a68f8884b991b4e1cf-0994.gif" alt="0994.gif"></p><p>把初始时的腐烂橘子加入队列，并计算新鲜橘子的个数。</p><p><strong>BFS</strong><br>将预处理阶段找到的腐烂橘子向四个方向开始腐烂，需要记录队列的初始长度，当长度减少到0时算一轮感染。再进行次轮感染，直到队列为空。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">orangesRotting</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> min = <span class="number">0</span>, fresh = <span class="number">0</span>;</span><br><span class="line">        queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) fresh++;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(grid[i][j] == <span class="number">2</span>) q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; dirs = &#123; &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125; &#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="type">bool</span> rotten = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">auto</span> x = q.<span class="built_in">front</span>();</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> cur: dirs) &#123;</span><br><span class="line">                    <span class="type">int</span> i = x.first + cur.first;</span><br><span class="line">                    <span class="type">int</span> j = x.second + cur.second;</span><br><span class="line">                    <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; grid.<span class="built_in">size</span>() &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                        grid[i][j] = <span class="number">2</span>;</span><br><span class="line">                        q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                        fresh--;</span><br><span class="line">                        rotten = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(rotten) min++;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> fresh ? <span class="number">-1</span> : min;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h1><p>对于一个有向图中的一个顶点，它的入度是指指向该顶点的边的数量，而出度是指从该顶点出发的边的数量。如果一个顶点的入度为0，则称其为源点；如果一个顶点的出度为0，则称其为汇点。</p><h2 id="方法一-拓扑排序"><a href="#方法一-拓扑排序" class="headerlink" title="方法一 拓扑排序"></a>方法一 拓扑排序</h2><p>课程之间的关系可以用有向图来表示，能完成课程的依据就是课程组成的有<strong>向图中没有环</strong>，可以通过拓扑排序来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//所有课程的入度</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ingree</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="comment">//保存课程和先修课程之间的关系</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; preCourse;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prerequisites.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">            preCourse[prerequisites[i][<span class="number">0</span>]].<span class="built_in">push_back</span>(prerequisites[i][<span class="number">1</span>]);</span><br><span class="line">            ingree[prerequisites[i][<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; zero_ingree;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses; ++i) &#123;</span><br><span class="line">            <span class="comment">//所有入度为0的课程入队列</span></span><br><span class="line">            <span class="keyword">if</span> (!ingree[i]) &#123;</span><br><span class="line">                zero_ingree.<span class="built_in">push</span>(i);</span><br><span class="line">                ++count;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!zero_ingree.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> cur_course = zero_ingree.<span class="built_in">front</span>();</span><br><span class="line">            zero_ingree.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; preCourse[cur_course].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                    <span class="comment">//当前入度为0的课程对应的先修课程入度减1</span></span><br><span class="line">                    --ingree[preCourse[cur_course][i]];</span><br><span class="line">                    <span class="keyword">if</span> (!ingree[preCourse[cur_course][i]]) &#123;</span><br><span class="line">                        <span class="comment">//入度为0的课程入队列</span></span><br><span class="line">                        zero_ingree.<span class="built_in">push</span>(preCourse[cur_course][i]);</span><br><span class="line">                        ++count;</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//所有课程的入度减为0，说明课程可以修完</span></span><br><span class="line">        <span class="keyword">if</span> (count == numCourses) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="方法二-深度优先搜索-DFS"><a href="#方法二-深度优先搜索-DFS" class="headerlink" title="方法二 深度优先搜索(DFS)"></a>方法二 深度优先搜索(DFS)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; edges;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; visited;</span><br><span class="line">    <span class="type">bool</span> valid = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        visited[u] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> v: edges[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (visited[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(v);</span><br><span class="line">                <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (visited[v] == <span class="number">1</span>) &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                如果 v为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[u] = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canFinish</span><span class="params">(<span class="type">int</span> numCourses, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">        edges.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        visited.<span class="built_in">resize</span>(numCourses);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; info: prerequisites) &#123;</span><br><span class="line">            edges[info[<span class="number">1</span>]].<span class="built_in">push_back</span>(info[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; numCourses &amp;&amp; valid; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">                <span class="built_in">dfs</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题计划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 提高 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
