<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Chapter 8 Cache(6) | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Chapter 8 Cache(6)  这一节是讲解6 Cache Memories的。这一小节的内容很重要，一般大题会考缓存的各种算法，需要掌握。  Lecture Contents 中英对照表        English Chinese     Purpose of Cache Memory 高速缓存存储器的目的   Organization o">
<meta property="og:type" content="article">
<meta property="og:title" content="Chapter 8 Cache(6)">
<meta property="og:url" content="http://totorocatcat.top/Chapter%208%20Cache(6)/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="Chapter 8 Cache(6)  这一节是讲解6 Cache Memories的。这一小节的内容很重要，一般大题会考缓存的各种算法，需要掌握。  Lecture Contents 中英对照表        English Chinese     Purpose of Cache Memory 高速缓存存储器的目的   Organization o">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/3805be3cc551f555d99699629220d71.png">
<meta property="article:published_time" content="2024-11-23T04:19:35.000Z">
<meta property="article:modified_time" content="2025-01-02T16:55:13.632Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/3805be3cc551f555d99699629220d71.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/b5ca6e582a7a45e6fde46e616eeb68e.png"><link rel="canonical" href="http://totorocatcat.top/Chapter%208%20Cache(6)/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":765,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Chapter 8 Cache(6)',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-01-03 00:55:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%BE%A0%E5%AE%A2-%E6%AD%A6%E4%BE%A0%E5%9C%BA%E6%99%AF-%E6%B8%B8%E6%88%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">859</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/3805be3cc551f555d99699629220d71.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Chapter 8 Cache(6)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-23T04:19:35.000Z" title="发表于 2024-11-23 12:19:35">2024-11-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-02T16:55:13.632Z" title="更新于 2025-01-03 00:55:13">2025-01-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>32分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Chapter 8 Cache(6)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/Chapter%208%20Cache(6)/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/Chapter%208%20Cache(6)/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="chapter-8-cache6">Chapter 8 Cache(6)</h1>
<blockquote>
<p>这一节是讲解6 Cache
Memories的。这一小节的内容很重要，一般大题会考缓存的各种算法，需要掌握。</p>
</blockquote>
<h2 id="lecture-contents-中英对照表">Lecture Contents 中英对照表</h2>
<table>
<colgroup>
<col style="width: 61%">
<col style="width: 38%">
</colgroup>
<thead>
<tr>
<th><strong>English</strong></th>
<th><strong>Chinese</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Purpose of Cache Memory</strong></td>
<td><strong>高速缓存存储器的目的</strong></td>
</tr>
<tr>
<td><strong>Organization of Cache/Main Memory System</strong></td>
<td><strong>高速缓存/主存系统的组织</strong></td>
</tr>
<tr>
<td><strong>Hit and Miss</strong></td>
<td><strong>命中与未命中</strong></td>
</tr>
<tr>
<td><strong>Cache Design Issues</strong></td>
<td><strong>高速缓存设计问题</strong></td>
</tr>
<tr>
<td><strong>Mapping Schemes</strong></td>
<td><strong>映射方案</strong></td>
</tr>
<tr>
<td><strong>Block Identification</strong></td>
<td><strong>块的标识</strong></td>
</tr>
<tr>
<td><strong>Replacement Algorithms</strong></td>
<td><strong>替换算法</strong></td>
</tr>
<tr>
<td><strong>Write Policies</strong></td>
<td><strong>写入策略</strong></td>
</tr>
</tbody>
</table>
<h2 id="高速缓存存储器的目的">高速缓存存储器的目的</h2>
<h4 id="问题性能差距"><strong>问题：性能差距</strong></h4>
<blockquote>
<p>处理器的增长速度实在是太快了！！！</p>
</blockquote>
<ul>
<li><strong>处理器速度增长快于 DRAM 的速度增长</strong>
<ul>
<li><strong>处理器速度</strong>：年增长率约 60%<br>
</li>
<li><strong>DRAM 速度</strong>：年增长率仅约 7%<br>
</li>
<li>导致 <strong>处理器与内存性能差距</strong>（每年扩大约 50%）。</li>
</ul></li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123143631968.png" alt="image-20241123143631968">
<figcaption aria-hidden="true">image-20241123143631968</figcaption>
</figure>
<hr>
<h4 id="解决方案高速缓存存储器"><strong>解决方案：高速缓存存储器</strong></h4>
<ul>
<li><strong>高速缓存</strong> 是基于 <strong>SRAM</strong>
的小型、快速存储器，由硬件自动管理。<br>
</li>
<li><strong>作用</strong>：作为 <strong>CPU
和主存之间的缓冲区</strong>，存储主存中经常访问的数据块。</li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123143659506.png" alt="image-20241123143659506">
<figcaption aria-hidden="true">image-20241123143659506</figcaption>
</figure>
<hr>
<h4 id="目的"><strong>目的</strong></h4>
<ol type="1">
<li><strong>提高访问速度</strong>
<ul>
<li>提供接近最快存储器速度的主存访问性能。</li>
</ul></li>
<li><strong>降低成本</strong>
<ul>
<li>在维持大容量存储的同时，使用相对廉价的半导体存储技术（如
DRAM）。</li>
</ul></li>
</ol>
<h2 id="高速缓存和主存系统的组织">高速缓存和主存系统的组织</h2>
<blockquote>
<p>高速缓存和主存的对应是用行来对应主存中的一个块。</p>
</blockquote>
<h4 id="高速缓存与主存的组织结构"><strong>高速缓存与主存的组织结构</strong></h4>
<ul>
<li><strong>主存块数量</strong>：
<ul>
<li>主存被分为多个块（Block），每个块的大小为 $ K $，块的总数为 $ 2^n /
K $。</li>
</ul></li>
<li><strong>高速缓存行</strong>：
<ul>
<li>高速缓存存储主存中的部分数据，每一行对应主存的一个块。<br>
</li>
<li>每一行存储某一部分地址的连续存储单元。</li>
</ul></li>
<li><strong>标识存储块</strong>：
<ul>
<li>每行高速缓存需要一个标识字段，标明当前行存储的是主存中的哪个具体块。</li>
</ul></li>
</ul>
<blockquote>
<p>一图胜千言，看图理解缓存和主存的对应关系。</p>
</blockquote>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123143841206.png" alt="image-20241123143841206">
<figcaption aria-hidden="true">image-20241123143841206</figcaption>
</figure>
<hr>
<h4 id="总结"><strong>总结</strong></h4>
<p>高速缓存的设计基于块的概念，通过组织块与行之间的对应关系，实现快速定位和访问主存数据，同时缓解主存与处理器间的性能差距。</p>
<h2 id="命中与未命中-hit-and-miss">命中与未命中 (Hit and Miss)</h2>
<blockquote>
<p>很好理解的概念，注意命中率和为命中率。</p>
</blockquote>
<h4 id="命中-hit"><strong>命中 (Hit)</strong></h4>
<ul>
<li>高速缓存访问到所需数据，并发现数据已经驻留在高速缓存中。</li>
</ul>
<h4 id="未命中-miss"><strong>未命中 (Miss)</strong></h4>
<ul>
<li>高速缓存访问到所需数据，但未发现数据驻留在缓存中，需强制访问主存获取数据。</li>
</ul>
<h4 id="命中率-hit-rate"><strong>命中率 (Hit Rate)</strong></h4>
<ul>
<li><strong>定义</strong>：表示通过高速缓存满足内存访问的百分比。<br>
</li>
<li><strong>要求</strong>：命中率高（通常在 0.9
以上）是高性能计算机的必要条件。</li>
</ul>
<h4 id="未命中率-miss-rate"><strong>未命中率 (Miss Rate)</strong></h4>
<ul>
<li><strong>定义</strong>：未命中率等于 $ 1 - $。</li>
</ul>
<hr>
<h4 id="总结-1"><strong>总结</strong></h4>
<ul>
<li>高速缓存的性能主要依赖于命中率。命中率越高，数据从缓存中获取的比例越大，减少对慢速主存的访问，从而提高整体系统性能。</li>
</ul>
<h2 id="高速缓存读取操作-cache-read-operation">高速缓存读取操作 (Cache
Read Operation)</h2>
<blockquote>
<p>这两种处理方式需要记住：一种是先加载到缓存，另外一种是在加载到缓存的同时将字发送给处理器。第二种会更快一点。</p>
</blockquote>
<h4 id="缓存读取操作的基本流程"><strong>缓存读取操作的基本流程</strong></h4>
<ol type="1">
<li><strong>处理器无感知缓存存在</strong>
<ul>
<li>处理器无需明确知道缓存的存在。<br>
</li>
<li>它通过使用内存地址发出读和写请求。</li>
</ul></li>
<li><strong>缓存控制电路的作用</strong>
<ul>
<li>缓存控制电路判断所请求的数据是否已存在于缓存中。</li>
</ul></li>
</ol>
<hr>
<h4 id="处理器的读取请求-processor-read-request"><strong>处理器的读取请求
(Processor: Read Request)</strong></h4>
<ol type="1">
<li><strong>缓存命中 (Cache Read Hit)</strong>
<ul>
<li>将请求的数据字直接转发给处理器。</li>
</ul></li>
<li><strong>缓存未命中 (Cache Read Miss)</strong>
<ul>
<li><strong>两种处理方式：</strong>
<ol type="1">
<li><strong>块加载 (Block Copy)：</strong>
<ul>
<li>从主存中将包含请求数据字的整个数据块复制到缓存中。<br>
</li>
<li>然后将所需的特定数据字转发给处理器。<br>
</li>
</ul></li>
<li><strong>提前加载/早启动 (Load Through/Early Restart)：</strong>
<ul>
<li>在将包含请求数据字的整个数据块从主存复制到缓存的同时，直接将所需的数据字立即转发给处理器。</li>
</ul></li>
</ol></li>
</ul></li>
</ol>
<hr>
<h4 id="缓存未命中-cache-read-miss"><strong>缓存未命中 (Cache Read
Miss)</strong></h4>
<ul>
<li>当缓存中未找到所需数据时，现代缓存组织通常使用优化的策略来减少主存访问延迟。</li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123144357571.png" alt="image-20241123144357571">
<figcaption aria-hidden="true">image-20241123144357571</figcaption>
</figure>
<hr>
<h3 id="总结-2">总结</h3>
<ul>
<li>缓存的读取操作分为命中与未命中。命中时直接提供数据，未命中时根据不同策略从主存加载数据块。<br>
</li>
<li><strong>早启动</strong>策略有助于减少处理器等待时间，提高读取效率。</li>
</ul>
<h2 id="高速缓存设计问题-cache-design-issues">高速缓存设计问题 (Cache
Design Issues)</h2>
<blockquote>
<p>上一节留下了一些问题，这一节将会解答这些问题。</p>
<p>歌曲总会让人产生思绪，一种名为感动的感觉纷至沓来。</p>
</blockquote>
<hr>
<h4 id="缓存映射方案-cache-mapping-schemes"><strong>1. 缓存映射方案
(Cache Mapping Schemes)</strong></h4>
<ul>
<li><strong>问题：</strong>
数据块（Block）可以放置在缓存中的什么位置？<br>
</li>
<li><strong>常见映射方案：</strong>
<ul>
<li><strong>直接映射 (Direct Mapping)：</strong>
每个主存块只能映射到缓存中的固定位置。</li>
<li><strong>全相联映射 (Fully Associative Mapping)：</strong>
主存块可以放置到缓存中的任意位置。</li>
<li><strong>组相联映射 (Set-Associative Mapping)：</strong>
主存块可以映射到一个特定组内的任何位置。</li>
</ul></li>
</ul>
<hr>
<h4 id="数据块标识-block-identification"><strong>2. 数据块标识 (Block
Identification)</strong></h4>
<ul>
<li><strong>问题：</strong>
如何判断所请求的数据块是否存在于缓存中？<br>
</li>
<li><strong>解决方法：</strong>
<ul>
<li>缓存通过<strong>标签 (Tag)</strong>字段来标识主存中的块。<br>
</li>
<li>标签存储在缓存行的元数据中，通过地址的高位部分与标签比较来确认命中。</li>
</ul></li>
</ul>
<hr>
<h4 id="替换算法-replacement-algorithms"><strong>3. 替换算法
(Replacement Algorithms)</strong></h4>
<ul>
<li><strong>问题：</strong>
当缓存未命中且缓存已满时，应该替换掉哪个缓存块？<br>
</li>
<li><strong>常用算法：</strong>
<ul>
<li><strong>最近最少使用 (LRU, Least Recently Used)：</strong>
替换最近最少被访问的块。</li>
<li><strong>先进先出 (FIFO, First-In-First-Out)：</strong>
替换最早进入缓存的块。</li>
<li><strong>随机替换 (Random)：</strong> 随机选择一个块替换。</li>
<li><strong>最少频率使用 (LFU, Least Frequently Used)：</strong>
替换访问次数最少的块。</li>
</ul></li>
</ul>
<hr>
<h4 id="写策略-write-policy"><strong>4. 写策略 (Write
Policy)</strong></h4>
<ul>
<li><strong>问题：</strong> 写操作时，如何处理缓存命中和未命中？
<ul>
<li><strong>写命中 (Write Hit)：</strong>
<ol type="1">
<li><strong>写直达 (Write-Through)：</strong> 同时更新缓存和主存。</li>
<li><strong>写回 (Write-Back)：</strong>
仅更新缓存，主存更新延迟到块被替换时。</li>
</ol></li>
<li><strong>写未命中 (Write Miss)：</strong>
<ol type="1">
<li><strong>写分配 (Write-Allocate)：</strong>
将缺失块加载到缓存，然后写入缓存。</li>
<li><strong>非写分配 (No-Write-Allocate)：</strong>
直接写入主存，不加载到缓存。</li>
</ol></li>
</ul></li>
</ul>
<hr>
<h3 id="精华所在">精华所在</h3>
<p>高速缓存设计需要解决以下核心问题：块放置位置、块的查找方式、替换策略以及写操作策略。合理的设计能够在性能和成本之间达到良好平衡。</p>
<h2 id="映射方案-mapping-scheme">映射方案 (Mapping Scheme)</h2>
<hr>
<h4 id="映射方案的作用"><strong>1. 映射方案的作用</strong></h4>
<ul>
<li><strong>定义：</strong><br>
映射方案决定了当主存中的数据块被复制到缓存时，数据块将被放置在缓存的哪个位置。</li>
<li><strong>地址转换：</strong><br>
缓存映射方案还需将主存地址转换为缓存中的具体位置，因为主存和缓存的结构不同。
<ul>
<li>当 CPU
生成一个主存地址请求时，如果数据存在于缓存中，则需要通过映射方案找到对应的缓存位置。</li>
</ul></li>
</ul>
<hr>
<h4 id="三种主要映射方案"><strong>2. 三种主要映射方案</strong></h4>
<ol type="1">
<li><strong>直接映射 (Direct Mapping)</strong>
<ul>
<li>每个主存块只能映射到缓存中的固定位置。</li>
<li><strong>优点：</strong> 实现简单，查找快速。</li>
<li><strong>缺点：</strong>
容易发生冲突（两个主存块映射到同一缓存行）。</li>
</ul></li>
<li><strong>全相联映射 (Associative Mapping)</strong>
<ul>
<li>主存块可以映射到缓存中的任意位置。</li>
<li><strong>优点：</strong> 最大限度减少冲突。</li>
<li><strong>缺点：</strong> 查找复杂且时间较长。</li>
</ul></li>
<li><strong>组相联映射 (Set-Associative Mapping)</strong>
<ul>
<li>主存块可以映射到一个固定组内的任意缓存位置。</li>
<li>是<strong>直接映射</strong>和<strong>全相联映射</strong>的折中方案。</li>
<li><strong>优点：</strong> 平衡了实现复杂度和冲突解决能力。</li>
</ul></li>
</ol>
<hr>
<h4 id="基本假设"><strong>3. 基本假设</strong></h4>
<ul>
<li><p><strong>缓存行 (Cache Line)：</strong></p>
<ul>
<li>表示为 $ L_i $, $ i = 0, 1, ..., m-1 $<br>
</li>
<li>$ m = 2^r $ 表示缓存中有 $ 2^r $ 个缓存行。</li>
</ul></li>
<li><p><strong>主存块 (Memory Block)：</strong></p>
<ul>
<li>表示为 $ B_j $, $ j = 0, 1, ..., n-1 $<br>
</li>
<li>$ n = 2^s $ 表示主存分为 $ 2^s $ 个块。</li>
</ul></li>
<li><p><strong>数据块大小：</strong><br>
每个块或行由 $ k = 2^w $ 个连续的字组成。</p></li>
<li><p><strong>主存地址结构：</strong><br>
主存地址由 $ s + w $ 位组成：</p>
<ul>
<li><strong>高 $ s $ 位：</strong> 用于确定数据块所在的主存块。<br>
</li>
<li><strong>低 $ w $ 位：</strong> 用于确定块内偏移。</li>
</ul></li>
</ul>
<h2 id="直接映射-direct-mapping"><strong>直接映射 (Direct Mapping)
</strong></h2>
<hr>
<h4 id="直接映射概念"><strong>1. 直接映射概念</strong></h4>
<ul>
<li>每个主存块 (Main Memory Block)
<strong>只能映射到缓存中的一个固定缓存行 (Cache Line)</strong>。</li>
<li><strong>映射函数：</strong><br>
$ i = j m $<br>
其中：
<ul>
<li>$ i $：缓存行号 (Cache Line Number)<br>
</li>
<li>$ j $：主存块号 (Main Memory Block Number)<br>
</li>
<li>$ m $：缓存中的缓存行总数</li>
</ul></li>
</ul>
<hr>
<h4 id="缓存行分配表"><strong>2. 缓存行分配表</strong></h4>
<table>
<colgroup>
<col style="width: 34%">
<col style="width: 65%">
</colgroup>
<thead>
<tr>
<th><strong>缓存行号 (Cache Line)</strong></th>
<th><strong>分配的主存块号 (Main Memory Blocks Assigned)</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>$ 0, m, 2m, ..., 2^s m $</td>
</tr>
<tr>
<td>1</td>
<td>$ 1, m+1, 2m+1, ..., 2^s m+1 $</td>
</tr>
<tr>
<td>...</td>
<td>...</td>
</tr>
<tr>
<td>$ m-1 $</td>
<td>$ m-1, 2m-1, 3m-1, ..., 2^s m-1 $</td>
</tr>
</tbody>
</table>
<hr>
<h4 id="主存地址结构"><strong>3. 主存地址结构</strong></h4>
<ul>
<li><p><strong>地址分割：</strong> 主存地址被划分为三个字段：</p>
<ul>
<li><strong>Tag 字段 (s-r bits)：</strong> 确定主存块是否在缓存中。</li>
<li><strong>Line 字段 (r bits)：</strong> 确定块所在的缓存行。</li>
<li><strong>Word 字段 (w bits)：</strong> 确定块内的具体字。</li>
</ul>
<p><strong>地址结构：</strong><br>
$ Tag $ $ Line $ $ Word $</p></li>
</ul>
<hr>
<h4 id="缓存访问过程"><strong>4. 缓存访问过程</strong></h4>
<ol type="1">
<li><strong>从 CPU 生成的地址中提取：</strong>
<ul>
<li>Tag 字段：用于比较，判断是否命中缓存。</li>
<li>Line 字段：定位对应的缓存行。</li>
<li>Word 字段：定位缓存行中的具体字。</li>
</ul></li>
<li><strong>匹配过程：</strong>
<ul>
<li>如果缓存行中的 Tag 匹配，则命中缓存 (Cache Hit)。</li>
<li>如果不匹配，则发生缓存未命中 (Cache Miss)，需要从主存加载数据。</li>
</ul></li>
</ol>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123145441147.png" alt="image-20241123145441147">
<figcaption aria-hidden="true">image-20241123145441147</figcaption>
</figure>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123145509374.png" alt="image-20241123145509374">
<figcaption aria-hidden="true">image-20241123145509374</figcaption>
</figure>
<hr>
<h4 id="例子分析"><strong>5. 例子分析</strong></h4>
<ul>
<li><p><strong>条件：</strong></p>
<ul>
<li>缓存行数：128<br>
</li>
<li>每行大小：16 个字<br>
</li>
<li>主存大小：64K 个字<br>
</li>
<li>主存地址为 16 位。</li>
</ul></li>
<li><p><strong>计算：</strong></p>
<ul>
<li>主存块总数：$ 64K / 16 = 4096 $<br>
</li>
<li>映射公式：$ i = j $<br>
</li>
<li>地址划分：
<ul>
<li>Word 字段：$ 4 $ 位 ($ _2 16 = 4 $)<br>
</li>
<li>Line 字段：$ 7 $ 位 ($ _2 128 = 7 $)<br>
</li>
<li>Tag 字段：$ 16 - 4 - 7 = 5 $ 位。</li>
</ul></li>
</ul></li>
<li><p><strong>缓存分配示例：</strong></p></li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images\image-20250103005504581.png" alt="image-20250103005504581">
<figcaption aria-hidden="true">image-20250103005504581</figcaption>
</figure>
<h4 id="优缺点分析"><strong>6. 优缺点分析</strong></h4>
<ul>
<li><strong>优点：</strong>
<ul>
<li>实现简单，硬件复杂度低。</li>
<li>低成本。</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li>固定位置映射导致冲突频繁：
<ul>
<li>如果程序频繁访问映射到同一缓存行的两个主存块，会导致缓存未命中率较高。</li>
</ul></li>
</ul></li>
</ul>
<h2 id="全相联映射-associative-mapping"><strong>全相联映射 (Associative
Mapping) </strong></h2>
<hr>
<h4 id="全相联映射概念"><strong>1. 全相联映射概念</strong></h4>
<ul>
<li><strong>无需映射函数：</strong> 主存的任何块 (Main Memory Block)
可以加载到缓存中的任意一行 (Cache Line)。<br>
</li>
<li><strong>主存地址结构：</strong>
<ul>
<li>地址被分解为 <strong>Tag 字段</strong> 和 <strong>Word
字段</strong>。</li>
<li><strong>Tag 字段：</strong> 唯一标识主存中的块。<br>
</li>
<li><strong>Word 字段：</strong> 指定块中的具体字。<br>
</li>
</ul></li>
<li><strong>访问机制：</strong>
<ul>
<li>缓存中的每一行都会检查其 Tag 值是否与主存地址的 Tag 字段匹配。</li>
<li>如果找到匹配，则命中缓存 (Cache Hit)。</li>
<li><strong>缺点：</strong> 检查所有行的 Tag，搜索开销较大。</li>
</ul></li>
</ul>
<hr>
<h4 id="主存地址结构-1"><strong>2. 主存地址结构</strong></h4>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Tag (s 位)</strong></td>
<td>用于标识主存块</td>
</tr>
<tr>
<td><strong>Word (w 位)</strong></td>
<td>用于定位块中的字</td>
</tr>
</tbody>
</table>
<p><strong>地址格式：</strong><br>
$ Tag (s 位) $ $ Word (w 位) $</p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123150351542.png" alt="image-20241123150351542">
<figcaption aria-hidden="true">image-20241123150351542</figcaption>
</figure>
<hr>
<h4 id="缓存访问过程-1"><strong>3. 缓存访问过程</strong></h4>
<ol type="1">
<li><strong>主存地址解析：</strong>
<ul>
<li>从主存地址中提取 Tag 和 Word 字段。</li>
<li>Tag 用于标识块，Word 用于选择块中的具体字。</li>
</ul></li>
<li><strong>缓存查找：</strong>
<ul>
<li>将主存地址的 Tag 字段与缓存中所有行的 Tag 逐一比较。</li>
<li>如果找到匹配，则读取对应行中的数据 (命中缓存)。</li>
<li>如果没有匹配，则发生未命中 (Cache Miss)，从主存加载数据到缓存。</li>
</ul></li>
<li><strong>缓存数据存储：</strong>
<ul>
<li>主存块可以存储到缓存中的任意行，位置无固定限制。</li>
</ul></li>
</ol>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123150444248.png" alt="image-20241123150444248">
<figcaption aria-hidden="true">image-20241123150444248</figcaption>
</figure>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123150759599.png" alt="image-20241123150759599">
<figcaption aria-hidden="true">image-20241123150759599</figcaption>
</figure>
<hr>
<h4 id="例子分析-1"><strong>4. 例子分析</strong></h4>
<ul>
<li><strong>条件：</strong>
<ul>
<li>缓存行数：128</li>
<li>主存块数：4096</li>
</ul></li>
<li><strong>特点：</strong>
<ul>
<li>主存地址只需拆分为 <strong>Tag</strong> 和 <strong>Word</strong>
字段：
<ul>
<li>Tag 字段：用于标识 4096 个主存块。</li>
<li>Word 字段：用于定位块内的具体字。</li>
</ul></li>
</ul></li>
</ul>
<hr>
<h4 id="优缺点分析-1"><strong>5. 优缺点分析</strong></h4>
<ul>
<li><strong>优点：</strong>
<ul>
<li><strong>灵活性高：</strong>
每个主存块可以加载到缓存的任意行，避免直接映射中的固定位置问题。</li>
<li>有效减少冲突问题，适合频繁访问不同主存块的场景。</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li><strong>硬件复杂度高：</strong>
<ul>
<li>查找缓存时，需要并行比较所有缓存行的 Tag 字段，电路设计复杂。</li>
<li>查找开销较大，影响性能。</li>
</ul></li>
</ul></li>
</ul>
<h2 id="组相联映射-set-associative-mapping"><strong>组相联映射 (Set
Associative Mapping) </strong></h2>
<hr>
<h4 id="组相联映射概念"><strong>1. 组相联映射概念</strong></h4>
<ul>
<li>结合了直接映射和全相联映射的技术。</li>
<li><strong>缓存划分：</strong>
<ul>
<li>缓存被划分为若干个“组” (Set)，每组包含若干“行” (Line)。</li>
<li>一个主存块 (Block) 可以被映射到一个特定组中的任意行。</li>
<li><strong>示例：</strong>
<ul>
<li>如果缓存的每组有 2 行，则称为 <strong>2 路组相联映射</strong>。</li>
<li>主存块 $ B_j $ 可以位于组 $ S_i $ 中的任意一行。</li>
</ul></li>
</ul></li>
</ul>
<hr>
<h4 id="组相联映射公式"><strong>2. 组相联映射公式</strong></h4>
<ul>
<li>假设缓存有 $ v = 2^d $ 组，每组有 $ k $ 行。
<ul>
<li>缓存总行数：$ m = v k $。</li>
<li>组号计算：$ i = j v $，其中：
<ul>
<li>$ i $ = 缓存组号</li>
<li>$ j $ = 主存块号</li>
<li>$ v $ = 缓存的组数</li>
</ul></li>
</ul></li>
<li><strong>特殊情况：</strong>
<ul>
<li>$ v = m, k = 1 $：直接映射</li>
<li>$ v = 1, k = m $：全相联映射</li>
<li>$ v = m/2, k = 2 $：2 路组相联映射</li>
<li>$ v = m/4, k = 4 $：4 路组相联映射</li>
</ul></li>
</ul>
<hr>
<h4 id="主存地址结构-2"><strong>3. 主存地址结构</strong></h4>
<table>
<thead>
<tr>
<th>字段</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Tag (s-d 位)</strong></td>
<td>标识主存块</td>
</tr>
<tr>
<td><strong>Set (d 位)</strong></td>
<td>指定主存块映射到的缓存组</td>
</tr>
<tr>
<td><strong>Word (w 位)</strong></td>
<td>指定块内的具体字</td>
</tr>
</tbody>
</table>
<ul>
<li>地址分解格式：$ Tag (s-d 位) $ $ Set (d 位) $ $ Word (w 位) $</li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123151402506.png" alt="image-20241123151402506">
<figcaption aria-hidden="true">image-20241123151402506</figcaption>
</figure>
<hr>
<h4 id="缓存访问过程-2"><strong>4. 缓存访问过程</strong></h4>
<ol type="1">
<li><strong>主存地址解析：</strong>
<ul>
<li>提取 <strong>Tag 字段</strong>、<strong>Set 字段</strong> 和
<strong>Word 字段</strong>。</li>
<li>Set 字段用于定位缓存组，Tag 字段用于验证块是否在缓存中。</li>
</ul></li>
<li><strong>查找缓存组：</strong>
<ul>
<li>根据 Set 字段确定具体组。</li>
<li>在该组中查找匹配的 Tag 值。</li>
<li>如果找到匹配，则发生命中 (Cache Hit)，读取数据。</li>
<li>如果未找到匹配，则发生未命中 (Cache
Miss)，需要从主存加载数据到该组。</li>
</ul></li>
<li><strong>数据加载到缓存：</strong>
<ul>
<li>数据从主存加载到对应组中的某行。</li>
<li>如果组已满，则根据替换算法选择一行进行替换。</li>
</ul></li>
</ol>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123151427632.png" alt="image-20241123151427632">
<figcaption aria-hidden="true">image-20241123151427632</figcaption>
</figure>
<hr>
<h4 id="示例"><strong>5. 示例</strong></h4>
<ul>
<li>条件：
<ul>
<li>2 路组相联映射</li>
<li>缓存组数：64 ($ v = 64 $)</li>
<li>主存块号 $ j $ 的组号计算：$ i = j $</li>
</ul></li>
<li>地址分解：
<ul>
<li>主存地址为 16 位：
<ul>
<li>Word 字段：4 位</li>
<li>Set 字段：6 位 ($ _2 64 $)</li>
<li>Tag 字段：$ 16 - 4 - 6 = 6 $ 位</li>
</ul></li>
</ul></li>
</ul>
<hr>
<h4 id="优缺点分析-2"><strong>6. 优缺点分析</strong></h4>
<ul>
<li><strong>优点：</strong>
<ul>
<li><strong>减少冲突问题：</strong>
通过为主存块提供多个存储选择，缓解了直接映射中的冲突问题。</li>
<li><strong>降低硬件复杂度：</strong>
与全相联映射相比，组相联映射的并行匹配硬件成本更低。</li>
</ul></li>
<li><strong>缺点：</strong>
<ul>
<li><strong>标签比较复杂度：</strong>
<ul>
<li>每次访问需要并行比较组中 $ k $ 行的 Tag 值，需要 $ k $
个比较器。</li>
<li>虽然比全相联映射 ($ n $ 个比较器，$ n $ 为缓存总行数)
成本低，但仍高于直接映射 (仅 1 个比较器)。</li>
</ul></li>
<li>硬件设计比直接映射更复杂。</li>
</ul></li>
</ul>
<h2 id="有效位-valid-bit"><strong>有效位 (Valid Bit) </strong></h2>
<hr>
<h4 id="有效位的作用"><strong>1. 有效位的作用</strong></h4>
<ul>
<li>在系统首次上电时，缓存中并没有有效数据。</li>
<li>每个缓存块需要一个<strong>控制位</strong>，通常称为<strong>有效位
(Valid Bit)</strong>，用于指示该块中的数据是否有效。</li>
</ul>
<hr>
<h4 id="有效位的定义"><strong>2. 有效位的定义</strong></h4>
<ul>
<li><strong>0</strong>：表示该缓存块中的数据无效。</li>
<li><strong>1</strong>：表示该缓存块中的数据有效。</li>
</ul>
<hr>
<h4 id="有效位的初始化"><strong>3. 有效位的初始化</strong></h4>
<ul>
<li>当系统上电时：
<ul>
<li>所有缓存块的有效位均设置为 <strong>0</strong>。</li>
<li>表明缓存初始化后不包含任何有效数据。</li>
</ul></li>
<li>当某块数据从主存加载到缓存中时：
<ul>
<li>该块的有效位被设置为
<strong>1</strong>，表示该块的数据现在是有效的。</li>
</ul></li>
</ul>
<hr>
<h4 id="示例-1"><strong>4. 示例</strong></h4>
<ul>
<li>假设缓存初始化时：
<ul>
<li>所有缓存块的有效位为 <strong>0</strong>。</li>
</ul></li>
<li>某次缓存缺失后：
<ul>
<li>主存将对应块数据加载到缓存中。</li>
<li>该缓存块的有效位被设置为 <strong>1</strong>。</li>
</ul></li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123151730569.png" alt="image-20241123151730569">
<figcaption aria-hidden="true">image-20241123151730569</figcaption>
</figure>
<hr>
<h4 id="总结-3"><strong>5. 总结</strong></h4>
<ul>
<li><strong>有效位的主要功能：</strong>
<ul>
<li>用于标记缓存块中数据的有效性。</li>
<li>避免处理无效数据，提高系统可靠性。</li>
</ul></li>
<li><strong>重要性：</strong>
<ul>
<li>在缓存的启动阶段和运行阶段，<strong>有效位</strong>是缓存控制的重要组成部分，保证了缓存数据的准确性和一致性。</li>
</ul></li>
</ul>
<h2 id="替换算法-replacement-algorithms-1"><strong>替换算法 (Replacement
Algorithms) </strong></h2>
<hr>
<h4 id="直接映射缓存-direct-mapped-cache"><strong>1. 直接映射缓存
(Direct Mapped Cache)</strong></h4>
<ul>
<li><strong>没有选择权</strong>：每个主存块只能映射到一个缓存行。</li>
<li><strong>替换策略</strong>：直接替换该缓存行。</li>
</ul>
<hr>
<h4 id="关联映射和集合关联映射缓存-associative-and-set-associative-mapped-cache"><strong>2.
关联映射和集合关联映射缓存 (Associative and Set Associative Mapped
Cache)</strong></h4>
<ul>
<li><strong>硬件实现算法</strong>：由于硬件速度要求，这些替换算法通常由硬件实现。</li>
</ul>
<hr>
<h4 id="替换算法种类"><strong>3. 替换算法种类</strong></h4>
<ul>
<li><strong>LRU（最近最少使用，Least Recently Used）</strong>：
<ul>
<li><strong>替换策略</strong>：替换最长时间没有被访问的块。</li>
<li>适用于当程序的访问模式表现出时间局部性时，优先保留最近访问的数据。</li>
</ul></li>
<li><strong>FIFO（先进先出，First In First Out）</strong>：
<ul>
<li><strong>替换策略</strong>：每当块被访问时，将其推入队列。</li>
<li>替换时，选择队列中最早被访问的块（即队列最前面的块）进行替换。</li>
</ul></li>
<li><strong>随机 (Random)</strong>：
<ul>
<li><strong>替换策略</strong>：随机选择一个块进行替换。</li>
<li>简单但可能不适用于所有情况，适用于硬件实现要求简单快速的场景。</li>
</ul></li>
</ul>
<hr>
<h4 id="总结-4"><strong>4. 总结</strong></h4>
<ul>
<li><strong>直接映射缓存</strong>替换策略最简单，因为每个数据块只能映射到一个缓存行。</li>
<li><strong>关联映射和集合关联映射缓存</strong>使用更复杂的替换算法如
<strong>LRU</strong>、<strong>FIFO</strong> 和
<strong>随机</strong>，这些算法能够在缓存中更高效地选择被替换的数据块，从而优化缓存命中率和性能。</li>
</ul>
<h2 id="映射技术示例-mapping-techniques-example"><strong>映射技术示例
(Mapping Techniques Example) </strong></h2>
<hr>
<h4 id="假设条件"><strong>1. 假设条件</strong></h4>
<ul>
<li>处理器具有分开的指令缓存和数据缓存。</li>
<li>数据缓存只能容纳8个数据块，每个块仅包含一个16位的数据字。</li>
<li>内存是按字地址化的，地址为16位。</li>
<li>使用 <strong>LRU</strong> (最近最少使用) 替换算法。</li>
</ul>
<hr>
<h4 id="问题描述"><strong>2. 问题描述</strong></h4>
<ul>
<li>一个4×10的数组，元素占用一个字，存储在内存地址 <strong>7A00</strong>
到 <strong>7A27</strong>。</li>
<li>数组 <strong>A</strong> 的元素按列顺序存储。</li>
<li>应用程序将数组 <strong>A</strong>
第一行的元素根据该行元素的平均值进行归一化，即： $ A(0,i) $</li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123183837269.png" alt="image-20241123183837269">
<figcaption aria-hidden="true">image-20241123183837269</figcaption>
</figure>
<blockquote>
<p>注意地址一定要看这张图，不能惯性思维的思考存储关系。</p>
</blockquote>
<hr>
<h4 id="代码结构"><strong>3. 代码结构</strong></h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">SUM := 0</span><br><span class="line">for j := 0 to 9 do</span><br><span class="line">    SUM := SUM + A(0,j)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">AVE := SUM / 10</span><br><span class="line"></span><br><span class="line">for i := 9 down to 0 do</span><br><span class="line">    A(0,i) := A(0,i) / AVE</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="直接映射缓存-direct-mapped-cache-1"><strong>4. 直接映射缓存
(Direct Mapped Cache)</strong></h4>
<ul>
<li>内存地址的块映射到特定的缓存行。</li>
<li>缓存替换情况：在执行第二个循环时，8个元素被替换。</li>
<li><strong>数据缓存内容变化</strong>：随着程序的执行，缓存中的元素依次替换。</li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123184036058.png" alt="image-20241123184036058">
<figcaption aria-hidden="true">image-20241123184036058</figcaption>
</figure>
<hr>
<h4 id="关联映射缓存-associative-mapped-cache"><strong>5. 关联映射缓存
(Associative Mapped Cache)</strong></h4>
<ul>
<li>在第二个循环执行过程中，仅替换了2个元素。</li>
<li><strong>数据缓存内容变化</strong>：缓存内容通过对比标签和缓存中的内容来更新，减少了替换的次数。</li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123185043045.png" alt="image-20241123185043045">
<figcaption aria-hidden="true">image-20241123185043045</figcaption>
</figure>
<hr>
<h4 id="集合关联映射缓存-set-associative-mapped-cache"><strong>6.
集合关联映射缓存 (Set Associative Mapped Cache)</strong></h4>
<ul>
<li>在第二个循环执行过程中，6个元素被重新加载到缓存中。</li>
<li><strong>数据缓存内容变化</strong>：相较于直接映射和关联映射，集合关联映射能够更灵活地选择替换的缓存行，减少了缓存失效率。</li>
</ul>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123185131598.png" alt="image-20241123185131598">
<figcaption aria-hidden="true">image-20241123185131598</figcaption>
</figure>
<hr>
<h4 id="映射技术对比"><strong>7. 映射技术对比</strong></h4>
<ul>
<li><strong>直接映射</strong>：每个块只能映射到特定的缓存行，容易导致缓存冲突，性能较低。</li>
<li><strong>关联映射</strong>：允许任何块映射到缓存中的任意位置，灵活但增加了硬件开销。</li>
<li><strong>集合关联映射</strong>：综合了两者的优点，允许每个块映射到多个缓存行中，减少了缓存冲突，性能较好，但硬件实现较复杂。</li>
</ul>
<hr>
<h4 id="总结-5"><strong>总结</strong></h4>
<ul>
<li>在上述例子中，不同的映射技术对数据缓存的影响表现不同，选择合适的映射方式可以优化程序性能，特别是在处理大数据量时，集合关联映射能更好地减少缓存未命中的情况。</li>
</ul>
<h2 id="quiz">Quiz</h2>
<p><strong>问题 1</strong>：<br>
<strong>通过 ____
映射技术，可以将主存块放置到缓存的任何位置。</strong></p>
<p>选项：<br>
A. 直接映射 (Direct)<br>
B. 全关联映射 (Associative)<br>
C. 集合关联映射 (Set Associative)<br>
D. 顺序映射 (Sequential)</p>
<p><strong>答案</strong>：<br>
B. <strong>全关联映射 (Associative)</strong></p>
<ul>
<li><strong>全关联映射</strong>是一种缓存映射技术，在这种方式下，主存的每一个块都可以被放置到缓存中的任何一个位置。它提供最大的灵活性，但也需要更多的硬件支持来查找缓存。</li>
</ul>
<hr>
<p><strong>问题 2</strong>：<br>
<strong>如果一个缓存的容量为 16KB，每个缓存行的长度为 128
字节，且该缓存是 2-way、4-way 或 8-way
集合关联映射，那么该缓存有多少个集合（sets）？</strong></p>
<p>选项：<br>
A. 64, 32, 16<br>
B. 64, 16, 8<br>
C. 32, 16, 8<br>
D. 128, 64, 32</p>
<p><strong>答案</strong>：<br>
A. <strong>64, 32, 16</strong></p>
<ul>
<li>计算过程：
<ul>
<li><strong>缓存总容量</strong> = 16KB = 16 * 1024B = 16384B</li>
<li><strong>每个缓存行的大小</strong> = 128B</li>
<li><strong>缓存行总数</strong> = 16384B / 128B = 128 个缓存行</li>
<li>在 <strong>2-way</strong> 集合关联映射下，每个集合包含 2
个缓存行，因此缓存有 128 / 2 = 64 个集合。</li>
<li>在 <strong>4-way</strong> 集合关联映射下，每个集合包含 4
个缓存行，因此缓存有 128 / 4 = 32 个集合。</li>
<li>在 <strong>8-way</strong> 集合关联映射下，每个集合包含 8
个缓存行，因此缓存有 128 / 8 = 16 个集合。</li>
</ul></li>
</ul>
<h3 id="精华所在-1">精华所在：</h3>
<ul>
<li><strong>全关联映射</strong>：每个主存块可以映射到缓存的任意位置，提供最大的灵活性，但查找和管理更复杂。</li>
<li><strong>集合关联映射</strong>：缓存被分成多个集合，每个集合包含多个缓存行，具体映射到哪个行取决于设置的方式，如
2-way、4-way 或 8-way 集合关联映射。</li>
</ul>
<p><strong>问题 3</strong>：<br>
<strong>一个集合关联缓存总共有 64 个块，分为 4 个块集合。主存包含 4096
个块，每个块包含 128 个字。主存地址需要多少位？</strong></p>
<p>选项：<br>
A. 21<br>
B. 24<br>
C. 19<br>
D. 32</p>
<p><strong>答案</strong>：<br>
C. <strong>19</strong></p>
<ul>
<li><strong>计算过程</strong>：
<ul>
<li>主存总共有 <strong>4096</strong> 个块，需要 <strong>12 位</strong>
来指定块地址（$ _2 4096 = 12 $）。</li>
<li>每个块包含 <strong>128 个字</strong>，需要 <strong>7 位</strong>
来指定字地址（$ _2 128 = 7 $）。</li>
<li>所以，主存地址总共有 <strong>12 + 7 = 19 位</strong>。</li>
</ul></li>
</ul>
<h3 id="精华所在-2">精华所在：</h3>
<ul>
<li><strong>主存地址</strong>：由块地址和字地址组成。块地址指定主存中块的位置，字地址指定块内字的位置。</li>
<li><strong>19 位地址</strong>：表示需要 <strong>12 位</strong> 来表示
4096 个块，和 <strong>7 位</strong> 来表示每个块内 128
个字的字地址。</li>
</ul>
<hr>
<p><strong>问题 4</strong>：<br>
<strong>一个集合关联缓存总共有 64 个块，分为 4 个块集合。主存包含 4096
个块，每个块包含 128 个字。每个地址中的 TAG、SET 和 WORD
字段各需要多少位？</strong></p>
<p>选项：<br>
A. 2, 5, 12<br>
B. 12, 2, 5<br>
C. 4, 8, 7<br>
D. 8, 4, 7</p>
<p><strong>答案</strong>：<br>
D. <strong>8, 4, 7</strong></p>
<ul>
<li><strong>计算过程</strong>：
<ul>
<li>主存地址总共有 <strong>19 位</strong>（如问题 3 所计算）。</li>
<li><strong>WORD</strong> 字段：每个块包含 128 个字，因此需要 <strong>7
位</strong> 来表示字地址。</li>
<li><strong>SET</strong> 字段：缓存总共有 64 个块，分为 4 个块集合，即有
<strong>16 个集合</strong>（$ = 16 <span class="math inline">\(）。所以需要 **4 位** 来表示集合地址（\)</span> _2
16 = 4 $）。</li>
<li><strong>TAG</strong> 字段：剩余的位数就是 TAG 字段，即 <strong>19 -
7 - 4 = 8 位</strong>。</li>
</ul></li>
</ul>
<h3 id="精华所在-3">精华所在：</h3>
<ul>
<li><strong>TAG 字段</strong>：用于标识缓存中的块。</li>
<li><strong>SET 字段</strong>：用于标识缓存中具体的集合。</li>
<li><strong>WORD 字段</strong>：表示块内字的偏移。</li>
</ul>
<p><strong>问题 5</strong>：<br>
<strong>直接映射的优缺点是什么？</strong></p>
<p><strong>答案</strong>：</p>
<ul>
<li><strong>优点</strong>：
<ol type="1">
<li><strong>简单，易于实现</strong>：直接映射是最简单的缓存映射方式，每个主存块映射到缓存中固定的一个位置，设计和实现都很直接。</li>
<li><strong>成本低</strong>：由于映射方式简单，硬件实现也较为便宜。</li>
</ol></li>
<li><strong>缺点</strong>：
<ol type="1">
<li><strong>固定位置</strong>：每个主存块只能映射到缓存中的一个固定位置，这样可能会导致缓存冲突，如果多个块映射到相同的缓存位置，则会发生替换，导致缓存效率下降。</li>
</ol></li>
</ul>
<h3 id="精华所在-4">精华所在：</h3>
<ul>
<li><strong>直接映射</strong>：每个主存块通过一个映射函数直接映射到缓存中某个固定位置，因此映射方式简单，硬件实现成本低。</li>
<li><strong>优点</strong>：简单、易实现、成本低。</li>
<li><strong>缺点</strong>：固定映射位置，可能导致缓存冲突和性能下降。</li>
</ul>
<hr>
<p><strong>问题 6</strong>：<br>
<strong>关联映射的优缺点是什么？</strong></p>
<p><strong>答案</strong>：</p>
<ul>
<li><strong>优点</strong>：
<ol type="1">
<li><strong>完全自由的缓存位置选择</strong>：关联映射允许主存块映射到缓存中的任意位置，因此相比于直接映射，它能够提供更灵活的缓存管理，减少缓存冲突的概率。</li>
</ol></li>
<li><strong>缺点</strong>：
<ol type="1">
<li><strong>复杂的电路</strong>：由于需要同时检查缓存中所有块的标签，因此关联映射需要更复杂的电路和更多的硬件资源来进行标签比较，这增加了硬件的复杂性和成本。</li>
</ol></li>
</ul>
<h3 id="精华所在-5">精华所在：</h3>
<ul>
<li><strong>关联映射</strong>：缓存块的位置可以根据需要自由选择，不需要固定位置，能有效减少缓存冲突。</li>
<li><strong>优点</strong>：灵活的缓存位置选择，减少冲突。</li>
<li><strong>缺点</strong>：硬件实现复杂，增加电路和资源需求。</li>
</ul>
<h2 id="写入策略">写入策略</h2>
<h3 id="section">(1)</h3>
<p><strong>写命中 (Write Hit)</strong></p>
<ul>
<li><strong>写直达 (Write Through)</strong>
<ul>
<li><strong>定义</strong>：缓存位置和主存位置同时更新。</li>
<li><strong>优点</strong>：
<ul>
<li>保证缓存和主存的数据一致性。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>所有写操作都需要访问主存（总线事务），增加了系统开销。</li>
<li>如果后续有读请求需要访问主存（因为缓存未命中），则必须等待之前的写操作完成，造成延迟。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="section-1">(2)</h3>
<ul>
<li><strong>写回 (Write Back)</strong>
<ul>
<li><strong>定义</strong>：只更新缓存位置，并通过附加的标志位（脏位）标记缓存为已修改。当该缓存块被替换时，再将主存中的数据更新。</li>
<li><strong>脏位</strong>：
<ul>
<li>0：未修改<br>
</li>
<li>1：已修改（脏）</li>
</ul></li>
</ul></li>
</ul>
<h3 id="section-2">(3)</h3>
<p><strong>写命中 (继续)</strong></p>
<ul>
<li><strong>写回 (继续)</strong>
<ul>
<li><strong>优点</strong>：
<ul>
<li>比写直达更快，因为不需要每次访问主存。</li>
<li>如果一个块内有多个字需要写入，只需要在主存中进行一次写操作。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>主存中部分数据可能变得无效，因此通过 I/O
模块的访问只能通过缓存进行。</li>
<li>需要在缓存中增加额外的位来标记哪些块已修改，这会增加缓存的大小。</li>
</ul></li>
</ul></li>
</ul>
<h3 id="section-3">(4)</h3>
<p><strong>写未命中 (Write Miss)</strong></p>
<ul>
<li><strong>无写分配 (No Write Allocate)</strong>
<ul>
<li><strong>定义</strong>：在写直达缓存中，信息直接写入主存，而不会加载到缓存中。</li>
</ul></li>
<li><strong>写分配 (Write Allocate)</strong>
<ul>
<li><strong>定义</strong>：在写回缓存中，首先将包含目标字的块加载到缓存中，然后在缓存中的相应位置进行写入。</li>
</ul></li>
</ul>
<h3 id="总结-6">总结：</h3>
<ul>
<li><strong>写直达</strong>：每次写操作都会同步更新缓存和主存，保证数据一致性，但会增加系统开销。</li>
<li><strong>写回</strong>：仅更新缓存，减少主存访问，提高效率，但需要额外的脏位标记，且可能导致部分主存数据无效。</li>
<li><strong>写未命中</strong>：直接写入主存，不加载到缓存中；写分配则将数据块加载到缓存后再写入。</li>
</ul>
<h2 id="缓存命中率-cache-hit-rate">缓存命中率 (Cache Hit Rate)</h2>
<ol type="1">
<li><p><strong>命中率 (Hit Rate)</strong></p>
<ul>
<li><strong>定义</strong>：命中率是所有访问中命中的次数占总访问次数的比例。<br>
</li>
<li><strong>公式</strong>： $ H = $
<ul>
<li><span class="math inline">\(H\)</span>：缓存命中率</li>
<li><span class="math inline">\(N_c\)</span>：访问缓存成功的次数</li>
<li><span class="math inline">\(N_m\)</span>：访问主存的次数<br>
</li>
<li>总的访问次数为 <span class="math inline">\(N_c +
N_m\)</span>，因此缓存未命中率为 <span class="math inline">\(1 -
H\)</span>。</li>
</ul></li>
</ul></li>
<li><p><strong>平均访问时间 (Average Access Time)</strong></p>
<ul>
<li><strong>定义</strong>：平均访问时间是处理器访问数据时所经历的平均时间，考虑了命中和未命中的情况。<br>
</li>
<li><strong>公式</strong>： $ t_{ave} = H t_c + (1 - H) t_m $
<ul>
<li><span class="math inline">\(t_{ave}\)</span>：平均访问时间</li>
<li><span class="math inline">\(H\)</span>：命中率</li>
<li><span class="math inline">\(t_c\)</span>：缓存访问时间</li>
<li><span class="math inline">\(t_m\)</span>：主存访问时间<br>
</li>
</ul></li>
<li><strong>例子</strong>：假设主存访问时间为70ns，缓存访问时间为10ns，命中率为90%。
<ul>
<li>平均访问时间： $ 0.9 + (1 - 0.9) = 9 + 7 = 16ns $</li>
<li>可以看到，缓存大大提高了访问速度。</li>
</ul></li>
</ul></li>
<li><p><strong>例子：访问延迟计算</strong></p>
<ul>
<li>假设缓存和主存的访问时间分别为 $ $ 和 $
10$，当缓存未命中时，将会加载一个包含8个字的数据块到缓存中。<br>
</li>
<li>访问延迟计算：
<ul>
<li>初次访问延迟： $ $（缓存未命中时的延迟）</li>
<li>数据块加载后，另一个延迟 $ $ 用于将数据传送给处理器<br>
</li>
<li>总延迟：<br>
$ + 10+ 7+ = 19 $</li>
</ul></li>
</ul></li>
<li><p><strong>命中率改进计算</strong></p>
<ul>
<li><p>假设程序中的30%指令涉及读写操作（即每100条指令有130次内存访问），且缓存中指令和数据的命中率分别为95%和90%。</p></li>
<li><p>改进计算： <span class="math display">\[
\text{未使用缓存的时间} - \text{使用缓存的时间} = 130 \times 10\tau /
100 \times (0.95\tau + 0.05 \times 19\tau) + 30 \times (0.9\tau + 0.1
\times 19\tau) = 4.7\tau
\]</span></p></li>
<li><p>结果表明，使用缓存能显著提高性能。</p></li>
</ul></li>
</ol>
<ul>
<li><strong>命中率</strong>是衡量缓存有效性的一个重要指标，决定了缓存的访问效率。</li>
<li><strong>平均访问时间</strong>考虑了缓存命中与未命中的影响，缓存命中率越高，平均访问时间越短。</li>
<li><strong>未命中延迟</strong>取决于加载数据块到缓存的过程，并且随着数据块大小增加，延迟也会增加。</li>
<li>通过提高缓存命中率，系统性能可以大幅提升，减少主存访问的次数。</li>
</ul>
<h2 id="多级缓存-multi-level-cache"><strong>多级缓存 (Multi-level
Cache)</strong></h2>
<ol type="1">
<li><strong>多级缓存层次结构</strong>
<ul>
<li>现代系统通常采用多级缓存体系结构。</li>
<li>各级缓存形成自己的小型内存层次。</li>
<li><strong>指令缓存与数据缓存</strong>：
<ul>
<li><strong>统一缓存</strong>：指令和数据都缓存的缓存结构。</li>
<li><strong>数据和指令分开缓存</strong>：为了避免过多的缓存未命中，现代系统通常将数据和指令缓存分开。</li>
<li><strong>优点</strong>：分开缓存减少了访问的随机性和增加了访问的聚集性，通常比统一缓存的访问时间更短。</li>
</ul></li>
</ul></li>
<li><strong>一级缓存（L1）与二级缓存（L2）</strong>
<ul>
<li><strong>一级缓存 (L1)</strong>：
<ul>
<li>通常位于CPU核心内。</li>
<li>通常分为指令缓存和数据缓存。</li>
<li>大小较小，通常为8KB到128KB。</li>
<li>访问时间通常为4ns左右。</li>
</ul></li>
<li><strong>二级缓存 (L2)</strong>：
<ul>
<li>位于CPU核心外。</li>
<li>比一级缓存大，通常为256KB到几MB。</li>
<li>通过高速总线与CPU连接，访问时间通常为15-20ns。</li>
<li>通常是统一缓存。</li>
</ul></li>
</ul></li>
<li><strong>平均访问时间 (Average Access Time)</strong>
<ul>
<li>假设：
<ul>
<li>$ h_1 $ 是一级缓存的命中率。</li>
<li>$ h_2 $ 是二级缓存的命中率。</li>
<li>$ C_1 $ 是访问一级缓存所需的时间。</li>
<li>$ C_2 $
是将信息从二级缓存传输到一级缓存的延迟（未命中的惩罚）。</li>
<li>$ M $ 是将信息从主存传输到二级缓存的延迟。</li>
</ul></li>
<li>平均访问时间公式为： $ t_{} = h_1 C_1 + (1 - h_1) (h_2 C_2 + (1 -
h_2) M) $</li>
</ul></li>
<li><strong>商用处理器中的缓存示例</strong>
<ul>
<li><strong>Intel缓存发展史</strong>：
<ul>
<li><strong>80386</strong>：没有片上缓存，外部缓存。</li>
<li><strong>80486</strong>：片上L1缓存，大小为8KB，使用16字节行和4路组相联组织；外部有L2缓存。</li>
<li><strong>Pentium</strong>（所有版本）：有两个片上L1缓存（分别用于数据和指令）。</li>
<li><strong>Pentium II</strong>：片上有L2缓存。</li>
<li><strong>Pentium III</strong>：添加了片外L3缓存。</li>
</ul></li>
</ul></li>
<li><strong>Intel缓存演变过程</strong>：
<ul>
<li><strong>问题与解决方案</strong>：
<ul>
<li><strong>问题</strong>：外部内存比系统总线慢。
<ul>
<li><strong>解决方案</strong>：增加外部缓存，使用更快的内存技术。</li>
<li><strong>首次出现于处理器</strong>：386。</li>
</ul></li>
<li><strong>问题</strong>：处理器速度提高导致外部总线成为缓存访问瓶颈。
<ul>
<li><strong>解决方案</strong>：将外部缓存移至片上，与处理器同步运行。</li>
<li><strong>首次出现于处理器</strong>：486。</li>
</ul></li>
<li><strong>问题</strong>：内部缓存较小，受芯片空间限制。
<ul>
<li><strong>解决方案</strong>：增加外部L2缓存，使用比主存更快的技术。</li>
<li><strong>首次出现于处理器</strong>：486。</li>
</ul></li>
<li><strong>问题</strong>：指令预取器和执行单元同时访问缓存时发生竞争。
<ul>
<li><strong>解决方案</strong>：创建分离的数据和指令缓存。</li>
<li><strong>首次出现于处理器</strong>：Pentium。</li>
</ul></li>
<li><strong>问题</strong>：处理器速度提高导致外部总线成为L2缓存访问瓶颈。
<ul>
<li><strong>解决方案</strong>：创建独立的背面总线（BSB），运行速度比前端总线更快，专门用于L2缓存。</li>
<li><strong>首次出现于处理器</strong>：Pentium Pro。</li>
</ul></li>
<li><strong>问题</strong>：一些应用需要快速访问大量数据，片上缓存过小。
<ul>
<li><strong>解决方案</strong>：增加外部L3缓存。</li>
<li><strong>首次出现于处理器</strong>：Pentium III。</li>
</ul></li>
<li><strong>问题</strong>：将L3缓存移至片上，进一步提高性能。
<ul>
<li><strong>首次出现于处理器</strong>：Pentium 4。</li>
</ul></li>
</ul></li>
</ul></li>
</ol>
<h2 id="测验">测验</h2>
<h3 id="缓存机制的有效性与计算机程序的属性"><strong>缓存机制的有效性与计算机程序的属性</strong></h3>
<h4 id="缓存机制的有效性基于计算机程序的哪个属性"><strong>缓存机制的有效性基于计算机程序的哪个属性？</strong></h4>
<ul>
<li><strong>答案：B. locality of reference（局部性原理）</strong>
<ul>
<li>缓存机制的有效性主要依赖于程序的局部性原理，即程序通常会在时间上或空间上访问相近的内存位置，缓存可以利用这一点提高效率。</li>
</ul></li>
</ul>
<h4 id="以下哪个管理缓存与主存之间数据的传输"><strong>以下哪个管理缓存与主存之间数据的传输？</strong></h4>
<ul>
<li><strong>答案：D. hardware（硬件）</strong>
<ul>
<li>缓存和主存之间的数据传输完全由硬件管理，硬件负责将数据从主存加载到缓存以及缓存中的数据写回主存。</li>
</ul></li>
</ul>
<h3 id="精华所在-6">精华所在：</h3>
<ol type="1">
<li><p><strong>局部性原理</strong>：缓存有效性的一个关键因素是局部性原理。程序在运行时往往会多次访问相同的内存位置（时间局部性）或相邻的内存位置（空间局部性）。缓存利用这种访问模式，通过存储频繁访问的数据来减少访问主存的次数，从而提高系统性能。</p></li>
<li><p><strong>硬件管理缓存与主存之间的数据传输</strong>：缓存和主存之间的数据传输通常由硬件自动管理，不需要操作系统或编译器干预。硬件负责判断是否发生缓存命中或未命中，并在未命中时自动将数据从主存加载到缓存，或将修改后的数据从缓存写回主存。</p></li>
</ol>
<h3 id="缓存系统问题解答"><strong>缓存系统问题解答：</strong></h3>
<h4 id="如果缓存的缓存行大小为64字节而主存对每个内存请求的响应时间为20个周期每次返回2字节数据那么从主存获取一个缓存行需要多少个周期"><strong>如果缓存的缓存行大小为64字节，而主存对每个内存请求的响应时间为20个周期，每次返回2字节数据，那么从主存获取一个缓存行需要多少个周期？</strong></h4>
<ul>
<li><strong>答案：C. 640</strong></li>
<li><strong>解释</strong>：主存每次返回2字节数据，因此需要进行64字节的请求，计算过程如下：
$ = 640 $ 即需要640个周期来从主存获取一个64字节的缓存行。</li>
</ul>
<h4 id="在缓存系统中当一个块需要被覆盖时最好覆盖那个最长时间没有被引用的块这种技术称为____替换算法">**在缓存系统中，当一个块需要被覆盖时，最好覆盖那个最长时间没有被引用的块。这种技术称为____替换算法。**</h4>
<ul>
<li><strong>答案：D. LRU（最近最少使用）</strong></li>
<li><strong>解释</strong>：LRU（Least Recently
Used）算法是一种替换策略，它会选择那个在缓存中最长时间没有被访问过的块进行替换，以优化缓存的命中率。该算法基于假设：如果一个块在最近没有被访问过，那么未来也不太可能被访问。</li>
</ul>
<h3 id="精华所在-7">精华所在：</h3>
<ol type="1">
<li><p><strong>缓存行的获取时间</strong>：缓存行大小和主存的响应时间直接影响获取缓存行的总时间。在此题中，每次从主存读取2字节，64字节的缓存行需要32次读取，每次读取需要20个周期，因此总时间为640个周期。</p></li>
<li><p><strong>LRU替换算法</strong>：LRU（最近最少使用）替换算法是缓存替换策略之一，它选择在缓存中最长时间未被访问的数据块进行替换。这种方法基于局部性原理，假设最近未被使用的数据未来也不太可能再被使用。</p></li>
</ol>
<h4 id="在直接映射缓存中当需要从缓存中驱逐一条缓存行以腾出空间时使用随机替换策略是合理的吗"><strong>在直接映射缓存中，当需要从缓存中驱逐一条缓存行以腾出空间时，使用随机替换策略是合理的吗？</strong></h4>
<ul>
<li><strong>答案：False</strong></li>
<li><strong>解释</strong>：在直接映射缓存（Direct Mapped
Cache）中，每个内存块只能映射到缓存中的唯一位置。因此，当需要替换数据时，并没有选择驱逐哪个缓存行的余地，必须替换掉映射到相同位置的缓存行。因此，不涉及随机替换策略。</li>
</ul>
<h4 id="在写操作中缓存位置和主存位置同时更新这种技术被称为写直通write-through协议"><strong>在写操作中，缓存位置和主存位置同时更新。这种技术被称为写直通（Write
Through）协议。</strong></h4>
<ul>
<li><strong>答案：True</strong></li>
<li><strong>解释</strong>：写直通（Write
Through）是一种缓存写策略。在这种策略中，每当缓存被更新时，主存中的对应位置也会同步更新。这种方法的优点是缓存与主存始终保持一致，但缺点是每次写操作都会访问主存，可能导致较大的性能开销。</li>
</ul>
<hr>
<h3 id="精华所在-8"><strong>精华所在：</strong></h3>
<h4 id="直接映射缓存中的替换策略"><strong>直接映射缓存中的替换策略：</strong></h4>
<ol type="1">
<li><strong>直接映射特点</strong>：
<ul>
<li>每个内存块只能映射到缓存中的一个固定位置。</li>
<li>因此，当发生替换时，并不需要选择替换策略，因为被替换的块是唯一确定的。</li>
</ul></li>
<li><strong>无需随机替换</strong>：
<ul>
<li>直接映射缓存并不使用随机替换策略。</li>
<li>替换的块是新数据映射到的固定位置的旧数据。</li>
</ul></li>
</ol>
<hr>
<h4 id="写直通write-through协议"><strong>写直通（Write
Through）协议：</strong></h4>
<ol type="1">
<li><strong>写直通操作机制</strong>：
<ul>
<li>写操作时，缓存和主存同步更新。</li>
<li>保证缓存和主存数据一致性。</li>
</ul></li>
<li><strong>优点</strong>：
<ul>
<li>简化了数据一致性问题。</li>
<li>特别适合频繁读取而不频繁写入的场景。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li>写操作性能较低，因为每次写操作都会访问主存。</li>
<li>相比写回（Write Back）策略，开销更大。</li>
</ul></li>
</ol>
<h3 id="写直通write-through策略的优缺点"><strong>写直通（Write
Through）策略的优缺点</strong></h3>
<h4 id="优点advantage"><strong>优点（Advantage）：</strong></h4>
<ol type="1">
<li><strong>数据一致性（Consistency）</strong>：
<ul>
<li>写操作时，缓存和主存会同步更新，始终保持数据一致。</li>
<li>适合需要高数据可靠性的场景，减少数据一致性管理的复杂性。</li>
</ul></li>
</ol>
<h4 id="缺点disadvantages"><strong>缺点（Disadvantages）：</strong></h4>
<ol type="1">
<li><strong>主存访问开销大（High Overhead of Main Memory
Access）</strong>：
<ul>
<li>每次写操作都需要访问主存，增加了总的写延迟。</li>
<li>主存访问需要通过总线（Bus Transaction），进一步降低性能。</li>
</ul></li>
<li><strong>系统性能下降（Performance Impact）</strong>：
<ul>
<li>如果缓存未命中且主存正在处理写请求，其他读请求需要等待写操作完成，可能导致系统整体性能下降。</li>
<li>与写回策略相比，频繁写操作的性能会显著受限。</li>
</ul></li>
</ol>
<hr>
<h3 id="精华所在-9"><strong>精华所在</strong></h3>
<h4 id="写直通write-through策略"><strong>写直通（Write
Through）策略</strong></h4>
<ol type="1">
<li><strong>特点</strong>：
<ul>
<li>写操作直接更新缓存和主存。</li>
<li>数据在缓存和主存中始终一致。</li>
</ul></li>
<li><strong>优点</strong>：
<ul>
<li>保证缓存和主存的数据一致性，无需额外机制管理一致性。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li><strong>高延迟</strong>：每次写入都需要同时更新主存，增加了写延迟。</li>
<li><strong>性能降低</strong>：缓存未命中时，主存写入会阻塞后续内存访问操作。</li>
</ul></li>
</ol>
<h3 id="写回write-back策略的优缺点"><strong>写回（Write
Back）策略的优缺点</strong></h3>
<h4 id="优点advantages"><strong>优点（Advantages）：</strong></h4>
<ol type="1">
<li><strong>速度更快（Faster Write Operations）：</strong>
<ul>
<li>数据只更新缓存，不立即写入主存，减少了主存的访问次数。</li>
<li>避免了每次写操作都占用总线带宽。</li>
</ul></li>
<li><strong>批量写入（Efficient for Multiple Writes）：</strong>
<ul>
<li>对缓存块中多个字的写操作可以合并为一次写回主存，减少了总的主存写入次数，提高效率。</li>
</ul></li>
</ol>
<hr>
<h4 id="缺点disadvantages-1"><strong>缺点（Disadvantages）：</strong></h4>
<ol type="1">
<li><strong>主存数据失效（Main Memory Inconsistency）：</strong>
<ul>
<li>缓存块未写回之前，主存中的数据是无效的。</li>
<li>这种情况下，I/O模块只能通过缓存访问数据，增加了数据访问的复杂性。</li>
</ul></li>
<li><strong>额外标记位（Additional Overhead）：</strong>
<ul>
<li>每个缓存块需要额外的标记位（脏位或修改位）来记录缓存块是否已被修改。</li>
<li>这增加了缓存的存储开销。</li>
</ul></li>
</ol>
<hr>
<h3 id="精华所在-10"><strong>精华所在</strong></h3>
<h4 id="写回write-back策略"><strong>写回（Write Back）策略</strong></h4>
<ol type="1">
<li><strong>特点</strong>：
<ul>
<li>写操作仅更新缓存，只有当缓存块被替换时，才将数据写回主存。</li>
<li>使用<strong>脏位（Dirty Bit）</strong>标记缓存块是否已被修改。</li>
</ul></li>
<li><strong>优点</strong>：
<ul>
<li><strong>性能高</strong>：减少了主存访问次数，写操作速度快。</li>
<li><strong>支持批量写入</strong>：同一块的多次写操作只需一次主存更新。</li>
</ul></li>
<li><strong>缺点</strong>：
<ul>
<li><strong>主存数据一致性问题</strong>：主存数据可能失效，I/O模块无法直接读取最新数据。</li>
<li><strong>硬件复杂度增加</strong>：需要额外的脏位，增加了缓存设计和管理的复杂性。</li>
</ul></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.totorocatcat.top/">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/Chapter%208%20Cache(6)/">http://totorocatcat.top/Chapter%208%20Cache(6)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/3805be3cc551f555d99699629220d71.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/Chapter%208%20Cache(7)/" title="Chapter 8 Cache(7)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/2ef847e0b7524acf0407d9664f8d873.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Chapter 8 Cache(7)</div></div></a></div><div class="next-post pull-right"><a href="/Chapter%208%20Cache(5)/" title="Chapter 8 Cache(5)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/604a9c701310585e293093d827dd202.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Chapter 8 Cache(5)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2010%E5%B9%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%9F%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="2010年计算机统考-数据结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/e345af5b515d2f76bb44fdaa6eff3db4d6f598d3.jpg@1256w_908h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-04</div><div class="title">2010年计算机统考-数据结构</div></div></a></div><div><a href="/2011%E5%B9%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%9F%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86/" title="2011年计算机统考-数据结构部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/e345af5b515d2f76bb44fdaa6eff3db4d6f598d3.jpg@1256w_908h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="title">2011年计算机统考-数据结构部分</div></div></a></div><div><a href="/2012%E5%B9%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%9F%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86/" title="2012年计算机统考-数据结构部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/e345af5b515d2f76bb44fdaa6eff3db4d6f598d3.jpg@1256w_908h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="title">2012年计算机统考-数据结构部分</div></div></a></div><div><a href="/2022%E5%B9%B4C-%E8%AF%95%E5%8D%B7%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2/" title="2022年C++试卷软件学院"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_80.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-16</div><div class="title">2022年C++试卷软件学院</div></div></a></div><div><a href="/2022C-%E8%AF%95%E5%8D%B7/" title="2022C++试卷"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_80.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-16</div><div class="title">2022C++试卷</div></div></a></div><div><a href="/AJAX%E5%9F%BA%E7%A1%80/" title="AJAX基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_169_2560x1440_96_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-16</div><div class="title">AJAX基础</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%BE%A0%E5%AE%A2-%E6%AD%A6%E4%BE%A0%E5%9C%BA%E6%99%AF-%E6%B8%B8%E6%88%8F.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description">热爱文学的SCUT软件学院学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">859</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div><a id="card-info-btn" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-8-cache6"><span class="toc-text">Chapter 8 Cache(6)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#lecture-contents-%E4%B8%AD%E8%8B%B1%E5%AF%B9%E7%85%A7%E8%A1%A8"><span class="toc-text">Lecture Contents 中英对照表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%9B%AE%E7%9A%84"><span class="toc-text">高速缓存存储器的目的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%80%A7%E8%83%BD%E5%B7%AE%E8%B7%9D"><span class="toc-text">问题：性能差距</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-text">解决方案：高速缓存存储器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-text">目的</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E5%92%8C%E4%B8%BB%E5%AD%98%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-text">高速缓存和主存系统的组织</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%8E%E4%B8%BB%E5%AD%98%E7%9A%84%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-text">高速缓存与主存的组织结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%B8%AD%E4%B8%8E%E6%9C%AA%E5%91%BD%E4%B8%AD-hit-and-miss"><span class="toc-text">命中与未命中 (Hit and Miss)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%B8%AD-hit"><span class="toc-text">命中 (Hit)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E5%91%BD%E4%B8%AD-miss"><span class="toc-text">未命中 (Miss)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%BD%E4%B8%AD%E7%8E%87-hit-rate"><span class="toc-text">命中率 (Hit Rate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E5%91%BD%E4%B8%AD%E7%8E%87-miss-rate"><span class="toc-text">未命中率 (Miss Rate)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C-cache-read-operation"><span class="toc-text">高速缓存读取操作 (Cache
Read Operation)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AF%BB%E5%8F%96%E6%93%8D%E4%BD%9C%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-text">缓存读取操作的基本流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E8%AF%BB%E5%8F%96%E8%AF%B7%E6%B1%82-processor-read-request"><span class="toc-text">处理器的读取请求
(Processor: Read Request)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9C%AA%E5%91%BD%E4%B8%AD-cache-read-miss"><span class="toc-text">缓存未命中 (Cache Read
Miss)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E9%97%AE%E9%A2%98-cache-design-issues"><span class="toc-text">高速缓存设计问题 (Cache
Design Issues)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%B9%E6%A1%88-cache-mapping-schemes"><span class="toc-text">1. 缓存映射方案
(Cache Mapping Schemes)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%9D%97%E6%A0%87%E8%AF%86-block-identification"><span class="toc-text">2. 数据块标识 (Block
Identification)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95-replacement-algorithms"><span class="toc-text">3. 替换算法
(Replacement Algorithms)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E7%AD%96%E7%95%A5-write-policy"><span class="toc-text">4. 写策略 (Write
Policy)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8"><span class="toc-text">精华所在</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E6%96%B9%E6%A1%88-mapping-scheme"><span class="toc-text">映射方案 (Mapping Scheme)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E6%96%B9%E6%A1%88%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">1. 映射方案的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E4%B8%BB%E8%A6%81%E6%98%A0%E5%B0%84%E6%96%B9%E6%A1%88"><span class="toc-text">2. 三种主要映射方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%81%87%E8%AE%BE"><span class="toc-text">3. 基本假设</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84-direct-mapping"><span class="toc-text">直接映射 (Direct Mapping)
</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 直接映射概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%A1%8C%E5%88%86%E9%85%8D%E8%A1%A8"><span class="toc-text">2. 缓存行分配表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84"><span class="toc-text">3. 主存地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B"><span class="toc-text">4. 缓存访问过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E5%88%86%E6%9E%90"><span class="toc-text">5. 例子分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-text">6. 优缺点分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84-associative-mapping"><span class="toc-text">全相联映射 (Associative
Mapping) </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A8%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 全相联映射概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84-1"><span class="toc-text">2. 主存地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B-1"><span class="toc-text">3. 缓存访问过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%E5%88%86%E6%9E%90-1"><span class="toc-text">4. 例子分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90-1"><span class="toc-text">5. 优缺点分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84-set-associative-mapping"><span class="toc-text">组相联映射 (Set
Associative Mapping) </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 组相联映射概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E7%9B%B8%E8%81%94%E6%98%A0%E5%B0%84%E5%85%AC%E5%BC%8F"><span class="toc-text">2. 组相联映射公式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84-2"><span class="toc-text">3. 主存地址结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AE%BF%E9%97%AE%E8%BF%87%E7%A8%8B-2"><span class="toc-text">4. 缓存访问过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-text">5. 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90-2"><span class="toc-text">6. 优缺点分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E4%BD%8D-valid-bit"><span class="toc-text">有效位 (Valid Bit) </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E4%BD%8D%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">1. 有效位的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E4%BD%8D%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">2. 有效位的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%95%88%E4%BD%8D%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">3. 有效位的初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">4. 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">5. 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95-replacement-algorithms-1"><span class="toc-text">替换算法 (Replacement
Algorithms) </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E7%BC%93%E5%AD%98-direct-mapped-cache"><span class="toc-text">1. 直接映射缓存
(Direct Mapped Cache)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84%E5%92%8C%E9%9B%86%E5%90%88%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84%E7%BC%93%E5%AD%98-associative-and-set-associative-mapped-cache"><span class="toc-text">2.
关联映射和集合关联映射缓存 (Associative and Set Associative Mapped
Cache)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95%E7%A7%8D%E7%B1%BB"><span class="toc-text">3. 替换算法种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">4. 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E6%8A%80%E6%9C%AF%E7%A4%BA%E4%BE%8B-mapping-techniques-example"><span class="toc-text">映射技术示例
(Mapping Techniques Example) </span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E6%9D%A1%E4%BB%B6"><span class="toc-text">1. 假设条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-text">2. 问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-text">3. 代码结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E7%BC%93%E5%AD%98-direct-mapped-cache-1"><span class="toc-text">4. 直接映射缓存
(Direct Mapped Cache)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84%E7%BC%93%E5%AD%98-associative-mapped-cache"><span class="toc-text">5. 关联映射缓存
(Associative Mapped Cache)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%85%B3%E8%81%94%E6%98%A0%E5%B0%84%E7%BC%93%E5%AD%98-set-associative-mapped-cache"><span class="toc-text">6.
集合关联映射缓存 (Set Associative Mapped Cache)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84%E6%8A%80%E6%9C%AF%E5%AF%B9%E6%AF%94"><span class="toc-text">7. 映射技术对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#quiz"><span class="toc-text">Quiz</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8-1"><span class="toc-text">精华所在：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8-2"><span class="toc-text">精华所在：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8-3"><span class="toc-text">精华所在：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8-4"><span class="toc-text">精华所在：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8-5"><span class="toc-text">精华所在：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E7%AD%96%E7%95%A5"><span class="toc-text">写入策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#section"><span class="toc-text">(1)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#section-1"><span class="toc-text">(2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#section-2"><span class="toc-text">(3)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#section-3"><span class="toc-text">(4)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%91%BD%E4%B8%AD%E7%8E%87-cache-hit-rate"><span class="toc-text">缓存命中率 (Cache Hit Rate)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98-multi-level-cache"><span class="toc-text">多级缓存 (Multi-level
Cache)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8B%E9%AA%8C"><span class="toc-text">测验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-text">缓存机制的有效性与计算机程序的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E7%9A%84%E6%9C%89%E6%95%88%E6%80%A7%E5%9F%BA%E4%BA%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%93%AA%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="toc-text">缓存机制的有效性基于计算机程序的哪个属性？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%B8%AA%E7%AE%A1%E7%90%86%E7%BC%93%E5%AD%98%E4%B8%8E%E4%B8%BB%E5%AD%98%E4%B9%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E7%9A%84%E4%BC%A0%E8%BE%93"><span class="toc-text">以下哪个管理缓存与主存之间数据的传输？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8-6"><span class="toc-text">精华所在：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94"><span class="toc-text">缓存系统问题解答：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E7%BC%93%E5%AD%98%E7%9A%84%E7%BC%93%E5%AD%98%E8%A1%8C%E5%A4%A7%E5%B0%8F%E4%B8%BA64%E5%AD%97%E8%8A%82%E8%80%8C%E4%B8%BB%E5%AD%98%E5%AF%B9%E6%AF%8F%E4%B8%AA%E5%86%85%E5%AD%98%E8%AF%B7%E6%B1%82%E7%9A%84%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%B8%BA20%E4%B8%AA%E5%91%A8%E6%9C%9F%E6%AF%8F%E6%AC%A1%E8%BF%94%E5%9B%9E2%E5%AD%97%E8%8A%82%E6%95%B0%E6%8D%AE%E9%82%A3%E4%B9%88%E4%BB%8E%E4%B8%BB%E5%AD%98%E8%8E%B7%E5%8F%96%E4%B8%80%E4%B8%AA%E7%BC%93%E5%AD%98%E8%A1%8C%E9%9C%80%E8%A6%81%E5%A4%9A%E5%B0%91%E4%B8%AA%E5%91%A8%E6%9C%9F"><span class="toc-text">如果缓存的缓存行大小为64字节，而主存对每个内存请求的响应时间为20个周期，每次返回2字节数据，那么从主存获取一个缓存行需要多少个周期？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%BD%93%E4%B8%80%E4%B8%AA%E5%9D%97%E9%9C%80%E8%A6%81%E8%A2%AB%E8%A6%86%E7%9B%96%E6%97%B6%E6%9C%80%E5%A5%BD%E8%A6%86%E7%9B%96%E9%82%A3%E4%B8%AA%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%BC%95%E7%94%A8%E7%9A%84%E5%9D%97%E8%BF%99%E7%A7%8D%E6%8A%80%E6%9C%AF%E7%A7%B0%E4%B8%BA____%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-text">**在缓存系统中，当一个块需要被覆盖时，最好覆盖那个最长时间没有被引用的块。这种技术称为____替换算法。**</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8-7"><span class="toc-text">精华所在：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E7%BC%93%E5%AD%98%E4%B8%AD%E5%BD%93%E9%9C%80%E8%A6%81%E4%BB%8E%E7%BC%93%E5%AD%98%E4%B8%AD%E9%A9%B1%E9%80%90%E4%B8%80%E6%9D%A1%E7%BC%93%E5%AD%98%E8%A1%8C%E4%BB%A5%E8%85%BE%E5%87%BA%E7%A9%BA%E9%97%B4%E6%97%B6%E4%BD%BF%E7%94%A8%E9%9A%8F%E6%9C%BA%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5%E6%98%AF%E5%90%88%E7%90%86%E7%9A%84%E5%90%97"><span class="toc-text">在直接映射缓存中，当需要从缓存中驱逐一条缓存行以腾出空间时，使用随机替换策略是合理的吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%86%99%E6%93%8D%E4%BD%9C%E4%B8%AD%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE%E5%92%8C%E4%B8%BB%E5%AD%98%E4%BD%8D%E7%BD%AE%E5%90%8C%E6%97%B6%E6%9B%B4%E6%96%B0%E8%BF%99%E7%A7%8D%E6%8A%80%E6%9C%AF%E8%A2%AB%E7%A7%B0%E4%B8%BA%E5%86%99%E7%9B%B4%E9%80%9Awrite-through%E5%8D%8F%E8%AE%AE"><span class="toc-text">在写操作中，缓存位置和主存位置同时更新。这种技术被称为写直通（Write
Through）协议。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8-8"><span class="toc-text">精华所在：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%98%A0%E5%B0%84%E7%BC%93%E5%AD%98%E4%B8%AD%E7%9A%84%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-text">直接映射缓存中的替换策略：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E7%9B%B4%E9%80%9Awrite-through%E5%8D%8F%E8%AE%AE"><span class="toc-text">写直通（Write
Through）协议：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E7%9B%B4%E9%80%9Awrite-through%E7%AD%96%E7%95%A5%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">写直通（Write
Through）策略的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9advantage"><span class="toc-text">优点（Advantage）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9disadvantages"><span class="toc-text">缺点（Disadvantages）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8-9"><span class="toc-text">精华所在</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E7%9B%B4%E9%80%9Awrite-through%E7%AD%96%E7%95%A5"><span class="toc-text">写直通（Write
Through）策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%9B%9Ewrite-back%E7%AD%96%E7%95%A5%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">写回（Write
Back）策略的优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9advantages"><span class="toc-text">优点（Advantages）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9disadvantages-1"><span class="toc-text">缺点（Disadvantages）：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8-10"><span class="toc-text">精华所在</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%9B%9Ewrite-back%E7%AD%96%E7%95%A5"><span class="toc-text">写回（Write Back）策略</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A15/" title="计算机网络八股5"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%BA%9A%E7%B4%A2-%E5%8A%A8%E6%BC%AB%E9%A3%8E.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络八股5"/></a><div class="content"><a class="title" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A15/" title="计算机网络八股5">计算机网络八股5</a><time datetime="2025-05-09T08:24:49.000Z" title="发表于 2025-05-09 16:24:49">2025-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A14/" title="计算机网络八股4"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%89%91%E5%AE%A2-%E5%8F%A4%E9%A3%8E%E6%8F%92%E7%94%BB.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络八股4"/></a><div class="content"><a class="title" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A14/" title="计算机网络八股4">计算机网络八股4</a><time datetime="2025-05-09T08:07:39.000Z" title="发表于 2025-05-09 16:07:39">2025-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A13/" title="计算机网络八股3"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%89%91%E5%AE%A2-%E5%8F%A4%E9%A3%8E%E6%8F%92%E7%94%BB.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络八股3"/></a><div class="content"><a class="title" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A13/" title="计算机网络八股3">计算机网络八股3</a><time datetime="2025-05-09T07:40:49.000Z" title="发表于 2025-05-09 15:40:49">2025-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A12/" title="计算机网络八股2"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%89%91%E5%AE%A2-%E5%8F%A4%E9%A3%8E%E6%8F%92%E7%94%BB.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络八股2"/></a><div class="content"><a class="title" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A12/" title="计算机网络八股2">计算机网络八股2</a><time datetime="2025-05-09T07:06:53.000Z" title="发表于 2025-05-09 15:06:53">2025-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A11/" title="计算机网络八股1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%89%91%E5%AE%A2-%E5%8F%A4%E9%A3%8E%E6%8F%92%E7%94%BB.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络八股1"/></a><div class="content"><a class="title" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A11/" title="计算机网络八股1">计算机网络八股1</a><time datetime="2025-05-09T06:05:30.000Z" title="发表于 2025-05-09 14:05:30">2025-05-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HT1PalaKkPaG1UqAXBhJXIu8-gzGzoHsz',
      appKey: 'iT0TnVVAwf9zuZ7NqwclQItY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="1" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/离散数学/&quot;);" href="javascript:void(0);">离散数学</a><span class="categoryBar-list-count">33</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS61B/&quot;);" href="javascript:void(0);">CS61B</a><span class="categoryBar-list-count">76</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/期末の旅/&quot;);" href="javascript:void(0);">期末の旅</a><span class="categoryBar-list-count">99</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题计划/&quot;);" href="javascript:void(0);">刷题计划</a><span class="categoryBar-list-count">60</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/区域赛の旅/&quot;);" href="javascript:void(0);">区域赛の旅</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Codeforcesの旅/&quot;);" href="javascript:void(0);">Codeforcesの旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/牛客の旅/&quot;);" href="javascript:void(0);">牛客の旅</a><span class="categoryBar-list-count">65</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACMの旅/&quot;);" href="javascript:void(0);">ACMの旅</a><span class="categoryBar-list-count">42</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数学建模/&quot;);" href="javascript:void(0);">数学建模</a><span class="categoryBar-list-count">26</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/前端の旅/&quot;);" href="javascript:void(0);">前端の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构/&quot;);" href="javascript:void(0);">数据结构</a><span class="categoryBar-list-count">47</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_24.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Atcoderの旅/&quot;);" href="javascript:void(0);">Atcoderの旅</a><span class="categoryBar-list-count">53</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_25.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-の旅/&quot;);" href="javascript:void(0);">C++の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_26.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS70の旅/&quot;);" href="javascript:void(0);">CS70の旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_27.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CSAPPの旅/&quot;);" href="javascript:void(0);">CSAPPの旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_28.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">47</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_29.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程基础/&quot;);" href="javascript:void(0);">编程基础</a><span class="categoryBar-list-count">14</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_30.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JAVAの旅/&quot;);" href="javascript:void(0);">JAVAの旅</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_31.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MIT-6-031-Software-Construction/&quot;);" href="javascript:void(0);">MIT 6.031:Software Construction</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_32.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS-110L/&quot;);" href="javascript:void(0);">CS 110L</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_33.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据库の旅/&quot;);" href="javascript:void(0);">数据库の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_34.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/灵魂の旅/&quot;);" href="javascript:void(0);">灵魂の旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_35.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/个人安排/&quot;);" href="javascript:void(0);">个人安排</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_36.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂项/&quot;);" href="javascript:void(0);">杂项</a><span class="categoryBar-list-count">13</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_37.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文学/&quot;);" href="javascript:void(0);">文学</a><span class="categoryBar-list-count">49</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_38.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/力扣の旅/&quot;);" href="javascript:void(0);">力扣の旅</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_39.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机网络/&quot;);" href="javascript:void(0);">计算机网络</a><span class="categoryBar-list-count">23</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/千里十二行/&quot;);" href="javascript:void(0);">千里十二行</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_41.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/🗡指offer/&quot;);" href="javascript:void(0);">🗡指offer</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_42.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/少年游/&quot;);" href="javascript:void(0);">少年游</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_43.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法提高课/&quot;);" href="javascript:void(0);">算法提高课</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/汇编の旅/&quot;);" href="javascript:void(0);">汇编の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-实训/&quot;);" href="javascript:void(0);">C++实训</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_45.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS知识/&quot;);" href="javascript:void(0);">CS知识</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_46.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编译原理/&quot;);" href="javascript:void(0);">编译原理</a><span class="categoryBar-list-count">22</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_48.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/操作系统/&quot;);" href="javascript:void(0);">操作系统</a><span class="categoryBar-list-count">26</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;诗录/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4b31456c6f0f4489f99177f89e936de7286431045.png@1256w_708h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;诗录/&quot;);" href="javascript:void(0);" alt="">诗录</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;诗录/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;诗兴大发/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;诗兴大发/&quot;);" href="javascript:void(0);" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;诗兴大发/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;TotoroのPlan/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/51d37eba99d243607ddedfff6e91568f617436609.jpg@1256w_1884h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">TotoroのPlan</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;Markdown格式/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.48/img_482_1920x1080_96_null_normal.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;Markdown格式/&quot;);" href="javascript:void(0);" alt="">Markdown格式</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;Markdown格式/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>