<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Chapter 5 Basic Processing Unit | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Chapter 5 Basic Processing Unit中英对照    Chinese English     5.1 一些基本概念 5.1 Some Fundamental Concepts   5.2 指令执行（5个步骤） 5.2 Instruction Execution (5 steps)   5.3 硬件组件（5个阶段） 5.3 Hardware Components (5 sta">
<meta property="og:type" content="article">
<meta property="og:title" content="Chapter 5 Basic Processing Unit">
<meta property="og:url" content="http://totorocatcat.top/Chapter%205%20Basic%20Processing%20Unit/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="Chapter 5 Basic Processing Unit中英对照    Chinese English     5.1 一些基本概念 5.1 Some Fundamental Concepts   5.2 指令执行（5个步骤） 5.2 Instruction Execution (5 steps)   5.3 硬件组件（5个阶段） 5.3 Hardware Components (5 sta">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/7c19b45104600b55d7e0a93de1eaff2.jpg">
<meta property="article:published_time" content="2024-11-23T16:15:41.000Z">
<meta property="article:modified_time" content="2024-11-23T16:17:22.429Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/7c19b45104600b55d7e0a93de1eaff2.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/b5ca6e582a7a45e6fde46e616eeb68e.png"><link rel="canonical" href="http://totorocatcat.top/Chapter%205%20Basic%20Processing%20Unit/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":765,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Chapter 5 Basic Processing Unit',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-11-24 00:17:22'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">813</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/7c19b45104600b55d7e0a93de1eaff2.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Chapter 5 Basic Processing Unit</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-23T16:15:41.000Z" title="发表于 2024-11-24 00:15:41">2024-11-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-23T16:17:22.429Z" title="更新于 2024-11-24 00:17:22">2024-11-24</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">15.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Chapter 5 Basic Processing Unit"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/Chapter%205%20Basic%20Processing%20Unit/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/Chapter%205%20Basic%20Processing%20Unit/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chapter-5-Basic-Processing-Unit"><a href="#Chapter-5-Basic-Processing-Unit" class="headerlink" title="Chapter 5 Basic Processing Unit"></a>Chapter 5 Basic Processing Unit</h1><h2 id="中英对照"><a href="#中英对照" class="headerlink" title="中英对照"></a>中英对照</h2><div class="table-container">
<table>
<thead>
<tr>
<th><strong>Chinese</strong></th>
<th><strong>English</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>5.1 一些基本概念</td>
<td>5.1 Some Fundamental Concepts</td>
</tr>
<tr>
<td>5.2 指令执行（5个步骤）</td>
<td>5.2 Instruction Execution (5 steps)</td>
</tr>
<tr>
<td>5.3 硬件组件（5个阶段）</td>
<td>5.3 Hardware Components (5 stages)</td>
</tr>
<tr>
<td>5.4 指令获取与执行步骤</td>
<td>5.4 Instruction Fetch and Execution Steps</td>
</tr>
<tr>
<td>5.5 控制信号</td>
<td>5.5 Control Signals</td>
</tr>
<tr>
<td>5.6 硬件控制</td>
<td>5.6 Hardwired Control</td>
</tr>
<tr>
<td>5.7 CISC风格的处理器</td>
<td>5.7 CISC Style Processors</td>
</tr>
</tbody>
</table>
</div>
<h1 id="5-1-一些基本概念"><a href="#5-1-一些基本概念" class="headerlink" title="5.1 一些基本概念"></a><strong>5.1 一些基本概念</strong></h1><ul>
<li><strong>处理单元 (Processing Unit)</strong></li>
<li><strong>指令集处理器或中央处理单元 (Instruction Set Processor or Central Processing Unit)</strong><ul>
<li>处理器负责从计算机的内存中读取程序指令并执行它们。</li>
<li>它一次获取一条指令。</li>
<li>它解码（解释）指令。</li>
<li>然后，它执行指令中指定的操作。</li>
</ul>
</li>
</ul>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><p>为了执行一条指令，处理器需要完成以下步骤：</p>
<ol>
<li><p><strong>从内存中取出由程序计数器（PC）指向的位置的内容</strong>。将该位置的内容加载到指令寄存器（IR）中。</p>
<ul>
<li><code>IR ← [PC]</code></li>
</ul>
<p>这个过程称为<strong>取指阶段（Fetch Phase）</strong>。</p>
</li>
<li><p><strong>将程序计数器（PC）递增，指向下一条指令</strong>。假设内存是按字节寻址的，并且每条指令占4个字节。</p>
<ul>
<li><code>PC ← [PC] + 4</code></li>
</ul>
<p>这个步骤也属于<strong>取指阶段（Fetch Phase）</strong>。</p>
</li>
<li><p><strong>执行指令寄存器（IR）中所指定的操作</strong>。执行阶段即根据从内存取出的指令执行相应的计算或操作。</p>
<p>这个过程称为<strong>执行阶段（Execution Phase）</strong>。</p>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123005007562.png" alt="image-20241123005007562"></p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul>
<li>如果一条指令占用多个内存单元，则步骤1和2需要重复多次，直到完整地取出整条指令。</li>
</ul>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>取指阶段</strong>：步骤1和步骤2</li>
<li><strong>执行阶段</strong>：步骤3</li>
</ul>
<h2 id="指令执行的操作"><a href="#指令执行的操作" class="headerlink" title="指令执行的操作"></a>指令执行的操作</h2><p>除了少数例外，指令的执行通常通过按照特定顺序执行以下操作之一或多个来完成：</p>
<ol>
<li><p><strong>读取给定内存位置的内容并将其加载到处理器寄存器中</strong>。</p>
</li>
<li><p><strong>从一个或多个处理器寄存器中读取数据</strong>。</p>
</li>
<li><p><strong>执行算术或逻辑运算，并将结果存储到处理器寄存器中</strong>。</p>
</li>
<li><p><strong>将处理器寄存器中的数据存储到给定的内存位置</strong>。</p>
</li>
</ol>
<p>这些操作是指令执行过程中常见的基本步骤，通过这些操作，处理器能够完成计算、数据传输和存储等任务。</p>
<h2 id="处理器的主要硬件组件"><a href="#处理器的主要硬件组件" class="headerlink" title="处理器的主要硬件组件"></a>处理器的主要硬件组件</h2><ol>
<li><p><strong>程序计数器（PC）</strong>：提供指令的地址。</p>
</li>
<li><p><strong>指令寄存器（IR）</strong>：从内存中取出的指令被加载到此寄存器。</p>
</li>
<li><p><strong>指令地址生成器</strong>：更新程序计数器（PC），指向下一条指令的地址。</p>
</li>
<li><p><strong>控制电路</strong>：解释指令，并生成控制信号以执行所需的操作。</p>
</li>
</ol>
<p>这些组件协同工作，确保处理器能够有效地获取和执行指令。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123005450489.png" alt="image-20241123005450489"></p>
<h2 id="数据处理系统的结构"><a href="#数据处理系统的结构" class="headerlink" title="数据处理系统的结构"></a>数据处理系统的结构</h2><p><strong>寄存器A的内容被处理并存放到寄存器B中</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123011850578.png" alt="image-20241123011850578"></p>
<p><strong>组合电路的操作</strong>：组合电路执行的操作通常可以分解为多个更简单的步骤，每个步骤由原始电路的子电路执行。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123011919304.png" alt="image-20241123011919304"></p>
<p><strong>为什么使用多阶段处理？</strong></p>
<ul>
<li>处理在每个时钟周期内从一个阶段移动到下一个阶段。</li>
<li>这种多阶段的系统被称为<strong>流水线</strong>。</li>
<li>高性能处理器通常采用流水线结构。</li>
<li><strong>流水线</strong>使得连续的指令可以重叠执行，提高处理效率。</li>
</ul>
<blockquote>
<p><strong>流水线将在第六章详细讨论</strong>。</p>
</blockquote>
<h2 id="指令执行"><a href="#指令执行" class="headerlink" title="指令执行"></a>指令执行</h2><ol>
<li><strong>流水线结构的效果</strong>：如果所有指令都能在相同的步骤数内执行，流水线结构最为高效。</li>
<li><strong>每个步骤在单独的硬件阶段完成</strong>。</li>
<li><strong>处理器设计</strong>：处理器的设计将通过五个硬件阶段来进行说明。</li>
<li><strong>如何将指令执行划分为五个步骤</strong>？</li>
</ol>
<h2 id="内存访问指令："><a href="#内存访问指令：" class="headerlink" title="内存访问指令："></a>内存访问指令：</h2><p><strong>指令：<code>Load R5, X(R7)</code></strong></p>
<ul>
<li><strong>操作</strong>：使用索引寻址方式，从内存位置 <code>X + [R7]</code> 加载一个数据字到寄存器 <code>R5</code>。</li>
</ul>
<h3 id="执行此指令所需的五个步骤："><a href="#执行此指令所需的五个步骤：" class="headerlink" title="执行此指令所需的五个步骤："></a>执行此指令所需的五个步骤：</h3><ol>
<li><strong>取指</strong>：取出指令并递增程序计数器（PC）。</li>
<li><strong>解码</strong>：解码指令并读取寄存器 <code>R7</code> 中的内容。</li>
<li><strong>计算有效地址</strong>：计算有效地址 <code>X + [R7]</code>。</li>
<li><strong>读取内存操作数</strong>：从内存中读取数据操作数。</li>
<li><strong>加载操作数</strong>：将读取到的操作数加载到目标寄存器 <code>R5</code> 中。</li>
</ol>
<h3 id="计算指令："><a href="#计算指令：" class="headerlink" title="计算指令："></a>计算指令：</h3><p><strong>指令：<code>Add R3, R4, R5</code></strong></p>
<ul>
<li><strong>操作</strong>：<code>Add</code> 指令不需要访问内存中的操作数，因此可以在四个步骤内完成。</li>
</ul>
<h3 id="执行此指令所需的五个步骤：-1"><a href="#执行此指令所需的五个步骤：-1" class="headerlink" title="执行此指令所需的五个步骤："></a>执行此指令所需的五个步骤：</h3><ol>
<li><strong>取指</strong>：取出指令并递增程序计数器（PC）。</li>
<li><strong>解码</strong>：解码指令并读取寄存器 <code>R4</code> 和 <code>R5</code> 中的内容。</li>
<li><strong>计算和</strong>：计算 <code>R4 + R5</code> 的和。</li>
<li><strong>无操作</strong>：在这一步中不进行任何操作（用于保持流水线的一致性）。</li>
<li><strong>加载结果</strong>：将计算结果加载到目标寄存器 <code>R3</code> 中。</li>
</ol>
<h3 id="流水线处理："><a href="#流水线处理：" class="headerlink" title="流水线处理："></a>流水线处理：</h3><ul>
<li>对于所有指令，使用相同的多阶段处理硬件是有利的。如果某些指令的执行步骤较少，可以在某个步骤中不执行任何操作，以保持流水线的连续性。</li>
</ul>
<h2 id="内存访问指令：-1"><a href="#内存访问指令：-1" class="headerlink" title="内存访问指令："></a>内存访问指令：</h2><p><strong>指令：<code>Store R6, X(R8)</code></strong></p>
<ul>
<li><strong>操作</strong>：将寄存器 <code>R6</code> 的内容存储到内存位置 <code>X + [R8]</code>。</li>
</ul>
<h3 id="执行此指令所需的五个步骤：-2"><a href="#执行此指令所需的五个步骤：-2" class="headerlink" title="执行此指令所需的五个步骤："></a>执行此指令所需的五个步骤：</h3><ol>
<li><strong>取指</strong>：取出指令并递增程序计数器（PC）。</li>
<li><strong>解码</strong>：解码指令并读取寄存器 <code>R6</code> 和 <code>R8</code> 中的内容。</li>
<li><strong>计算有效地址</strong>：计算有效地址 <code>X + [R8]</code>。</li>
<li><strong>存储操作数</strong>：将寄存器 <code>R6</code> 的内容存储到内存位置 <code>X + [R8]</code>。</li>
<li><strong>无操作</strong>：在这一步中不进行任何操作（用于保持流水线的一致性）。</li>
</ol>
<h3 id="流水线处理：-1"><a href="#流水线处理：-1" class="headerlink" title="流水线处理："></a>流水线处理：</h3><ul>
<li><code>Store</code> 指令不需要像 <code>Load</code> 指令那样加载结果到目标寄存器，因此最后一步没有任何操作。</li>
</ul>
<h2 id="适用于所有指令的五步序列（RISC-风格指令集）"><a href="#适用于所有指令的五步序列（RISC-风格指令集）" class="headerlink" title="适用于所有指令的五步序列（RISC 风格指令集）"></a>适用于所有指令的五步序列（RISC 风格指令集）</h2><p>以下五个步骤适用于所有 RISC 风格的指令：</p>
<ol>
<li><strong>取指</strong>：取出指令并递增程序计数器（PC）。</li>
<li><strong>解码</strong>：解码指令并从寄存器文件中读取所需的寄存器。</li>
<li><strong>执行 ALU 操作</strong>：执行算术逻辑单元（ALU）操作。</li>
<li><strong>读写内存</strong>：如果指令涉及内存操作数，则进行内存的数据读写。</li>
<li><strong>写回结果</strong>：如果需要，将结果写入目标寄存器。</li>
</ol>
<p>这个步骤序列适用于所有类型的指令，包括算术、逻辑、内存访问等操作。</p>
<h2 id="寄存器文件（Register-File）"><a href="#寄存器文件（Register-File）" class="headerlink" title="寄存器文件（Register File）"></a>寄存器文件（Register File）</h2><ol>
<li><p><strong>2端口寄存器文件</strong>：</p>
<ul>
<li>为了同时读取两个源寄存器，需要使用一个<strong>2端口寄存器文件</strong>。</li>
<li>寄存器文件有两个输出端口（A 和 B），这两个输出端口用于提供读取的源寄存器的内容。</li>
<li>寄存器文件有两个地址输入端口，用于选择要读取的两个寄存器，这些地址输入与指令寄存器（IR）中的源寄存器字段相连接。</li>
<li>寄存器文件还具有一个数据输入端口（C），以及一个相应的地址输入端口，用于选择目标寄存器。这个地址输入连接到 IR 中指定目标寄存器的字段。</li>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123012503226.png" alt="image-20241123012503226"></li>
</ul>
</li>
<li><p><strong>2端口寄存器文件的替代实现</strong>：</p>
<ul>
<li><p>另一种实现方法是使用<strong>两个单端口内存块</strong>来代替传统的2端口寄存器文件。  </p>
<ul>
<li>每个单端口内存块只能在一个时钟周期内进行一次读或写操作。为了实现2端口功能，需要通过两次时钟周期分别完成两个源寄存器的读取操作。</li>
<li>这种实现方法相对简单，但可能会增加延迟，因为需要两个时钟周期来完成两个寄存器的读取。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123012548079.png" alt="image-20241123012548079"></p>
</li>
</ul>
</li>
</ol>
<h3 id="详细描述："><a href="#详细描述：" class="headerlink" title="详细描述："></a>详细描述：</h3><ul>
<li>在 RISC 架构中，<strong>寄存器文件</strong>是一个非常关键的硬件组件，它用于存储和读取处理器的寄存器数据。寄存器文件需要能够高效地支持读取和写入操作。</li>
<li><strong>2端口寄存器文件</strong>允许同时读取两个寄存器的内容，这是因为许多指令（例如加法、减法等算术运算指令）需要同时从两个寄存器中获取数据。通过为每个源寄存器分配一个独立的端口，2端口设计可以在单一时钟周期内并行执行这些读取操作。</li>
<li><strong>目标寄存器</strong>通常是指令的执行结果所在的位置，因此，寄存器文件需要能够在执行后将计算结果写入到指定的目标寄存器中。</li>
</ul>
<h2 id="ALU（算术逻辑单元）"><a href="#ALU（算术逻辑单元）" class="headerlink" title="ALU（算术逻辑单元）"></a><strong>ALU（算术逻辑单元）</strong></h2><h4 id="1-什么是-ALU？"><a href="#1-什么是-ALU？" class="headerlink" title="1. 什么是 ALU？"></a><strong>1. 什么是 ALU？</strong></h4><ul>
<li>ALU 是处理器的<strong>算术逻辑单元</strong>，负责对数据进行操作。</li>
<li>主要用于执行<strong>算术运算</strong>和<strong>逻辑运算</strong>。</li>
</ul>
<hr>
<h4 id="2-ALU-的功能"><a href="#2-ALU-的功能" class="headerlink" title="2. ALU 的功能"></a><strong>2. ALU 的功能</strong></h4><ol>
<li><strong>算术运算</strong>：<ul>
<li>加法（Addition）</li>
<li>减法（Subtraction）</li>
</ul>
</li>
<li><strong>逻辑运算</strong>：<ul>
<li>与（AND）</li>
<li>或（OR）</li>
<li>异或（XOR）</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-数据操作方式"><a href="#3-数据操作方式" class="headerlink" title="3. 数据操作方式"></a><strong>3. 数据操作方式</strong></h4><ul>
<li>ALU 的操作数来源于<strong>寄存器文件</strong>（Register File）。<ul>
<li>源操作数：<strong>[RA]</strong> 和 <strong>[RB]</strong></li>
<li>结果存储位置：<strong>[RC]</strong></li>
</ul>
</li>
<li>数据流：<ul>
<li>从寄存器 RA 和 RB 中读取操作数。</li>
<li>运算结果写入寄存器 RC。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a><strong>4. 小结</strong></h4><ul>
<li>ALU 是处理器核心组件，负责执行关键的算术和逻辑操作。</li>
<li>所有的操作都基于寄存器之间的数据交互完成。</li>
</ul>
<hr>
<h4 id="相关信号与组件"><a href="#相关信号与组件" class="headerlink" title="相关信号与组件"></a><strong>相关信号与组件</strong></h4><ol>
<li><strong>AddressA、AddressB</strong>：<ul>
<li>用于从寄存器文件中选择源操作数 [RA] 和 [RB] 的地址。</li>
</ul>
</li>
<li><strong>AddressC</strong>：<ul>
<li>指向寄存器文件中存储运算结果的目标地址 [RC]。</li>
</ul>
</li>
<li><strong>Mux B</strong>：<ul>
<li>多路复用器（Mux），用于选择第二个操作数的来源：<ul>
<li>来自寄存器 [RB]。</li>
<li>或直接选择立即数（Immediate Value）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Immediate Value</strong>：<ul>
<li>从指令寄存器（IR）中取出的固定值，用于与寄存器操作数一起参与运算。</li>
</ul>
</li>
</ol>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123223152717.png" alt="image-20241123223152717"></p>
<h2 id="数据路径-Datapath"><a href="#数据路径-Datapath" class="headerlink" title="数据路径 (Datapath)"></a>数据路径 (Datapath)</h2><p><strong>指令处理的两个阶段：</strong></p>
<ol>
<li><p><strong>取指阶段 (Fetch Phase)</strong>  </p>
<ul>
<li>这个阶段负责从内存中获取指令。</li>
<li>取指阶段会对获取的指令进行解码，生成控制信号，进而指示执行阶段采取适当的操作。</li>
</ul>
</li>
<li><p><strong>执行阶段 (Execution Phase)</strong>  </p>
<ul>
<li>这个阶段根据解码后的指令，从寄存器或者内存中读取操作数。</li>
<li>执行阶段执行必要的计算操作，并将结果存储在寄存器或内存中。</li>
</ul>
</li>
</ol>
<h2 id="处理器硬件的两个主要部分："><a href="#处理器硬件的两个主要部分：" class="headerlink" title="处理器硬件的两个主要部分："></a>处理器硬件的两个主要部分：</h2><ol>
<li><p><strong>取指部分</strong>  </p>
<ul>
<li>负责从内存获取指令，解码指令并生成控制信号。</li>
</ul>
</li>
<li><p><strong>执行部分</strong>  </p>
<ul>
<li>负责读取指令中指定的数据操作数，进行相应的计算或操作，并将结果保存。</li>
</ul>
</li>
</ol>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>取指阶段</strong> 和 <strong>执行阶段</strong> 分工明确，前者主要负责指令的获取、解码和控制信号的生成，后者则执行实际的计算操作。</li>
<li>数据路径的设计确保了处理器高效执行指令，同时将指令执行过程中的每个步骤清晰分开，以便于管理和优化。</li>
</ul>
<h2 id="5阶段RISC处理器实现"><a href="#5阶段RISC处理器实现" class="headerlink" title="5阶段RISC处理器实现"></a>5阶段RISC处理器实现</h2><h4 id="指令处理过程"><a href="#指令处理过程" class="headerlink" title="指令处理过程"></a>指令处理过程</h4><ol>
<li><p><strong>第1阶段：取指阶段 (IF - Instruction Fetch)</strong></p>
<ul>
<li>在这一阶段，指令从内存中获取并放入指令寄存器 (IR) 中。</li>
</ul>
</li>
<li><p><strong>第2阶段：解码阶段 (ID - Instruction Decode)</strong></p>
<ul>
<li>指令被解码，并且源寄存器的值被读取，为后续的计算做准备。</li>
</ul>
</li>
<li><p><strong>第3阶段：执行阶段 (EX - Execute)</strong></p>
<ul>
<li>这时，指令的运算操作在算术逻辑单元 (ALU) 中执行。</li>
</ul>
</li>
<li><p><strong>第4阶段：访存阶段 (MEM - Memory Access)</strong></p>
<ul>
<li>如果指令涉及内存操作（如读取或写入数据），则在这一阶段进行内存访问。</li>
</ul>
</li>
<li><p><strong>第5阶段：写回阶段 (WB - Write Back)</strong></p>
<ul>
<li>最终的计算结果会被存储回目标寄存器中。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123223358040.png" alt="image-20241123223358040"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123223406481.png" alt="image-20241123223406481"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li>在这种5阶段的RISC处理器架构中，每个时钟周期都完成一个阶段的操作，确保指令流的连续性和处理的高效性。</li>
<li>各个阶段分工明确，从取指到写回每个阶段都在独立的时钟周期内执行，提升了并行性和处理器的吞吐量。</li>
</ul>
<p>在RISC处理器的5阶段流水线中，阶段2到阶段5之间需要使用不同的<strong>中间寄存器</strong>来传递数据，这些寄存器使得数据能够从一个阶段传递到下一个阶段。以下是这些重要组件的作用和它们之间的数据流动：</p>
<h3 id="关键组件"><a href="#关键组件" class="headerlink" title="关键组件"></a>关键组件</h3><ol>
<li><p><strong>中间寄存器</strong>：</p>
<ul>
<li><strong>RZ</strong>、<strong>RM</strong>、<strong>RY</strong>：这些是不同阶段之间的数据缓冲寄存器，它们用于在不同的阶段之间传递计算结果或操作数。例如：<ul>
<li><strong>RZ</strong>可能存储从执行阶段到内存访问阶段的数据。</li>
<li><strong>RM</strong>可能存储从内存访问阶段到写回阶段的数据。</li>
<li><strong>RY</strong>用于存储来自执行阶段的数据，传递给寄存器写回阶段。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>寄存器文件 (Register File)</strong>：</p>
<ul>
<li>存储着处理器中的数据寄存器。指令在执行过程中会从寄存器文件中读取操作数（例如RA, RB）并将计算结果写回（RY）。</li>
</ul>
</li>
<li><p><strong>ALU (算术逻辑单元)</strong>：</p>
<ul>
<li>在<strong>执行阶段</strong>，ALU对指令进行运算。例如，它可以执行加法、减法、与、或等运算。</li>
<li><strong>MUXB</strong>（多路复用器）用于在ALU输入中选择正确的操作数。根据不同的控制信号，MUXB可以选择寄存器文件中的寄存器值或直接使用立即数。</li>
</ul>
</li>
<li><p><strong>内存阶段 (Memory Stage)</strong>：</p>
<ul>
<li>访问内存进行读写操作。</li>
<li><strong>MUXY</strong>：内存阶段中的多路复用器，选择数据输入到内存或从内存读取数据，具体取决于指令的类型（读/写）。</li>
</ul>
</li>
<li><p><strong>写回阶段 (Write Back Stage)</strong>：</p>
<ul>
<li>将计算结果或从内存获取的数据写回寄存器文件中。</li>
<li><strong>RY</strong>：存储从内存或ALU得到的结果，用于写回寄存器文件。</li>
</ul>
</li>
</ol>
<h3 id="数据流动"><a href="#数据流动" class="headerlink" title="数据流动"></a>数据流动</h3><ul>
<li><strong>RA</strong> 和 <strong>RB</strong>：寄存器文件中的操作数地址，通过这些地址从寄存器文件中读取数据。</li>
<li><strong>MUXB</strong>：多路复用器选择ALU输入数据，可能是来自寄存器文件的数据或立即数。</li>
<li><strong>RZ</strong>：存储ALU计算结果，传递到内存访问阶段。</li>
<li><strong>RM</strong>：在内存访问阶段存储从内存读取的数据或写入数据的地址。</li>
<li><strong>RY</strong>：在写回阶段存储最终结果，最后写回到寄存器文件。</li>
</ul>
<h3 id="例子：如何运作"><a href="#例子：如何运作" class="headerlink" title="例子：如何运作"></a>例子：如何运作</h3><p>假设我们有一个指令<code>ADD R1, R2, R3</code>，它将<code>R2</code>和<code>R3</code>的值加起来，并把结果存储到<code>R1</code>。</p>
<ol>
<li><p><strong>取指阶段 (IF)</strong>：</p>
<ul>
<li>从内存中取出指令，存入指令寄存器 (IR)。</li>
</ul>
</li>
<li><p><strong>解码阶段 (ID)</strong>：</p>
<ul>
<li>解码指令并读取寄存器<code>R2</code>和<code>R3</code>的值（通过RA、RB）。</li>
<li>将这些数据传递到ALU阶段。</li>
</ul>
</li>
<li><p><strong>执行阶段 (EX)</strong>：</p>
<ul>
<li>ALU进行加法操作，将<code>R2</code>和<code>R3</code>相加，结果存入<code>RZ</code>。</li>
</ul>
</li>
<li><p><strong>内存阶段 (MEM)</strong>：</p>
<ul>
<li>此阶段不涉及内存读写操作，因为是计算指令。</li>
<li>将<code>RZ</code>中的数据传递到写回阶段。</li>
</ul>
</li>
<li><p><strong>写回阶段 (WB)</strong>：</p>
<ul>
<li>将ALU的计算结果（来自<code>RZ</code>）写回到寄存器<code>R1</code>。</li>
</ul>
</li>
</ol>
<p>通过这种方式，数据在各个阶段之间流动并最终得到处理。</p>
<h2 id="数据路径：寄存器文件-阶段-2-amp-5"><a href="#数据路径：寄存器文件-阶段-2-amp-5" class="headerlink" title="数据路径：寄存器文件 (阶段 2 &amp; 5)"></a>数据路径：寄存器文件 (阶段 2 &amp; 5)</h2><p>在RISC处理器的流水线中，<strong>寄存器文件</strong>在指令的解码阶段（阶段 2）和写回阶段（阶段 5）扮演着重要角色。</p>
<h4 id="寄存器文件的工作原理："><a href="#寄存器文件的工作原理：" class="headerlink" title="寄存器文件的工作原理："></a>寄存器文件的工作原理：</h4><ol>
<li><p><strong>地址输入</strong>：</p>
<ul>
<li>寄存器文件的地址输入与指令寄存器（IR）中的字段相连接。具体来说，指令中会指定需要读取的源寄存器地址（如<code>RA</code>和<code>RB</code>）。</li>
<li>在解码阶段（阶段 2），从指令寄存器（IR）中读取操作数的寄存器地址。</li>
</ul>
</li>
<li><p><strong>读取源寄存器的值</strong>：</p>
<ul>
<li>在阶段 2，指令解码时会根据地址输入（通常是IR中的寄存器字段）从寄存器文件中读取<strong>源寄存器</strong>的值。</li>
<li>被读取的寄存器值会存储到寄存器<code>RA</code>和<code>RB</code>中，供后续的计算使用。</li>
</ul>
</li>
<li><p><strong>结果存储到目标寄存器</strong>：</p>
<ul>
<li>在阶段 5，指令执行完毕后，计算的结果会被存储到目标寄存器中。目标寄存器由IR中的相应地址字段选定。</li>
<li>寄存器文件将写回计算结果到正确的寄存器，完成数据处理。</li>
</ul>
</li>
</ol>
<h4 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h4><ul>
<li>在阶段 2，寄存器文件主要负责读取源寄存器的数据，并将其存入<code>RA</code>和<code>RB</code>中。</li>
<li>在阶段 5，寄存器文件将处理结果写回到目标寄存器，确保数据更新和存储。</li>
</ul>
<p>这种操作流使得处理器能够有效地从寄存器中读取数据进行运算，并在指令执行完成后将结果写回寄存器，支持高效的计算过程。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123223845979.png" alt="image-20241123223845979"></p>
<h2 id="数据路径：ALU阶段"><a href="#数据路径：ALU阶段" class="headerlink" title="数据路径：ALU阶段"></a>数据路径：ALU阶段</h2><p>在RISC处理器的流水线中的<strong>ALU阶段</strong>，主要处理指令指定的计算任务。ALU（算术逻辑单元）是执行实际运算的核心模块，涉及到数据的计算和处理。以下是ALU阶段的关键操作：</p>
<h4 id="ALU阶段的工作原理："><a href="#ALU阶段的工作原理：" class="headerlink" title="ALU阶段的工作原理："></a>ALU阶段的工作原理：</h4><ol>
<li><p><strong>ALU执行计算</strong>：</p>
<ul>
<li>ALU根据指令中的操作码（opcode）执行特定的计算任务。这些任务可能包括加法、减法、与操作、或操作等。</li>
</ul>
</li>
<li><p><strong>选择输入数据</strong>：</p>
<ul>
<li><strong>多路选择器 MuxB</strong> 的作用是从两个输入数据中选择一个作为ALU的第二个操作数：<ul>
<li>选择 <strong>RB</strong>（寄存器B的内容），或者</li>
<li>选择 <strong>立即数（Immediate）</strong> 字段，这个立即数来源于指令寄存器（IR）。</li>
</ul>
</li>
<li>这种选择机制允许ALU处理不同类型的操作，比如立即数操作或者寄存器操作。</li>
</ul>
</li>
<li><p><strong>存储计算结果</strong>：</p>
<ul>
<li>计算结果会被存储在<strong>RZ</strong>寄存器中。这个寄存器用于保存ALU计算后的结果，供后续使用或存储。</li>
</ul>
</li>
<li><p><strong>数据转移至内存</strong>：</p>
<ul>
<li>在ALU阶段，如果当前的指令涉及内存写操作（例如存储指令），那么数据会从寄存器<strong>RB</strong>转移到寄存器<strong>RM</strong>，然后准备写入内存中。</li>
</ul>
</li>
</ol>
<h4 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h4><ul>
<li><strong>ALU</strong>根据指令执行计算任务，处理寄存器中的数据或立即数。</li>
<li><strong>MuxB</strong>控制数据的选择，决定是从寄存器中读取数据还是使用立即数。</li>
<li>计算结果存储在<strong>RZ</strong>，如果有内存操作，数据将传送到<strong>RM</strong>。</li>
</ul>
<p>通过这个阶段，ALU不仅完成了必要的计算任务，还决定了计算结果是写回寄存器、传送到内存，还是执行其他操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123224104380.png" alt="image-20241123224104380"></p>
<h2 id="Datapath-Memory-Stage（内存阶段）"><a href="#Datapath-Memory-Stage（内存阶段）" class="headerlink" title="Datapath: Memory Stage（内存阶段）"></a>Datapath: Memory Stage（内存阶段）</h2><blockquote>
<p>注意一下RM。</p>
</blockquote>
<p>在处理内存指令时，<strong>Memory stage</strong>（内存阶段）主要负责以下几个任务：</p>
<ol>
<li><p><strong>RZ 提供内存地址</strong>：</p>
<ul>
<li><strong>RZ</strong>（寄存器Z）提供了内存访问的地址，这通常是在执行内存读取或写入时，从ALU计算中获得的结果。</li>
</ul>
</li>
<li><p><strong>MuxY 选择读取的数据放入 RY</strong>：</p>
<ul>
<li><strong>MuxY</strong> 是一个多路复用器，它决定从哪个输入选择数据。对于内存读取指令，<strong>MuxY</strong> 会选择从内存读取的数据，并将其放入 <strong>RY</strong>（寄存器Y），这是存储数据的地方。</li>
<li>对于计算指令，<strong>MuxY</strong> 选择 <strong>RZ</strong> 中的内容放入 <strong>RY</strong>。</li>
</ul>
</li>
<li><p><strong>RM 提供内存写入操作的数据</strong>：</p>
<ul>
<li>对于写内存操作（如 <code>SW</code> 指令），<strong>RM</strong> 存储着要写入内存的数据。这个数据会传递到内存中进行存储。</li>
</ul>
</li>
<li><p><strong>用于子程序调用时的输入2（MuxY）</strong>：</p>
<ul>
<li>在进行子程序调用时，<strong>MuxY</strong> 的第二个输入会被使用，这可以将数据传递到内存操作或计算中。</li>
</ul>
</li>
</ol>
<h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ul>
<li><strong>RZ</strong>：用于提供内存地址，通常是从ALU计算得到的结果。</li>
<li><strong>MuxY</strong>：根据指令类型选择数据，内存读取时将数据放入 <strong>RY</strong>，计算指令时从 <strong>RZ</strong> 放入 <strong>RY</strong>。</li>
<li><strong>RM</strong>：对于内存写指令，提供要写入内存的数据。</li>
<li><strong>RY</strong>：存储从内存读取的结果，或者ALU的计算结果。</li>
<li><strong>子程序调用时的输入2</strong>：用于特定情况下的数据选择，尤其是在处理函数调用时。</li>
</ul>
<p>这个阶段主要负责内存操作和计算结果的存储，是数据从内存到寄存器的一个关键转接点。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123224318371.png" alt="image-20241123224318371"></p>
<h2 id="Instruction-Fetch-Section（指令获取部分）"><a href="#Instruction-Fetch-Section（指令获取部分）" class="headerlink" title="Instruction Fetch Section（指令获取部分）"></a>Instruction Fetch Section（指令获取部分）</h2><h3 id="1-Memory-Address-Generation（内存地址生成）"><a href="#1-Memory-Address-Generation（内存地址生成）" class="headerlink" title="1. Memory Address Generation（内存地址生成）"></a>1. <strong>Memory Address Generation（内存地址生成）</strong></h3><ul>
<li><strong>MuxMA 选择 PC 地址</strong>：在获取指令时，<strong>MuxMA</strong> 选择程序计数器（PC）的值作为内存地址，以便从内存中取出指令。</li>
<li><strong>指令地址生成器</strong>：指令地址生成器在获取指令后会自增程序计数器（PC），指向下一条指令的地址。</li>
<li><strong>生成分支和子程序地址</strong>：该模块还负责生成分支指令的目标地址，以及在调用子程序时生成返回地址。</li>
<li><strong>MuxMA 选择 RZ 读取或写入数据操作数</strong>：当进行数据操作数的读取或写入时，<strong>MuxMA</strong> 会选择 <strong>RZ</strong> 作为内存地址，确保数据从正确的位置读取或写入。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123224657866.png" alt="image-20241123224657866"></p>
<h3 id="2-Processor-Control-Section（处理器控制部分）"><a href="#2-Processor-Control-Section（处理器控制部分）" class="headerlink" title="2. Processor Control Section（处理器控制部分）"></a>2. <strong>Processor Control Section（处理器控制部分）</strong></h3><ul>
<li><strong>指令读取并存储到 IR</strong>：当一条指令被从内存读取时，它会被放置到指令寄存器（IR）中，准备解码和执行。</li>
<li><strong>控制电路解码指令</strong>：解码器负责将指令解码，理解指令的操作类型，确定如何驱动处理器的各个单元。</li>
<li><strong>生成控制信号</strong>：根据指令的解码结果，控制电路会生成一组控制信号，来驱动处理器中的所有单元，以确保指令的正确执行。</li>
<li><strong>Immediate Block 扩展立即数操作数</strong>：在指令中，如果有立即数操作数，<strong>Immediate Block</strong> 会根据指令的要求将其扩展到 32 位，保证数据宽度与系统要求一致。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123224715066.png" alt="image-20241123224715066"></p>
<h3 id="3-Instruction-Address-Generator（指令地址生成器）"><a href="#3-Instruction-Address-Generator（指令地址生成器）" class="headerlink" title="3. Instruction Address Generator（指令地址生成器）"></a>3. <strong>Instruction Address Generator（指令地址生成器）</strong></h3><ul>
<li><strong>与 RY 和 RA 连接，用于子程序调用和返回</strong>：指令地址生成器还与寄存器 <strong>RY</strong> 和 <strong>RA</strong> 连接，这些寄存器用于子程序调用和返回地址的存储。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123224938272.png" alt="image-20241123224938272"></p>
<p>在RISC处理器的指令获取阶段，<strong>PC-Temp</strong>、<strong>PC</strong>、<strong>MuxPC</strong> 和 <strong>MUXINC</strong> 都是涉及到程序计数器（PC）管理的关键组件。它们的作用如下：</p>
<h4 id="1-PC-Temp（PC-临时寄存器）"><a href="#1-PC-Temp（PC-临时寄存器）" class="headerlink" title="1. PC-Temp（PC 临时寄存器）"></a>1. <strong>PC-Temp（PC 临时寄存器）</strong></h4><ul>
<li><strong>功能</strong>：用于存储当前程序计数器（PC）的值，通常在需要更新PC值之前，将其临时存储在 <strong>PC-Temp</strong> 中。这个临时存储可以防止直接修改 <strong>PC</strong>，确保在决定下一个PC值时不会丢失当前PC的内容。</li>
<li><strong>应用场景</strong>：比如在跳转指令（如分支指令）处理中，处理器需要保存当前PC值，以便之后返回。</li>
</ul>
<h4 id="2-PC（程序计数器）"><a href="#2-PC（程序计数器）" class="headerlink" title="2. PC（程序计数器）"></a>2. <strong>PC（程序计数器）</strong></h4><ul>
<li><strong>功能</strong>：PC寄存器存储当前正在执行的指令的地址（内存地址）。在每个时钟周期结束时，PC会递增，指向下一条指令。</li>
<li><strong>应用场景</strong>：每当处理器执行完一条指令后，程序计数器会更新为下一条指令的地址，通常会加1，也有例外情况（例如分支指令）。</li>
</ul>
<h4 id="3-MuxPC（程序计数器多路复用器）"><a href="#3-MuxPC（程序计数器多路复用器）" class="headerlink" title="3. MuxPC（程序计数器多路复用器）"></a>3. <strong>MuxPC（程序计数器多路复用器）</strong></h4><ul>
<li><strong>功能</strong>：<strong>MuxPC</strong> 是一个多路复用器，用于选择下一个程序计数器的值。它根据控制信号的不同，选择不同的输入作为程序计数器的值。</li>
<li><strong>输入来源</strong>：<ul>
<li><strong>PC + 4</strong>：通常情况下，程序计数器指向当前指令的地址，加4后指向下一条指令（每条指令通常占4个字节）。</li>
<li><strong>跳转目标地址</strong>：在执行跳转指令时，程序计数器会跳转到一个新的地址。此时，<strong>MuxPC</strong> 会选择跳转指令的目标地址而不是加4的值。</li>
</ul>
</li>
<li><strong>应用场景</strong>：分支、跳转等指令可能会修改程序计数器的值，因此通过 <strong>MuxPC</strong> 选择正确的地址。</li>
</ul>
<h4 id="4-MUXINC（PC-增量多路复用器）"><a href="#4-MUXINC（PC-增量多路复用器）" class="headerlink" title="4. MUXINC（PC 增量多路复用器）"></a>4. <strong>MUXINC（PC 增量多路复用器）</strong></h4><ul>
<li><strong>功能</strong>：<strong>MUXINC</strong> 用来生成程序计数器递增的值。在大多数情况下，<strong>MUXINC</strong> 会生成一个常数值，通常是4，用来指向下一条指令的地址。</li>
<li><strong>应用场景</strong>：用于PC更新时，通常PC值会增加4（假设每条指令是4字节）。但是在分支或跳转指令执行时，PC会变成一个新的地址。<strong>MUXINC</strong> 就是在常规情况下，用来递增PC的值。</li>
</ul>
<h4 id="他们如何协作："><a href="#他们如何协作：" class="headerlink" title="他们如何协作："></a>他们如何协作：</h4><ul>
<li>在没有跳转指令时，程序计数器（PC）会自动递增，通常加4，以指向下一条指令。<strong>MUXINC</strong> 输出值4，<strong>MuxPC</strong> 选择该值并加到 <strong>PC</strong> 上。</li>
<li>如果遇到跳转或分支指令，<strong>MuxPC</strong> 会根据控制信号选择跳转目标地址或返回地址，而不是自动递增的PC值。</li>
<li>在跳转或分支指令中，程序计数器的更新会通过 <strong>PC-Temp</strong> 暂存当前PC值，然后通过 <strong>MuxPC</strong> 选择正确的新PC值。</li>
</ul>
<h3 id="关键点总结："><a href="#关键点总结：" class="headerlink" title="关键点总结："></a>关键点总结：</h3><ul>
<li><strong>MuxMA</strong>：选择程序计数器（PC）作为内存地址，或者在数据操作中选择 <strong>RZ</strong> 作为内存地址。</li>
<li><strong>指令地址生成器</strong>：负责更新程序计数器（PC），并在需要时生成分支地址或子程序返回地址。</li>
<li><strong>IR</strong>：指令寄存器，存储当前从内存读取的指令。</li>
<li><strong>Immediate Block</strong>：负责扩展立即数操作数，确保它符合 32 位的要求。</li>
<li><strong>控制电路</strong>：解码指令并生成控制信号，控制整个处理器的操作。</li>
</ul>
<p>这些功能的组合确保了指令的顺利获取、解码和执行。</p>
<h1 id="5-4-指令获取与执行步骤"><a href="#5-4-指令获取与执行步骤" class="headerlink" title="5.4 指令获取与执行步骤"></a>5.4 指令获取与执行步骤</h1><h2 id="示例-1-Add-R3-R4-R5（将-R4-和-R5-相加，结果存入-R3）"><a href="#示例-1-Add-R3-R4-R5（将-R4-和-R5-相加，结果存入-R3）" class="headerlink" title="示例 1: Add R3, R4, R5（将 R4 和 R5 相加，结果存入 R3）"></a>示例 1: Add R3, R4, R5（将 R4 和 R5 相加，结果存入 R3）</h2><p>这个过程分为多个步骤，在每个步骤中，处理器执行不同的任务以完成这条指令。下面是步骤的中文解释：</p>
<hr>
<h4 id="步骤-1：指令获取"><a href="#步骤-1：指令获取" class="headerlink" title="步骤 1：指令获取"></a>步骤 1：指令获取</h4><ul>
<li><strong>内存地址 ← [PC]</strong>：程序计数器（PC）提供当前指令的内存地址。</li>
<li><strong>读取内存，IR ← 内存数据</strong>：处理器从内存中读取指令并将其存入指令寄存器（IR）。</li>
<li><strong>PC ← [PC] + 4</strong>：指令获取完毕后，程序计数器（PC）递增4（假设每条指令占用4字节），指向下一条指令。</li>
</ul>
<blockquote>
<p><strong>解释</strong>：第一步完成了从内存中获取当前指令，并更新了程序计数器，使得下一条指令的获取地址准备好。</p>
</blockquote>
<hr>
<h4 id="步骤-2：解码指令"><a href="#步骤-2：解码指令" class="headerlink" title="步骤 2：解码指令"></a>步骤 2：解码指令</h4><ul>
<li><strong>RA ← [R4]</strong>：从寄存器文件中读取寄存器 R4 的值，存入临时寄存器 RA。</li>
<li><strong>RB ← [R5]</strong>：从寄存器文件中读取寄存器 R5 的值，存入临时寄存器 RB。</li>
</ul>
<blockquote>
<p><strong>解释</strong>：在第二步，解码指令并准备好操作数。寄存器 R4 和 R5 的内容被加载到寄存器 RA 和 RB 中，供下一步计算使用。</p>
</blockquote>
<hr>
<h4 id="步骤-3：执行计算"><a href="#步骤-3：执行计算" class="headerlink" title="步骤 3：执行计算"></a>步骤 3：执行计算</h4><ul>
<li><strong>RZ ← [RA] + [RB]</strong>：将 RA 和 RB 寄存器中的值相加，结果存入临时寄存器 RZ。</li>
</ul>
<blockquote>
<p><strong>解释</strong>：在执行阶段，ALU（算术逻辑单元）对两个寄存器的值进行加法运算，计算出结果并存入寄存器 RZ。</p>
</blockquote>
<hr>
<h4 id="步骤-4：保存计算结果"><a href="#步骤-4：保存计算结果" class="headerlink" title="步骤 4：保存计算结果"></a>步骤 4：保存计算结果</h4><ul>
<li><strong>RY ← [RZ]</strong>：将临时寄存器 RZ 中的结果存入寄存器 RY（这里假设 RY 是一个临时寄存器或计算结果的存储寄存器）。</li>
</ul>
<blockquote>
<p><strong>解释</strong>：这一步可能是为了准备将计算结果进一步处理，或将结果传递给下一步。</p>
</blockquote>
<hr>
<h4 id="步骤-5：写回结果"><a href="#步骤-5：写回结果" class="headerlink" title="步骤 5：写回结果"></a>步骤 5：写回结果</h4><ul>
<li><strong>R3 ← [RY]</strong>：将最终的计算结果从寄存器 RY 写回到目标寄存器 R3。</li>
</ul>
<blockquote>
<p><strong>解释</strong>：最后，计算结果存回寄存器 R3，完成指令的执行。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123225130162.png" alt="image-20241123225130162"></p>
<hr>
<h3 id="指令编码格式"><a href="#指令编码格式" class="headerlink" title="指令编码格式"></a>指令编码格式</h3><p>指令格式定义了指令中各个字段的布局。不同的操作数格式决定了指令的结构，下面是三种常见的指令编码格式：</p>
<h4 id="a-寄存器操作数格式（Register-operand-format）"><a href="#a-寄存器操作数格式（Register-operand-format）" class="headerlink" title="(a) 寄存器操作数格式（Register-operand format）"></a>(a) <strong>寄存器操作数格式（Register-operand format）</strong></h4><p>这种格式用于那些操作数都来自寄存器的指令。格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| Rsrc1 | Rsrc2 | Rdst | OP code |</span><br><span class="line">31     27 26   22 21  17 16      0</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Rsrc1</strong> 和 <strong>Rsrc2</strong>：表示操作数的源寄存器，通常是参与计算的两个寄存器。</li>
<li><strong>Rdst</strong>：表示目标寄存器，存储操作结果的寄存器。</li>
<li><strong>OP code</strong>：操作码，指定该指令执行的操作类型（例如加法、减法等）。</li>
</ul>
<h4 id="b-立即数操作数格式（Immediate-operand-format）"><a href="#b-立即数操作数格式（Immediate-operand-format）" class="headerlink" title="(b) 立即数操作数格式（Immediate-operand format）"></a>(b) <strong>立即数操作数格式（Immediate-operand format）</strong></h4><p>这种格式用于指令中包含立即数的操作数。格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| Rsrc | Rdst | Immediate operand | OP code |</span><br><span class="line">31     27 26 22 21               6 5      0</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Rsrc</strong>：源寄存器，操作数之一来自寄存器。</li>
<li><strong>Rdst</strong>：目标寄存器，存储操作结果的寄存器。</li>
<li><strong>Immediate operand</strong>：立即数操作数，直接在指令中给出的常数值。</li>
<li><strong>OP code</strong>：操作码，指定该指令执行的操作类型。</li>
</ul>
<h4 id="c-调用格式（Call-format）"><a href="#c-调用格式（Call-format）" class="headerlink" title="(c) 调用格式（Call format）"></a>(c) <strong>调用格式（Call format）</strong></h4><p>这种格式用于函数调用指令，通常在调用子程序时使用。格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| Immediate value | OP code |</span><br><span class="line">31                6 5       0</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Immediate value</strong>：存储跳转目标地址或偏移量，指向调用的子程序地址。</li>
<li><strong>OP code</strong>：操作码，指明这是一个函数调用指令。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123225144266.png" alt="image-20241123225144266"></p>
<h3 id="示例2：加载指令（Load-R5-X-R7-）"><a href="#示例2：加载指令（Load-R5-X-R7-）" class="headerlink" title="示例2：加载指令（Load R5, X(R7)）"></a>示例2：<strong>加载指令（Load R5, X(R7)）</strong></h3><p>该指令的操作是从内存地址 <code>X + [R7]</code> 处读取数据，并将其加载到寄存器 <code>R5</code> 中。具体的步骤如下：</p>
<ol>
<li><p><strong>取指令</strong></p>
<ul>
<li><strong>Memory address ← [PC]</strong>：获取程序计数器（PC）指向的内存地址。</li>
<li><strong>Read memory, IR ← Memory data</strong>：从内存中读取指令，并将其存储到指令寄存器（IR）中。</li>
<li><strong>PC ← [PC] + 4</strong>：程序计数器自增，指向下一条指令。</li>
</ul>
</li>
<li><p><strong>解码指令</strong></p>
<ul>
<li><strong>RA ← [R7]</strong>：从寄存器 <code>R7</code> 中读取数据，并将其存储到寄存器 <code>RA</code> 中。</li>
</ul>
</li>
<li><p><strong>计算内存地址</strong></p>
<ul>
<li><strong>RZ ← [RA] + Immediate value X</strong>：将寄存器 <code>RA</code> 中的值与立即数 <code>X</code> 相加，计算出内存地址 <code>RZ</code>。</li>
</ul>
</li>
<li><p><strong>访问内存</strong></p>
<ul>
<li><strong>Memory address ← [RZ]</strong>：使用计算出的内存地址 <code>RZ</code>。</li>
<li><strong>Read memory, RY ← Memory data</strong>：从内存地址 <code>RZ</code> 读取数据，并将其存储到寄存器 <code>RY</code> 中。</li>
</ul>
</li>
<li><p><strong>写回寄存器</strong></p>
<ul>
<li><strong>R5 ← [RY]</strong>：将从内存中读取的数据存入寄存器 <code>R5</code>。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123225621324.png" alt="image-20241123225621324"></p>
<h3 id="示例3：存储指令（Store-R6-X-R8-）"><a href="#示例3：存储指令（Store-R6-X-R8-）" class="headerlink" title="示例3：存储指令（Store R6, X(R8)）"></a>示例3：<strong>存储指令（Store R6, X(R8)）</strong></h3><p>该指令的操作是将寄存器 <code>R6</code> 中的数据存储到内存地址 <code>X + [R8]</code> 处。具体的步骤如下：</p>
<ol>
<li><p><strong>取指令</strong></p>
<ul>
<li><strong>Memory address ← [PC]</strong>：获取程序计数器（PC）指向的内存地址。</li>
<li><strong>Read memory, IR ← Memory data</strong>：从内存中读取指令，并将其存储到指令寄存器（IR）中。</li>
<li><strong>PC ← [PC] + 4</strong>：程序计数器自增，指向下一条指令。</li>
</ul>
</li>
<li><p><strong>解码指令</strong></p>
<ul>
<li><strong>RA ← [R8]</strong>：从寄存器 <code>R8</code> 中读取数据，并将其存储到寄存器 <code>RA</code> 中。</li>
<li><strong>RB ← [R6]</strong>：从寄存器 <code>R6</code> 中读取数据，并将其存储到寄存器 <code>RB</code> 中。</li>
</ul>
</li>
<li><p><strong>计算内存地址并准备写入数据</strong></p>
<ul>
<li><strong>RZ ← [RA] + Immediate value X</strong>：将寄存器 <code>RA</code> 中的值与立即数 <code>X</code> 相加，计算出内存地址 <code>RZ</code>。</li>
<li><strong>RM ← [RB]</strong>：将寄存器 <code>RB</code> 中的值（即寄存器 <code>R6</code> 的值）存储到寄存器 <code>RM</code> 中，作为要写入内存的数据。</li>
</ul>
</li>
<li><p><strong>访问内存并写数据</strong></p>
<ul>
<li><strong>Memory address ← [RZ]</strong>：使用计算出的内存地址 <code>RZ</code>。</li>
<li><strong>Memory data ← [RM], Write memory</strong>：将寄存器 <code>RM</code> 中的数据写入到内存地址 <code>RZ</code> 指定的内存位置。</li>
</ul>
</li>
<li><p><strong>没有其他操作</strong></p>
<ul>
<li><strong>No action</strong>：此步骤不进行其他操作。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123225734013.png" alt="image-20241123225734013"></p>
<h3 id="无条件跳转指令（Unconditional-Branch）"><a href="#无条件跳转指令（Unconditional-Branch）" class="headerlink" title="无条件跳转指令（Unconditional Branch）"></a>无条件跳转指令（Unconditional Branch）</h3><p>无条件跳转指令的执行过程包括以下几个步骤：</p>
<ol>
<li><p><strong>取指令</strong></p>
<ul>
<li><strong>Memory address ← [PC]</strong>：获取程序计数器（PC）指向的内存地址。</li>
<li><strong>Read memory, IR ← Memory data</strong>：从内存中读取指令，并将其存储到指令寄存器（IR）中。</li>
<li><strong>PC ← [PC] + 4</strong>：程序计数器自增，指向下一条指令。</li>
</ul>
</li>
<li><p><strong>解码指令</strong></p>
<ul>
<li>对指令进行解码，获取跳转目标地址的偏移量。</li>
</ul>
</li>
<li><p><strong>计算跳转地址</strong></p>
<ul>
<li><strong>PC ← [PC] + Branch offset</strong>：根据指令中的分支偏移量更新程序计数器（PC），跳转到新的指令位置。</li>
</ul>
</li>
<li><p><strong>没有其他操作</strong></p>
<ul>
<li><strong>No action</strong>：此步骤不进行其他操作。</li>
</ul>
</li>
<li><p><strong>没有其他操作</strong></p>
<ul>
<li><strong>No action</strong>：此步骤不进行其他操作。</li>
</ul>
</li>
</ol>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>无条件跳转指令的执行通过更新程序计数器（PC）来实现跳转。首先，取指令并更新PC，然后根据指令中的偏移量修改PC，实现无条件跳转到指定位置。</p>
<h3 id="条件跳转指令（Conditional-Branch）"><a href="#条件跳转指令（Conditional-Branch）" class="headerlink" title="条件跳转指令（Conditional Branch）"></a>条件跳转指令（Conditional Branch）</h3><p>条件跳转指令的执行过程包括以下几个步骤：</p>
<ol>
<li><p><strong>取指令</strong></p>
<ul>
<li><strong>Memory address ← [PC]</strong>：获取程序计数器（PC）指向的内存地址。</li>
<li><strong>Read memory, IR ← Memory data</strong>：从内存中读取指令，并将其存储到指令寄存器（IR）中。</li>
<li><strong>PC ← [PC] + 4</strong>：程序计数器自增，指向下一条指令。</li>
</ul>
</li>
<li><p><strong>解码指令</strong></p>
<ul>
<li>对指令进行解码，读取寄存器R5和R6的内容：<ul>
<li><strong>RA ← [R5]</strong>：将寄存器R5的内容存储到RA中。</li>
<li><strong>RB ← [R6]</strong>：将寄存器R6的内容存储到RB中。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>比较寄存器值</strong></p>
<ul>
<li><strong>Compare [RA] to [RB]</strong>：将寄存器RA和RB的值进行比较。</li>
<li><strong>If [RA] = [RB], then PC ← [PC] + Branch offset</strong>：如果RA的值与RB相等，程序计数器（PC）将跳转到根据指令中的分支偏移量计算的目标地址。</li>
</ul>
</li>
<li><p><strong>没有其他操作</strong></p>
<ul>
<li><strong>No action</strong>：此步骤不进行其他操作。</li>
</ul>
</li>
<li><p><strong>没有其他操作</strong></p>
<ul>
<li><strong>No action</strong>：此步骤不进行其他操作。</li>
</ul>
</li>
</ol>
<h3 id="比较操作"><a href="#比较操作" class="headerlink" title="比较操作"></a>比较操作</h3><p>为了判断RA和RB是否相等，可以通过执行 <strong>[RA] - [RB]</strong> 的减法操作来完成比较。但是这种做法可能比较耗时，因此可以使用更简单和更快速的比较器来进行此操作，避免消耗过多的时间。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>条件跳转指令通过判断寄存器中的值是否相等来决定是否跳转。取指令并解码后，比较两个寄存器的值，如果相等，则通过更新程序计数器（PC）跳转到目标地址。</p>
<h3 id="子程序调用（带间接寻址）"><a href="#子程序调用（带间接寻址）" class="headerlink" title="子程序调用（带间接寻址）"></a>子程序调用（带间接寻址）</h3><p>子程序调用指令在执行时会进行跳转，并保存当前程序计数器（PC）的值，以便在子程序执行完毕后能够返回。下面是带间接寻址的子程序调用的步骤：</p>
<ol>
<li><p><strong>取指令</strong></p>
<ul>
<li><strong>Memory address ← [PC]</strong>：获取当前程序计数器（PC）指向的内存地址。</li>
<li><strong>Read memory, IR ← Memory data</strong>：从内存中读取数据并存储到指令寄存器（IR）中。</li>
<li><strong>PC ← [PC] + 4</strong>：程序计数器自增，指向下一条指令。</li>
</ul>
</li>
<li><p><strong>解码指令</strong></p>
<ul>
<li>解码当前指令并读取寄存器R9的内容：<ul>
<li><strong>RA ← [R9]</strong>：将寄存器R9中的值存储到寄存器RA中。此值通常是跳转目标的地址，表示要调用的子程序的入口地址。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>保存当前程序计数器（PC）</strong></p>
<ul>
<li><strong>PC Temp ← [PC]</strong>：将当前的程序计数器（PC）的值存储到临时寄存器PC Temp中，准备稍后用来返回。</li>
</ul>
</li>
<li><p><strong>跳转到子程序</strong></p>
<ul>
<li><strong>PC ← [RA]</strong>：将RA中的值作为新的程序计数器（PC），即跳转到子程序的入口地址。</li>
</ul>
</li>
<li><p><strong>保存返回地址</strong></p>
<ul>
<li><strong>RY ← PC Temp</strong>：将临时保存的程序计数器值（PC Temp）存储到寄存器RY中，以便子程序结束后可以返回。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123230014618.png" alt="image-20241123230014618"></p>
<h3 id="等待内存（Wait-for-Memory）"><a href="#等待内存（Wait-for-Memory）" class="headerlink" title="等待内存（Wait for Memory）"></a>等待内存（Wait for Memory）</h3><p>在计算机系统中，内存访问操作通常分为两个主要情境：</p>
<ol>
<li><p><strong>缓存命中</strong>：</p>
<ul>
<li>当所需的指令或数据在缓存中找到时，内存读写操作通常会在一个时钟周期内完成。</li>
</ul>
</li>
<li><p><strong>缓存未命中</strong>：</p>
<ul>
<li>当所需的数据不在缓存中，需要从主内存中提取时，可能需要多个时钟周期才能完成操作。</li>
</ul>
</li>
</ol>
<h4 id="内存完成信号-MFC"><a href="#内存完成信号-MFC" class="headerlink" title="内存完成信号 (MFC)"></a>内存完成信号 (MFC)</h4><ul>
<li><strong>MFC (Memory Function Completed)</strong> 信号：用于指示内存操作是否已完成。<ul>
<li>当数据在缓存中时，<strong>MFC信号</strong>会在发出内存请求的同一时钟周期结束之前生成，意味着操作在一个时钟周期内完成。</li>
<li>如果需要访问主内存，<strong>MFC信号</strong>的响应会延迟，直到内存操作完成，这个过程会延续多个时钟周期。</li>
</ul>
</li>
</ul>
<h4 id="步骤-1：指令执行中的内存等待"><a href="#步骤-1：指令执行中的内存等待" class="headerlink" title="步骤 1：指令执行中的内存等待"></a>步骤 1：指令执行中的内存等待</h4><p>在每条指令的执行过程中，第一步包括等待MFC信号：</p>
<ul>
<li><strong>Memory address ← [PC]</strong>：根据程序计数器（PC）获取内存地址。</li>
<li><strong>Read memory</strong>：从内存中读取数据。</li>
<li><strong>Wait for MFC</strong>：等待内存操作完成信号（MFC）。</li>
<li><strong>IR ← Memory data</strong>：将从内存读取的数据加载到指令寄存器（IR）中。</li>
<li><strong>PC ← [PC] + 4</strong>：程序计数器自增，指向下一条指令。</li>
</ul>
<h4 id="加载和存储指令中的MFC等待"><a href="#加载和存储指令中的MFC等待" class="headerlink" title="加载和存储指令中的MFC等待"></a>加载和存储指令中的MFC等待</h4><p>对于加载（Load）和存储（Store）指令，在步骤 4 中也需要等待 MFC 信号，确保内存操作完成后，数据才能继续传输和处理。</p>
<h3 id="精华所在"><a href="#精华所在" class="headerlink" title="精华所在"></a>精华所在</h3><p>“等待内存”主要是处理缓存命中与未命中的两种情形。通过使用 MFC 信号，系统能够有效地同步内存访问操作，确保在缓存未命中的情况下仍能完成指令执行，但会消耗更多的时钟周期。</p>
<h2 id="控制信号-Control-Signals"><a href="#控制信号-Control-Signals" class="headerlink" title="控制信号 (Control Signals)"></a>控制信号 (Control Signals)</h2><p>在处理器中，硬件组件的操作由<strong>控制信号</strong>来管理。这些信号确保数据流动的正确性和操作执行的顺利进行，具体功能包括：</p>
<ol>
<li><p><strong>控制多路复用器选择</strong>：</p>
<ul>
<li>控制信号用于选择正确的数据流路径，指导数据在各个硬件单元之间的流动。比如，通过控制多路复用器（Mux），可以选择从寄存器、ALU或内存读取的数据。</li>
</ul>
</li>
<li><p><strong>设置ALU的功能</strong>：</p>
<ul>
<li>ALU（算术逻辑单元）的功能由控制信号来设定。控制信号决定ALU执行哪种运算（例如加法、减法、与运算、或运算等）。</li>
</ul>
</li>
<li><p><strong>确定何时写入数据</strong>：</p>
<ul>
<li>控制信号还决定数据什么时候写入到以下几个地方：<ul>
<li>程序计数器（PC）</li>
<li>指令寄存器（IR）</li>
<li>寄存器文件</li>
<li>内存<br>这些操作的时序和选择会影响程序执行的进度。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>跨阶段寄存器始终启用</strong>：</p>
<ul>
<li>在处理器的多个阶段之间，寄存器用于传递数据。控制信号确保跨阶段寄存器始终处于启用状态，以便能正确地传递数据。</li>
</ul>
</li>
</ol>
<h2 id="寄存器文件控制信号-Register-File-Control-Signals"><a href="#寄存器文件控制信号-Register-File-Control-Signals" class="headerlink" title="寄存器文件控制信号 (Register File Control Signals)"></a>寄存器文件控制信号 (Register File Control Signals)</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123231447429.png" alt="image-20241123231447429"></p>
<h2 id="ALU-control-signals"><a href="#ALU-control-signals" class="headerlink" title="ALU control signals"></a>ALU control signals</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123231505490.png" alt="image-20241123231505490"></p>
<h2 id="Result-selection"><a href="#Result-selection" class="headerlink" title="Result selection"></a>Result selection</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123231526084.png" alt="image-20241123231526084"></p>
<h2 id="内存访问-Memory-Access"><a href="#内存访问-Memory-Access" class="headerlink" title="内存访问 (Memory Access)"></a>内存访问 (Memory Access)</h2><ol>
<li><p><strong>缓存内存</strong>：</p>
<ul>
<li>缓存内存是比主内存更快但更小的存储器，作为主内存的辅助存储器，用于提高数据访问速度。</li>
<li>缓存内存的作用是加速对常用数据的访问。若数据已经存在于缓存中，内存访问可以在一个时钟周期内完成。</li>
</ul>
</li>
<li><p><strong>访问主内存</strong>：</p>
<ul>
<li>当数据未在缓存中时，读取或写入操作可能需要多个时钟周期，从主内存加载数据到缓存中。</li>
</ul>
</li>
<li><p><strong>MFC 控制信号</strong>：</p>
<ul>
<li><p>需要一个控制信号来指示内存操作已完成，通常这个信号被称为 <strong>Memory Function Completed (MFC)</strong> 信号。</p>
</li>
<li><p>例如，在指令获取步骤1中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1. 内存地址 &lt;- [PC], 读取内存，等待 MFC 信号，IR &lt;- 内存数据，PC &lt;- [PC] + 4</span><br></pre></td></tr></table></figure>
</li>
<li><p>这表明在内存操作完成之前，必须等待 MFC 信号，以确保数据正确加载。</p>
</li>
</ul>
</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li>缓存内存的引入大大提高了内存访问的速度，减少了从主内存读取数据的时间。</li>
<li>当数据不在缓存中时，需要通过主内存加载，并且通过 MFC 控制信号来确保操作完成，防止在数据准备好之前进行后续处理。</li>
</ul>
<h2 id="Memory-and-IR-control-signals"><a href="#Memory-and-IR-control-signals" class="headerlink" title="Memory and IR control signals"></a>Memory and IR control signals</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123231638070.png" alt="image-20241123231638070"></p>
<h2 id="Control-signals-of-instruction-address-generator"><a href="#Control-signals-of-instruction-address-generator" class="headerlink" title="Control signals of instruction address generator"></a>Control signals of instruction address generator</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123231658898.png" alt="image-20241123231658898"></p>
<h2 id="5-6-硬连线控制-Hardwired-Control"><a href="#5-6-硬连线控制-Hardwired-Control" class="headerlink" title="5.6 硬连线控制 (Hardwired Control)"></a>5.6 硬连线控制 (Hardwired Control)</h2><ol>
<li><p><strong>简介</strong>：</p>
<ul>
<li>我们已经描述了指令的获取和执行过程，以及执行这些操作所需的控制信号。</li>
<li>但是，如何生成这些控制信号，并确保操作按照正确的顺序和时机执行呢？</li>
</ul>
</li>
<li><p><strong>控制信号生成</strong>：</p>
<ul>
<li>控制信号是用于驱动硬件执行特定操作的信号。</li>
<li>要确保每个步骤都按顺序执行并在合适的时机进行，需要设计合适的控制信号。</li>
</ul>
</li>
<li><p><strong>两种基本方法</strong>：</p>
<ul>
<li><p><strong>硬连线控制（Hardwired Control）</strong>：</p>
<ul>
<li>硬连线控制是通过组合逻辑电路来生成控制信号，硬件直接决定指令的执行。</li>
<li>这种方法实现速度快，但灵活性较低，不易修改或扩展。</li>
</ul>
</li>
<li><p><strong>微程序控制（Microprogramming）</strong>：</p>
<ul>
<li>微程序控制使用一组存储在内存中的微指令来生成控制信号，控制信号的生成是通过软件编程来实现的。</li>
<li>这种方法灵活性较高，但速度相对较慢。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>硬连线控制</strong>通过硬件逻辑来生成控制信号，适用于要求高速度的场景。</li>
<li><strong>微程序控制</strong>则通过存储的微指令灵活控制，适用于更复杂的操作，但执行速度较慢。</li>
</ul>
<h2 id="硬连线控制信号生成-Hardwired-Generation-of-Control-Signals"><a href="#硬连线控制信号生成-Hardwired-Generation-of-Control-Signals" class="headerlink" title="硬连线控制信号生成 (Hardwired Generation of Control Signals)"></a>硬连线控制信号生成 (Hardwired Generation of Control Signals)</h2><ol>
<li><p><strong>硬连线控制概述</strong>：</p>
<ul>
<li>硬连线控制涉及实现电路，这些电路需要考虑<strong>步骤计数器</strong>、<strong>指令寄存器（IR）</strong>、<strong>ALU 结果</strong>以A及外部输入（如 MFC 信号、中断请求等）。</li>
</ul>
</li>
<li><p><strong>步骤计数器</strong>：</p>
<ul>
<li><strong>步骤计数器</strong>用于跟踪指令执行的进度。</li>
<li>每个时钟周期对应前述五个步骤中的一个步骤。</li>
<li>步骤计数器帮助控制信号按顺序生成，以确保每个操作按正确的顺序执行。</li>
</ul>
</li>
<li><p><strong>信号生成的依据</strong>：</p>
<ul>
<li>通过<strong>硬件电路</strong>，控制信号根据步骤计数器、IR的内容、ALU的计算结果以及外部信号（如内存操作完成信号 MFC 或中断请求）来生成。</li>
<li>硬连线控制通过直接的逻辑运算来产生所需的控制信号，使得操作能够自动且迅速地进行。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123231836628.png" alt="image-20241123231836628"></p>
<h2 id="硬连线控制信号生成-Hardwired-Generation-of-Control-Signals-1"><a href="#硬连线控制信号生成-Hardwired-Generation-of-Control-Signals-1" class="headerlink" title="硬连线控制信号生成 (Hardwired Generation of Control Signals)"></a>硬连线控制信号生成 (Hardwired Generation of Control Signals)</h2><ol>
<li><p><strong>指令解码器</strong>：</p>
<ul>
<li>指令解码器通过解读<strong>指令寄存器（IR）</strong>中的操作码（OP code）和寻址模式信息，并将对应的<strong>INSi</strong>输出设置为1，从而确定当前执行的操作。</li>
</ul>
</li>
<li><p><strong>步骤计数器</strong>：</p>
<ul>
<li>在每个时钟周期，<strong>步骤计数器</strong>的T1至T5之一的输出被设置为1，指示当前正在执行五个步骤中的哪个步骤。</li>
</ul>
</li>
<li><p><strong>控制信号生成器</strong>：</p>
<ul>
<li>控制信号生成器是一个组合逻辑电路，它根据输入信号（如INS、T、E、F等）生成相应的控制信号。</li>
<li>输入信号包括：INS（指令寄存器）、T（步骤计数器的输出）、E（外部输入信号）、F（功能信号）。</li>
<li>输出信号是C（控制信号），其生成是输入信号的某种函数。</li>
</ul>
</li>
</ol>
<h3 id="硬连线控制的功能"><a href="#硬连线控制的功能" class="headerlink" title="硬连线控制的功能"></a>硬连线控制的功能</h3><ul>
<li><strong>输入</strong>：INS、T、E、F</li>
<li><strong>输出</strong>：C = f(INS, T, E, F)，控制信号是根据上述输入信号计算出来的。</li>
</ul>
<h3 id="步骤1：指令执行过程的硬连线控制"><a href="#步骤1：指令执行过程的硬连线控制" class="headerlink" title="步骤1：指令执行过程的硬连线控制"></a>步骤1：指令执行过程的硬连线控制</h3><p>考虑执行过程中的步骤1：</p>
<ol>
<li><strong>新指令取指</strong>：在此步骤中，新指令被取出，并通过T1信号被识别。</li>
<li><strong>MA_select设置为1</strong>：这时选择程序计数器（PC）作为内存地址的来源。</li>
<li><strong>MEM_read激活</strong>：启动内存读取操作，取出指令数据。</li>
<li><strong>IR寄存器加载</strong>：当内存操作完成（MFC信号被触发）时，激活IR_enable信号将指令加载到指令寄存器中。</li>
<li><strong>PC增加4</strong>：通过设置<strong>INC_select为0</strong>和<strong>PC_select为1</strong>，程序计数器（PC）增加4，指向下一条指令。</li>
<li><strong>PC_enable激活</strong>：在时钟正边沿（步骤T1结束时），激活PC_enable信号，将新的PC值加载到程序计数器中。</li>
</ol>
<h3 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h3><p>硬连线控制通过组合电路和步骤计数器控制指令的执行过程，每个步骤都有相应的信号来激活所需的操作。</p>
<h3 id="数据路径控制信号-Datapath-Control-Signals"><a href="#数据路径控制信号-Datapath-Control-Signals" class="headerlink" title="数据路径控制信号 (Datapath Control Signals)"></a>数据路径控制信号 (Datapath Control Signals)</h3><ol>
<li><p><strong>控制信号的生成</strong>：</p>
<ul>
<li>每条指令在执行过程中有多个步骤，每个步骤需要相应的控制信号来指导数据的流动和操作的执行。</li>
<li>控制信号的设定可以通过检查每个执行步骤中所采取的动作来确定。</li>
</ul>
</li>
<li><p><strong>RF_write 信号</strong>：</p>
<ul>
<li>例如，<strong>RF_write</strong> 信号在步骤 <strong>T5</strong> 中被设定为 1。它可以通过以下逻辑表达式生成：<br>[<br>\text{RF_write} = T5 \cdot (\text{ALU} + \text{Load} + \text{Call})<br>]</li>
<li>这意味着 <strong>RF_write</strong> 信号既是指令操作的一部分，又依赖于时序信号。</li>
</ul>
</li>
<li><p><strong>选择信号的设定</strong>：</p>
<ul>
<li>一些多路选择器的设置在不同的时序步骤中可能保持不变。例如，<strong>B_select</strong> 信号在所有需要使用立即数（Immediate）的指令中都会设为 <strong>Immediate</strong>。</li>
<li><strong>Immediate</strong> 代表的是所有在指令寄存器（IR）中使用立即数的指令。</li>
</ul>
</li>
</ol>
<h3 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h3><ul>
<li>控制信号的生成不仅依赖于指令本身的类型，还受到执行步骤的时序控制。控制信号的设置是由时序信号（如T5等）和操作信号（如ALU、Load、Call等）共同决定的。</li>
</ul>
<h3 id="处理内存延迟-Dealing-with-Memory-Delay"><a href="#处理内存延迟-Dealing-with-Memory-Delay" class="headerlink" title="处理内存延迟 (Dealing with Memory Delay)"></a>处理内存延迟 (Dealing with Memory Delay)</h3><ol>
<li><p><strong>时序信号 T1 到 T5</strong>：</p>
<ul>
<li>这些时序信号按顺序触发，当步骤计数器（step counter）推进时。</li>
<li>通常情况下，步骤计数器在每个时钟周期结束时递增。</li>
</ul>
</li>
<li><p><strong>内存读取和写入操作的延迟</strong>：</p>
<ul>
<li>在发出 <strong>MEM_read</strong> 或 <strong>MEM_write</strong> 命令时，该步骤在 <strong>MFC</strong>（Memory Function Completed）信号被触发之前不会结束。</li>
<li>为了处理这种延迟，需要禁用步骤计数器，以便将执行步骤的持续时间延长为多个时钟周期。</li>
</ul>
</li>
<li><p><strong>禁用步骤计数器</strong>：</p>
<ul>
<li>使用 <strong>Counter_enable = WMFC + MFC</strong> 来控制步骤计数器的使能。</li>
<li>当 <strong>WMFC</strong>（Write MFC）没有触发或 <strong>MFC</strong> 已触发时，<strong>Counter_enable</strong> 信号被设置为 1。</li>
</ul>
</li>
<li><p><strong>确保 PC 仅在特定条件下递增</strong>：</p>
<ul>
<li>当一个执行步骤延长为多个时钟周期时，需要确保程序计数器（PC）只在适当的时候递增。</li>
<li>在获取指令时，只有当接收到 <strong>MFC</strong> 信号时，PC 才能启用递增。</li>
<li>对于需要跳转的指令（如分支指令），在 <strong>T3</strong> 步骤中也需要启用 PC。</li>
</ul>
</li>
<li><p><strong>PC 的使能</strong>：</p>
<ul>
<li><strong>PC_enable = T1 · MFC + T3 · BR</strong><ul>
<li>在 <strong>T1</strong> 步骤且 <strong>MFC</strong> 信号触发时，PC 会被使能；</li>
<li>在分支指令（<strong>BR</strong>）的 <strong>T3</strong> 步骤中，PC 也会被使能。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="总结：-6"><a href="#总结：-6" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>MFC</strong> 信号的处理是保证指令执行步骤按时完成的关键，特别是在涉及内存读写操作时。通过适当的时序控制和禁用步骤计数器，可以确保 PC 的递增行为和执行步骤的时间协调。</li>
</ul>
<h3 id="5-7-CISC-风格处理器-CISC-style-Processors"><a href="#5-7-CISC-风格处理器-CISC-style-Processors" class="headerlink" title="5.7 CISC 风格处理器 (CISC-style Processors)"></a>5.7 CISC 风格处理器 (CISC-style Processors)</h3><ol>
<li><p><strong>CISC 处理器的特点</strong>：</p>
<ul>
<li>CISC（复杂指令集计算机）风格的处理器具有更多复杂的指令。</li>
<li>不同的指令可能包含不同的操作数、操作类型和操作模式，因此每条指令的执行步骤可能会有所不同。</li>
</ul>
</li>
<li><p><strong>执行步骤的灵活性</strong>：</p>
<ul>
<li><strong>CISC 处理器的指令集合</strong>：完整的指令集合不能在固定数量的步骤中实现，因为某些指令需要执行的步骤较多。</li>
<li><strong>执行步骤的变化</strong>：不同的指令的执行步骤可能不遵循固定的顺序，指令执行可能会根据操作类型或操作数类型的不同而有所变化。</li>
</ul>
</li>
<li><p><strong>硬件组织的要求</strong>：</p>
<ul>
<li>为了适应 CISC 风格的灵活性，硬件组织需要支持数据流和操作流程的灵活管理。</li>
<li>这意味着硬件结构必须能够处理多种不同的指令格式和不同的执行路径。</li>
</ul>
</li>
</ol>
<h3 id="总结：-7"><a href="#总结：-7" class="headerlink" title="总结："></a>总结：</h3><p>CISC 处理器通过更复杂的指令集提供强大的功能，但也要求硬件能够灵活地适应不同的指令执行需求，因此需要更复杂的数据流控制和硬件设计。</p>
<h2 id="Hardware-organization-for-a-CISC-computer"><a href="#Hardware-organization-for-a-CISC-computer" class="headerlink" title="Hardware organization for a CISC computer"></a>Hardware organization for a CISC computer</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123232452032.png" alt="image-20241123232452032"></p>
<h2 id="总线-Bus"><a href="#总线-Bus" class="headerlink" title="总线 (Bus)"></a>总线 (Bus)</h2><ol>
<li><p><strong>总线概述</strong>：</p>
<ul>
<li>总线是一种常见的互联网络 (interconnection network)，用于连接系统中不同的功能单元。</li>
<li>在总线系统中，数据在多个模块之间传输，通常会有一个共享的传输通道。</li>
</ul>
</li>
<li><p><strong>三态驱动器 (Tri-state driver)</strong>：</p>
<ul>
<li>当多个功能单元共享一条总线时，使用<strong>三态驱动器</strong>来控制信号。</li>
<li><strong>三态驱动器</strong>具有三种状态：驱动高电平、驱动低电平和高阻态（即不驱动信号）。通过这种方式，多个模块可以按需在总线上传递信号，而不发生冲突。</li>
</ul>
</li>
<li><p><strong>总线数据加载</strong>：</p>
<ul>
<li>当<code>R_in = 1</code>时，<strong>多路复用器</strong>选择总线上的数据，并将其加载到<strong>触发器</strong>中。</li>
<li><strong>触发器</strong>的输出连接到总线线，通过<strong>三态门</strong>将其输出。当<code>R_out = 1</code>时，三态门被打开，使触发器的输出连接到总线上。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123233121550.png" alt="image-20241123233121550"></p>
<h3 id="三总线互连网络-A-3-bus-interconnection-network"><a href="#三总线互连网络-A-3-bus-interconnection-network" class="headerlink" title="三总线互连网络 (A 3-bus interconnection network)"></a>三总线互连网络 (A 3-bus interconnection network)</h3><ol>
<li><strong>三总线系统</strong>：<ul>
<li>在三总线系统中，数据通过三个独立的总线进行传输，能够更高效地在多个功能单元之间共享数据。</li>
<li>每个总线可能有不同的功能，提供不同的连接路径，以支持复杂的数据流动。</li>
</ul>
</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123233305340.png" alt="image-20241123233305340"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123233314221.png" alt="image-20241123233314221"></p>
<h3 id="总结：-8"><a href="#总结：-8" class="headerlink" title="总结："></a>总结：</h3><p>总线是计算机内部用于连接不同模块的数据传输通道。通过三态驱动器，多个模块可以在同一总线上安全地发送和接收数据。三总线系统提供了更多的路径和灵活性，使得多个功能单元可以更高效地进行数据交换。</p>
<h2 id="示例：加法指令-Add-R5-R6"><a href="#示例：加法指令-Add-R5-R6" class="headerlink" title="示例：加法指令 Add R5, R6"></a>示例：加法指令 <code>Add R5, R6</code></h2><ol>
<li><p><strong>步骤 1：获取指令</strong></p>
<ul>
<li>内存地址&lt;-[PC]：从程序计数器（PC）获取内存地址。</li>
<li>读取内存，等待 MFC：从内存中读取数据，并等待内存操作完成信号（MFC）。</li>
<li>IR&lt;-内存数据：将从内存读取到的数据加载到指令寄存器（IR）中。</li>
<li>PC&lt;-[PC] + 4：程序计数器加 4，指向下一条指令的地址。</li>
</ul>
</li>
<li><p><strong>步骤 2：解码指令</strong></p>
<ul>
<li>解析指令寄存器（IR）中的操作码，确定该执行加法操作。</li>
<li>确定源寄存器和目标寄存器（此例中为 R5 和 R6）。</li>
</ul>
</li>
<li><p><strong>步骤 3：执行加法</strong></p>
<ul>
<li>R5&lt;-[R5] + [R6]：将寄存器 R6 的值与 R5 中的值相加，并将结果存储回 R5。</li>
</ul>
</li>
</ol>
<h3 id="示例：And-X-R7-R9-指令"><a href="#示例：And-X-R7-R9-指令" class="headerlink" title="示例：And X(R7), R9 指令"></a>示例：<code>And X(R7), R9</code> 指令</h3><p>假设偏移量 X 是一个 32 位的值，作为指令的第二个字。</p>
<h3 id="步骤-1：获取操作码"><a href="#步骤-1：获取操作码" class="headerlink" title="步骤 1：获取操作码"></a>步骤 1：获取操作码</h3><ul>
<li>首先，获取指令的操作码（OP code）。这一步骤是指从内存中读取指令的第一部分，即操作码。</li>
</ul>
<h3 id="步骤-2：解码并获取偏移量-X"><a href="#步骤-2：解码并获取偏移量-X" class="headerlink" title="步骤 2：解码并获取偏移量 X"></a>步骤 2：解码并获取偏移量 X</h3><ul>
<li>在指令解码过程中，当解码电路识别到使用 <strong>索引寻址模式</strong>（Index addressing mode）时，它会从指令中提取出偏移量 X。此时，偏移量 X 会作为指令的第二个字被提取。</li>
</ul>
<h3 id="步骤-3：执行操作"><a href="#步骤-3：执行操作" class="headerlink" title="步骤 3：执行操作"></a>步骤 3：执行操作</h3><ul>
<li>执行 <strong>AND</strong> 操作。操作数是内存地址 <code>X(R7)</code>（即基址为 R7，偏移量为 X）和寄存器 R9。该操作会将 R9 的值与 <code>X(R7)</code> 位置的数据进行 AND 运算，并将结果存储回寄存器 R9。</li>
</ul>
<h2 id="微程序设计（Microprogramming）"><a href="#微程序设计（Microprogramming）" class="headerlink" title="微程序设计（Microprogramming）"></a>微程序设计（Microprogramming）</h2><p>微程序设计是一种基于软件的生成控制信号的方式。它通过存储在微指令中的控制信号来控制处理器操作。</p>
<h4 id="微程序设计的工作原理："><a href="#微程序设计的工作原理：" class="headerlink" title="微程序设计的工作原理："></a>微程序设计的工作原理：</h4><ol>
<li><p><strong>微指令存储</strong>：</p>
<ul>
<li>每个时钟周期的控制信号的值存储在一个微指令（控制字）中。</li>
<li>每个控制信号对应控制字中的一个比特。</li>
</ul>
</li>
<li><p><strong>微程序</strong>：</p>
<ul>
<li>处理器指令通过一系列微指令（微程序或微例程）来实现，这些微指令被存储在控制存储器中。</li>
<li>每条处理器指令的执行都对应一系列微指令的执行。</li>
</ul>
</li>
<li><p><strong>控制信号的生成</strong>：</p>
<ul>
<li>在解码指令时，指令寄存器（IR）会提供信息，控制电路根据这些信息执行相应的微指令序列。</li>
<li>这些微指令通过控制存储器从控制信号生成。</li>
</ul>
</li>
<li><p><strong>PC（程序计数器）</strong>：</p>
<ul>
<li><strong>PC</strong> 用来保持当前微指令的位置，指示下一条将要执行的微指令。</li>
</ul>
</li>
</ol>
<h4 id="微程序设计的优点："><a href="#微程序设计的优点：" class="headerlink" title="微程序设计的优点："></a>微程序设计的优点：</h4><ul>
<li>微程序设计比硬件控制更加灵活，可以通过修改微程序来改变处理器的控制逻辑，而无需更改硬件。</li>
</ul>
<h1 id="Quiz"><a href="#Quiz" class="headerlink" title="Quiz"></a>Quiz</h1><h2 id="选择题-1：硬件控制单元中，所需的控制信号是通过以下信息确定的，除了："><a href="#选择题-1：硬件控制单元中，所需的控制信号是通过以下信息确定的，除了：" class="headerlink" title="选择题 1：硬件控制单元中，所需的控制信号是通过以下信息确定的，除了："></a>选择题 1：硬件控制单元中，所需的控制信号是通过以下信息确定的，除了：</h2><p>A. 控制步骤计数器的内容<br>B. 条件码标志的内容<br>C. 指令寄存器的内容<br>D. 程序计数器的内容  </p>
<h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a>答案解析：</h4><p>硬件控制单元中的控制信号通常依赖以下内容：</p>
<ul>
<li><strong>A</strong>（控制步骤计数器的内容）：控制步骤计数器记录指令执行的步骤，影响控制信号的生成。</li>
<li><strong>C</strong>（指令寄存器的内容）：指令寄存器存储当前执行的指令，决定要执行哪些操作。</li>
<li><strong>D</strong>（程序计数器的内容）：程序计数器指向下一条要执行的指令，控制指令的流。</li>
</ul>
<p><strong>B</strong>（条件码标志的内容）通常与指令执行后的结果相关，特别是在做分支或条件跳转时，但并不直接用于硬件控制单元的信号生成。因此，<strong>B</strong> 不是硬件控制单元所需的直接输入信息。</p>
<h2 id="选择题-2：在微程序控制的机器中，机器指令所需的控制信号是由以下哪项生成的？"><a href="#选择题-2：在微程序控制的机器中，机器指令所需的控制信号是由以下哪项生成的？" class="headerlink" title="选择题 2：在微程序控制的机器中，机器指令所需的控制信号是由以下哪项生成的？"></a>选择题 2：在微程序控制的机器中，机器指令所需的控制信号是由以下哪项生成的？</h2><p>A. 控制存储器 (control store)<br>B. 控制字 (control word)<br>C. 微例程 (microroutine)<br>D. 微指令 (microinstruction)  </p>
<h3 id="答案解析：-1"><a href="#答案解析：-1" class="headerlink" title="答案解析："></a>答案解析：</h3><p>在微程序控制的机器中，<strong>微指令</strong>（D）用于生成控制信号。每个微指令指定一个或多个控制信号，定义了机器操作的细节。多个微指令组合成一个<strong>微例程</strong>（C），而<strong>控制存储器</strong>（A）用于存储这些微指令。</p>
<ul>
<li><strong>A</strong>（控制存储器）：用于存储微程序（微指令）。</li>
<li><strong>B</strong>（控制字）：是微指令的一部分，它由多个控制信号的位组成，用来具体控制硬件操作。</li>
<li><strong>C</strong>（微例程）：是由一系列微指令组成的控制序列，用于完成某个机器指令的执行。</li>
<li><strong>D</strong>（微指令）：直接生成控制信号，指示硬件执行特定的操作。</li>
</ul>
<p>因此，<strong>D（微指令）</strong>是生成机器指令所需控制信号的直接来源。</p>
<h2 id="选择题-3：计算机指令集中所有指令的微程序存储在一个特殊的存储器中，这个存储器叫做？"><a href="#选择题-3：计算机指令集中所有指令的微程序存储在一个特殊的存储器中，这个存储器叫做？" class="headerlink" title="选择题 3：计算机指令集中所有指令的微程序存储在一个特殊的存储器中，这个存储器叫做？"></a>选择题 3：计算机指令集中所有指令的微程序存储在一个特殊的存储器中，这个存储器叫做？</h2><p>A. 内存控制器 (memory controller)<br>B. 主存 (main memory)<br>C. 缓存 (cache)<br>D. 控制存储器 (control store)  </p>
<h3 id="答案解析：-2"><a href="#答案解析：-2" class="headerlink" title="答案解析："></a>答案解析：</h3><p><strong>D. 控制存储器 (control store)</strong> 是用来存储计算机所有指令的微程序的地方。每条指令的执行都由一系列微指令来控制，这些微指令通常存储在控制存储器中。</p>
<ul>
<li><strong>A. 内存控制器</strong>：控制存储器的访问，但不是存储微程序的地方。</li>
<li><strong>B. 主存</strong>：用于存储程序和数据，而非微程序。</li>
<li><strong>C. 缓存</strong>：用于加速数据访问，不存储微程序。</li>
<li><strong>D. 控制存储器</strong>：专门用于存储微程序，控制指令的执行。</li>
</ul>
<p>因此，正确答案是 <strong>D. 控制存储器</strong>。</p>
<h2 id="选择题-4：在微程序控制的计算机中，机器指令和微指令之间的关系是？"><a href="#选择题-4：在微程序控制的计算机中，机器指令和微指令之间的关系是？" class="headerlink" title="选择题 4：在微程序控制的计算机中，机器指令和微指令之间的关系是？"></a>选择题 4：在微程序控制的计算机中，机器指令和微指令之间的关系是？</h2><p>A. 一条机器指令由一条微指令执行<br>B. 一条微指令由若干机器指令组成<br>C. 一条机器指令由一段微程序执行，微程序由若干微指令组成<br>D. 以上都不对</p>
<h3 id="答案解析：-3"><a href="#答案解析：-3" class="headerlink" title="答案解析："></a>答案解析：</h3><p><strong>C. 一条机器指令由一段微程序执行，微程序由若干微指令组成</strong> 是正确的。</p>
<p>在微程序控制的计算机中，机器指令的执行是通过微程序来实现的。微程序由一系列微指令组成，每条机器指令都需要一个特定的微程序来执行。</p>
<ul>
<li><strong>A. 一条机器指令由一条微指令执行</strong>：不正确，因为机器指令通常需要多个微指令来执行。</li>
<li><strong>B. 一条微指令由若干机器指令组成</strong>：不正确，微指令控制机器指令的执行，而不是由机器指令组成。</li>
<li><strong>C. 一条机器指令由一段微程序执行，微程序由若干微指令组成</strong>：这是微程序控制机器的正确描述。</li>
</ul>
<p>因此，正确答案是 <strong>C. 一条机器指令由一段微程序执行，微程序由若干微指令组成</strong>。</p>
<h2 id="选择题-5：硬件控制与微程序控制的优缺点是什么？"><a href="#选择题-5：硬件控制与微程序控制的优缺点是什么？" class="headerlink" title="选择题 5：硬件控制与微程序控制的优缺点是什么？"></a>选择题 5：硬件控制与微程序控制的优缺点是什么？</h2><p><strong>硬件控制的主要优点：</strong></p>
<ul>
<li><strong>快速操作</strong>：硬件控制由于是通过直接电路实现的，因此能够在每个时钟周期内迅速产生控制信号，从而提供更高的执行速度。</li>
</ul>
<p><strong>硬件控制的缺点：</strong></p>
<ul>
<li><strong>成本较高</strong>：硬件控制需要复杂的电路设计，通常会导致较高的生产成本。</li>
<li><strong>缺乏灵活性</strong>：一旦设计完成，硬件控制系统难以修改或扩展，增加新功能或改变现有功能通常需要重新设计硬件。</li>
<li><strong>设计和实现时间较长</strong>：设计和实现硬件控制系统比微程序控制要更耗时，因为它涉及到硬件电路的设计和验证。</li>
</ul>
<p><strong>微程序控制的主要优点：</strong></p>
<ul>
<li><strong>低成本</strong>：微程序控制的设计和实现依赖于存储程序（微程序），通常成本较低，因为它不需要专门的硬件电路。</li>
<li><strong>高灵活性</strong>：微程序控制可以通过修改微程序来改变机器的行为，不需要硬件上的重大更改，具有更高的灵活性。</li>
</ul>
<p><strong>微程序控制的缺点：</strong></p>
<ul>
<li><strong>操作速度较慢</strong>：由于每条机器指令由多个微指令执行，且微指令需要通过内存读取，微程序控制的速度较硬件控制慢，可能不适用于高性能计算机。</li>
</ul>
<h3 id="总结：-9"><a href="#总结：-9" class="headerlink" title="总结："></a>总结：</h3><ul>
<li><strong>硬件控制</strong>具有<strong>快速操作</strong>的优点，但存在<strong>成本高、灵活性差</strong>的缺点。</li>
<li><strong>微程序控制</strong>具有<strong>低成本和高灵活性</strong>的优点，但<strong>操作速度较慢</strong>，可能不适合高性能计算。</li>
</ul>
<h2 id="选择题-6："><a href="#选择题-6：" class="headerlink" title="选择题 6："></a>选择题 6：</h2><p><strong>问题描述：</strong><br>使用5级RISC处理器执行以下指令：<br><code>Load R4, 100(R2)</code><br>该处理器的数据路径和所有控制信号如图所示。</p>
<hr>
<p><strong>简要分析：</strong><br>这道题目考察了如何通过RISC处理器的五个阶段执行指令 <code>Load R4, 100(R2)</code>。<br>在RISC体系结构中，典型的5阶段指令周期包括：  </p>
<ol>
<li><strong>取指阶段 (IF)</strong>: 从内存中取指令，并更新程序计数器 (PC)。</li>
<li><strong>解码阶段 (ID)</strong>: 解码指令，读取源寄存器 (如R2)，并进行必要的操作。</li>
<li><strong>执行阶段 (EX)</strong>: 计算地址，基于 <code>100(R2)</code> 计算出内存地址。</li>
<li><strong>内存访问阶段 (MEM)</strong>: 根据计算出的地址，访问内存并将数据加载到寄存器。</li>
<li><strong>写回阶段 (WB)</strong>: 将从内存读取的数据存储到目标寄存器 R4 中。</li>
</ol>
<hr>
<p><strong>数据路径和控制信号：</strong>  </p>
<ul>
<li><strong>取指阶段 (IF)</strong>：  <ul>
<li>使用 <code>PC</code> 生成内存地址，读取指令到 IR，PC 增加 4。</li>
</ul>
</li>
<li><strong>解码阶段 (ID)</strong>：  <ul>
<li>解码指令，<code>R2</code> 的内容加载到 <code>RA</code>。</li>
</ul>
</li>
<li><strong>执行阶段 (EX)</strong>：  <ul>
<li>计算内存地址，<code>R2</code> 中的数据与偏移量 <code>100</code> 相加，结果存储在 <code>RZ</code> 中。</li>
</ul>
</li>
<li><strong>内存阶段 (MEM)</strong>：  <ul>
<li>通过计算出的地址，访问内存并将数据加载到 <code>RY</code>。</li>
</ul>
</li>
<li><strong>写回阶段 (WB)</strong>：  <ul>
<li>将内存中读取的数据写回到寄存器 <code>R4</code>。</li>
</ul>
</li>
</ul>
<p>在这个过程中，控制信号将决定各个阶段如何执行，如选择寄存器文件、控制内存读写、ALU 操作等。</p>
<h2 id="选择题-7："><a href="#选择题-7：" class="headerlink" title="选择题 7："></a>选择题 7：</h2><p><strong>问题描述：</strong><br>(1) 写出在执行指令 <code>Load R4, 100(R2)</code> 时第 3 阶段、第 4 阶段和第 5 阶段需要执行的动作。<br>(2) 写出第 3 阶段的 <code>B_select</code>、第 4 阶段的 <code>Y_select</code> 和第 5 阶段的 <code>RF_write</code> 控制信号的值。  </p>
<ul>
<li><strong>答案：</strong>  <ul>
<li><code>B_select = 1</code>  </li>
<li><code>Y_select = 01</code>  </li>
<li><code>RF_write = 1</code>  </li>
</ul>
</li>
</ul>
<hr>
<p><strong>解析：</strong></p>
<ol>
<li><p><strong>阶段 3（执行阶段）：</strong>  </p>
<ul>
<li>在这个阶段，计算内存地址。  </li>
<li>执行：  <ul>
<li>通过将寄存器 <code>R2</code> 中的值与偏移量 <code>100</code> 相加，计算出内存地址。  </li>
<li>结果存储在 <code>RZ</code> 寄存器中。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>阶段 4（内存访问阶段）：</strong>  </p>
<ul>
<li>在这个阶段，访问内存。  </li>
<li>执行：  <ul>
<li>使用计算出来的内存地址 <code>RZ</code> 访问内存。  </li>
<li>将从内存读取的数据存储到 <code>RY</code> 中。  </li>
</ul>
</li>
<li><strong>控制信号：</strong>  <ul>
<li><code>Y_select = 01</code>（选择从内存读取的数据）。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>阶段 5（写回阶段）：</strong>  </p>
<ul>
<li>在这个阶段，写回寄存器。  </li>
<li>执行：  <ul>
<li>将内存读取到的数据存储到寄存器 <code>R4</code> 中。  </li>
</ul>
</li>
<li><strong>控制信号：</strong>  <ul>
<li><code>RF_write = 1</code>（允许向寄存器文件写数据）。  </li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p><strong>控制信号解释：</strong></p>
<ul>
<li><strong>B_select = 1</strong>：表示在第 3 阶段，ALU 的第二个输入是立即数（<code>100</code>），或者是偏移量，而不是寄存器值。</li>
<li><strong>Y_select = 01</strong>：在第 4 阶段，选择内存读取的数据作为 Y 输入。</li>
<li><strong>RF_write = 1</strong>：在第 5 阶段，表示将数据写入寄存器文件，通常是把从内存读取的值写入目标寄存器（在本例中是 <code>R4</code>）。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.totorocatcat.top/">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/Chapter%205%20Basic%20Processing%20Unit/">http://totorocatcat.top/Chapter%205%20Basic%20Processing%20Unit/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/7c19b45104600b55d7e0a93de1eaff2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E7%A6%BB%E6%95%A3PPT%E5%90%88%E9%9B%86/" title="离散PPT问题合集"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/db3de1085687df057372811df7dd9d6.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">离散PPT问题合集</div></div></a></div><div class="next-post pull-right"><a href="/Chapter%208%20Cache(9)/" title="Chapter 8 Cache(9)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4e0d02920af5e683a1aca9fd37a0596.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Chapter 8 Cache(9)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2009%E5%B9%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%9F%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86/" title="2009年计算机统考-数据结构部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/e345af5b515d2f76bb44fdaa6eff3db4d6f598d3.jpg@1256w_908h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-04</div><div class="title">2009年计算机统考-数据结构部分</div></div></a></div><div><a href="/2010%E5%B9%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%9F%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="2010年计算机统考-数据结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/e345af5b515d2f76bb44fdaa6eff3db4d6f598d3.jpg@1256w_908h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-04</div><div class="title">2010年计算机统考-数据结构</div></div></a></div><div><a href="/2011%E5%B9%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%9F%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86/" title="2011年计算机统考-数据结构部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/e345af5b515d2f76bb44fdaa6eff3db4d6f598d3.jpg@1256w_908h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="title">2011年计算机统考-数据结构部分</div></div></a></div><div><a href="/2012%E5%B9%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%9F%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86/" title="2012年计算机统考-数据结构部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/e345af5b515d2f76bb44fdaa6eff3db4d6f598d3.jpg@1256w_908h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="title">2012年计算机统考-数据结构部分</div></div></a></div><div><a href="/2022%E5%B9%B4C-%E8%AF%95%E5%8D%B7%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2/" title="2022年C++试卷软件学院"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_80.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-16</div><div class="title">2022年C++试卷软件学院</div></div></a></div><div><a href="/2022C-%E8%AF%95%E5%8D%B7/" title="2022C++试卷"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_80.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-16</div><div class="title">2022C++试卷</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description">热爱文学的SCUT软件学院学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">813</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-5-Basic-Processing-Unit"><span class="toc-text">Chapter 5 Basic Processing Unit</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E8%8B%B1%E5%AF%B9%E7%85%A7"><span class="toc-text">中英对照</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-1-%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">5.1 一些基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-text">指令执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%EF%BC%9A"><span class="toc-text">注意：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">指令执行的操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E7%A1%AC%E4%BB%B6%E7%BB%84%E4%BB%B6"><span class="toc-text">处理器的主要硬件组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-text">数据处理系统的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C"><span class="toc-text">指令执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4%EF%BC%9A"><span class="toc-text">内存访问指令：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%AD%A4%E6%8C%87%E4%BB%A4%E6%89%80%E9%9C%80%E7%9A%84%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-text">执行此指令所需的五个步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%8C%87%E4%BB%A4%EF%BC%9A"><span class="toc-text">计算指令：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%AD%A4%E6%8C%87%E4%BB%A4%E6%89%80%E9%9C%80%E7%9A%84%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A-1"><span class="toc-text">执行此指令所需的五个步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-text">流水线处理：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%8C%87%E4%BB%A4%EF%BC%9A-1"><span class="toc-text">内存访问指令：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%AD%A4%E6%8C%87%E4%BB%A4%E6%89%80%E9%9C%80%E7%9A%84%E4%BA%94%E4%B8%AA%E6%AD%A5%E9%AA%A4%EF%BC%9A-2"><span class="toc-text">执行此指令所需的五个步骤：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%A4%84%E7%90%86%EF%BC%9A-1"><span class="toc-text">流水线处理：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E4%BA%8E%E6%89%80%E6%9C%89%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BA%94%E6%AD%A5%E5%BA%8F%E5%88%97%EF%BC%88RISC-%E9%A3%8E%E6%A0%BC%E6%8C%87%E4%BB%A4%E9%9B%86%EF%BC%89"><span class="toc-text">适用于所有指令的五步序列（RISC 风格指令集）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%87%E4%BB%B6%EF%BC%88Register-File%EF%BC%89"><span class="toc-text">寄存器文件（Register File）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%EF%BC%9A"><span class="toc-text">详细描述：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ALU%EF%BC%88%E7%AE%97%E6%9C%AF%E9%80%BB%E8%BE%91%E5%8D%95%E5%85%83%EF%BC%89"><span class="toc-text">ALU（算术逻辑单元）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF-ALU%EF%BC%9F"><span class="toc-text">1. 什么是 ALU？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-ALU-%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">2. ALU 的功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-text">3. 数据操作方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B0%8F%E7%BB%93"><span class="toc-text">4. 小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E4%BF%A1%E5%8F%B7%E4%B8%8E%E7%BB%84%E4%BB%B6"><span class="toc-text">相关信号与组件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84-Datapath"><span class="toc-text">数据路径 (Datapath)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%A1%AC%E4%BB%B6%E7%9A%84%E4%B8%A4%E4%B8%AA%E4%B8%BB%E8%A6%81%E9%83%A8%E5%88%86%EF%BC%9A"><span class="toc-text">处理器硬件的两个主要部分：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E9%98%B6%E6%AE%B5RISC%E5%A4%84%E7%90%86%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">5阶段RISC处理器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B"><span class="toc-text">指令处理过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6"><span class="toc-text">关键组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81%E5%8A%A8"><span class="toc-text">数据流动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90%EF%BC%9A%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C"><span class="toc-text">例子：如何运作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84%EF%BC%9A%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%87%E4%BB%B6-%E9%98%B6%E6%AE%B5-2-amp-5"><span class="toc-text">数据路径：寄存器文件 (阶段 2 &amp; 5)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%87%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">寄存器文件的工作原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-2"><span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84%EF%BC%9AALU%E9%98%B6%E6%AE%B5"><span class="toc-text">数据路径：ALU阶段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ALU%E9%98%B6%E6%AE%B5%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">ALU阶段的工作原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-3"><span class="toc-text">总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Datapath-Memory-Stage%EF%BC%88%E5%86%85%E5%AD%98%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="toc-text">Datapath: Memory Stage（内存阶段）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%EF%BC%9A"><span class="toc-text">关键点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Instruction-Fetch-Section%EF%BC%88%E6%8C%87%E4%BB%A4%E8%8E%B7%E5%8F%96%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-text">Instruction Fetch Section（指令获取部分）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Memory-Address-Generation%EF%BC%88%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90%EF%BC%89"><span class="toc-text">1. Memory Address Generation（内存地址生成）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Processor-Control-Section%EF%BC%88%E5%A4%84%E7%90%86%E5%99%A8%E6%8E%A7%E5%88%B6%E9%83%A8%E5%88%86%EF%BC%89"><span class="toc-text">2. Processor Control Section（处理器控制部分）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Instruction-Address-Generator%EF%BC%88%E6%8C%87%E4%BB%A4%E5%9C%B0%E5%9D%80%E7%94%9F%E6%88%90%E5%99%A8%EF%BC%89"><span class="toc-text">3. Instruction Address Generator（指令地址生成器）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-PC-Temp%EF%BC%88PC-%E4%B8%B4%E6%97%B6%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%89"><span class="toc-text">1. PC-Temp（PC 临时寄存器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-PC%EF%BC%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%89"><span class="toc-text">2. PC（程序计数器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-MuxPC%EF%BC%88%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8%EF%BC%89"><span class="toc-text">3. MuxPC（程序计数器多路复用器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-MUXINC%EF%BC%88PC-%E5%A2%9E%E9%87%8F%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%99%A8%EF%BC%89"><span class="toc-text">4. MUXINC（PC 增量多路复用器）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%96%E4%BB%AC%E5%A6%82%E4%BD%95%E5%8D%8F%E4%BD%9C%EF%BC%9A"><span class="toc-text">他们如何协作：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%82%B9%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">关键点总结：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-4-%E6%8C%87%E4%BB%A4%E8%8E%B7%E5%8F%96%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%AD%A5%E9%AA%A4"><span class="toc-text">5.4 指令获取与执行步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-Add-R3-R4-R5%EF%BC%88%E5%B0%86-R4-%E5%92%8C-R5-%E7%9B%B8%E5%8A%A0%EF%BC%8C%E7%BB%93%E6%9E%9C%E5%AD%98%E5%85%A5-R3%EF%BC%89"><span class="toc-text">示例 1: Add R3, R4, R5（将 R4 和 R5 相加，结果存入 R3）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E6%8C%87%E4%BB%A4%E8%8E%B7%E5%8F%96"><span class="toc-text">步骤 1：指令获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%EF%BC%9A%E8%A7%A3%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="toc-text">步骤 2：解码指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3%EF%BC%9A%E6%89%A7%E8%A1%8C%E8%AE%A1%E7%AE%97"><span class="toc-text">步骤 3：执行计算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-4%EF%BC%9A%E4%BF%9D%E5%AD%98%E8%AE%A1%E7%AE%97%E7%BB%93%E6%9E%9C"><span class="toc-text">步骤 4：保存计算结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-5%EF%BC%9A%E5%86%99%E5%9B%9E%E7%BB%93%E6%9E%9C"><span class="toc-text">步骤 5：写回结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-text">指令编码格式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-%E5%AF%84%E5%AD%98%E5%99%A8%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%BC%E5%BC%8F%EF%BC%88Register-operand-format%EF%BC%89"><span class="toc-text">(a) 寄存器操作数格式（Register-operand format）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-%E7%AB%8B%E5%8D%B3%E6%95%B0%E6%93%8D%E4%BD%9C%E6%95%B0%E6%A0%BC%E5%BC%8F%EF%BC%88Immediate-operand-format%EF%BC%89"><span class="toc-text">(b) 立即数操作数格式（Immediate-operand format）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E8%B0%83%E7%94%A8%E6%A0%BC%E5%BC%8F%EF%BC%88Call-format%EF%BC%89"><span class="toc-text">(c) 调用格式（Call format）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B2%EF%BC%9A%E5%8A%A0%E8%BD%BD%E6%8C%87%E4%BB%A4%EF%BC%88Load-R5-X-R7-%EF%BC%89"><span class="toc-text">示例2：加载指令（Load R5, X(R7)）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B3%EF%BC%9A%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4%EF%BC%88Store-R6-X-R8-%EF%BC%89"><span class="toc-text">示例3：存储指令（Store R6, X(R8)）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%EF%BC%88Unconditional-Branch%EF%BC%89"><span class="toc-text">无条件跳转指令（Unconditional Branch）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E8%B7%B3%E8%BD%AC%E6%8C%87%E4%BB%A4%EF%BC%88Conditional-Branch%EF%BC%89"><span class="toc-text">条件跳转指令（Conditional Branch）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E6%93%8D%E4%BD%9C"><span class="toc-text">比较操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%EF%BC%88%E5%B8%A6%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%EF%BC%89"><span class="toc-text">子程序调用（带间接寻址）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%86%85%E5%AD%98%EF%BC%88Wait-for-Memory%EF%BC%89"><span class="toc-text">等待内存（Wait for Memory）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AE%8C%E6%88%90%E4%BF%A1%E5%8F%B7-MFC"><span class="toc-text">内存完成信号 (MFC)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AD%89%E5%BE%85"><span class="toc-text">步骤 1：指令执行中的内存等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%92%8C%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84MFC%E7%AD%89%E5%BE%85"><span class="toc-text">加载和存储指令中的MFC等待</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%E6%89%80%E5%9C%A8"><span class="toc-text">精华所在</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7-Control-Signals"><span class="toc-text">控制信号 (Control Signals)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%96%87%E4%BB%B6%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7-Register-File-Control-Signals"><span class="toc-text">寄存器文件控制信号 (Register File Control Signals)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ALU-control-signals"><span class="toc-text">ALU control signals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Result-selection"><span class="toc-text">Result selection</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE-Memory-Access"><span class="toc-text">内存访问 (Memory Access)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Memory-and-IR-control-signals"><span class="toc-text">Memory and IR control signals</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Control-signals-of-instruction-address-generator"><span class="toc-text">Control signals of instruction address generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-6-%E7%A1%AC%E8%BF%9E%E7%BA%BF%E6%8E%A7%E5%88%B6-Hardwired-Control"><span class="toc-text">5.6 硬连线控制 (Hardwired Control)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E8%BF%9E%E7%BA%BF%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E7%94%9F%E6%88%90-Hardwired-Generation-of-Control-Signals"><span class="toc-text">硬连线控制信号生成 (Hardwired Generation of Control Signals)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E8%BF%9E%E7%BA%BF%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E7%94%9F%E6%88%90-Hardwired-Generation-of-Control-Signals-1"><span class="toc-text">硬连线控制信号生成 (Hardwired Generation of Control Signals)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E8%BF%9E%E7%BA%BF%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-text">硬连线控制的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A41%EF%BC%9A%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E7%9A%84%E7%A1%AC%E8%BF%9E%E7%BA%BF%E6%8E%A7%E5%88%B6"><span class="toc-text">步骤1：指令执行过程的硬连线控制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-4"><span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%B7%AF%E5%BE%84%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7-Datapath-Control-Signals"><span class="toc-text">数据路径控制信号 (Datapath Control Signals)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-5"><span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%86%85%E5%AD%98%E5%BB%B6%E8%BF%9F-Dealing-with-Memory-Delay"><span class="toc-text">处理内存延迟 (Dealing with Memory Delay)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-6"><span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-CISC-%E9%A3%8E%E6%A0%BC%E5%A4%84%E7%90%86%E5%99%A8-CISC-style-Processors"><span class="toc-text">5.7 CISC 风格处理器 (CISC-style Processors)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-7"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hardware-organization-for-a-CISC-computer"><span class="toc-text">Hardware organization for a CISC computer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF-Bus"><span class="toc-text">总线 (Bus)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E6%80%BB%E7%BA%BF%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C-A-3-bus-interconnection-network"><span class="toc-text">三总线互连网络 (A 3-bus interconnection network)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-8"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%8A%A0%E6%B3%95%E6%8C%87%E4%BB%A4-Add-R5-R6"><span class="toc-text">示例：加法指令 Add R5, R6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9AAnd-X-R7-R9-%E6%8C%87%E4%BB%A4"><span class="toc-text">示例：And X(R7), R9 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-1%EF%BC%9A%E8%8E%B7%E5%8F%96%E6%93%8D%E4%BD%9C%E7%A0%81"><span class="toc-text">步骤 1：获取操作码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-2%EF%BC%9A%E8%A7%A3%E7%A0%81%E5%B9%B6%E8%8E%B7%E5%8F%96%E5%81%8F%E7%A7%BB%E9%87%8F-X"><span class="toc-text">步骤 2：解码并获取偏移量 X</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4-3%EF%BC%9A%E6%89%A7%E8%A1%8C%E6%93%8D%E4%BD%9C"><span class="toc-text">步骤 3：执行操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88Microprogramming%EF%BC%89"><span class="toc-text">微程序设计（Microprogramming）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%9A"><span class="toc-text">微程序设计的工作原理：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">微程序设计的优点：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Quiz"><span class="toc-text">Quiz</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%A2%98-1%EF%BC%9A%E7%A1%AC%E4%BB%B6%E6%8E%A7%E5%88%B6%E5%8D%95%E5%85%83%E4%B8%AD%EF%BC%8C%E6%89%80%E9%9C%80%E7%9A%84%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E6%98%AF%E9%80%9A%E8%BF%87%E4%BB%A5%E4%B8%8B%E4%BF%A1%E6%81%AF%E7%A1%AE%E5%AE%9A%E7%9A%84%EF%BC%8C%E9%99%A4%E4%BA%86%EF%BC%9A"><span class="toc-text">选择题 1：硬件控制单元中，所需的控制信号是通过以下信息确定的，除了：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-text">答案解析：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%A2%98-2%EF%BC%9A%E5%9C%A8%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E6%9C%BA%E5%99%A8%E4%B8%AD%EF%BC%8C%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E6%89%80%E9%9C%80%E7%9A%84%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E6%98%AF%E7%94%B1%E4%BB%A5%E4%B8%8B%E5%93%AA%E9%A1%B9%E7%94%9F%E6%88%90%E7%9A%84%EF%BC%9F"><span class="toc-text">选择题 2：在微程序控制的机器中，机器指令所需的控制信号是由以下哪项生成的？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%9A-1"><span class="toc-text">答案解析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%A2%98-3%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%8C%87%E4%BB%A4%E9%9B%86%E4%B8%AD%E6%89%80%E6%9C%89%E6%8C%87%E4%BB%A4%E7%9A%84%E5%BE%AE%E7%A8%8B%E5%BA%8F%E5%AD%98%E5%82%A8%E5%9C%A8%E4%B8%80%E4%B8%AA%E7%89%B9%E6%AE%8A%E7%9A%84%E5%AD%98%E5%82%A8%E5%99%A8%E4%B8%AD%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%AD%98%E5%82%A8%E5%99%A8%E5%8F%AB%E5%81%9A%EF%BC%9F"><span class="toc-text">选择题 3：计算机指令集中所有指令的微程序存储在一个特殊的存储器中，这个存储器叫做？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%9A-2"><span class="toc-text">答案解析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%A2%98-4%EF%BC%9A%E5%9C%A8%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%EF%BC%8C%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E5%92%8C%E5%BE%AE%E6%8C%87%E4%BB%A4%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%EF%BC%9F"><span class="toc-text">选择题 4：在微程序控制的计算机中，机器指令和微指令之间的关系是？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%9A-3"><span class="toc-text">答案解析：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%A2%98-5%EF%BC%9A%E7%A1%AC%E4%BB%B6%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">选择题 5：硬件控制与微程序控制的优缺点是什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-9"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%A2%98-6%EF%BC%9A"><span class="toc-text">选择题 6：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%A2%98-7%EF%BC%9A"><span class="toc-text">选择题 7：</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E7%A6%BB%E6%95%A3%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%8813%EF%BC%89/" title="离散习题讲解（13）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/s33532039.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="离散习题讲解（13）"/></a><div class="content"><a class="title" href="/%E7%A6%BB%E6%95%A3%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%8813%EF%BC%89/" title="离散习题讲解（13）">离散习题讲解（13）</a><time datetime="2024-12-17T10:20:07.000Z" title="发表于 2024-12-17 18:20:07">2024-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E7%A6%BB%E6%95%A3%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%8812%EF%BC%89/" title="离散习题讲解（12）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/s33532039.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="离散习题讲解（12）"/></a><div class="content"><a class="title" href="/%E7%A6%BB%E6%95%A3%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%8812%EF%BC%89/" title="离散习题讲解（12）">离散习题讲解（12）</a><time datetime="2024-12-17T09:37:49.000Z" title="发表于 2024-12-17 17:37:49">2024-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E7%A6%BB%E6%95%A3%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%8811%EF%BC%89/" title="离散习题讲解（11）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/s33532039.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="离散习题讲解（11）"/></a><div class="content"><a class="title" href="/%E7%A6%BB%E6%95%A3%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%8811%EF%BC%89/" title="离散习题讲解（11）">离散习题讲解（11）</a><time datetime="2024-12-17T09:37:09.000Z" title="发表于 2024-12-17 17:37:09">2024-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E7%A6%BB%E6%95%A3%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%8810%EF%BC%89/" title="离散习题讲解（10）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/s33532039.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="离散习题讲解（10）"/></a><div class="content"><a class="title" href="/%E7%A6%BB%E6%95%A3%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%8810%EF%BC%89/" title="离散习题讲解（10）">离散习题讲解（10）</a><time datetime="2024-12-17T09:30:01.000Z" title="发表于 2024-12-17 17:30:01">2024-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E7%A6%BB%E6%95%A3%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%889%EF%BC%89/" title="离散习题讲解（9）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/s33532039.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="离散习题讲解（9）"/></a><div class="content"><a class="title" href="/%E7%A6%BB%E6%95%A3%E4%B9%A0%E9%A2%98%E8%AE%B2%E8%A7%A3%EF%BC%889%EF%BC%89/" title="离散习题讲解（9）">离散习题讲解（9）</a><time datetime="2024-12-17T08:43:42.000Z" title="发表于 2024-12-17 16:43:42">2024-12-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HT1PalaKkPaG1UqAXBhJXIu8-gzGzoHsz',
      appKey: 'iT0TnVVAwf9zuZ7NqwclQItY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="1" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS61B/&quot;);" href="javascript:void(0);">CS61B</a><span class="categoryBar-list-count">76</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/离散数学/&quot;);" href="javascript:void(0);">离散数学</a><span class="categoryBar-list-count">42</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/期末の旅/&quot;);" href="javascript:void(0);">期末の旅</a><span class="categoryBar-list-count">99</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACMの旅/&quot;);" href="javascript:void(0);">ACMの旅</a><span class="categoryBar-list-count">68</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/区域赛の旅/&quot;);" href="javascript:void(0);">区域赛の旅</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数学建模/&quot;);" href="javascript:void(0);">数学建模</a><span class="categoryBar-list-count">31</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Codeforcesの旅/&quot;);" href="javascript:void(0);">Codeforcesの旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/牛客の旅/&quot;);" href="javascript:void(0);">牛客の旅</a><span class="categoryBar-list-count">65</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题计划/&quot;);" href="javascript:void(0);">刷题计划</a><span class="categoryBar-list-count">38</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/前端の旅/&quot;);" href="javascript:void(0);">前端の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构/&quot;);" href="javascript:void(0);">数据结构</a><span class="categoryBar-list-count">47</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_24.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Atcoderの旅/&quot;);" href="javascript:void(0);">Atcoderの旅</a><span class="categoryBar-list-count">53</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_25.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-の旅/&quot;);" href="javascript:void(0);">C++の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_26.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS70の旅/&quot;);" href="javascript:void(0);">CS70の旅</a><span class="categoryBar-list-count">25</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_27.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CSAPPの旅/&quot;);" href="javascript:void(0);">CSAPPの旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_28.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS知识/&quot;);" href="javascript:void(0);">CS知识</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_29.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">48</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_30.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程基础/&quot;);" href="javascript:void(0);">编程基础</a><span class="categoryBar-list-count">22</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_31.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JAVAの旅/&quot;);" href="javascript:void(0);">JAVAの旅</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_32.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MIT-6-031-Software-Construction/&quot;);" href="javascript:void(0);">MIT 6.031:Software Construction</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_33.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS-110L/&quot;);" href="javascript:void(0);">CS 110L</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_34.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/灵魂の旅/&quot;);" href="javascript:void(0);">灵魂の旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_35.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/个人安排/&quot;);" href="javascript:void(0);">个人安排</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_36.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂项/&quot;);" href="javascript:void(0);">杂项</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_37.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文学/&quot;);" href="javascript:void(0);">文学</a><span class="categoryBar-list-count">49</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_38.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/力扣の旅/&quot;);" href="javascript:void(0);">力扣の旅</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_39.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/千里十二行/&quot;);" href="javascript:void(0);">千里十二行</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/🗡指offer/&quot;);" href="javascript:void(0);">🗡指offer</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_41.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/少年游/&quot;);" href="javascript:void(0);">少年游</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_42.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法提高课/&quot;);" href="javascript:void(0);">算法提高课</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_43.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/汇编の旅/&quot;);" href="javascript:void(0);">汇编の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-实训/&quot;);" href="javascript:void(0);">C++实训</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;诗录/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4b31456c6f0f4489f99177f89e936de7286431045.png@1256w_708h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;诗录/&quot;);" href="javascript:void(0);" alt="">诗录</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;诗录/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;诗兴大发/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;诗兴大发/&quot;);" href="javascript:void(0);" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;诗兴大发/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;TotoroのPlan/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/51d37eba99d243607ddedfff6e91568f617436609.jpg@1256w_1884h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">TotoroのPlan</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;Markdown格式/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.48/img_482_1920x1080_96_null_normal.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;Markdown格式/&quot;);" href="javascript:void(0);" alt="">Markdown格式</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;Markdown格式/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>