<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>操作系统CH2（2） | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Chapter 2 Processes and Threads 2.3 进程间通信（Inter-Process Communication, IPC）  1. 进程间通信涉及的三个问题 Three Issues in Inter-Process Communication (IPC)  信息传递（How One Process Can Pass Information to">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统CH2（2）">
<meta property="og:url" content="http://totorocatcat.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="Chapter 2 Processes and Threads 2.3 进程间通信（Inter-Process Communication, IPC）  1. 进程间通信涉及的三个问题 Three Issues in Inter-Process Communication (IPC)  信息传递（How One Process Can Pass Information to">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.22/img_220_1200x675_350.011993408203_null_normal.jpg">
<meta property="article:published_time" content="2025-05-06T09:04:48.000Z">
<meta property="article:modified_time" content="2025-05-06T09:05:14.076Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="提高">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.22/img_220_1200x675_350.011993408203_null_normal.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/b5ca6e582a7a45e6fde46e616eeb68e.png"><link rel="canonical" href="http://totorocatcat.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":765,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '操作系统CH2（2）',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2025-05-06 17:05:14'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="/css/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%BE%A0%E5%AE%A2-%E6%AD%A6%E4%BE%A0%E5%9C%BA%E6%99%AF-%E6%B8%B8%E6%88%8F.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">856</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://npm.elemecdn.com/ushio-api-img-moe@5.0.22/img_220_1200x675_350.011993408203_null_normal.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统CH2（2）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-06T09:04:48.000Z" title="发表于 2025-05-06 17:04:48">2025-05-06</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-05-06T09:05:14.076Z" title="更新于 2025-05-06 17:05:14">2025-05-06</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>90分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="操作系统CH2（2）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="chapter-2-processes-and-threads">Chapter 2 Processes and
Threads</h1>
<h3 id="进程间通信inter-process-communication-ipc"><strong>2.3
进程间通信（Inter-Process Communication, IPC）</strong></h3>
<hr>
<h4 id="进程间通信涉及的三个问题"><strong>1.
进程间通信涉及的三个问题</strong></h4>
<p><strong>Three Issues in Inter-Process Communication
(IPC)</strong></p>
<ol type="1">
<li><p><strong>信息传递（How One Process Can Pass Information to
Another）：</strong><br>
• 进程之间如何传递信息。<br>
<strong>How one process can pass information to
another.</strong></p></li>
<li><p><strong>资源共享（Resource Shared）：</strong><br>
•
如何确保多个进程在访问共享资源（如打印机）时不会相互干扰（互斥）。<br>
<strong>How to ensure that multiple processes do not interfere with each
other when accessing shared resources (e.g., printer) (Mutual
Exclusion).</strong></p></li>
<li><p><strong>进程协作（Process Cooperation）：</strong><br>
• 当存在依赖关系时，如何确保进程的正确执行顺序（同步）。<br>
<strong>Proper sequencing when dependencies are present
(Synchronization).</strong></p></li>
</ol>
<hr>
<h4 id="进程同步process-synchronization"><strong>2. 进程同步（Process
Synchronization）</strong></h4>
<p>• <strong>背景：</strong><br>
<strong>Background:</strong><br>
• 多个进程访问共享资源时，可能会导致竞争条件（Race
Conditions），最终结果取决于操作的顺序。<br>
<strong>When multiple processes access shared resources, race conditions
may occur, where the final result depends on the order of
operations.</strong></p>
<p>• <strong>互斥（Mutual Exclusion）：</strong><br>
<strong>Mutual Exclusion:</strong><br>
• 确保同一时间只有一个进程访问共享资源。<br>
<strong>Ensure that only one process accesses the shared resource at a
time.</strong></p>
<p>• <strong>同步（Synchronization）：</strong><br>
<strong>Synchronization:</strong><br>
• 确保进程按照正确的顺序执行，特别是在存在依赖关系时。<br>
<strong>Ensure that processes execute in the correct order, especially
when dependencies are present.</strong></p>
<hr>
<h4 id="spooling-示例正确与竞争条件"><strong>3. Spooling
示例：正确与竞争条件</strong></h4>
<p><strong>Spooling Example: Correct vs Race Conditions</strong></p>
<p>• <strong>正确示例（Correct Example）：</strong><br>
<strong>Correct Example:</strong><br>
• 进程1和进程2按顺序访问共享资源，避免了竞争条件。<br>
<strong>Process 1 and Process 2 access the shared resource in sequence,
avoiding race conditions.</strong></p>
<p>• <strong>竞争条件示例（Race Conditions Example）：</strong><br>
<strong>Race Conditions Example:</strong><br>
• 进程1和进程2同时访问共享资源，导致数据不一致。<br>
<strong>Process 1 and Process 2 access the shared resource
simultaneously, leading to data inconsistency.</strong></p>
<hr>
<h4 id="互斥与竞争条件"><strong>4. 互斥与竞争条件</strong></h4>
<p><strong>Mutual Exclusion and Race Conditions</strong></p>
<p>• <strong>互斥（Mutual Exclusion）：</strong><br>
<strong>Mutual Exclusion:</strong><br>
• 确保同一时间只有一个进程访问共享变量或文件。<br>
<strong>Ensure that only one process accesses a shared variable or file
at a time.</strong></p>
<p>• <strong>竞争条件（Race Conditions）：</strong><br>
<strong>Race Conditions:</strong><br>
• 多个进程访问共享数据时，最终结果取决于操作的顺序。<br>
<strong>Situations in which several processes access shared data, and
the final result depends on the order of operations.</strong></p>
<p>• <strong>避免竞争条件的关键：</strong><br>
<strong>Key to Avoid Race Conditions:</strong><br>
• 禁止多个进程同时读写共享数据。<br>
<strong>Prohibit more than one process from reading and writing the
shared data at the same time.</strong></p>
<hr>
<h4 id="临界资源与临界区"><strong>5. 临界资源与临界区</strong></h4>
<p><strong>Critical Resource and Critical Region</strong></p>
<p>• <strong>临界资源（Critical Resource）：</strong><br>
<strong>Critical Resource:</strong><br>
• 多个进程共享的资源，需要互斥访问。 （一次仅允许一个进程访问）
<strong>A resource shared by multiple processes that requires mutual
exclusion.</strong></p>
<p>• <strong>临界区（Critical Region/Critical Section）：</strong><br>
<strong>Critical Region (Critical Section):</strong><br>
• 程序中访问临界资源的部分。<br>
<strong>The part of the program where the critical resource is
accessed.</strong></p>
<p>• <strong>避免竞争条件的方法：</strong><br>
<strong>How to Avoid Race Conditions:</strong><br>
• 确保同一时间只有一个进程处于临界区。<br>
<strong>Ensure that no two processes are in their critical regions at
the same time.</strong></p>
<hr>
<h3 id="总结"><strong>总结</strong></h3>
<p><strong>Summary</strong></p>
<p>• <strong>进程间通信的三个问题：</strong><br>
<strong>Three Issues in IPC:</strong><br>
• 信息传递、资源共享和进程协作。<br>
<strong>Information passing, resource sharing, and process
cooperation.</strong></p>
<p>• <strong>进程同步：</strong><br>
<strong>Process Synchronization:</strong><br>
• 通过互斥和同步确保进程正确访问共享资源。<br>
<strong>Ensure correct access to shared resources through mutual
exclusion and synchronization.</strong></p>
<p>• <strong>Spooling 示例：</strong><br>
<strong>Spooling Example:</strong><br>
• 展示了正确访问和竞争条件的情况。<br>
<strong>Demonstrates correct access and race conditions.</strong></p>
<p>• <strong>临界资源与临界区：</strong><br>
<strong>Critical Resource and Critical Region:</strong><br>
• 临界资源是共享资源，临界区是访问临界资源的代码部分。<br>
<strong>Critical resources are shared resources, and critical regions
are the code sections accessing critical resources.</strong></p>
<p>• <strong>避免竞争条件：</strong><br>
<strong>Avoid Race Conditions:</strong><br>
• 确保同一时间只有一个进程处于临界区。<br>
<strong>Ensure that only one process is in the critical region at a
time.</strong></p>
<p>进程间通信和同步是操作系统中的重要概念，确保多个进程能够高效、安全地协作。<br>
<strong>Inter-process communication and synchronization are crucial
concepts in operating systems, ensuring that multiple processes can
collaborate efficiently and safely.</strong></p>
<h3 id="进程同步与互斥process-synchronization-and-mutual-exclusion"><strong>2.3
进程同步与互斥（Process Synchronization and Mutual
Exclusion）</strong></h3>
<hr>
<h4 id="临界区的要求"><strong>1. 临界区的要求</strong></h4>
<p><strong>Critical Region Requirements</strong></p>
<p>• <strong>提供互斥的四个条件：</strong><br>
<strong>Four Conditions to Provide Mutual Exclusion:</strong><br>
1. <strong>互斥性：</strong> 不能有两个进程同时处于临界区。<br>
<strong>No two processes simultaneously in the critical
region.</strong><br>
2. <strong>无假设性：</strong> 不能对进程的速度或CPU数量做出假设。<br>
<strong>No assumptions made about speeds or numbers of
CPUs.</strong><br>
3. <strong>非阻塞性：</strong>
不在临界区运行的进程不能阻塞其他进程。<br>
<strong>No process running outside its critical region may block another
process.</strong><br>
4. <strong>有限等待：</strong> 进程不能无限等待进入临界区。<br>
<strong>No process must wait forever to enter its critical
region.</strong></p>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/20250506142445.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<hr>
<h4 id="互斥的实现方法"><strong>2. 互斥的实现方法</strong></h4>
<p><strong>Possible Solutions for Mutual Exclusion</strong></p>
<ol type="1">
<li><p><strong>禁用中断（Disabling Interrupts）：</strong><br>
• <strong>工作原理：</strong>
进入临界区前禁用中断，离开临界区后重新启用中断。<br>
<strong>How it works:</strong> Disable all interrupts before entering
the critical section and re-enable them after leaving.<br>
• <strong>为什么有效：</strong>
禁用中断后，时钟中断不会发生，进程切换也不会发生。<br>
<strong>Why it works:</strong> With interrupts disabled, no clock
interrupts occur, and no process switching can happen.<br>
• <strong>问题：</strong><br>
◦ 如果进程忘记启用中断，系统将无法恢复。<br>
<strong>If the process forgets to enable interrupts, the system will not
recover.</strong><br>
◦ 不适用于多处理器系统（禁用中断只影响一个CPU）。<br>
<strong>Not suitable for multiprocessor systems (disabling interrupts
only affects one CPU).</strong><br>
• <strong>适用场景：</strong> 仅用于操作系统内部。<br>
<strong>Only used inside the OS.</strong></p></li>
<li><h3 id="锁变量lock-variable的深入解释"><strong>锁变量（Lock
Variable）的深入解释</strong></h3>
<p>锁变量是一种简单的互斥机制，用于确保多个进程不会同时进入临界区。然而，它存在一些关键问题，特别是在多进程并发访问时。以下是详细解释：</p>
<hr>
<h4 id="锁变量的工作原理"><strong>1. 锁变量的工作原理</strong></h4>
<p><strong>How Lock Variable Works</strong></p>
<p>• <strong>锁变量的定义：</strong><br>
<strong>Definition of Lock Variable:</strong><br>
• 锁变量是一个共享的整型变量，通常初始化为0。<br>
<strong>The lock variable is a shared integer variable, typically
initialized to 0.</strong><br>
• 当锁变量的值为0时，表示临界区可用；为1时，表示临界区已被占用。<br>
<strong>When the lock variable is 0, the critical section is available;
when it is 1, the critical section is occupied.</strong></p>
<p>• <strong>进入临界区的逻辑：</strong><br>
<strong>Logic for Entering Critical Section:</strong><br>
• 进程在进入临界区前，检查锁变量的值：<br>
<strong>Before entering the critical section, a process checks the value
of the lock variable:</strong><br>
◦ 如果锁变量为0，进程将其设置为1，表示占用临界区。<br>
<strong>If the lock variable is 0, the process sets it to 1, indicating
that the critical section is occupied.</strong><br>
◦ 如果锁变量为1，进程等待，直到锁变量变为0。<br>
<strong>If the lock variable is 1, the process waits until it becomes
0.</strong></p>
<p>• <strong>退出临界区的逻辑：</strong><br>
<strong>Logic for Exiting Critical Section:</strong><br>
• 进程退出临界区后，将锁变量重置为0，表示释放临界区。<br>
<strong>After exiting the critical section, the process resets the lock
variable to 0, indicating that the critical section is
released.</strong></p>
<hr>
<h4 id="代码示例"><strong>2. 代码示例</strong></h4>
<p><strong>Code Example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shared <span class="type">int</span> lock = <span class="number">0</span>;  <span class="comment">// 共享的锁变量，初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Entry code: execute before entering critical section */</span></span><br><span class="line"><span class="keyword">while</span> (lock != <span class="number">0</span>);   <span class="comment">// 等待，直到锁变量为0</span></span><br><span class="line">lock = <span class="number">1</span>;            <span class="comment">// 设置锁变量为1，表示占用临界区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Critical section */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Exit code: execute after leaving critical section */</span></span><br><span class="line">lock = <span class="number">0</span>;            <span class="comment">// 设置锁变量为0，表示释放临界区</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="锁变量的问题"><strong>3. 锁变量的问题</strong></h4>
<p><strong>Problems with Lock Variable</strong></p>
<ol type="1">
<li><p><strong>竞争条件（Race Condition）：</strong><br>
<strong>Race Condition:</strong><br>
•
如果两个进程同时检查锁变量，并且锁变量的值为0，它们可能会同时进入临界区。<br>
<strong>If two processes check the lock variable simultaneously and the
lock variable is 0, they may both enter the critical
section.</strong><br>
• <strong>示例：</strong><br>
<strong>Example:</strong><br>
◦
进程A和进程B同时执行<code>while (lock != 0);</code>，发现锁变量为0。<br>
<strong>Process A and Process B both execute
<code>while (lock != 0);</code> and find that the lock variable is
0.</strong><br>
◦
进程A和进程B都执行<code>lock = 1;</code>，导致它们同时进入临界区。<br>
<strong>Process A and Process B both execute <code>lock = 1;</code>,
causing them to enter the critical section
simultaneously.</strong></p></li>
<li><p><strong>非原子操作（Non-Atomic Operation）：</strong><br>
<strong>Non-Atomic Operation:</strong><br>
• 锁变量的检查和设置是分开的操作，不是原子的。<br>
<strong>The check and set of the lock variable are separate operations
and are not atomic.</strong><br>
• <strong>示例：</strong><br>
<strong>Example:</strong><br>
◦
进程A检查锁变量，发现为0，但在设置锁变量为1之前，进程B也检查锁变量，发现为0。<br>
<strong>Process A checks the lock variable and finds it to be 0, but
before setting it to 1, Process B also checks the lock variable and
finds it to be 0.</strong><br>
◦ 进程A和进程B都设置锁变量为1，导致它们同时进入临界区。<br>
<strong>Process A and Process B both set the lock variable to 1, causing
them to enter the critical section simultaneously.</strong></p></li>
</ol>
<hr>
<h4 id="如何解决锁变量的问题"><strong>4.
如何解决锁变量的问题？</strong></h4>
<p><strong>How to Solve the Problems with Lock Variable?</strong></p>
<ol type="1">
<li><p><strong>使用原子操作（Atomic Operations）：</strong><br>
<strong>Using Atomic Operations:</strong><br>
• 锁变量的检查和设置需要是原子的，即在一次操作中完成。<br>
<strong>The check and set of the lock variable need to be atomic, i.e.,
completed in a single operation.</strong><br>
• <strong>硬件支持：</strong><br>
<strong>Hardware Support:</strong><br>
◦ 现代CPU提供了原子指令，如测试并设置锁（Test-and-Set Lock,
TSL）或交换指令（XCHG）。<br>
<strong>Modern CPUs provide atomic instructions, such as Test-and-Set
Lock (TSL) or Exchange (XCHG).</strong></p></li>
<li><p><strong>使用更高级的同步机制：</strong><br>
<strong>Using Higher-Level Synchronization Mechanisms:</strong><br>
• 例如，信号量（Semaphore）、互斥锁（Mutex）或条件变量（Condition
Variable）。<br>
<strong>For example, semaphores, mutexes, or condition
variables.</strong></p></li>
</ol>
<hr>
<h4 id="锁变量的适用场景"><strong>5. 锁变量的适用场景</strong></h4>
<p><strong>Use Cases for Lock Variable</strong></p>
<p>• <strong>单处理器系统：</strong><br>
<strong>Single-Processor Systems:</strong><br>
• 在单处理器系统中，禁用中断可以避免竞争条件。<br>
<strong>In single-processor systems, disabling interrupts can avoid race
conditions.</strong></p>
<p>• <strong>简单的嵌入式系统：</strong><br>
<strong>Simple Embedded Systems:</strong><br>
• 在资源有限的嵌入式系统中，锁变量可能是一种简单的解决方案。<br>
<strong>In resource-constrained embedded systems, lock variables may be
a simple solution.</strong></p>
<hr>
<h3 id="总结-1"><strong>总结</strong></h3>
<p><strong>Summary</strong></p>
<p>• <strong>锁变量的工作原理：</strong><br>
<strong>How Lock Variable Works:</strong><br>
• 通过一个共享的整型变量来控制对临界区的访问。<br>
<strong>Controls access to the critical section using a shared integer
variable.</strong></p>
<p>• <strong>锁变量的问题：</strong><br>
<strong>Problems with Lock Variable:</strong><br>
• 竞争条件和非原子操作可能导致多个进程同时进入临界区。<br>
<strong>Race conditions and non-atomic operations may allow multiple
processes to enter the critical section simultaneously.</strong></p>
<p>• <strong>解决方案：</strong><br>
<strong>Solutions:</strong><br>
• 使用原子操作或更高级的同步机制。<br>
<strong>Use atomic operations or higher-level synchronization
mechanisms.</strong></p>
<p>锁变量是一种简单的互斥机制，但在多进程并发访问时存在严重问题。为了确保互斥，需要使用更可靠的同步机制。<br>
<strong>Lock variables are a simple mutual exclusion mechanism but have
serious issues in multi-process concurrent access. To ensure mutual
exclusion, more reliable synchronization mechanisms are
needed.</strong></p></li>
<li><p><strong>严格交替（Strict Alternation）：</strong><br>
• <strong>问题：</strong><br>
◦
进程必须严格交替进入临界区，可能导致一个进程被阻塞，即使另一个进程不需要进入临界区。<br>
<strong>Processes must strictly alternate entering their critical
sections, which may block a process even if the other process does not
need to enter.</strong></p></li>
<li><p><strong>Peterson算法（Peterson’s Solution）：</strong></p></li>
<li><h3 id="peterson算法的深入解释"><strong>Peterson算法的深入解释</strong></h3>
<p>Peterson算法是一种经典的软件解决方案，用于解决两个进程之间的互斥问题。它通过两个变量（<code>turn</code>和<code>flag</code>）确保互斥性和有限等待，同时避免了硬件依赖。以下是详细解释：</p>
<hr>
<h4 id="peterson算法的工作原理"><strong>1.
Peterson算法的工作原理</strong></h4>
<p><strong>How Peterson’s Solution Works</strong></p>
<p>• <strong>核心思想：</strong><br>
<strong>Core Idea:</strong><br>
•
使用两个共享变量<code>turn</code>和<code>flag</code>来协调两个进程的临界区访问。<br>
<strong>Uses two shared variables, <code>turn</code> and
<code>flag</code>, to coordinate access to the critical section between
two processes.</strong></p>
<p>• <strong>变量说明：</strong><br>
<strong>Variable Description:</strong></p>
<ol type="1">
<li><strong><code>flag[2]</code>：</strong><br>
◦ 一个数组，表示每个进程是否想要进入临界区。<br>
<strong>An array indicating whether each process wants to enter the
critical section.</strong><br>
◦
<code>flag[0]</code>表示进程0是否想要进入临界区，<code>flag[1]</code>表示进程1是否想要进入临界区。<br>
<strong><code>flag[0]</code> indicates whether process 0 wants to enter
the critical section, and <code>flag[1]</code> indicates whether process
1 wants to enter the critical section.</strong><br>
</li>
<li><strong><code>turn</code>：</strong><br>
◦ 表示当前轮到哪个进程进入临界区。<br>
<strong>Indicates which process’s turn it is to enter the critical
section.</strong></li>
</ol>
<p>• <strong>进入临界区的逻辑：</strong><br>
<strong>Logic for Entering Critical Section:</strong></p>
<ol type="1">
<li>进程设置自己的<code>flag</code>为1，表示它想要进入临界区。<br>
<strong>The process sets its own <code>flag</code> to 1, indicating that
it wants to enter the critical section.</strong><br>
</li>
<li>进程将<code>turn</code>设置为另一个进程的ID，表示它愿意让另一个进程先进入临界区。<br>
<strong>The process sets <code>turn</code> to the ID of the other
process, indicating that it is willing to let the other process enter
first.</strong><br>
</li>
<li>进程等待，直到另一个进程不想进入临界区，或者轮到自己进入临界区。<br>
<strong>The process waits until the other process does not want to enter
the critical section or it is its turn to enter.</strong></li>
</ol>
<p>• <strong>退出临界区的逻辑：</strong><br>
<strong>Logic for Exiting Critical Section:</strong></p>
<ol type="1">
<li>进程将自己的<code>flag</code>设置为0，表示它不再需要进入临界区。<br>
<strong>The process sets its own <code>flag</code> to 0, indicating that
it no longer needs to enter the critical section.</strong></li>
</ol>
<hr>
<h4 id="代码示例-1"><strong>2. 代码示例</strong></h4>
<p><strong>Code Example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> turn;              <span class="comment">// 表示当前轮到哪个进程进入临界区</span></span><br><span class="line"><span class="type">int</span> flag[<span class="number">2</span>];           <span class="comment">// 表示每个进程是否想要进入临界区</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_region</span><span class="params">(<span class="type">int</span> process)</span> &#123;</span><br><span class="line">    <span class="type">int</span> other = <span class="number">1</span> - process;  <span class="comment">// 另一个进程的ID</span></span><br><span class="line">    flag[process] = <span class="number">1</span>;        <span class="comment">// 表示当前进程想要进入临界区</span></span><br><span class="line">    turn = process;           <span class="comment">// 表示当前进程愿意让另一个进程先进入</span></span><br><span class="line">    <span class="keyword">while</span> (flag[other] == <span class="number">1</span> &amp;&amp; turn == process);  <span class="comment">// 等待，直到另一个进程不想进入或轮到自己</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leave_region</span><span class="params">(<span class="type">int</span> process)</span> &#123;</span><br><span class="line">    flag[process] = <span class="number">0</span>;        <span class="comment">// 表示当前进程不再需要进入临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="peterson算法的优点"><strong>3. Peterson算法的优点</strong></h4>
<p><strong>Advantages of Peterson’s Solution</strong></p>
<ol type="1">
<li><p><strong>互斥性（Mutual Exclusion）：</strong><br>
<strong>Mutual Exclusion:</strong><br>
• 确保同一时间只有一个进程进入临界区。<br>
<strong>Ensures that only one process enters the critical section at a
time.</strong></p></li>
<li><p><strong>有限等待（Bounded Waiting）：</strong><br>
<strong>Bounded Waiting:</strong><br>
• 确保进程不会无限等待进入临界区。<br>
<strong>Ensures that no process waits forever to enter the critical
section.</strong></p></li>
<li><p><strong>非阻塞性（No Busy Waiting）：</strong><br>
<strong>No Busy Waiting:</strong><br>
• 进程在等待时不会占用CPU资源。<br>
<strong>Processes do not consume CPU resources while
waiting.</strong></p></li>
<li><p><strong>软件实现（Software Implementation）：</strong><br>
<strong>Software Implementation:</strong><br>
• 不依赖硬件支持，适用于任何系统。<br>
<strong>Does not rely on hardware support and can be used on any
system.</strong></p></li>
</ol>
<hr>
<h4 id="peterson算法的工作流程"><strong>4.
Peterson算法的工作流程</strong></h4>
<p><strong>Workflow of Peterson’s Solution</strong></p>
<p>• <strong>进程0和进程1的执行流程：</strong><br>
<strong>Execution Flow of Process 0 and Process 1:</strong></p>
<ol type="1">
<li>进程0调用<code>enter_region(0)</code>，设置<code>flag[0] = 1</code>，并将<code>turn</code>设置为1。<br>
<strong>Process 0 calls <code>enter_region(0)</code>, sets
<code>flag[0] = 1</code>, and sets <code>turn</code> to
1.</strong><br>
</li>
<li>进程1调用<code>enter_region(1)</code>，设置<code>flag[1] = 1</code>，并将<code>turn</code>设置为0。<br>
<strong>Process 1 calls <code>enter_region(1)</code>, sets
<code>flag[1] = 1</code>, and sets <code>turn</code> to
0.</strong><br>
</li>
<li>进程0检查<code>flag[1]</code>和<code>turn</code>：<br>
<strong>Process 0 checks <code>flag[1]</code> and
<code>turn</code>:</strong><br>
◦
如果<code>flag[1] == 1</code>且<code>turn == 0</code>，进程0等待。<br>
<strong>If <code>flag[1] == 1</code> and <code>turn == 0</code>, Process
0 waits.</strong><br>
</li>
<li>进程1检查<code>flag[0]</code>和<code>turn</code>：<br>
<strong>Process 1 checks <code>flag[0]</code> and
<code>turn</code>:</strong><br>
◦
如果<code>flag[0] == 1</code>且<code>turn == 1</code>，进程1等待。<br>
<strong>If <code>flag[0] == 1</code> and <code>turn == 1</code>, Process
1 waits.</strong><br>
</li>
<li>如果<code>turn</code>的值使得一个进程可以进入临界区，则该进程进入临界区。<br>
<strong>If the value of <code>turn</code> allows a process to enter the
critical section, that process enters.</strong></li>
</ol>
<hr>
<h4 id="peterson算法的局限性"><strong>5.
Peterson算法的局限性</strong></h4>
<p><strong>Limitations of Peterson’s Solution</strong></p>
<ol type="1">
<li><p><strong>仅适用于两个进程：</strong><br>
<strong>Only Works for Two Processes:</strong><br>
• Peterson算法只能解决两个进程之间的互斥问题。<br>
<strong>Peterson’s solution only works for mutual exclusion between two
processes.</strong></p></li>
<li><p><strong>不支持多处理器系统：</strong><br>
<strong>Does Not Support Multiprocessor Systems:</strong><br>
• 在多处理器系统中，内存访问顺序可能不一致，导致算法失效。<br>
<strong>In multiprocessor systems, memory access order may be
inconsistent, causing the algorithm to fail.</strong></p></li>
</ol>
<hr>
<h3 id="总结-2"><strong>总结</strong></h3>
<p><strong>Summary</strong></p>
<p>• <strong>Peterson算法：</strong><br>
<strong>Peterson’s Solution:</strong><br>
•
通过<code>turn</code>和<code>flag</code>两个变量实现互斥和有限等待。<br>
<strong>Achieves mutual exclusion and bounded waiting using
<code>turn</code> and <code>flag</code> variables.</strong></p>
<p>• <strong>优点：</strong><br>
<strong>Advantages:</strong><br>
• 满足互斥的四个条件，不依赖硬件支持。<br>
<strong>Satisfies the four conditions for mutual exclusion and does not
rely on hardware support.</strong></p>
<p>• <strong>局限性：</strong><br>
<strong>Limitations:</strong><br>
• 仅适用于两个进程，不支持多处理器系统。<br>
<strong>Only works for two processes and does not support multiprocessor
systems.</strong></p>
<p>Peterson算法是一种经典的软件解决方案，适用于简单的双进程互斥场景。对于更复杂的场景，需要使用更高级的同步机制。<br>
<strong>Peterson’s solution is a classic software-based approach
suitable for simple two-process mutual exclusion scenarios. For more
complex scenarios, higher-level synchronization mechanisms are
needed.</strong></p></li>
<li><p><strong>硬件解决方案：测试并设置锁（Test-and-Set Locks,
TSL）：</strong> <strong>硬件解决方案：测试并设置锁（Test-and-Set Locks,
TSL）的深入解释</strong></p>
<p>测试并设置锁（TSL）是一种硬件支持的原子操作，用于实现互斥。它通过一条特殊的指令<code>tsl</code>，确保对共享变量的检查和设置是不可分割的，从而避免竞争条件。以下是详细解释：</p>
<hr>
<h4 id="tsl的工作原理"><strong>1. TSL的工作原理</strong></h4>
<blockquote>
<p>先锁上，反复判断——忙等待情况！</p>
</blockquote>
<p><strong>How TSL Works</strong></p>
<p>• <strong>TSL指令的功能：</strong><br>
<strong>Functionality of TSL Instruction:</strong><br>
•
TSL指令将内存中的值复制到寄存器，并将内存中的值设置为1，这两步操作是原子的。<br>
<strong>The TSL instruction copies a value in memory to a CPU register
and sets the memory value to 1, both in a single atomic
action.</strong></p>
<p>• <strong>锁变量的定义：</strong><br>
<strong>Definition of Lock Variable:</strong><br>
• 锁变量是一个共享的整型变量，初始化为0。<br>
<strong>The lock variable is a shared integer variable, typically
initialized to 0.</strong><br>
• 当锁变量为0时，表示临界区可用；为1时，表示临界区已被占用。<br>
<strong>When the lock variable is 0, the critical section is available;
when it is 1, the critical section is occupied.</strong></p>
<p>• <strong>进入临界区的逻辑：</strong><br>
<strong>Logic for Entering Critical Section:</strong></p>
<ol type="1">
<li>进程调用<code>tsl(&amp;lock)</code>指令，将锁变量的值复制到寄存器，并将锁变量设置为1。<br>
<strong>The process calls the <code>tsl(&amp;lock)</code> instruction,
which copies the value of the lock variable to a register and sets the
lock variable to 1.</strong><br>
</li>
<li>如果寄存器中的值为0，表示锁变量之前为0，进程进入临界区。<br>
<strong>If the value in the register is 0, it means the lock variable
was previously 0, and the process enters the critical
section.</strong><br>
</li>
<li>如果寄存器中的值为1，表示锁变量之前为1，进程等待，直到锁变量变为0。<br>
<strong>If the value in the register is 1, it means the lock variable
was previously 1, and the process waits until it becomes
0.</strong></li>
</ol>
<p>• <strong>退出临界区的逻辑：</strong><br>
<strong>Logic for Exiting Critical Section:</strong></p>
<ol type="1">
<li>进程将锁变量重置为0，表示释放临界区。<br>
<strong>The process resets the lock variable to 0, indicating that the
critical section is released.</strong></li>
</ol>
<hr>
<h4 id="代码示例-2"><strong>2. 代码示例</strong></h4>
<p><strong>Code Example</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lock = <span class="number">0</span>;  <span class="comment">// 共享的锁变量，初始化为0</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_region</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (tsl(&amp;lock) != <span class="number">0</span>);  <span class="comment">// 等待，直到锁变量为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leave_region</span><span class="params">()</span> &#123;</span><br><span class="line">    lock = <span class="number">0</span>;  <span class="comment">// 设置锁变量为0，表示释放临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="tsl的优点"><strong>3. TSL的优点</strong></h4>
<p><strong>Advantages of TSL</strong></p>
<ol type="1">
<li><p><strong>原子性：</strong><br>
<strong>Atomicity:</strong><br>
•
TSL指令是原子的，确保锁变量的检查和设置是不可分割的，避免了竞争条件。<br>
<strong>The TSL instruction is atomic, ensuring that the check and set
of the lock variable are indivisible, avoiding race
conditions.</strong></p></li>
<li><p><strong>简单高效：</strong><br>
<strong>Simple and Efficient:</strong><br>
• TSL指令的实现简单，且效率高，适用于需要快速互斥的场景。<br>
<strong>The implementation of TSL is simple and efficient, suitable for
scenarios requiring fast mutual exclusion.</strong></p></li>
<li><p><strong>硬件支持：</strong><br>
<strong>Hardware Support:</strong><br>
• TSL指令由硬件支持，适用于多种处理器架构。<br>
<strong>The TSL instruction is supported by hardware and can be used on
various processor architectures.</strong></p></li>
</ol>
<hr>
<h4 id="tsl的局限性"><strong>4. TSL的局限性</strong></h4>
<p><strong>Limitations of TSL</strong></p>
<ol type="1">
<li><p><strong>忙等待（Busy Waiting）：</strong><br>
<strong>Busy Waiting:</strong><br>
• 进程在等待锁变量变为0时，会不断执行TSL指令，占用CPU资源。<br>
<strong>While waiting for the lock variable to become 0, the process
continuously executes the TSL instruction, consuming CPU
resources.</strong></p></li>
<li><p><strong>仅适用于单处理器系统：</strong><br>
<strong>Only Suitable for Single-Processor Systems:</strong><br>
• 在多处理器系统中，TSL指令可能无法完全避免竞争条件。<br>
<strong>In multiprocessor systems, the TSL instruction may not
completely avoid race conditions.</strong></p></li>
</ol>
<hr>
<h4 id="tsl的工作流程"><strong>5. TSL的工作流程</strong></h4>
<p><strong>Workflow of TSL</strong></p>
<p>• <strong>进程A和进程B的执行流程：</strong><br>
<strong>Execution Flow of Process A and Process B:</strong></p>
<ol type="1">
<li>进程A调用<code>enter_region()</code>，执行<code>tsl(&amp;lock)</code>：<br>
<strong>Process A calls <code>enter_region()</code> and executes
<code>tsl(&amp;lock)</code>:</strong><br>
◦ 如果锁变量为0，进程A进入临界区。<br>
<strong>If the lock variable is 0, Process A enters the critical
section.</strong><br>
◦ 如果锁变量为1，进程A等待。<br>
<strong>If the lock variable is 1, Process A waits.</strong><br>
</li>
<li>进程B调用<code>enter_region()</code>，执行<code>tsl(&amp;lock)</code>：<br>
<strong>Process B calls <code>enter_region()</code> and executes
<code>tsl(&amp;lock)</code>:</strong><br>
◦ 如果锁变量为0，进程B进入临界区。<br>
<strong>If the lock variable is 0, Process B enters the critical
section.</strong><br>
◦ 如果锁变量为1，进程B等待。<br>
<strong>If the lock variable is 1, Process B waits.</strong><br>
</li>
<li>进程A退出临界区，将锁变量重置为0。<br>
<strong>Process A exits the critical section and resets the lock
variable to 0.</strong><br>
</li>
<li>进程B检测到锁变量为0，进入临界区。<br>
<strong>Process B detects that the lock variable is 0 and enters the
critical section.</strong></li>
</ol>
<hr>
<h3 id="总结-3"><strong>总结</strong></h3>
<p><strong>Summary</strong></p>
<p>• <strong>TSL的工作原理：</strong><br>
<strong>How TSL Works:</strong><br>
• 通过一条原子的TSL指令，实现锁变量的检查和设置，确保互斥。<br>
<strong>Uses an atomic TSL instruction to check and set the lock
variable, ensuring mutual exclusion.</strong></p>
<p>• <strong>优点：</strong><br>
<strong>Advantages:</strong><br>
• 原子性、简单高效、硬件支持。<br>
<strong>Atomicity, simplicity, efficiency, and hardware
support.</strong></p>
<p>• <strong>局限性：</strong><br>
<strong>Limitations:</strong><br>
• 忙等待，仅适用于单处理器系统。<br>
<strong>Busy waiting and only suitable for single-processor
systems.</strong></p>
<p>TSL是一种高效的硬件解决方案，适用于需要快速互斥的场景，但在多处理器系统中可能需要更复杂的机制。<br>
<strong>TSL is an efficient hardware-based solution suitable for
scenarios requiring fast mutual exclusion, but more complex mechanisms
may be needed in multiprocessor systems.</strong></p></li>
<li><p><strong>硬件解决方案：交换指令（XCHG
Instruction）：</strong><br>
• <strong>工作原理：</strong><br>
<strong>How it works:</strong><br>
◦ 交换两个位置的内容，原子操作。<br>
<strong>Exchanges the contents of two locations
atomically.</strong><br>
• <strong>适用场景：</strong> 所有Intel x86
CPU都使用XCHG指令进行低级同步。<br>
<strong>All Intel x86 CPUs use the XCHG instruction for low-level
synchronization.</strong></p></li>
</ol>
<hr>
<h3 id="总结-4"><strong>总结</strong></h3>
<p><strong>Summary</strong></p>
<p>• <strong>临界区的四个条件：</strong><br>
<strong>Four Conditions for Critical Regions:</strong><br>
• 互斥性、无假设性、非阻塞性、有限等待。<br>
<strong>Mutual exclusion, no assumptions, non-blocking, and bounded
waiting.</strong></p>
<p>• <strong>互斥的实现方法：</strong><br>
<strong>Solutions for Mutual Exclusion:</strong><br>
• 禁用中断、锁变量、严格交替、Peterson算法、TSL、XCHG。<br>
<strong>Disabling interrupts, lock variables, strict alternation,
Peterson’s solution, TSL, XCHG.</strong></p>
<p>• <strong>硬件解决方案：</strong><br>
<strong>Hardware Solutions:</strong><br>
• TSL和XCHG指令提供原子操作，确保互斥。<br>
<strong>TSL and XCHG instructions provide atomic operations, ensuring
mutual exclusion.</strong></p>
<p>这些方法各有优缺点，需要根据具体场景选择合适的实现方式。<br>
<strong>These methods have their pros and cons, and the appropriate
implementation should be chosen based on the specific
scenario.</strong></p>
<h3 id="忙等待的互斥mutual-exclusion-with-busy-waiting"><strong>忙等待的互斥（Mutual
Exclusion with Busy Waiting）</strong></h3>
<p>忙等待（Busy
Waiting）是一种实现互斥的方式，但它在某些情况下可能会导致问题，例如优先级反转（Priority
Inversion）。以下是详细解释：</p>
<hr>
<h4 id="忙等待的定义"><strong>1. 忙等待的定义</strong></h4>
<p><strong>Definition of Busy Waiting</strong></p>
<p>• <strong>忙等待：</strong><br>
<strong>Busy Waiting:</strong><br>
•
进程在等待进入临界区时，会不断执行一个循环，检查某个条件是否满足，直到条件为真。<br>
<strong>A process waiting to enter the critical section continuously
executes a loop, checking whether a condition is met, until the
condition becomes true.</strong></p>
<p>• <strong>特点：</strong><br>
<strong>Characteristics:</strong><br>
• 忙等待会占用CPU资源，因为进程在等待时不会释放CPU。<br>
<strong>Busy waiting consumes CPU resources because the process does not
release the CPU while waiting.</strong></p>
<hr>
<h4 id="忙等待的互斥实现"><strong>2. 忙等待的互斥实现</strong></h4>
<p><strong>Mutual Exclusion with Busy Waiting</strong></p>
<p>• <strong>示例：测试并设置锁（Test-and-Set Locks,
TSL）</strong><br>
<strong>Example: Test-and-Set Locks (TSL)</strong><br>
• 进程在进入临界区前，不断执行TSL指令，检查锁变量是否为0。<br>
<strong>Before entering the critical section, the process continuously
executes the TSL instruction, checking whether the lock variable is
0.</strong></p>
<p>• <strong>代码示例：</strong><br>
<strong>Code Example:</strong><br>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> lock = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">enter_region</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (tsl(&amp;lock) != <span class="number">0</span>);  <span class="comment">// 忙等待，直到锁变量为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">leave_region</span><span class="params">()</span> &#123;</span><br><span class="line">    lock = <span class="number">0</span>;  <span class="comment">// 设置锁变量为0，表示释放临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="忙等待的问题"><strong>3. 忙等待的问题</strong></h4>
<p><strong>Problems with Busy Waiting</strong></p>
<ol type="1">
<li><p><strong>优先级反转（Priority Inversion）：</strong><br>
<strong>Priority Inversion:</strong><br>
• 当使用简单的优先级调度时，忙等待可能导致优先级反转。<br>
<strong>When simple priority scheduling is used, busy waiting may lead
to priority inversion.</strong><br>
• <strong>示例：</strong><br>
<strong>Example:</strong><br>
◦ 低优先级进程P0在临界区中执行。<br>
<strong>Low-priority process P0 is executing in the critical
section.</strong><br>
◦
高优先级进程P1尝试进入临界区，但由于忙等待，它不断执行TSL指令，占用CPU资源。<br>
<strong>High-priority process P1 tries to enter the critical section
but, due to busy waiting, continuously executes the TSL instruction,
consuming CPU resources.</strong><br>
◦
由于优先级调度，P1会一直被调度，而P0无法执行，导致P1被低优先级进程P0阻塞。<br>
<strong>Due to priority scheduling, P1 keeps getting scheduled, while P0
cannot execute, causing P1 to be blocked by the low-priority process
P0.</strong><br>
◦ 这种情况称为优先级反转。<br>
<strong>This situation is called priority inversion.</strong></p></li>
<li><p><strong>CPU资源浪费：</strong><br>
<strong>CPU Resource Waste:</strong><br>
• 忙等待会占用CPU资源，降低系统效率。<br>
<strong>Busy waiting consumes CPU resources, reducing system
efficiency.</strong></p></li>
</ol>
<hr>
<h4 id="优先级反转的示例"><strong>4. 优先级反转的示例</strong></h4>
<p><strong>Example of Priority Inversion</strong></p>
<p>• <strong>场景描述：</strong><br>
<strong>Scenario Description:</strong><br>
1. 低优先级进程P0在临界区中执行。<br>
<strong>Low-priority process P0 is executing in the critical
section.</strong><br>
2. 高优先级进程P1尝试进入临界区，但由于忙等待，它不断执行TSL指令。<br>
<strong>High-priority process P1 tries to enter the critical section
but, due to busy waiting, continuously executes the TSL
instruction.</strong><br>
3. 由于优先级调度，P1会一直被调度，而P0无法执行，导致P1被P0阻塞。<br>
<strong>Due to priority scheduling, P1 keeps getting scheduled, while P0
cannot execute, causing P1 to be blocked by P0.</strong><br>
4. 这种情况称为优先级反转。<br>
<strong>This situation is called priority inversion.</strong></p>
<hr>
<h4 id="如何避免优先级反转"><strong>5.
如何避免优先级反转？</strong></h4>
<p><strong>How to Avoid Priority Inversion?</strong></p>
<ol type="1">
<li><p><strong>优先级继承（Priority Inheritance）：</strong><br>
<strong>Priority Inheritance:</strong><br>
•
当高优先级进程被低优先级进程阻塞时，低优先级进程临时继承高优先级，以避免优先级反转。<br>
<strong>When a high-priority process is blocked by a low-priority
process, the low-priority process temporarily inherits the high priority
to avoid priority inversion.</strong></p></li>
<li><p><strong>优先级天花板（Priority Ceiling）：</strong><br>
<strong>Priority Ceiling:</strong><br>
•
为临界区分配一个优先级天花板，当进程进入临界区时，其优先级提升到天花板优先级。<br>
<strong>Assign a priority ceiling to the critical section, and when a
process enters the critical section, its priority is raised to the
ceiling priority.</strong></p></li>
<li><p><strong>使用信号量（Semaphore）：</strong><br>
<strong>Using Semaphore:</strong><br>
• 使用信号量实现互斥，避免忙等待。<br>
<strong>Use semaphores to implement mutual exclusion, avoiding busy
waiting.</strong></p></li>
</ol>
<hr>
<h3 id="总结-5"><strong>总结</strong></h3>
<p><strong>Summary</strong></p>
<p>• <strong>忙等待的互斥：</strong><br>
<strong>Mutual Exclusion with Busy Waiting:</strong><br>
• 进程在等待进入临界区时，不断执行循环检查条件，占用CPU资源。<br>
<strong>A process waiting to enter the critical section continuously
executes a loop, consuming CPU resources.</strong></p>
<p>• <strong>优先级反转：</strong><br>
<strong>Priority Inversion:</strong><br>
• 当高优先级进程被低优先级进程阻塞时，称为优先级反转。<br>
<strong>When a high-priority process is blocked by a low-priority
process, it is called priority inversion.</strong></p>
<p>• <strong>避免优先级反转的方法：</strong><br>
<strong>Ways to Avoid Priority Inversion:</strong><br>
• 优先级继承、优先级天花板、使用信号量。<br>
<strong>Priority inheritance, priority ceiling, and using
semaphores.</strong></p>
<p>忙等待虽然简单，但可能导致优先级反转和CPU资源浪费，因此在设计互斥机制时需要谨慎选择方法。<br>
<strong>Busy waiting is simple but may lead to priority inversion and
CPU resource waste, so careful consideration is needed when designing
mutual exclusion mechanisms.</strong></p>
<h3 id="睡眠与唤醒sleep-and-wakeup"><strong>睡眠与唤醒（Sleep and
Wakeup）</strong></h3>
<p>睡眠与唤醒是一种解决忙等待问题的方法，通过让进程在无法进入临界区时进入睡眠状态，而不是占用CPU资源。以下是详细解释：</p>
<hr>
<h4 id="睡眠与唤醒的基本思想"><strong>1.
睡眠与唤醒的基本思想</strong></h4>
<p><strong>Basic Idea of Sleep and Wakeup</strong></p>
<p>• <strong>问题：</strong><br>
<strong>Problem:</strong><br>
• 忙等待会占用CPU资源，降低系统效率。<br>
<strong>Busy waiting consumes CPU resources, reducing system
efficiency.</strong></p>
<p>• <strong>解决方案：</strong><br>
<strong>Solution:</strong><br>
•
当进程无法进入临界区时，进入睡眠状态（<code>sleep</code>），而不是忙等待。<br>
<strong>When a process cannot enter the critical section, it goes to
sleep (<code>sleep</code>) instead of busy waiting.</strong><br>
•
当条件满足时，唤醒（<code>wakeup</code>）睡眠的进程，使其重新尝试进入临界区。<br>
<strong>When the condition is met, wake up (<code>wakeup</code>) the
sleeping process so it can retry entering the critical
section.</strong></p>
<hr>
<h4 id="生产者-消费者问题producer-consumer-problem"><strong>2.
生产者-消费者问题（Producer-Consumer Problem）</strong></h4>
<p><strong>Producer-Consumer Problem (Bounded-Buffer
Problem)</strong></p>
<p>• <strong>问题描述：</strong><br>
<strong>Problem Description:</strong><br>
• 两个进程共享一个大小为N的循环缓冲区。<br>
<strong>Two processes share a circular buffer that can hold N
items.</strong><br>
• 生产者向缓冲区中添加数据，消费者从缓冲区中移除数据。<br>
<strong>Producers add items to the buffer, and consumers remove items
from the buffer.</strong><br>
• 需要限制对缓冲区的访问，以确保正确执行。<br>
<strong>Access to the buffer needs to be restricted to ensure correct
execution.</strong></p>
<p>• <strong>潜在问题：</strong><br>
<strong>Potential Problem:</strong><br>
• 如果生产者和消费者同时访问缓冲区，可能会导致数据不一致。<br>
<strong>If producers and consumers access the buffer simultaneously, it
may lead to data inconsistency.</strong></p>
<hr>
<h4 id="睡眠与唤醒的致命竞争条件"><strong>3.
睡眠与唤醒的致命竞争条件</strong></h4>
<p><strong>Fatal Race Condition with Sleep and Wakeup</strong></p>
<p>• <strong>场景描述：</strong><br>
<strong>Scenario Description:</strong><br>
1. 消费者检查缓冲区是否为空（<code>count == 0</code>）。<br>
<strong>The consumer checks if the buffer is empty
(<code>count == 0</code>).</strong><br>
2. 消费者被中断，生产者向缓冲区中添加数据，并尝试唤醒消费者。<br>
<strong>The consumer is interrupted, the producer adds data to the
buffer, and tries to wake up the consumer.</strong><br>
3. 消费者继续执行，发现缓冲区为空，进入睡眠状态。<br>
<strong>The consumer continues execution, finds the buffer empty, and
goes to sleep.</strong><br>
4. 生产者的唤醒信号丢失，生产者和消费者都进入睡眠状态，导致死锁。<br>
<strong>The producer’s wakeup signal is lost, and both the producer and
consumer go to sleep, causing a deadlock.</strong></p>
<hr>
<h4 id="解决方案添加唤醒等待位"><strong>4.
解决方案：添加唤醒等待位</strong></h4>
<p><strong>Solution: Add a Wakeup Waiting Bit</strong></p>
<p>• <strong>工作原理：</strong><br>
<strong>How It Works:</strong><br>
•
当向一个仍然处于唤醒状态的进程发送唤醒信号时，唤醒等待位被设置为1。<br>
<strong>When a wakeup signal is sent to a process that is still awake,
the wakeup waiting bit is set to 1.</strong><br>
•
当进程尝试进入睡眠状态时，如果唤醒等待位为1，则将其重置为0，但进程仍然保持唤醒状态。<br>
<strong>When the process tries to go to sleep, if the wakeup waiting bit
is on, it is turned off, but the process remains awake.</strong></p>
<p>• <strong>代码示例：</strong><br>
<strong>Code Example:</strong><br>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> wakeup_waiting = <span class="number">0</span>;  <span class="comment">// 唤醒等待位</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sleep</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (wakeup_waiting == <span class="number">1</span>) &#123;</span><br><span class="line">        wakeup_waiting = <span class="number">0</span>;  <span class="comment">// 重置唤醒等待位</span></span><br><span class="line">        <span class="keyword">return</span>;              <span class="comment">// 保持唤醒状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进入睡眠状态</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">wakeup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="comment">/* 进程处于睡眠状态 */</span>) &#123;</span><br><span class="line">        <span class="comment">// 唤醒进程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        wakeup_waiting = <span class="number">1</span>;  <span class="comment">// 设置唤醒等待位</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="总结-6"><strong>5. 总结</strong></h4>
<p><strong>Summary</strong></p>
<p>• <strong>睡眠与唤醒：</strong><br>
<strong>Sleep and Wakeup:</strong><br>
• 让进程在无法进入临界区时进入睡眠状态，而不是忙等待。<br>
<strong>Let processes go to sleep when they cannot enter the critical
section, instead of busy waiting.</strong></p>
<p>• <strong>生产者-消费者问题：</strong><br>
<strong>Producer-Consumer Problem:</strong><br>
• 需要限制对共享缓冲区的访问，以避免数据不一致。<br>
<strong>Access to the shared buffer needs to be restricted to avoid data
inconsistency.</strong></p>
<p>• <strong>致命竞争条件：</strong><br>
<strong>Fatal Race Condition:</strong><br>
• 如果唤醒信号丢失，生产者和消费者可能都进入睡眠状态，导致死锁。<br>
<strong>If the wakeup signal is lost, both the producer and consumer may
go to sleep, causing a deadlock.</strong></p>
<p>• <strong>解决方案：</strong><br>
<strong>Solution:</strong><br>
• 添加唤醒等待位，确保唤醒信号不会丢失。<br>
<strong>Add a wakeup waiting bit to ensure that wakeup signals are not
lost.</strong></p>
<p>睡眠与唤醒是一种有效的解决忙等待问题的方法，但在实现时需要注意竞争条件和信号丢失问题。<br>
<strong>Sleep and wakeup is an effective solution to busy waiting, but
care must be taken to address race conditions and signal loss issues
during implementation.</strong></p>
<h3 id="信号量semaphores"><strong>信号量（Semaphores）</strong></h3>
<p>信号量是一种高级的同步机制，由Edsger W.
Dijkstra于1965年提出，用于解决进程间的互斥和同步问题。以下是信号量的详细解释：</p>
<hr>
<h4 id="信号量的定义"><strong>1. 信号量的定义</strong></h4>
<p><strong>Definition of Semaphores</strong></p>
<p>• <strong>信号量的结构：</strong><br>
<strong>Structure of Semaphores:</strong><br>
• 信号量<code>S</code>由两部分组成：<br>
<strong>A semaphore <code>S</code> consists of two parts:</strong><br>
1. <strong>计数器<code>count</code>：</strong>
表示可用资源的数量。<br>
<strong>Counter <code>count</code>:</strong> Represents the number of
available resources.<br>
2. <strong>阻塞队列<code>Q</code>：</strong> 存储被阻塞进程的PID。<br>
<strong>Blocked queue <code>Q</code>:</strong> Stores the PIDs of
blocked processes.</p>
<p>• <strong>代码表示：</strong><br>
<strong>Code Representation:</strong><br>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">    <span class="built_in">queue</span> Q;</span><br><span class="line">&#125; semaphore;</span><br><span class="line">semaphore S;</span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="信号量的类型"><strong>2. 信号量的类型</strong></h4>
<p><strong>Types of Semaphores</strong></p>
<ol type="1">
<li><p><strong>计数信号量（Counting Semaphores）：</strong><br>
<strong>Counting Semaphores:</strong><br>
•
计数器<code>count</code>的范围为<code>0..N</code>，初始化为<code>N</code>。<br>
<strong>The counter <code>count</code> ranges from <code>0..N</code> and
is initialized to <code>N</code>.</strong><br>
• 用于管理多个资源。<br>
<strong>Used to manage multiple resources.</strong></p></li>
<li><p><strong>二进制信号量（Binary Semaphores）：</strong><br>
<strong>Binary Semaphores:</strong><br>
•
计数器<code>count</code>的范围为<code>0,1</code>，初始化为<code>1</code>。<br>
<strong>The counter <code>count</code> ranges from <code>0,1</code> and
is initialized to <code>1</code>.</strong><br>
• 用于实现互斥。<br>
<strong>Used to implement mutual exclusion.</strong></p></li>
</ol>
<hr>
<h4 id="信号量的操作"><strong>3. 信号量的操作</strong></h4>
<p><strong>Operations on Semaphores</strong></p>
<ol type="1">
<li><p><strong>P操作（P(S)或wait(S)或down(S)）：</strong><br>
<strong>P Operation (P(S) or wait(S) or down(S)):</strong><br>
• 申请资源，计数器<code>count</code>减1。<br>
<strong>Acquire a resource and decrement
<code>count</code>.</strong><br>
•
如果<code>count &lt; 0</code>，则阻塞当前进程，并将其PID加入阻塞队列<code>Q</code>。<br>
<strong>If <code>count &lt; 0</code>, block the current process and add
its PID to the blocked queue <code>Q</code>.</strong></p></li>
<li><p><strong>V操作（V(S)或signal(S)或up(S)）：</strong><br>
<strong>V Operation (V(S) or signal(S) or up(S)):</strong><br>
• 释放资源，计数器<code>count</code>加1。<br>
<strong>Release a resource and increment
<code>count</code>.</strong><br>
•
如果<code>count &lt;= 0</code>，则从阻塞队列<code>Q</code>中唤醒一个进程。<br>
<strong>If <code>count &lt;= 0</code>, wake up a process from the
blocked queue <code>Q</code>.</strong></p></li>
</ol>
<p>• <strong>原子性：</strong><br>
<strong>Atomicity:</strong><br>
• 任何信号量操作都是不可分割的，必须原子执行。<br>
<strong>Any semaphore operation is indivisible and must be executed
atomically.</strong></p>
<hr>
<h4 id="p操作和v操作的详细流程"><strong>4.
P操作和V操作的详细流程</strong></h4>
<p><strong>Detailed Workflow of P and V Operations</strong></p>
<ol type="1">
<li><strong>P操作（DOWN(S)）：</strong><br>
<strong>P Operation (DOWN(S)):</strong><br>
• <code>S.count = S.count - 1;</code><br>
• 如果<code>S.count &lt; 0</code>，则：<br>
<strong>If <code>S.count &lt; 0</code>, then:</strong>
<ol type="1">
<li>将当前进程的PID加入阻塞队列<code>Q</code>。<br>
<strong>Enqueue the PID of the current process in
<code>Q</code>.</strong><br>
</li>
<li>阻塞当前进程（将其PID从就绪队列中移除）。<br>
<strong>Block the current process (remove its PID from the ready
queue).</strong><br>
</li>
<li>将控制权交给调度器。<br>
<strong>Pass control to the scheduler.</strong></li>
</ol></li>
<li><strong>V操作（UP(S)）：</strong><br>
<strong>V Operation (UP(S)):</strong><br>
• <code>S.count = S.count + 1;</code><br>
• 如果<code>S.count &lt;= 0</code>，则：<br>
<strong>If <code>S.count &lt;= 0</code>, then:</strong>
<ol type="1">
<li>从阻塞队列<code>Q</code>中移除一个PID。<br>
<strong>Remove a PID from <code>Q</code>.</strong><br>
</li>
<li>将该PID加入就绪队列。<br>
<strong>Add the PID to the ready queue.</strong><br>
</li>
<li>将控制权交给调度器。<br>
<strong>Pass control to the scheduler.</strong></li>
</ol></li>
</ol>
<hr>
<h4 id="生产者-消费者问题中的信号量"><strong>5.
生产者-消费者问题中的信号量</strong></h4>
<p><strong>Semaphores in the Producer-Consumer Problem</strong></p>
<p>• <strong>信号量的使用：</strong><br>
<strong>Use of Semaphores:</strong></p>
<ol type="1">
<li><strong>互斥信号量（mutex）：</strong>
用于确保生产者和消费者互斥访问缓冲区。<br>
<strong>Mutex semaphore:</strong> Ensures mutual exclusion between
producers and consumers when accessing the buffer.<br>
</li>
<li><strong>同步信号量（full, empty）：</strong>
用于协调生产者和消费者的执行顺序。<br>
<strong>Synchronization semaphores (full, empty):</strong> Coordinate
the execution order of producers and consumers.</li>
</ol>
<hr>
<h4 id="信号量的总结"><strong>6. 信号量的总结</strong></h4>
<p><strong>Summary of Semaphores</strong></p>
<p>• <strong>信号量的用途：</strong><br>
<strong>Uses of Semaphores:</strong><br>
1. <strong>互斥（mutex）：</strong> 确保多个进程互斥访问共享资源。<br>
<strong>Mutual exclusion (mutex):</strong> Ensures that multiple
processes mutually exclude access to shared resources.<br>
2. <strong>进程同步（full, empty）：</strong> 协调进程的执行顺序。<br>
<strong>Process synchronization (full, empty):</strong> Coordinates the
execution order of processes.</p>
<p>• <strong>信号量的优点：</strong><br>
<strong>Advantages of Semaphores:</strong><br>
• 提供了一种高级的同步机制，适用于复杂的进程同步场景。<br>
<strong>Provides a high-level synchronization mechanism suitable for
complex process synchronization scenarios.</strong></p>
<p>• <strong>信号量的缺点：</strong><br>
<strong>Disadvantages of Semaphores:</strong><br>
• 使用不当可能导致死锁或优先级反转。<br>
<strong>Improper use may lead to deadlock or priority
inversion.</strong></p>
<p>• <strong>信号量是否容易使用？</strong><br>
<strong>Is it easy to use semaphores?</strong><br>
• 信号量的使用需要谨慎设计，避免竞争条件和死锁。<br>
<strong>Using semaphores requires careful design to avoid race
conditions and deadlock.</strong></p>
<hr>
<h3 id="总结-7"><strong>总结</strong></h3>
<p><strong>Conclusion</strong></p>
<p>信号量是一种强大的同步工具，可以用于实现互斥和进程同步。通过理解信号量的工作原理和操作，可以更好地设计和实现多进程系统中的同步机制。<br>
<strong>Semaphores are a powerful synchronization tool that can be used
to implement mutual exclusion and process synchronization. By
understanding the working principles and operations of semaphores, we
can better design and implement synchronization mechanisms in
multi-process systems.</strong></p>
<h3 id="互斥锁mutex-binary-semaphore"><strong>互斥锁（Mutex: Binary
Semaphore）</strong></h3>
<p>互斥锁是信号量的简化版本，专门用于解决互斥问题。以下是互斥锁的详细解释：</p>
<hr>
<h4 id="互斥锁的定义"><strong>1. 互斥锁的定义</strong></h4>
<p><strong>Definition of Mutex</strong></p>
<p>• <strong>互斥锁：</strong><br>
<strong>Mutex:</strong><br>
• 互斥锁是一种二进制信号量，只有两种状态：<br>
<strong>A mutex is a binary semaphore with only two
states:</strong><br>
1. <strong>锁定（Locked）：</strong> 表示资源被占用。<br>
<strong>Locked:</strong> Indicates that the resource is occupied.<br>
2. <strong>解锁（Unlocked）：</strong> 表示资源可用。<br>
<strong>Unlocked:</strong> Indicates that the resource is available.</p>
<p>• <strong>简化信号量：</strong><br>
<strong>Simplified Semaphore:</strong><br>
• 互斥锁是信号量的简化版本，专门用于实现互斥。<br>
<strong>A mutex is a simplified version of a semaphore, specifically
used for mutual exclusion.</strong></p>
<hr>
<h4 id="互斥锁的使用"><strong>2. 互斥锁的使用</strong></h4>
<p><strong>Using Mutex for Mutual Exclusion</strong></p>
<p>• <strong>互斥锁的初始化：</strong><br>
<strong>Initialization of Mutex:</strong><br>
• 互斥锁的计数器<code>count</code>初始化为1。<br>
<strong>The counter <code>count</code> of the mutex is initialized to
1.</strong></p>
<p>• <strong>互斥锁的操作：</strong><br>
<strong>Operations on Mutex:</strong><br>
1. <strong>DOWN(mutex)：</strong><br>
◦ 在进入临界区之前调用，申请互斥锁。<br>
<strong>Called before entering the critical section to acquire the
mutex.</strong><br>
◦
如果<code>mutex.count == 1</code>，则锁定互斥锁，<code>mutex.count</code>减1。<br>
<strong>If <code>mutex.count == 1</code>, lock the mutex and decrement
<code>mutex.count</code>.</strong><br>
◦ 如果<code>mutex.count == 0</code>，则阻塞当前进程。<br>
<strong>If <code>mutex.count == 0</code>, block the current
process.</strong></p>
<ol start="2" type="1">
<li><strong>UP(mutex)：</strong><br>
◦ 在离开临界区之后调用，释放互斥锁。<br>
<strong>Called after leaving the critical section to release the
mutex.</strong><br>
◦ <code>mutex.count</code>加1。<br>
<strong>Increment <code>mutex.count</code>.</strong><br>
◦ 如果有进程被阻塞，则唤醒一个进程。<br>
<strong>If there are blocked processes, wake up one
process.</strong></li>
</ol>
<p>• <strong>代码示例：</strong><br>
<strong>Code Example:</strong><br>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 初始化互斥锁，计数器为1</span></span><br><span class="line"></span><br><span class="line">DOWN(mutex);  <span class="comment">// 申请互斥锁</span></span><br><span class="line"><span class="comment">// 临界区</span></span><br><span class="line">UP(mutex);    <span class="comment">// 释放互斥锁</span></span><br></pre></td></tr></table></figure></p>
<hr>
<h4 id="互斥锁的计数器范围"><strong>3. 互斥锁的计数器范围</strong></h4>
<p><strong>Range of Mutex Counter</strong></p>
<p>• <strong>两个并行进程：</strong><br>
<strong>For Two Parallel Processes:</strong><br>
•
互斥锁的计数器<code>mutex.count</code>的取值范围为<code>1, 0, -1</code>。<br>
<strong>The range of <code>mutex.count</code> is <code>1, 0, -1</code>
for two parallel processes.</strong></p>
<p>• <strong>N个并行进程：</strong><br>
<strong>For N Parallel Processes:</strong><br>
•
互斥锁的计数器<code>mutex.count</code>的取值范围为<code>1</code>到<code>-(N-1)</code>。<br>
<strong>The range of <code>mutex.count</code> is <code>1</code> to
<code>-(N-1)</code> for N parallel processes.</strong></p>
<hr>
<h4 id="互斥锁的工作流程"><strong>4. 互斥锁的工作流程</strong></h4>
<p><strong>Workflow of Mutex</strong></p>
<ol type="1">
<li><p><strong>进程A申请互斥锁：</strong><br>
<strong>Process A Acquires Mutex:</strong><br>
•
调用<code>DOWN(mutex)</code>，<code>mutex.count</code>减1，<code>mutex.count</code>变为0。<br>
<strong>Call <code>DOWN(mutex)</code>, decrement
<code>mutex.count</code>, and <code>mutex.count</code> becomes
0.</strong></p></li>
<li><p><strong>进程B申请互斥锁：</strong><br>
<strong>Process B Acquires Mutex:</strong><br>
•
调用<code>DOWN(mutex)</code>，<code>mutex.count</code>减1，<code>mutex.count</code>变为-1。<br>
<strong>Call <code>DOWN(mutex)</code>, decrement
<code>mutex.count</code>, and <code>mutex.count</code> becomes
-1.</strong><br>
• 进程B被阻塞，加入阻塞队列。<br>
<strong>Process B is blocked and added to the blocked
queue.</strong></p></li>
<li><p><strong>进程A释放互斥锁：</strong><br>
<strong>Process A Releases Mutex:</strong><br>
•
调用<code>UP(mutex)</code>，<code>mutex.count</code>加1，<code>mutex.count</code>变为0。<br>
<strong>Call <code>UP(mutex)</code>, increment <code>mutex.count</code>,
and <code>mutex.count</code> becomes 0.</strong><br>
• 进程B被唤醒，从阻塞队列中移除。<br>
<strong>Process B is woken up and removed from the blocked
queue.</strong></p></li>
<li><p><strong>进程B释放互斥锁：</strong><br>
<strong>Process B Releases Mutex:</strong><br>
•
调用<code>UP(mutex)</code>，<code>mutex.count</code>加1，<code>mutex.count</code>变为1。<br>
<strong>Call <code>UP(mutex)</code>, increment <code>mutex.count</code>,
and <code>mutex.count</code> becomes 1.</strong></p></li>
</ol>
<hr>
<h4 id="互斥锁的总结"><strong>5. 互斥锁的总结</strong></h4>
<p><strong>Summary of Mutex</strong></p>
<p>• <strong>互斥锁的用途：</strong><br>
<strong>Uses of Mutex:</strong><br>
• 确保多个进程互斥访问共享资源。<br>
<strong>Ensures that multiple processes mutually exclude access to
shared resources.</strong></p>
<p>• <strong>互斥锁的优点：</strong><br>
<strong>Advantages of Mutex:</strong><br>
• 简单高效，适用于实现互斥。<br>
<strong>Simple and efficient, suitable for implementing mutual
exclusion.</strong></p>
<p>• <strong>互斥锁的缺点：</strong><br>
<strong>Disadvantages of Mutex:</strong><br>
• 仅适用于互斥问题，无法用于更复杂的同步场景。<br>
<strong>Only suitable for mutual exclusion problems and cannot be used
for more complex synchronization scenarios.</strong></p>
<p>• <strong>互斥锁的计数器范围：</strong><br>
<strong>Range of Mutex Counter:</strong><br>
•
对于N个并行进程，<code>mutex.count</code>的取值范围为<code>1</code>到<code>-(N-1)</code>。<br>
<strong>For N parallel processes, the range of <code>mutex.count</code>
is <code>1</code> to <code>-(N-1)</code>.</strong></p>
<hr>
<h3 id="总结-8"><strong>总结</strong></h3>
<p><strong>Conclusion</strong></p>
<p>互斥锁是一种简单高效的同步机制，专门用于解决互斥问题。通过理解互斥锁的工作原理和操作，可以更好地设计和实现多进程系统中的互斥机制。<br>
<strong>A mutex is a simple and efficient synchronization mechanism
specifically used for mutual exclusion. By understanding the working
principles and operations of mutexes, we can better design and implement
mutual exclusion mechanisms in multi-process systems.</strong></p>
<h3 id="问题分析"><strong>问题分析</strong></h3>
<p>题目描述：<br>
如果信号量<code>S</code>的初始值为2，在执行<code>down()</code>和<code>up()</code>操作后，其当前值为<code>-1</code>，这意味着有多少个进程在等待？<br>
选项：<br>
A. 0<br>
B. 1<br>
C. 2<br>
D. 3</p>
<hr>
<h4 id="信号量的初始值和操作"><strong>1.
信号量的初始值和操作</strong></h4>
<p><strong>Initial Value and Operations of Semaphore</strong></p>
<p>• <strong>信号量的初始值：</strong><br>
<strong>Initial Value of Semaphore:</strong><br>
• 信号量<code>S</code>的初始值为2，表示最初有2个可用资源。<br>
<strong>The initial value of semaphore <code>S</code> is 2, indicating
that there are initially 2 available resources.</strong></p>
<p>• <strong><code>down()</code>操作：</strong><br>
<strong><code>down()</code> Operation:</strong><br>
•
<code>down(S)</code>会减少信号量<code>S</code>的值，表示申请一个资源。<br>
<strong><code>down(S)</code> decrements the value of semaphore
<code>S</code>, indicating the acquisition of a resource.</strong><br>
•
如果<code>S</code>的值变为负数，表示资源不足，当前进程会被阻塞，并加入等待队列。<br>
<strong>If the value of <code>S</code> becomes negative, it indicates a
lack of resources, and the current process is blocked and added to the
waiting queue.</strong></p>
<p>• <strong><code>up()</code>操作：</strong><br>
<strong><code>up()</code> Operation:</strong><br>
•
<code>up(S)</code>会增加信号量<code>S</code>的值，表示释放一个资源。<br>
<strong><code>up(S)</code> increments the value of semaphore
<code>S</code>, indicating the release of a resource.</strong><br>
•
如果<code>S</code>的值仍然小于或等于0，表示有进程在等待，唤醒一个等待的进程。<br>
<strong>If the value of <code>S</code> is still less than or equal to 0,
it indicates that there are processes waiting, and one waiting process
is woken up.</strong></p>
<hr>
<h4 id="信号量当前值为-1的含义"><strong>2.
信号量当前值为<code>-1</code>的含义</strong></h4>
<p><strong>Meaning of Semaphore’s Current Value
<code>-1</code></strong></p>
<p>• <strong>信号量的当前值：</strong><br>
<strong>Current Value of Semaphore:</strong><br>
• 信号量<code>S</code>的当前值为<code>-1</code>，表示：<br>
<strong>The current value of semaphore <code>S</code> is
<code>-1</code>, indicating that:</strong><br>
1.
有1个资源被占用（因为<code>S</code>的初始值为2，现在为<code>-1</code>，说明有3个资源被申请）。<br>
<strong>One resource is occupied (since the initial value of
<code>S</code> is 2 and the current value is <code>-1</code>, it means 3
resources have been requested).</strong><br>
2.
有1个进程在等待（因为<code>S</code>的值为<code>-1</code>，表示有1个进程被阻塞）。<br>
<strong>One process is waiting (since the value of <code>S</code> is
<code>-1</code>, it means one process is blocked).</strong></p>
<hr>
<h4 id="为什么答案是b1"><strong>3. 为什么答案是B（1）？</strong></h4>
<p><strong>Why is the Answer B (1)?</strong></p>
<p>• <strong>信号量的当前值为<code>-1</code>，表示：</strong><br>
<strong>The current value of semaphore <code>S</code> is
<code>-1</code>, which means:</strong><br>
• 有1个进程在等待。<br>
<strong>There is 1 process waiting.</strong></p>
<p>• <strong>推导过程：</strong><br>
<strong>Derivation Process:</strong><br>
1. 初始值<code>S = 2</code>，表示有2个可用资源。<br>
<strong>Initial value <code>S = 2</code>, indicating 2 available
resources.</strong><br>
2.
当前值<code>S = -1</code>，表示有3个资源被申请（<code>2 - 3 = -1</code>）。<br>
<strong>Current value <code>S = -1</code>, indicating 3 resources have
been requested (<code>2 - 3 = -1</code>).</strong><br>
3. 如果有3个资源被申请，而初始只有2个资源，说明有1个进程在等待。<br>
<strong>If 3 resources have been requested but only 2 are available, it
means 1 process is waiting.</strong></p>
<hr>
<h4 id="总结-9"><strong>4. 总结</strong></h4>
<p><strong>Summary</strong></p>
<p>•
<strong>信号量的当前值为<code>-1</code>，表示有1个进程在等待。</strong><br>
<strong>The current value of semaphore <code>S</code> is
<code>-1</code>, indicating that 1 process is waiting.</strong></p>
<p>• <strong>正确答案：B（1）。</strong><br>
<strong>Correct Answer: B (1).</strong></p>
<hr>
<h3 id="最终答案"><strong>最终答案</strong></h3>
<p><strong>Final Answer</strong></p>
<p><strong>B. 1</strong></p>
<h3 id="使用信号量进行进程同步"><strong>使用信号量进行进程同步</strong></h3>
<p>信号量不仅可以用于实现互斥，还可以用于协调多个进程的执行顺序。以下是使用信号量实现进程同步的详细解释：</p>
<hr>
<h4 id="问题描述"><strong>1. 问题描述</strong></h4>
<p><strong>Problem Description</strong></p>
<p>假设我们有3个进程：<code>P1</code>、<code>P2</code>和<code>P3</code>。<code>P1</code>和<code>P2</code>必须在<code>P3</code>之前完成执行。<br>
<strong>Suppose we have 3 processes: <code>P1</code>, <code>P2</code>,
and <code>P3</code>. <code>P1</code> and <code>P2</code> must finish
executing before <code>P3</code>.</strong></p>
<hr>
<h4 id="信号量的使用"><strong>2. 信号量的使用</strong></h4>
<p><strong>Using Semaphores</strong></p>
<p>• <strong>信号量的定义：</strong><br>
<strong>Definition of Semaphores:</strong><br>
1. <code>S1 = 0</code>：表示<code>P1</code>尚未完成。<br>
<strong><code>S1 = 0</code>:</strong> Indicates that <code>P1</code> is
still unfinished.<br>
2. <code>S2 = 0</code>：表示<code>P2</code>尚未完成。<br>
<strong><code>S2 = 0</code>:</strong> Indicates that <code>P2</code> is
still unfinished.</p>
<p>• <strong>信号量的操作：</strong><br>
<strong>Operations on Semaphores:</strong><br>
1.
<code>UP(S1)</code>：<code>P1</code>完成时调用，表示<code>P1</code>已完成。<br>
<strong><code>UP(S1)</code>:</strong> Called when <code>P1</code>
finishes, indicating that <code>P1</code> is completed.<br>
2.
<code>UP(S2)</code>：<code>P2</code>完成时调用，表示<code>P2</code>已完成。<br>
<strong><code>UP(S2)</code>:</strong> Called when <code>P2</code>
finishes, indicating that <code>P2</code> is completed.<br>
3.
<code>DOWN(S1)</code>：<code>P3</code>调用，等待<code>P1</code>完成。<br>
<strong><code>DOWN(S1)</code>:</strong> Called by <code>P3</code>,
waiting for <code>P1</code> to complete.<br>
4.
<code>DOWN(S2)</code>：<code>P3</code>调用，等待<code>P2</code>完成。<br>
<strong><code>DOWN(S2)</code>:</strong> Called by <code>P3</code>,
waiting for <code>P2</code> to complete.</p>
<hr>
<h4 id="进程的执行流程"><strong>3. 进程的执行流程</strong></h4>
<p><strong>Execution Flow of Processes</strong></p>
<p>以下是<code>P1</code>、<code>P2</code>和<code>P3</code>的代码示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程P1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// P1的执行逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    UP(S1);  <span class="comment">// P1完成，通知P3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// P2的执行逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    UP(S2);  <span class="comment">// P2完成，通知P3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P3</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">P3</span><span class="params">()</span> &#123;</span><br><span class="line">    DOWN(S1);  <span class="comment">// 等待P1完成</span></span><br><span class="line">    DOWN(S2);  <span class="comment">// 等待P2完成</span></span><br><span class="line">    <span class="comment">// P3的执行逻辑</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="工作流程详解"><strong>4. 工作流程详解</strong></h4>
<p><strong>Detailed Workflow</strong></p>
<ol type="1">
<li><p><strong><code>P1</code>和<code>P2</code>开始执行：</strong><br>
<strong><code>P1</code> and <code>P2</code> start
executing:</strong><br>
• <code>P1</code>和<code>P2</code>分别执行自己的逻辑。<br>
<strong><code>P1</code> and <code>P2</code> execute their respective
logic.</strong></p></li>
<li><p><strong><code>P1</code>完成时调用<code>UP(S1)</code>：</strong><br>
<strong><code>P1</code> calls <code>UP(S1)</code> when it
finishes:</strong><br>
•
<code>P1</code>完成执行，调用<code>UP(S1)</code>，将<code>S1</code>的值从0增加到1。<br>
<strong><code>P1</code> finishes execution and calls
<code>UP(S1)</code>, incrementing the value of <code>S1</code> from 0 to
1.</strong></p></li>
<li><p><strong><code>P2</code>完成时调用<code>UP(S2)</code>：</strong><br>
<strong><code>P2</code> calls <code>UP(S2)</code> when it
finishes:</strong><br>
•
<code>P2</code>完成执行，调用<code>UP(S2)</code>，将<code>S2</code>的值从0增加到1。<br>
<strong><code>P2</code> finishes execution and calls
<code>UP(S2)</code>, incrementing the value of <code>S2</code> from 0 to
1.</strong></p></li>
<li><p><strong><code>P3</code>调用<code>DOWN(S1)</code>和<code>DOWN(S2)</code>：</strong><br>
<strong><code>P3</code> calls <code>DOWN(S1)</code> and
<code>DOWN(S2)</code>:</strong><br>
•
<code>P3</code>调用<code>DOWN(S1)</code>，如果<code>S1</code>的值为0，则<code>P3</code>会被阻塞，直到<code>P1</code>调用<code>UP(S1)</code>。<br>
<strong><code>P3</code> calls <code>DOWN(S1)</code>. If the value of
<code>S1</code> is 0, <code>P3</code> is blocked until <code>P1</code>
calls <code>UP(S1)</code>.</strong><br>
•
<code>P3</code>调用<code>DOWN(S2)</code>，如果<code>S2</code>的值为0，则<code>P3</code>会被阻塞，直到<code>P2</code>调用<code>UP(S2)</code>。<br>
<strong><code>P3</code> calls <code>DOWN(S2)</code>. If the value of
<code>S2</code> is 0, <code>P3</code> is blocked until <code>P2</code>
calls <code>UP(S2)</code>.</strong></p></li>
<li><p><strong><code>P3</code>开始执行：</strong><br>
<strong><code>P3</code> starts executing:</strong><br>
•
当<code>P1</code>和<code>P2</code>都完成后，<code>P3</code>开始执行自己的逻辑。<br>
<strong>When both <code>P1</code> and <code>P2</code> are completed,
<code>P3</code> starts executing its logic.</strong></p></li>
</ol>
<hr>
<h4 id="总结-10"><strong>5. 总结</strong></h4>
<p><strong>Summary</strong></p>
<p>• <strong>信号量的用途：</strong><br>
<strong>Uses of Semaphores:</strong><br>
• 用于协调多个进程的执行顺序，确保某些进程在其他进程之前完成。<br>
<strong>Used to coordinate the execution order of multiple processes,
ensuring that certain processes complete before others.</strong></p>
<p>• <strong>代码示例：</strong><br>
<strong>Code Example:</strong><br>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程P1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    UP(S1);  <span class="comment">// P1完成，通知P3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P2</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    UP(S2);  <span class="comment">// P2完成，通知P3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 进程P3</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">P3</span><span class="params">()</span> &#123;</span><br><span class="line">    DOWN(S1);  <span class="comment">// 等待P1完成</span></span><br><span class="line">    DOWN(S2);  <span class="comment">// 等待P2完成</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过使用信号量，可以轻松实现进程间的同步，确保<code>P1</code>和<code>P2</code>在<code>P3</code>之前完成执行。<br>
<strong>By using semaphores, we can easily achieve synchronization
between processes, ensuring that <code>P1</code> and <code>P2</code>
complete before <code>P3</code>.</strong></p>
<h3 id="示例使用信号量解决生产者-消费者问题"><strong>示例：使用信号量解决生产者-消费者问题</strong></h3>
<p>以下是一个使用信号量解决生产者-消费者问题的示例。假设有一个家庭场景，父亲和母亲是生产者，女儿和儿子是消费者。他们共享一个盘子（缓冲区），父亲和母亲将苹果和橙子放入盘子，女儿和儿子从盘子中取出水果。</p>
<hr>
<h4 id="信号量的定义-1"><strong>1. 信号量的定义</strong></h4>
<p><strong>Definition of Semaphores</strong></p>
<p>• <strong><code>plate = 1</code>：</strong>
表示盘子中最多可以放1个水果。<br>
<strong><code>plate = 1</code>:</strong> Indicates that the plate can
hold at most 1 fruit.<br>
• <strong><code>apple = 0</code>：</strong> 表示盘子中没有苹果。<br>
<strong><code>apple = 0</code>:</strong> Indicates that there is no
apple in the plate.<br>
• <strong><code>orange = 0</code>：</strong> 表示盘子中没有橙子。<br>
<strong><code>orange = 0</code>:</strong> Indicates that there is no
orange in the plate.</p>
<hr>
<h4 id="进程的定义"><strong>2. 进程的定义</strong></h4>
<p><strong>Definition of Processes</strong></p>
<p>• <strong>父亲（Father）：</strong> 生产者，将苹果放入盘子。<br>
<strong>Father:</strong> Producer, puts an apple into the plate.<br>
• <strong>母亲（Mother）：</strong> 生产者，将橙子放入盘子。<br>
<strong>Mother:</strong> Producer, puts an orange into the plate.<br>
• <strong>女儿（Daughter）：</strong> 消费者，从盘子中取出苹果。<br>
<strong>Daughter:</strong> Consumer, takes an apple from the
plate.<br>
• <strong>儿子（Son）：</strong> 消费者，从盘子中取出橙子。<br>
<strong>Son:</strong> Consumer, takes an orange from the plate.</p>
<hr>
<h4 id="进程的代码实现"><strong>3. 进程的代码实现</strong></h4>
<p><strong>Code Implementation of Processes</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父亲：生产者，放入苹果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">    P(plate);          <span class="comment">// 申请盘子</span></span><br><span class="line">    放入苹果到盘子;     <span class="comment">// 放入苹果</span></span><br><span class="line">    V(apple);          <span class="comment">// 通知女儿有苹果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 母亲：生产者，放入橙子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mother</span><span class="params">()</span> &#123;</span><br><span class="line">    P(plate);          <span class="comment">// 申请盘子</span></span><br><span class="line">    放入橙子到盘子;     <span class="comment">// 放入橙子</span></span><br><span class="line">    V(orange);         <span class="comment">// 通知儿子有橙子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 女儿：消费者，取出苹果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Daughter</span><span class="params">()</span> &#123;</span><br><span class="line">    P(apple);          <span class="comment">// 等待苹果</span></span><br><span class="line">    从盘子中取出苹果;   <span class="comment">// 取出苹果</span></span><br><span class="line">    V(plate);          <span class="comment">// 释放盘子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 儿子：消费者，取出橙子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">    P(orange);         <span class="comment">// 等待橙子</span></span><br><span class="line">    从盘子中取出橙子;   <span class="comment">// 取出橙子</span></span><br><span class="line">    V(plate);          <span class="comment">// 释放盘子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="工作流程详解-1"><strong>4. 工作流程详解</strong></h4>
<p><strong>Detailed Workflow</strong></p>
<ol type="1">
<li><p><strong>父亲和母亲的生产过程：</strong><br>
<strong>Production Process of Father and Mother:</strong><br>
• 父亲和母亲分别调用<code>P(plate)</code>申请盘子。<br>
<strong>Father and Mother call <code>P(plate)</code> to acquire the
plate.</strong><br>
•
如果盘子为空，父亲或母亲可以将水果放入盘子，并调用<code>V(apple)</code>或<code>V(orange)</code>通知消费者。<br>
<strong>If the plate is empty, Father or Mother can put a fruit into the
plate and call <code>V(apple)</code> or <code>V(orange)</code> to notify
the consumers.</strong></p></li>
<li><p><strong>女儿和儿子的消费过程：</strong><br>
<strong>Consumption Process of Daughter and Son:</strong><br>
•
女儿调用<code>P(apple)</code>等待苹果，儿子调用<code>P(orange)</code>等待橙子。<br>
<strong>Daughter calls <code>P(apple)</code> to wait for an apple, and
Son calls <code>P(orange)</code> to wait for an orange.</strong><br>
•
当父亲或母亲放入水果后，女儿或儿子会收到通知，取出水果，并调用<code>V(plate)</code>释放盘子。<br>
<strong>When Father or Mother puts a fruit into the plate, Daughter or
Son will be notified, take the fruit, and call <code>V(plate)</code> to
release the plate.</strong></p></li>
</ol>
<hr>
<h4 id="总结-11"><strong>5. 总结</strong></h4>
<p><strong>Summary</strong></p>
<p>• <strong>信号量的用途：</strong><br>
<strong>Uses of Semaphores:</strong><br>
• <code>plate</code>：用于确保盘子中最多只能放1个水果。<br>
<strong><code>plate</code>:</strong> Ensures that the plate can hold at
most 1 fruit.<br>
•
<code>apple</code>和<code>orange</code>：用于协调生产者和消费者之间的同步。<br>
<strong><code>apple</code> and <code>orange</code>:</strong> Coordinate
synchronization between producers and consumers.</p>
<p>• <strong>代码示例：</strong><br>
<strong>Code Example:</strong><br>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父亲：生产者，放入苹果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">    P(plate);          <span class="comment">// 申请盘子</span></span><br><span class="line">    放入苹果到盘子;     <span class="comment">// 放入苹果</span></span><br><span class="line">    V(apple);          <span class="comment">// 通知女儿有苹果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 母亲：生产者，放入橙子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mother</span><span class="params">()</span> &#123;</span><br><span class="line">    P(plate);          <span class="comment">// 申请盘子</span></span><br><span class="line">    放入橙子到盘子;     <span class="comment">// 放入橙子</span></span><br><span class="line">    V(orange);         <span class="comment">// 通知儿子有橙子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 女儿：消费者，取出苹果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Daughter</span><span class="params">()</span> &#123;</span><br><span class="line">    P(apple);          <span class="comment">// 等待苹果</span></span><br><span class="line">    从盘子中取出苹果;   <span class="comment">// 取出苹果</span></span><br><span class="line">    V(plate);          <span class="comment">// 释放盘子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 儿子：消费者，取出橙子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Son</span><span class="params">()</span> &#123;</span><br><span class="line">    P(orange);         <span class="comment">// 等待橙子</span></span><br><span class="line">    从盘子中取出橙子;   <span class="comment">// 取出橙子</span></span><br><span class="line">    V(plate);          <span class="comment">// 释放盘子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过使用信号量，可以确保生产者和消费者之间的正确同步，避免竞争条件和死锁。<br>
<strong>By using semaphores, we can ensure correct synchronization
between producers and consumers, avoiding race conditions and
deadlock.</strong></p>
<h3 id="quiz-1-使用信号量解决生产者-消费者问题"><strong>Quiz 1:
使用信号量解决生产者-消费者问题</strong></h3>
<p>以下是关于生产者-消费者问题的详细解释和代码实现，帮助你更好地理解信号量的使用。</p>
<hr>
<h4 id="问题描述-1"><strong>1. 问题描述</strong></h4>
<p><strong>Problem Description</strong></p>
<p>假设有一个盘子（缓冲区），最多可以放2个水果。父亲和母亲是生产者，分别将苹果和橙子放入盘子；女儿和儿子是消费者，分别从盘子中取出苹果和橙子。需要使用信号量来协调生产者和消费者之间的同步。</p>
<hr>
<h4 id="信号量的定义-2"><strong>2. 信号量的定义</strong></h4>
<p><strong>Definition of Semaphores</strong></p>
<p>• <strong><code>plate = 2</code>：</strong>
表示盘子中最多可以放2个水果。<br>
<strong><code>plate = 2</code>:</strong> Indicates that the plate can
hold at most 2 fruits.<br>
• <strong><code>apple = 0</code>：</strong> 表示盘子中没有苹果。<br>
<strong><code>apple = 0</code>:</strong> Indicates that there is no
apple in the plate.<br>
• <strong><code>orange = 0</code>：</strong> 表示盘子中没有橙子。<br>
<strong><code>orange = 0</code>:</strong> Indicates that there is no
orange in the plate.<br>
• <strong><code>mutex = 1</code>：</strong>
用于确保对盘子的互斥访问。<br>
<strong><code>mutex = 1</code>:</strong> Ensures mutual exclusion when
accessing the plate.</p>
<hr>
<h4 id="进程的定义-1"><strong>3. 进程的定义</strong></h4>
<p><strong>Definition of Processes</strong></p>
<p>• <strong>父亲（Father）：</strong> 生产者，将苹果放入盘子。<br>
<strong>Father:</strong> Producer, puts an apple into the plate.<br>
• <strong>母亲（Mother）：</strong> 生产者，将橙子放入盘子。<br>
<strong>Mother:</strong> Producer, puts an orange into the plate.<br>
• <strong>女儿（Daughter i, i=1,2）：</strong>
消费者，从盘子中取出苹果。<br>
<strong>Daughter i (i=1,2):</strong> Consumer, takes an apple from the
plate.<br>
• <strong>儿子（Son i, i=1,2）：</strong>
消费者，从盘子中取出橙子。<br>
<strong>Son i (i=1,2):</strong> Consumer, takes an orange from the
plate.</p>
<hr>
<h4 id="进程的代码实现-1"><strong>4. 进程的代码实现</strong></h4>
<p><strong>Code Implementation of Processes</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父亲：生产者，放入苹果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">    P(plate);          <span class="comment">// 申请盘子</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    放入苹果到盘子;     <span class="comment">// 放入苹果</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(apple);          <span class="comment">// 通知女儿有苹果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 母亲：生产者，放入橙子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mother</span><span class="params">()</span> &#123;</span><br><span class="line">    P(plate);          <span class="comment">// 申请盘子</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    放入橙子到盘子;     <span class="comment">// 放入橙子</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(orange);         <span class="comment">// 通知儿子有橙子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 女儿i：消费者，取出苹果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Daughter_i</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(apple);          <span class="comment">// 等待苹果</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    从盘子中取出苹果;   <span class="comment">// 取出苹果</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(plate);          <span class="comment">// 释放盘子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 儿子i：消费者，取出橙子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Son_i</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(orange);         <span class="comment">// 等待橙子</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    从盘子中取出橙子;   <span class="comment">// 取出橙子</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(plate);          <span class="comment">// 释放盘子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="工作流程详解-2"><strong>5. 工作流程详解</strong></h4>
<p><strong>Detailed Workflow</strong></p>
<ol type="1">
<li><p><strong>父亲和母亲的生产过程：</strong><br>
<strong>Production Process of Father and Mother:</strong><br>
• 父亲和母亲分别调用<code>P(plate)</code>申请盘子。<br>
<strong>Father and Mother call <code>P(plate)</code> to acquire the
plate.</strong><br>
•
如果盘子中有空间，父亲或母亲可以调用<code>P(mutex)</code>申请互斥锁，将水果放入盘子，然后调用<code>V(mutex)</code>释放互斥锁，并调用<code>V(apple)</code>或<code>V(orange)</code>通知消费者。<br>
<strong>If there is space in the plate, Father or Mother calls
<code>P(mutex)</code> to acquire the mutex, puts a fruit into the plate,
calls <code>V(mutex)</code> to release the mutex, and calls
<code>V(apple)</code> or <code>V(orange)</code> to notify the
consumers.</strong></p></li>
<li><p><strong>女儿和儿子的消费过程：</strong><br>
<strong>Consumption Process of Daughter and Son:</strong><br>
•
女儿调用<code>P(apple)</code>等待苹果，儿子调用<code>P(orange)</code>等待橙子。<br>
<strong>Daughter calls <code>P(apple)</code> to wait for an apple, and
Son calls <code>P(orange)</code> to wait for an orange.</strong><br>
•
当父亲或母亲放入水果后，女儿或儿子会收到通知，调用<code>P(mutex)</code>申请互斥锁，取出水果，然后调用<code>V(mutex)</code>释放互斥锁，并调用<code>V(plate)</code>释放盘子。<br>
<strong>When Father or Mother puts a fruit into the plate, Daughter or
Son will be notified, calls <code>P(mutex)</code> to acquire the mutex,
takes the fruit, calls <code>V(mutex)</code> to release the mutex, and
calls <code>V(plate)</code> to release the plate.</strong></p></li>
</ol>
<hr>
<h4 id="信号量的作用"><strong>6. 信号量的作用</strong></h4>
<p><strong>Role of Semaphores</strong></p>
<p>• <strong><code>plate</code>：</strong>
确保盘子中最多只能放2个水果，避免多个生产者同时放入水果。<br>
<strong><code>plate</code>:</strong> Ensures that the plate can hold at
most 2 fruits, preventing multiple producers from putting fruits
simultaneously.</p>
<p>• <strong><code>apple</code>和<code>orange</code>：</strong>
用于协调生产者和消费者之间的同步，确保消费者只有在有水果时才会取出。<br>
<strong><code>apple</code> and <code>orange</code>:</strong> Coordinate
synchronization between producers and consumers, ensuring that consumers
only take fruits when they are available.</p>
<p>• <strong><code>mutex</code>：</strong>
用于确保对盘子的互斥访问，避免多个进程同时访问盘子。<br>
<strong><code>mutex</code>:</strong> Ensures mutual exclusion when
accessing the plate, preventing multiple processes from accessing the
plate simultaneously.</p>
<hr>
<h4 id="总结-12"><strong>7. 总结</strong></h4>
<p><strong>Summary</strong></p>
<p>• <strong>信号量的用途：</strong><br>
<strong>Uses of Semaphores:</strong><br>
• <code>plate</code>：用于确保盘子中最多只能放2个水果。<br>
<strong><code>plate</code>:</strong> Ensures that the plate can hold at
most 2 fruits.<br>
•
<code>apple</code>和<code>orange</code>：用于协调生产者和消费者之间的同步。<br>
<strong><code>apple</code> and <code>orange</code>:</strong> Coordinate
synchronization between producers and consumers.<br>
• <code>mutex</code>：用于确保对盘子的互斥访问。<br>
<strong><code>mutex</code>:</strong> Ensures mutual exclusion when
accessing the plate.</p>
<p>• <strong>代码示例：</strong><br>
<strong>Code Example:</strong><br>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父亲：生产者，放入苹果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">    P(plate);          <span class="comment">// 申请盘子</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    放入苹果到盘子;     <span class="comment">// 放入苹果</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(apple);          <span class="comment">// 通知女儿有苹果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 母亲：生产者，放入橙子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mother</span><span class="params">()</span> &#123;</span><br><span class="line">    P(plate);          <span class="comment">// 申请盘子</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    放入橙子到盘子;     <span class="comment">// 放入橙子</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(orange);         <span class="comment">// 通知儿子有橙子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 女儿i：消费者，取出苹果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Daughter_i</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(apple);          <span class="comment">// 等待苹果</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    从盘子中取出苹果;   <span class="comment">// 取出苹果</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(plate);          <span class="comment">// 释放盘子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 儿子i：消费者，取出橙子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Son_i</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(orange);         <span class="comment">// 等待橙子</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    从盘子中取出橙子;   <span class="comment">// 取出橙子</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(plate);          <span class="comment">// 释放盘子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过使用信号量，可以确保生产者和消费者之间的正确同步，避免竞争条件和死锁。<br>
<strong>By using semaphores, we can ensure correct synchronization
between producers and consumers, avoiding race conditions and
deadlock.</strong></p>
<h3 id="quiz-1-使用信号量解决生产者-消费者问题-1"><strong>Quiz 1:
使用信号量解决生产者-消费者问题</strong></h3>
<p>以下是关于生产者-消费者问题的详细解释和代码实现，帮助你更好地理解信号量的使用。</p>
<hr>
<h4 id="问题描述-2"><strong>1. 问题描述</strong></h4>
<p><strong>Problem Description</strong></p>
<p>假设有一个盘子（缓冲区），最多可以放2个水果。父亲和母亲是生产者，分别将苹果和橙子放入盘子；女儿和儿子是消费者，分别从盘子中取出苹果和橙子。需要使用信号量来协调生产者和消费者之间的同步。</p>
<hr>
<h4 id="信号量的定义-3"><strong>2. 信号量的定义</strong></h4>
<p><strong>Definition of Semaphores</strong></p>
<p>• <strong><code>plate = 2</code>：</strong>
表示盘子中最多可以放2个水果。<br>
<strong><code>plate = 2</code>:</strong> Indicates that the plate can
hold at most 2 fruits.<br>
• <strong><code>apple = 0</code>：</strong> 表示盘子中没有苹果。<br>
<strong><code>apple = 0</code>:</strong> Indicates that there is no
apple in the plate.<br>
• <strong><code>orange = 0</code>：</strong> 表示盘子中没有橙子。<br>
<strong><code>orange = 0</code>:</strong> Indicates that there is no
orange in the plate.<br>
• <strong><code>mutex = 1</code>：</strong>
用于确保对盘子的互斥访问。<br>
<strong><code>mutex = 1</code>:</strong> Ensures mutual exclusion when
accessing the plate.</p>
<hr>
<h4 id="进程的定义-2"><strong>3. 进程的定义</strong></h4>
<p><strong>Definition of Processes</strong></p>
<p>• <strong>父亲（Father）：</strong> 生产者，将苹果放入盘子。<br>
<strong>Father:</strong> Producer, puts an apple into the plate.<br>
• <strong>母亲（Mother）：</strong> 生产者，将橙子放入盘子。<br>
<strong>Mother:</strong> Producer, puts an orange into the plate.<br>
• <strong>女儿（Daughter i, i=1,2）：</strong>
消费者，从盘子中取出苹果。<br>
<strong>Daughter i (i=1,2):</strong> Consumer, takes an apple from the
plate.<br>
• <strong>儿子（Son i, i=1,2）：</strong>
消费者，从盘子中取出橙子。<br>
<strong>Son i (i=1,2):</strong> Consumer, takes an orange from the
plate.</p>
<hr>
<h4 id="进程的代码实现-2"><strong>4. 进程的代码实现</strong></h4>
<p><strong>Code Implementation of Processes</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父亲：生产者，放入苹果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">    P(plate);          <span class="comment">// 申请盘子</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    放入苹果到盘子;     <span class="comment">// 放入苹果</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(apple);          <span class="comment">// 通知女儿有苹果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 母亲：生产者，放入橙子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mother</span><span class="params">()</span> &#123;</span><br><span class="line">    P(plate);          <span class="comment">// 申请盘子</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    放入橙子到盘子;     <span class="comment">// 放入橙子</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(orange);         <span class="comment">// 通知儿子有橙子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 女儿i：消费者，取出苹果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Daughter_i</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(apple);          <span class="comment">// 等待苹果</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    从盘子中取出苹果;   <span class="comment">// 取出苹果</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(plate);          <span class="comment">// 释放盘子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 儿子i：消费者，取出橙子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Son_i</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(orange);         <span class="comment">// 等待橙子</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    从盘子中取出橙子;   <span class="comment">// 取出橙子</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(plate);          <span class="comment">// 释放盘子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="工作流程详解-3"><strong>5. 工作流程详解</strong></h4>
<p><strong>Detailed Workflow</strong></p>
<ol type="1">
<li><p><strong>父亲和母亲的生产过程：</strong><br>
<strong>Production Process of Father and Mother:</strong><br>
• 父亲和母亲分别调用<code>P(plate)</code>申请盘子。<br>
<strong>Father and Mother call <code>P(plate)</code> to acquire the
plate.</strong><br>
•
如果盘子中有空间，父亲或母亲可以调用<code>P(mutex)</code>申请互斥锁，将水果放入盘子，然后调用<code>V(mutex)</code>释放互斥锁，并调用<code>V(apple)</code>或<code>V(orange)</code>通知消费者。<br>
<strong>If there is space in the plate, Father or Mother calls
<code>P(mutex)</code> to acquire the mutex, puts a fruit into the plate,
calls <code>V(mutex)</code> to release the mutex, and calls
<code>V(apple)</code> or <code>V(orange)</code> to notify the
consumers.</strong></p></li>
<li><p><strong>女儿和儿子的消费过程：</strong><br>
<strong>Consumption Process of Daughter and Son:</strong><br>
•
女儿调用<code>P(apple)</code>等待苹果，儿子调用<code>P(orange)</code>等待橙子。<br>
<strong>Daughter calls <code>P(apple)</code> to wait for an apple, and
Son calls <code>P(orange)</code> to wait for an orange.</strong><br>
•
当父亲或母亲放入水果后，女儿或儿子会收到通知，调用<code>P(mutex)</code>申请互斥锁，取出水果，然后调用<code>V(mutex)</code>释放互斥锁，并调用<code>V(plate)</code>释放盘子。<br>
<strong>When Father or Mother puts a fruit into the plate, Daughter or
Son will be notified, calls <code>P(mutex)</code> to acquire the mutex,
takes the fruit, calls <code>V(mutex)</code> to release the mutex, and
calls <code>V(plate)</code> to release the plate.</strong></p></li>
</ol>
<hr>
<h4 id="信号量的作用-1"><strong>6. 信号量的作用</strong></h4>
<p><strong>Role of Semaphores</strong></p>
<p>• <strong><code>plate</code>：</strong>
确保盘子中最多只能放2个水果，避免多个生产者同时放入水果。<br>
<strong><code>plate</code>:</strong> Ensures that the plate can hold at
most 2 fruits, preventing multiple producers from putting fruits
simultaneously.</p>
<p>• <strong><code>apple</code>和<code>orange</code>：</strong>
用于协调生产者和消费者之间的同步，确保消费者只有在有水果时才会取出。<br>
<strong><code>apple</code> and <code>orange</code>:</strong> Coordinate
synchronization between producers and consumers, ensuring that consumers
only take fruits when they are available.</p>
<p>• <strong><code>mutex</code>：</strong>
用于确保对盘子的互斥访问，避免多个进程同时访问盘子。<br>
<strong><code>mutex</code>:</strong> Ensures mutual exclusion when
accessing the plate, preventing multiple processes from accessing the
plate simultaneously.</p>
<hr>
<h4 id="总结-13"><strong>7. 总结</strong></h4>
<p><strong>Summary</strong></p>
<p>• <strong>信号量的用途：</strong><br>
<strong>Uses of Semaphores:</strong><br>
• <code>plate</code>：用于确保盘子中最多只能放2个水果。<br>
<strong><code>plate</code>:</strong> Ensures that the plate can hold at
most 2 fruits.<br>
•
<code>apple</code>和<code>orange</code>：用于协调生产者和消费者之间的同步。<br>
<strong><code>apple</code> and <code>orange</code>:</strong> Coordinate
synchronization between producers and consumers.<br>
• <code>mutex</code>：用于确保对盘子的互斥访问。<br>
<strong><code>mutex</code>:</strong> Ensures mutual exclusion when
accessing the plate.</p>
<p>• <strong>代码示例：</strong><br>
<strong>Code Example:</strong><br>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父亲：生产者，放入苹果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Father</span><span class="params">()</span> &#123;</span><br><span class="line">    P(plate);          <span class="comment">// 申请盘子</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    放入苹果到盘子;     <span class="comment">// 放入苹果</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(apple);          <span class="comment">// 通知女儿有苹果</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 母亲：生产者，放入橙子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Mother</span><span class="params">()</span> &#123;</span><br><span class="line">    P(plate);          <span class="comment">// 申请盘子</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    放入橙子到盘子;     <span class="comment">// 放入橙子</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(orange);         <span class="comment">// 通知儿子有橙子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 女儿i：消费者，取出苹果</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Daughter_i</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(apple);          <span class="comment">// 等待苹果</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    从盘子中取出苹果;   <span class="comment">// 取出苹果</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(plate);          <span class="comment">// 释放盘子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 儿子i：消费者，取出橙子</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Son_i</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    P(orange);         <span class="comment">// 等待橙子</span></span><br><span class="line">    P(mutex);          <span class="comment">// 申请互斥锁</span></span><br><span class="line">    从盘子中取出橙子;   <span class="comment">// 取出橙子</span></span><br><span class="line">    V(mutex);          <span class="comment">// 释放互斥锁</span></span><br><span class="line">    V(plate);          <span class="comment">// 释放盘子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过使用信号量，可以确保生产者和消费者之间的正确同步，避免竞争条件和死锁。<br>
<strong>By using semaphores, we can ensure correct synchronization
between producers and consumers, avoiding race conditions and
deadlock.</strong></p>
<blockquote>
<p>等待信号发出之后，接收信号！</p>
</blockquote>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/20250506145432.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<h3 id="管程monitors"><strong>管程（Monitors）</strong></h3>
<p>管程是一种高级的同步机制，用于管理共享资源的访问。以下是关于管程的详细解释和笔记。</p>
<hr>
<h4 id="管程的基本概念"><strong>1. 管程的基本概念</strong></h4>
<p><strong>Basic Concepts of Monitors</strong></p>
<p>• <strong>管程的定义：</strong><br>
<strong>Definition of Monitors:</strong><br>
•
管程是一种特殊的模块或包，包含一组过程、变量和数据结构，用于管理共享资源的访问。<br>
<strong>A monitor is a special kind of module or package that contains a
collection of procedures, variables, and data structures, used to manage
access to shared resources.</strong></p>
<p>• <strong>管程的特点：</strong><br>
<strong>Characteristics of Monitors:</strong></p>
<ol type="1">
<li><strong>互斥访问：</strong> 同一时间只能有一个进程进入管程。<br>
<strong>Mutual Exclusion:</strong> Only one process can enter the
monitor at a time.<br>
</li>
<li><strong>进程同步：</strong> 使用条件变量（Condition
Variables）实现进程间的同步。<br>
<strong>Process Synchronization:</strong> Use condition variables to
synchronize processes.<br>
</li>
<li><strong>局部变量：</strong>
管程的局部变量只能由管程内的过程访问。<br>
<strong>Local Variables:</strong> Local variables of the monitor can
only be accessed by procedures within the monitor.</li>
</ol>
<hr>
<h4 id="管程的使用规则"><strong>2. 管程的使用规则</strong></h4>
<p><strong>Rules to Follow with Monitors</strong></p>
<ol type="1">
<li><p><strong>进入管程：</strong><br>
<strong>Entering the Monitor:</strong><br>
• 进程通过调用管程的过程进入管程。<br>
<strong>A process enters the monitor by invoking one of its
procedures.</strong></p></li>
<li><p><strong>互斥访问：</strong><br>
<strong>Mutual Exclusion:</strong><br>
• 同一时间只能有一个进程在管程内执行。<br>
<strong>Only one process can be active within the monitor at a
time.</strong><br>
• 其他试图进入管程的进程会被挂起，直到管程可用。<br>
<strong>Any other process that has invoked the monitor is suspended,
waiting for the monitor to become available.</strong></p></li>
<li><p><strong>局部变量的访问：</strong><br>
<strong>Access to Local Variables:</strong><br>
• 进程不能直接访问管程的局部变量。<br>
<strong>No process can directly access a monitor’s local
variables.</strong><br>
• 管程的过程只能访问管程的局部变量。<br>
<strong>A monitor may only access its local variables.</strong></p></li>
</ol>
<hr>
<h4 id="管程的实现机制"><strong>3. 管程的实现机制</strong></h4>
<p><strong>Implementation Mechanisms of Monitors</strong></p>
<ol type="1">
<li><p><strong>互斥访问的实现：</strong><br>
<strong>Implementation of Mutual Exclusion:</strong><br>
• 编译器使用互斥锁或二进制信号量实现管程的互斥访问。<br>
<strong>The compiler uses a mutex or a binary semaphore to implement
mutual exclusion on monitor entries.</strong></p></li>
<li><p><strong>进程同步的实现：</strong><br>
<strong>Implementation of Process Synchronization:</strong><br>
• 使用条件变量（Condition Variables）实现进程间的同步。<br>
<strong>Use condition variables to synchronize processes.</strong><br>
•
条件变量只能与<code>wait</code>和<code>signal</code>操作一起使用。<br>
<strong>Condition variables can only be used with the operations
<code>wait</code> and <code>signal</code>.</strong></p></li>
<li><p><strong>条件变量的操作：</strong><br>
<strong>Operations on Condition Variables:</strong><br>
•
<code>wait(x)</code>：调用该操作的进程被挂起，直到另一个进程调用<code>signal(x)</code>。<br>
<strong><code>wait(x)</code>: The process invoking this operation is
suspended until another process invokes
<code>signal(x)</code>.</strong><br>
•
<code>signal(x)</code>：恢复一个被挂起的进程。如果没有进程被挂起，则该操作无效。<br>
<strong><code>signal(x)</code>: Resumes exactly one suspended process.
If no process is suspended, then the signal operation has no
effect.</strong></p></li>
</ol>
<hr>
<h4 id="生产者-消费者问题的管程实现"><strong>4.
生产者-消费者问题的管程实现</strong></h4>
<p><strong>Producer-Consumer Problem with Monitors</strong></p>
<p>以下是使用管程解决生产者-消费者问题的概要：</p>
<figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">monitor ProducerConsumer <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    condition full, empty;  // 条件变量</span></span><br><span class="line"><span class="comment">    int count = 0;         // 缓冲区中的物品数量</span></span><br><span class="line"><span class="comment">    int buffer[N];         // 缓冲区</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    procedure produce(item) &#123;</span></span><br><span class="line"><span class="comment">        if (count == N) wait(empty);  // 如果缓冲区满，等待</span></span><br><span class="line"><span class="comment">        buffer[count] = item;         // 放入物品</span></span><br><span class="line"><span class="comment">        count++;</span></span><br><span class="line"><span class="comment">        signal(full);                 // 通知消费者</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">procedure</span> <span class="title">consume</span><span class="params">()</span> <span class="title">returns</span> <span class="title">item</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="comment"><span class="function">        if (count == 0) wait(full);   // 如果缓冲区空，等待</span></span></span><br><span class="line"><span class="comment"><span class="function">        count--;</span></span></span><br><span class="line"><span class="comment"><span class="function">        item = buffer[count];         // 取出物品</span></span></span><br><span class="line"><span class="comment"><span class="function">        signal(empty);                // 通知生产者</span></span></span><br><span class="line"><span class="comment"><span class="function">        return item;</span></span></span><br><span class="line"><span class="comment"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="管程的总结"><strong>5. 管程的总结</strong></h4>
<p><strong>Summary of Monitors</strong></p>
<p>•
<strong>管程是一种高级的同步机制，用于管理共享资源的访问。</strong><br>
<strong>A monitor is a high-level synchronization mechanism used to
manage access to shared resources.</strong></p>
<p>•
<strong>管程的特点包括互斥访问、进程同步和局部变量的保护。</strong><br>
<strong>Characteristics of monitors include mutual exclusion, process
synchronization, and protection of local variables.</strong></p>
<p>•
<strong>管程的实现机制包括互斥锁、条件变量和<code>wait</code>/<code>signal</code>操作。</strong><br>
<strong>Implementation mechanisms of monitors include mutexes, condition
variables, and <code>wait</code>/<code>signal</code>
operations.</strong></p>
<p>•
<strong>管程的应用场景包括生产者-消费者问题等需要同步的场景。</strong><br>
<strong>Application scenarios of monitors include the producer-consumer
problem and other scenarios requiring synchronization.</strong></p>
<p>通过理解管程的工作原理和实现机制，可以更好地设计和实现多进程系统中的同步机制。<br>
<strong>By understanding the working principles and implementation
mechanisms of monitors, we can better design and implement
synchronization mechanisms in multi-process systems.</strong></p>
<hr>
<h3 id="回顾睡眠与唤醒sleep-and-wakeup"><strong>回顾：睡眠与唤醒（Sleep
and Wakeup）</strong></h3>
<p>在睡眠与唤醒机制中，如果消费者在读取<code>count</code>为0后被中断，可能会导致唤醒信号丢失，从而导致死锁。以下是详细解释：</p>
<hr>
<h4 id="消费者被中断的场景"><strong>1. 消费者被中断的场景</strong></h4>
<p><strong>Scenario of Consumer Being Interrupted</strong></p>
<ol type="1">
<li><p><strong>消费者检查<code>count</code>：</strong><br>
<strong>Consumer checks <code>count</code>:</strong><br>
•
消费者检查缓冲区的<code>count</code>，发现<code>count == 0</code>，准备进入睡眠状态。<br>
<strong>The consumer checks the buffer’s <code>count</code> and finds
<code>count == 0</code>, preparing to go to sleep.</strong></p></li>
<li><p><strong>消费者被中断：</strong><br>
<strong>Consumer is interrupted:</strong><br>
•
在消费者进入睡眠状态之前，它被中断，操作系统切换到其他任务（如生产者）。<br>
<strong>Before the consumer goes to sleep, it is interrupted, and the
operating system switches to other tasks (e.g., the
producer).</strong></p></li>
<li><p><strong>生产者向缓冲区添加数据：</strong><br>
<strong>Producer adds data to the buffer:</strong><br>
• 生产者向缓冲区中添加数据，<code>count</code>变为1。<br>
<strong>The producer adds data to the buffer, and <code>count</code>
becomes 1.</strong></p></li>
<li><p><strong>生产者发送唤醒信号：</strong><br>
<strong>Producer sends wakeup signal:</strong><br>
•
生产者发现<code>count &gt; 0</code>，认为消费者可能在等待，于是发送唤醒信号。<br>
<strong>The producer finds <code>count &gt; 0</code>, thinks the
consumer may be waiting, and sends a wakeup signal.</strong></p></li>
<li><p><strong>消费者继续执行并进入睡眠状态：</strong><br>
<strong>Consumer continues execution and goes to sleep:</strong><br>
•
消费者从中断中恢复，继续执行，发现<code>count == 0</code>，于是进入睡眠状态。<br>
<strong>The consumer resumes from the interrupt, continues execution,
finds <code>count == 0</code>, and goes to sleep.</strong></p></li>
<li><p><strong>唤醒信号丢失：</strong><br>
<strong>Wakeup signal is lost:</strong><br>
• 生产者的唤醒信号在消费者进入睡眠状态之前被发送，因此信号被忽略。<br>
<strong>The producer’s wakeup signal is sent before the consumer goes to
sleep, so the signal is ignored.</strong></p></li>
<li><p><strong>死锁产生：</strong><br>
<strong>Deadlock occurs:</strong><br>
• 消费者进入睡眠状态，等待生产者唤醒它。<br>
<strong>The consumer goes to sleep, waiting for the producer to wake it
up.</strong><br>
•
生产者继续运行，直到缓冲区满，然后进入睡眠状态，等待消费者唤醒它。<br>
<strong>The producer continues to run until the buffer is full, then
goes to sleep, waiting for the consumer to wake it up.</strong><br>
• 结果，生产者和消费者都进入睡眠状态，无法继续运行，导致死锁。<br>
<strong>As a result, both the producer and consumer go to sleep, unable
to continue, causing deadlock.</strong></p></li>
</ol>
<hr>
<h3 id="消息传递message-passing"><strong>消息传递（Message
Passing）</strong></h3>
<p>消息传递是一种进程间通信（IPC）机制，允许进程通过发送和接收消息进行通信。以下是消息传递的详细解释：</p>
<hr>
<h4 id="进程间通信的可能方法"><strong>1.
进程间通信的可能方法</strong></h4>
<p><strong>Possible Approaches of IPC</strong></p>
<ol type="1">
<li><p><strong>共享内存（Shared Memory）：</strong><br>
<strong>Shared Memory:</strong><br>
• 多个进程共享同一块内存区域，通过读写内存进行通信。<br>
<strong>Multiple processes share the same memory region and communicate
by reading and writing memory.</strong></p></li>
<li><p><strong>共享文件模式（Shared File Mode）：</strong><br>
<strong>Shared File Mode:</strong><br>
• 使用文件作为通信媒介，例如管道（pipe）。<br>
<strong>Use files as a communication medium, e.g., pipes.</strong><br>
• <strong>管道（Pipe）：</strong> 一端用于读取，另一端用于写入。<br>
<strong>Pipe:</strong> One end is for reading, and the other end is for
writing.</p></li>
<li><p><strong>消息传递（Message Passing）：</strong><br>
<strong>Message Passing:</strong><br>
• 使用<code>send</code>和<code>receive</code>原语进行通信。<br>
<strong>Use <code>send</code> and <code>receive</code> primitives for
communication.</strong><br>
• <strong>直接消息传递：</strong>
为每个进程分配唯一的地址（如<code>addr</code>），然后直接向进程发送消息。<br>
<strong>Direct Message Passing:</strong> Assign each process a unique
address (e.g., <code>addr</code>) and send messages directly to the
process.<br>
• <strong>邮箱（Mailbox）：</strong>
使用邮箱作为消息的中转站，进程通过邮箱发送和接收消息。<br>
<strong>Mailbox:</strong> Use mailboxes as message hubs, and processes
send and receive messages through mailboxes.</p></li>
</ol>
<hr>
<h4 id="生产者-消费者问题的消息传递实现"><strong>2.
生产者-消费者问题的消息传递实现</strong></h4>
<p><strong>Producer-Consumer Problem with Message Passing</strong></p>
<p>以下是使用消息传递解决生产者-消费者问题的概要：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生产者</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Producer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        item = produce_item();  <span class="comment">// 生产物品</span></span><br><span class="line">        send(consumer_addr, item);  <span class="comment">// 向消费者发送物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Consumer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        receive(producer_addr, item);  <span class="comment">// 从生产者接收物品</span></span><br><span class="line">        consume_item(item);  <span class="comment">// 消费物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="屏障barriers"><strong>屏障（Barriers）</strong></h3>
<p>屏障是一种同步机制，用于确保多个进程在某个点同步执行。以下是屏障的详细解释：</p>
<hr>
<h4 id="屏障的使用"><strong>1. 屏障的使用</strong></h4>
<p><strong>Use of Barriers</strong></p>
<ol type="1">
<li><p><strong>进程接近屏障：</strong><br>
<strong>Processes approaching a barrier:</strong><br>
• 多个进程向屏障点靠近。<br>
<strong>Multiple processes approach the barrier point.</strong></p></li>
<li><p><strong>所有进程但一个被阻塞在屏障：</strong><br>
<strong>All processes but one blocked at barrier:</strong><br>
• 除了最后一个进程，其他进程都被阻塞在屏障点。<br>
<strong>All processes except the last one are blocked at the barrier
point.</strong></p></li>
<li><p><strong>最后一个进程到达，所有进程被放行：</strong><br>
<strong>Last process arrives, all are let through:</strong><br>
• 最后一个进程到达屏障点后，所有进程被放行，继续执行。<br>
<strong>After the last process arrives at the barrier point, all
processes are let through and continue execution.</strong></p></li>
</ol>
<figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/20250506150142.png" alt="img">
<figcaption aria-hidden="true">img</figcaption>
</figure>
<hr>
<h4 id="屏障的示例并行矩阵乘法"><strong>2.
屏障的示例：并行矩阵乘法</strong></h4>
<p><strong>Example: Parallel Matrix Multiplication</strong></p>
<p>在并行矩阵乘法中，使用屏障确保所有线程在某个点同步执行，例如在计算完部分结果后等待其他线程完成。</p>
<hr>
<h3 id="经典的进程间通信问题"><strong>经典的进程间通信问题</strong></h3>
<p><strong>Classical IPC Problems</strong></p>
<p>以下是几个经典的进程间通信问题，用于测试新提出的同步方案：</p>
<hr>
<h4 id="有限缓冲区问题生产者-消费者问题"><strong>1.
有限缓冲区问题（生产者-消费者问题）</strong></h4>
<p><strong>Bounded-Buffer (Producer-Consumer) Problem</strong></p>
<p>• <strong>问题描述：</strong>
生产者和消费者共享一个有限大小的缓冲区，需要确保生产者不会在缓冲区满时放入数据，消费者不会在缓冲区空时取出数据。<br>
<strong>Problem Description:</strong> Producers and consumers share a
bounded buffer. Ensure that producers do not put data when the buffer is
full, and consumers do not take data when the buffer is empty.</p>
<hr>
<h4 id="哲学家就餐问题"><strong>2. 哲学家就餐问题</strong></h4>
<p><strong>Dining-Philosophers Problem</strong></p>
<p>• <strong>问题描述：</strong>
多个哲学家围坐在一张圆桌旁，每个哲学家左右各有一根筷子。哲学家需要拿起两根筷子才能吃饭，如何避免死锁和饥饿？<br>
<strong>Problem Description:</strong> Multiple philosophers sit around a
round table, each with a chopstick on the left and right. A philosopher
needs to pick up two chopsticks to eat. How to avoid deadlock and
starvation?</p>
<hr>
<h4 id="读者-写者问题"><strong>3. 读者-写者问题</strong></h4>
<p><strong>Readers and Writers Problem</strong></p>
<p>• <strong>问题描述：</strong>
多个读者和写者共享一个数据资源，需要确保多个读者可以同时读取数据，但写者必须独占访问数据。<br>
<strong>Problem Description:</strong> Multiple readers and writers share
a data resource. Ensure that multiple readers can read data
simultaneously, but writers must have exclusive access to the data.</p>
<hr>
<h3 id="总结-14"><strong>总结</strong></h3>
<p><strong>Summary</strong></p>
<p>•
<strong>睡眠与唤醒机制可能导致唤醒信号丢失，从而引发死锁。</strong><br>
<strong>The sleep and wakeup mechanism may lead to lost wakeup signals,
causing deadlock.</strong></p>
<p>•
<strong>消息传递是一种进程间通信机制，包括直接消息传递和邮箱模式。</strong><br>
<strong>Message passing is an IPC mechanism, including direct message
passing and mailbox mode.</strong></p>
<p>• <strong>屏障用于确保多个进程在某个点同步执行。</strong><br>
<strong>Barriers are used to ensure that multiple processes synchronize
at a certain point.</strong></p>
<p>•
<strong>经典的进程间通信问题包括有限缓冲区问题、哲学家就餐问题和读者-写者问题。</strong><br>
<strong>Classical IPC problems include the bounded-buffer problem,
dining-philosophers problem, and readers-writers problem.</strong></p>
<p>通过理解这些同步机制和经典问题，可以更好地设计和实现多进程系统中的同步和通信机制。<br>
<strong>By understanding these synchronization mechanisms and classical
problems, we can better design and implement synchronization and
communication mechanisms in multi-process systems.</strong></p>
<h3 id="哲学家就餐问题dining-philosophers-problem"><strong>哲学家就餐问题（Dining
Philosophers Problem）</strong></h3>
<p>哲学家就餐问题是由Dijkstra于1965年提出的经典同步问题，用于展示多进程/多线程环境中的死锁和资源竞争问题。以下是详细解释和解决方案。</p>
<hr>
<h4 id="问题描述-3"><strong>1. 问题描述</strong></h4>
<p><strong>Problem Description</strong></p>
<p>• <strong>场景：</strong><br>
<strong>Scenario:</strong><br>
• 五个哲学家围坐在一张圆桌旁，每个哲学家左右各有一根叉子。<br>
<strong>Five philosophers are seated around a table, each with a fork on
the left and right.</strong></p>
<p>• <strong>行为：</strong><br>
<strong>Behavior:</strong><br>
• 哲学家交替进行思考和就餐。<br>
<strong>Philosophers alternate between thinking and
eating.</strong><br>
• 就餐时需要同时拿起左右两根叉子。<br>
<strong>To eat, a philosopher needs to grab both adjacent
forks.</strong><br>
• 就餐时间是有限的。<br>
<strong>They only eat for finite periods of time.</strong></p>
<p>• <strong>目标：</strong><br>
<strong>Goal:</strong><br>
• 设计一种算法，确保哲学家能够正确就餐，同时避免死锁和饥饿。<br>
<strong>Design an algorithm to ensure that philosophers can eat
correctly while avoiding deadlock and starvation.</strong></p>
<hr>
<h4 id="问题的挑战"><strong>2. 问题的挑战</strong></h4>
<p><strong>Challenges of the Problem</strong></p>
<ol type="1">
<li><p><strong>死锁（Deadlock）：</strong><br>
<strong>Deadlock:</strong><br>
•
如果所有哲学家同时拿起左边的叉子，然后尝试拿起右边的叉子，会导致所有哲学家都被阻塞，无法继续执行。<br>
<strong>If all philosophers pick up the left fork simultaneously and
then try to pick up the right fork, all philosophers will be blocked,
unable to proceed.</strong></p></li>
<li><p><strong>饥饿（Starvation）：</strong><br>
<strong>Starvation:</strong><br>
• 某些哲学家可能永远无法获得两根叉子，导致无法就餐。<br>
<strong>Some philosophers may never get both forks, leading to
starvation.</strong></p></li>
</ol>
<hr>
<h4 id="非解决方案"><strong>3. 非解决方案</strong></h4>
<p><strong>A Nonsolution</strong></p>
<p>以下是一种可能导致死锁的非解决方案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        think();               <span class="comment">// 思考</span></span><br><span class="line">        P(fork[i]);            <span class="comment">// 拿起左边的叉子</span></span><br><span class="line">        P(fork[(i + <span class="number">1</span>) % <span class="number">5</span>]);  <span class="comment">// 拿起右边的叉子</span></span><br><span class="line">        eat();                 <span class="comment">// 就餐</span></span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % <span class="number">5</span>]);  <span class="comment">// 放下右边的叉子</span></span><br><span class="line">        V(fork[i]);            <span class="comment">// 放下左边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>• <strong>问题：</strong><br>
<strong>Problem:</strong><br>
•
如果所有哲学家同时拿起左边的叉子，然后尝试拿起右边的叉子，会导致死锁。<br>
<strong>If all philosophers pick up the left fork simultaneously and
then try to pick up the right fork, deadlock will occur.</strong></p>
<hr>
<h4 id="解决方案"><strong>4. 解决方案</strong></h4>
<p><strong>Solutions</strong></p>
<p>以下是几种解决哲学家就餐问题的方法：</p>
<ol type="1">
<li><p><strong>限制同时尝试拿叉子的哲学家数量：</strong><br>
<strong>Limit the number of philosophers trying to grab
forks:</strong><br>
• 只允许最多四个哲学家同时尝试拿叉子。<br>
<strong>Only allow up to four philosophers to try grabbing their
forks.</strong></p></li>
<li><p><strong>非对称解决方案：</strong><br>
<strong>Asymmetric solution:</strong><br>
• 奇数编号的哲学家先拿左边的叉子，偶数编号的哲学家先拿右边的叉子。<br>
<strong>Odd-numbered philosophers grab their left fork first, whereas
even-numbered philosophers grab their right fork
first.</strong></p></li>
<li><p><strong>使用互斥锁保护拿叉子的操作：</strong><br>
<strong>Protect the fork-grabbing operations with a
mutex:</strong><br>
• 使用互斥锁确保同一时间只有一个哲学家尝试拿叉子。<br>
<strong>Use a mutex to ensure that only one philosopher tries to grab
forks at a time.</strong></p></li>
<li><p><strong>只有在两根叉子都可用时才拿叉子：</strong><br>
<strong>Pick up the forks only if both are available:</strong><br>
• 哲学家只有在左右两根叉子都可用时才拿叉子。<br>
<strong>A philosopher picks up the forks only if both are
available.</strong></p></li>
</ol>
<hr>
<h4 id="解决方案的代码实现"><strong>5. 解决方案的代码实现</strong></h4>
<p><strong>Code Implementation of Solutions</strong></p>
<p>以下是使用互斥锁保护拿叉子操作的解决方案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">// 互斥锁</span></span><br><span class="line">semaphore fork[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;  <span class="comment">// 五根叉子</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        think();               <span class="comment">// 思考</span></span><br><span class="line">        P(mutex);              <span class="comment">// 申请互斥锁</span></span><br><span class="line">        P(fork[i]);            <span class="comment">// 拿起左边的叉子</span></span><br><span class="line">        P(fork[(i + <span class="number">1</span>) % <span class="number">5</span>]);  <span class="comment">// 拿起右边的叉子</span></span><br><span class="line">        V(mutex);              <span class="comment">// 释放互斥锁</span></span><br><span class="line">        eat();                 <span class="comment">// 就餐</span></span><br><span class="line">        V(fork[(i + <span class="number">1</span>) % <span class="number">5</span>]);  <span class="comment">// 放下右边的叉子</span></span><br><span class="line">        V(fork[i]);            <span class="comment">// 放下左边的叉子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="总结-15"><strong>6. 总结</strong></h4>
<p><strong>Summary</strong></p>
<p>•
<strong>哲学家就餐问题是一个经典的同步问题，用于展示死锁和资源竞争。</strong><br>
<strong>The dining philosophers problem is a classical synchronization
problem that demonstrates deadlock and resource contention.</strong></p>
<p>• <strong>问题的挑战包括死锁和饥饿。</strong><br>
<strong>The challenges of the problem include deadlock and
starvation.</strong></p>
<p>•
<strong>解决方案包括限制哲学家数量、非对称策略、使用互斥锁和仅在叉子可用时拿叉子。</strong><br>
<strong>Solutions include limiting the number of philosophers,
asymmetric strategies, using a mutex, and picking up forks only if both
are available.</strong></p>
<p>通过理解哲学家就餐问题和其解决方案，可以更好地设计和实现多进程系统中的同步机制。<br>
<strong>By understanding the dining philosophers problem and its
solutions, we can better design and implement synchronization mechanisms
in multi-process systems.</strong></p>
<hr>
<h3 id="读者-写者问题readers-and-writers-problem"><strong>读者-写者问题（Readers
and Writers Problem）</strong></h3>
<p>读者-写者问题是一个经典的同步问题，用于模拟对共享数据库的访问。以下是详细解释和解决方案。</p>
<hr>
<h4 id="问题描述-4"><strong>1. 问题描述</strong></h4>
<p><strong>Problem Description</strong></p>
<p>• <strong>场景：</strong><br>
<strong>Scenario:</strong><br>
• 多个读者和写者共享一个数据库。<br>
<strong>Multiple readers and writers share a database.</strong></p>
<p>• <strong>规则：</strong><br>
<strong>Rules:</strong><br>
1. <strong>多个读者可以同时读取数据。</strong><br>
<strong>Multiple readers can read the data
simultaneously.</strong><br>
2. <strong>同一时间只能有一个写者写入数据。</strong><br>
<strong>Only one writer can write the data at any time.</strong><br>
3. <strong>读者和写者不能同时进入临界区。</strong><br>
<strong>A reader and a writer cannot be in the critical section
together.</strong></p>
<p>• <strong>访问矩阵：</strong><br>
<strong>Access Matrix:</strong><br>
| | Reader | Writer | | ---------- | ------ | ------ | |
<strong>Reader</strong> | OK | No | | <strong>Writer</strong> | No | No
|</p>
<hr>
<h4 id="读者优先的解决方案"><strong>2. 读者优先的解决方案</strong></h4>
<p><strong>Reader Preference Solution</strong></p>
<p>以下是一种读者优先的解决方案：</p>
<ol type="1">
<li><p><strong>新读者到来时：</strong><br>
<strong>When a new reader arrives:</strong><br>
• 如果写者在等待且已有读者在读取数据，则允许新读者读取数据。<br>
<strong>If a writer is waiting and some reader is reading, then the new
reader can read.</strong></p></li>
<li><p><strong>新写者到来时：</strong><br>
<strong>When a new writer arrives:</strong><br>
•
如果没有读者或写者在访问数据库，则允许新写者写入数据，否则写者需要等待。<br>
<strong>If no reader or writer is accessing the database, the new writer
can write; otherwise, the writer must wait.</strong></p></li>
</ol>
<hr>
<h4 id="弱读者优先的变体"><strong>3. 弱读者优先的变体</strong></h4>
<p><strong>Weak Reader Preference Variant</strong></p>
<p>• <strong>规则：</strong><br>
<strong>Rule:</strong><br>
• 如果有写者在等待，则暂停新读者进入临界区，直到写者完成写入。<br>
<strong>Suspend incoming readers as long as a writer is
waiting.</strong></p>
<hr>
<h4 id="读者-写者问题的解决方案"><strong>4.
读者-写者问题的解决方案</strong></h4>
<p><strong>Solution to the Readers and Writers Problem</strong></p>
<p>以下是读者-写者问题的一种解决方案：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;        <span class="comment">// 互斥锁，用于保护读者计数器的访问</span></span><br><span class="line">semaphore rw_mutex = <span class="number">1</span>;     <span class="comment">// 读写互斥锁，用于保护数据库的访问</span></span><br><span class="line"><span class="type">int</span> reader_count = <span class="number">0</span>;       <span class="comment">// 当前正在读取数据的读者数量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(mutex);           <span class="comment">// 申请互斥锁</span></span><br><span class="line">        reader_count++;     <span class="comment">// 增加读者数量</span></span><br><span class="line">        <span class="keyword">if</span> (reader_count == <span class="number">1</span>) &#123;</span><br><span class="line">            P(rw_mutex);    <span class="comment">// 如果是第一个读者，申请读写互斥锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);           <span class="comment">// 释放互斥锁</span></span><br><span class="line"></span><br><span class="line">        read_database();    <span class="comment">// 读取数据</span></span><br><span class="line"></span><br><span class="line">        P(mutex);           <span class="comment">// 申请互斥锁</span></span><br><span class="line">        reader_count--;     <span class="comment">// 减少读者数量</span></span><br><span class="line">        <span class="keyword">if</span> (reader_count == <span class="number">0</span>) &#123;</span><br><span class="line">            V(rw_mutex);    <span class="comment">// 如果是最后一个读者，释放读写互斥锁</span></span><br><span class="line">        &#125;</span><br><span class="line">        V(mutex);           <span class="comment">// 释放互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        P(rw_mutex);        <span class="comment">// 申请读写互斥锁</span></span><br><span class="line"></span><br><span class="line">        write_database();   <span class="comment">// 写入数据</span></span><br><span class="line"></span><br><span class="line">        V(rw_mutex);        <span class="comment">// 释放读写互斥锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="解决方案的工作流程"><strong>5. 解决方案的工作流程</strong></h4>
<p><strong>Workflow of the Solution</strong></p>
<ol type="1">
<li><p><strong>读者进入临界区：</strong><br>
<strong>Reader enters the critical section:</strong><br>
•
读者首先申请互斥锁<code>mutex</code>，增加读者计数器<code>reader_count</code>。<br>
<strong>The reader first acquires the mutex <code>mutex</code> and
increments the reader counter <code>reader_count</code>.</strong><br>
• 如果这是第一个读者，则申请读写互斥锁<code>rw_mutex</code>。<br>
<strong>If this is the first reader, it acquires the read-write mutex
<code>rw_mutex</code>.</strong><br>
• 读者释放互斥锁<code>mutex</code>，然后开始读取数据。<br>
<strong>The reader releases the mutex <code>mutex</code> and then starts
reading the database.</strong></p></li>
<li><p><strong>读者离开临界区：</strong><br>
<strong>Reader leaves the critical section:</strong><br>
•
读者申请互斥锁<code>mutex</code>，减少读者计数器<code>reader_count</code>。<br>
<strong>The reader acquires the mutex <code>mutex</code> and decrements
the reader counter <code>reader_count</code>.</strong><br>
• 如果这是最后一个读者，则释放读写互斥锁<code>rw_mutex</code>。<br>
<strong>If this is the last reader, it releases the read-write mutex
<code>rw_mutex</code>.</strong><br>
• 读者释放互斥锁<code>mutex</code>。<br>
<strong>The reader releases the mutex
<code>mutex</code>.</strong></p></li>
<li><p><strong>写者进入临界区：</strong><br>
<strong>Writer enters the critical section:</strong><br>
• 写者申请读写互斥锁<code>rw_mutex</code>，然后开始写入数据。<br>
<strong>The writer acquires the read-write mutex <code>rw_mutex</code>
and then starts writing the database.</strong></p></li>
<li><p><strong>写者离开临界区：</strong><br>
<strong>Writer leaves the critical section:</strong><br>
• 写者释放读写互斥锁<code>rw_mutex</code>。<br>
<strong>The writer releases the read-write mutex
<code>rw_mutex</code>.</strong></p></li>
</ol>
<hr>
<h4 id="总结-16"><strong>6. 总结</strong></h4>
<p><strong>Summary</strong></p>
<p>•
<strong>读者-写者问题是一个经典的同步问题，用于模拟对共享数据库的访问。</strong><br>
<strong>The readers and writers problem is a classical synchronization
problem that models access to a shared database.</strong></p>
<p>•
<strong>解决方案需要确保多个读者可以同时读取数据，而同一时间只能有一个写者写入数据。</strong><br>
<strong>The solution needs to ensure that multiple readers can read the
data simultaneously, while only one writer can write the data at any
time.</strong></p>
<p>•
<strong>读者优先的解决方案允许新读者在有写者等待时继续读取数据，而弱读者优先的变体则会暂停新读者直到写者完成写入。</strong><br>
<strong>The reader preference solution allows new readers to continue
reading even if a writer is waiting, while the weak reader preference
variant suspends new readers until the writer finishes
writing.</strong></p>
<p>通过理解读者-写者问题和其解决方案，可以更好地设计和实现多进程系统中的同步机制。<br>
<strong>By understanding the readers and writers problem and its
solutions, we can better design and implement synchronization mechanisms
in multi-process systems.</strong></p>
<hr>
<h3 id="单板桥问题single-plank-bridge-problem"><strong>单板桥问题（Single-Plank
Bridge Problem）</strong></h3>
<p>这个问题模拟了两个士兵组通过一座单板桥的场景。由于桥很窄，同一时间只能有一个方向的士兵组通过。以下是详细解释和基于信号量的解决方案。</p>
<hr>
<h4 id="问题描述-5"><strong>1. 问题描述</strong></h4>
<p><strong>Problem Description</strong></p>
<p>• <strong>场景：</strong><br>
<strong>Scenario:</strong><br>
•
一座单板桥的两端分别有两组士兵，每组分别有<code>m</code>和<code>n</code>人，需要过桥。<br>
<strong>On the two sides of a single-plank bridge, there are two groups
of soldiers composed of <code>m</code> and <code>n</code> people
respectively, who need to cross the bridge.</strong></p>
<p>• <strong>规则：</strong><br>
<strong>Rules:</strong><br>
1. 桥很窄，同一时间只能有一个方向的士兵组通过。<br>
<strong>The narrow bridge allows only one group of soldiers in the same
direction to cross at the same time.</strong><br>
2. 一组士兵只要桥上没有人，就可以开始过桥。<br>
<strong>One group of soldiers is permitted to cross as long as there are
no people on the bridge.</strong><br>
3.
一旦一组士兵开始过桥，另一组士兵必须等待，直到第一组士兵全部通过桥。<br>
<strong>Once one group of soldiers begins walking on the bridge, the
other group should wait until all members of the first group have passed
the bridge.</strong></p>
<hr>
<h4 id="信号量和变量的定义"><strong>2. 信号量和变量的定义</strong></h4>
<p><strong>Definition of Semaphores and Variables</strong></p>
<ol type="1">
<li><p><strong>信号量：</strong><br>
<strong>Semaphores:</strong><br>
•
<code>mutex1</code>：用于保护<code>count1</code>的访问，初始值为<code>1</code>。<br>
<strong><code>mutex1</code>: Used to protect access to
<code>count1</code>, initial value is <code>1</code>.</strong><br>
•
<code>mutex2</code>：用于保护<code>count2</code>的访问，初始值为<code>1</code>。<br>
<strong><code>mutex2</code>: Used to protect access to
<code>count2</code>, initial value is <code>1</code>.</strong><br>
• <code>bridge</code>：用于控制桥的访问，初始值为<code>1</code>。<br>
<strong><code>bridge</code>: Used to control access to the bridge,
initial value is <code>1</code>.</strong></p></li>
<li><p><strong>变量：</strong><br>
<strong>Variables:</strong><br>
•
<code>count1</code>：表示第一组士兵中正在过桥的士兵数量，初始值为<code>0</code>。<br>
<strong><code>count1</code>: Represents the number of soldiers from the
first group currently crossing the bridge, initial value is
<code>0</code>.</strong><br>
•
<code>count2</code>：表示第二组士兵中正在过桥的士兵数量，初始值为<code>0</code>。<br>
<strong><code>count2</code>: Represents the number of soldiers from the
second group currently crossing the bridge, initial value is
<code>0</code>.</strong></p></li>
</ol>
<hr>
<h4 id="进程的设计"><strong>3. 进程的设计</strong></h4>
<p><strong>Design of Processes</strong></p>
<p>以下是两组士兵过桥的进程设计：</p>
<hr>
<h5 id="进程p1第一组士兵"><strong>进程P1：第一组士兵</strong></h5>
<p><strong>Process P1: First Group of Soldiers</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">P1</span><span class="params">()</span> &#123;</span><br><span class="line">    down(mutex1);          <span class="comment">// 申请互斥锁mutex1</span></span><br><span class="line">    count1++;              <span class="comment">// 增加第一组士兵的计数</span></span><br><span class="line">    <span class="keyword">if</span> (count1 == <span class="number">1</span>) &#123;</span><br><span class="line">        down(bridge);      <span class="comment">// 如果这是第一个士兵，申请桥的访问权</span></span><br><span class="line">    &#125;</span><br><span class="line">    up(mutex1);            <span class="comment">// 释放互斥锁mutex1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过桥</span></span><br><span class="line">    crossing_the_bridge();</span><br><span class="line"></span><br><span class="line">    down(mutex1);          <span class="comment">// 申请互斥锁mutex1</span></span><br><span class="line">    count1--;              <span class="comment">// 减少第一组士兵的计数</span></span><br><span class="line">    <span class="keyword">if</span> (count1 == <span class="number">0</span>) &#123;</span><br><span class="line">        up(bridge);        <span class="comment">// 如果这是最后一个士兵，释放桥的访问权</span></span><br><span class="line">    &#125;</span><br><span class="line">    up(mutex1);            <span class="comment">// 释放互斥锁mutex1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="进程p2第二组士兵"><strong>进程P2：第二组士兵</strong></h5>
<p><strong>Process P2: Second Group of Soldiers</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">P2</span><span class="params">()</span> &#123;</span><br><span class="line">    down(mutex2);          <span class="comment">// 申请互斥锁mutex2</span></span><br><span class="line">    count2++;              <span class="comment">// 增加第二组士兵的计数</span></span><br><span class="line">    <span class="keyword">if</span> (count2 == <span class="number">1</span>) &#123;</span><br><span class="line">        down(bridge);      <span class="comment">// 如果这是第一个士兵，申请桥的访问权</span></span><br><span class="line">    &#125;</span><br><span class="line">    up(mutex2);            <span class="comment">// 释放互斥锁mutex2</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过桥</span></span><br><span class="line">    crossing_the_bridge();</span><br><span class="line"></span><br><span class="line">    down(mutex2);          <span class="comment">// 申请互斥锁mutex2</span></span><br><span class="line">    count2--;              <span class="comment">// 减少第二组士兵的计数</span></span><br><span class="line">    <span class="keyword">if</span> (count2 == <span class="number">0</span>) &#123;</span><br><span class="line">        up(bridge);        <span class="comment">// 如果这是最后一个士兵，释放桥的访问权</span></span><br><span class="line">    &#125;</span><br><span class="line">    up(mutex2);            <span class="comment">// 释放互斥锁mutex2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="工作流程详解-4"><strong>4. 工作流程详解</strong></h4>
<p><strong>Detailed Workflow</strong></p>
<ol type="1">
<li><p><strong>第一组士兵过桥：</strong><br>
<strong>First Group of Soldiers Crossing the Bridge:</strong><br>
• 第一个士兵申请桥的访问权，后续士兵可以直接过桥。<br>
<strong>The first soldier acquires the bridge access, and subsequent
soldiers can cross directly.</strong><br>
• 最后一个士兵过桥后，释放桥的访问权。<br>
<strong>The last soldier releases the bridge access after
crossing.</strong></p></li>
<li><p><strong>第二组士兵过桥：</strong><br>
<strong>Second Group of Soldiers Crossing the Bridge:</strong><br>
• 第一个士兵申请桥的访问权，后续士兵可以直接过桥。<br>
<strong>The first soldier acquires the bridge access, and subsequent
soldiers can cross directly.</strong><br>
• 最后一个士兵过桥后，释放桥的访问权。<br>
<strong>The last soldier releases the bridge access after
crossing.</strong></p></li>
</ol>
<hr>
<h4 id="总结-17"><strong>5. 总结</strong></h4>
<p><strong>Summary</strong></p>
<p>•
<strong>单板桥问题模拟了两个士兵组通过一座单板桥的场景，需要确保同一时间只有一个方向的士兵组过桥。</strong><br>
<strong>The single-plank bridge problem simulates two groups of soldiers
crossing a narrow bridge, ensuring that only one group can cross at a
time.</strong></p>
<p>•
<strong>使用信号量<code>mutex1</code>和<code>mutex2</code>保护<code>count1</code>和<code>count2</code>的访问，使用信号量<code>bridge</code>控制桥的访问。</strong><br>
<strong>Semaphores <code>mutex1</code> and <code>mutex2</code> protect
access to <code>count1</code> and <code>count2</code>, and semaphore
<code>bridge</code> controls access to the bridge.</strong></p>
<p>•
<strong>进程P1和P2分别描述了两组士兵的过桥行为，确保同一时间只有一个方向的士兵组过桥。</strong><br>
<strong>Processes P1 and P2 describe the crossing behavior of the two
groups of soldiers, ensuring that only one group can cross at a
time.</strong></p>
<p>通过理解单板桥问题和其解决方案，可以更好地设计和实现多进程系统中的同步机制。<br>
<strong>By understanding the single-plank bridge problem and its
solutions, we can better design and implement synchronization mechanisms
in multi-process systems.</strong></p>
<hr>
<h3 id="总结同步机制与经典问题"><strong>总结：同步机制与经典问题</strong></h3>
<p>以下是关于同步机制和经典问题的总结，帮助你全面理解多进程/多线程环境中的同步问题及其解决方案。</p>
<hr>
<h4 id="竞争条件临界区和互斥"><strong>1.
竞争条件、临界区和互斥</strong></h4>
<p><strong>Race Condition, Critical Region, and Mutual
Exclusion</strong></p>
<p>• <strong>竞争条件（Race Condition）：</strong><br>
<strong>Race Condition:</strong><br>
• 多个进程/线程同时访问共享资源，导致结果不可预测。<br>
<strong>Multiple processes/threads access shared resources
simultaneously, leading to unpredictable results.</strong></p>
<p>• <strong>临界区（Critical Region）：</strong><br>
<strong>Critical Region:</strong><br>
• 访问共享资源的代码段，需要互斥访问。<br>
<strong>The section of code that accesses shared resources and requires
mutual exclusion.</strong></p>
<p>• <strong>互斥（Mutual Exclusion）：</strong><br>
<strong>Mutual Exclusion:</strong><br>
• 确保同一时间只有一个进程/线程进入临界区。<br>
<strong>Ensure that only one process/thread enters the critical section
at a time.</strong></p>
<hr>
<h4 id="使用忙等待实现互斥"><strong>2. 使用忙等待实现互斥</strong></h4>
<p><strong>Mutual Exclusion Using Busy Waiting</strong></p>
<ol type="1">
<li><p><strong>Peterson算法（Peterson’s Solution）：</strong><br>
<strong>Peterson’s Solution:</strong><br>
•
一种软件解决方案，使用两个变量<code>flag</code>和<code>turn</code>实现互斥。<br>
<strong>A software solution that uses two variables <code>flag</code>
and <code>turn</code> to achieve mutual exclusion.</strong></p></li>
<li><p><strong>TSL指令（Test and Set Lock）：</strong><br>
<strong>TSL (Test and Set Lock):</strong><br>
• 一种硬件支持的原子操作，用于实现互斥。<br>
<strong>A hardware-supported atomic operation used to achieve mutual
exclusion.</strong></p></li>
</ol>
<hr>
<h4 id="睡眠与唤醒sleep-and-wakeup-1"><strong>3. 睡眠与唤醒（Sleep and
Wakeup）</strong></h4>
<p>• <strong>机制：</strong><br>
<strong>Mechanism:</strong><br>
• 进程在无法继续执行时进入睡眠状态，等待其他进程唤醒。<br>
<strong>A process goes to sleep when it cannot proceed and waits for
another process to wake it up.</strong></p>
<p>• <strong>问题：</strong><br>
<strong>Problem:</strong><br>
• 可能导致唤醒信号丢失，从而引发死锁。<br>
<strong>May lead to lost wakeup signals, causing deadlock.</strong></p>
<hr>
<h4 id="信号量semaphores-1"><strong>4.
信号量（Semaphores）</strong></h4>
<p>• <strong>定义：</strong><br>
<strong>Definition:</strong><br>
• 一种同步机制，用于管理共享资源的访问。<br>
<strong>A synchronization mechanism used to manage access to shared
resources.</strong></p>
<p>• <strong>操作：</strong><br>
<strong>Operations:</strong><br>
• <code>P(S)</code>：申请资源，信号量<code>S</code>减1。<br>
<strong><code>P(S)</code>: Acquire a resource, decrement
<code>S</code>.</strong><br>
• <code>V(S)</code>：释放资源，信号量<code>S</code>加1。<br>
<strong><code>V(S)</code>: Release a resource, increment
<code>S</code>.</strong></p>
<hr>
<h4 id="管程monitors-1"><strong>5. 管程（Monitors）</strong></h4>
<p>• <strong>定义：</strong><br>
<strong>Definition:</strong><br>
• 一种高级同步机制，封装了共享资源和同步操作。<br>
<strong>A high-level synchronization mechanism that encapsulates shared
resources and synchronization operations.</strong></p>
<p>• <strong>特点：</strong><br>
<strong>Characteristics:</strong><br>
• 同一时间只能有一个进程进入管程。<br>
<strong>Only one process can enter the monitor at a time.</strong><br>
• 使用条件变量实现进程同步。<br>
<strong>Use condition variables to synchronize processes.</strong></p>
<hr>
<h4 id="屏障barriers-1"><strong>6. 屏障（Barriers）</strong></h4>
<p>• <strong>定义：</strong><br>
<strong>Definition:</strong><br>
• 一种同步机制，用于确保多个进程在某个点同步执行。<br>
<strong>A synchronization mechanism used to ensure that multiple
processes synchronize at a certain point.</strong></p>
<p>• <strong>应用：</strong><br>
<strong>Application:</strong><br>
• 例如，在并行矩阵乘法中，使用屏障确保所有线程在某个点同步。<br>
<strong>For example, in parallel matrix multiplication, use barriers to
ensure all threads synchronize at a certain point.</strong></p>
<hr>
<h4 id="消息传递message-passing-1"><strong>7. 消息传递（Message
Passing）</strong></h4>
<p>• <strong>机制：</strong><br>
<strong>Mechanism:</strong><br>
• 进程通过发送和接收消息进行通信。<br>
<strong>Processes communicate by sending and receiving
messages.</strong></p>
<p>• <strong>模式：</strong><br>
<strong>Modes:</strong><br>
• 直接消息传递：使用进程的唯一地址发送消息。<br>
<strong>Direct message passing: Send messages using the process’s unique
address.</strong><br>
• 邮箱模式：使用邮箱作为消息的中转站。<br>
<strong>Mailbox mode: Use mailboxes as message hubs.</strong></p>
<hr>
<h4 id="经典同步问题"><strong>8. 经典同步问题</strong></h4>
<p><strong>Classic Synchronization Problems</strong></p>
<ol type="1">
<li><p><strong>哲学家就餐问题（Dining-Philosophers
Problem）：</strong><br>
<strong>Dining-Philosophers Problem:</strong><br>
• 多个哲学家围坐在一张圆桌旁，需要同时拿起左右两根叉子才能就餐。<br>
<strong>Multiple philosophers sit around a round table and need to pick
up both left and right forks to eat.</strong></p></li>
<li><p><strong>读者-写者问题（Readers and Writers
Problem）：</strong><br>
<strong>Readers and Writers Problem:</strong><br>
•
多个读者和写者共享一个数据库，需要确保多个读者可以同时读取数据，而同一时间只能有一个写者写入数据。<br>
<strong>Multiple readers and writers share a database, ensuring that
multiple readers can read simultaneously while only one writer can write
at a time.</strong></p></li>
</ol>
<hr>
<h3 id="总结-18"><strong>总结</strong></h3>
<p><strong>Summary</strong></p>
<p>•
<strong>竞争条件、临界区和互斥是多进程/多线程环境中的核心问题。</strong><br>
<strong>Race conditions, critical regions, and mutual exclusion are core
issues in multi-process/multi-threaded environments.</strong></p>
<p>•
<strong>使用忙等待、信号量、管程、屏障和消息传递等机制可以实现同步。</strong><br>
<strong>Synchronization can be achieved using mechanisms such as busy
waiting, semaphores, monitors, barriers, and message
passing.</strong></p>
<p>•
<strong>哲学家就餐问题和读者-写者问题是经典的同步问题，用于测试和验证同步机制。</strong><br>
<strong>The dining-philosophers problem and readers-writers problem are
classical synchronization problems used to test and validate
synchronization mechanisms.</strong></p>
<p>通过理解这些同步机制和经典问题，可以更好地设计和实现多进程/多线程系统中的同步和通信机制。<br>
<strong>By understanding these synchronization mechanisms and classical
problems, we can better design and implement synchronization and
communication mechanisms in multi-process/multi-threaded
systems.</strong></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://www.totorocatcat.top/">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89/">http://totorocatcat.top/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%882%EF%BC%89/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8F%90%E9%AB%98/">提高</a></div><div class="post_share"><div class="social-share" data-image="https://npm.elemecdn.com/ushio-api-img-moe@5.0.22/img_220_1200x675_350.011993408203_null_normal.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FCH2%EF%BC%883%EF%BC%89/" title="操作系统CH2（3）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.22/img_220_1200x675_350.011993408203_null_normal.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">操作系统CH2（3）</div></div></a></div><div class="next-post pull-right"><a href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9FCH2/" title="操作系统CH2（1）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.22/img_220_1200x675_350.011993408203_null_normal.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统CH2（1）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/'Lec2%20Logic%20and%20Proof,%20Sets,%20and%20Function'/" title="Lec2 Logic and Proof, Sets, and Function"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/1fe6130ca86bb9e7e6a37c9187a32c8.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-20</div><div class="title">Lec2 Logic and Proof, Sets, and Function</div></div></a></div><div><a href="/02%EF%BC%89/" title="CS61B 课程笔记（Lecture 02）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/v2-2ed7f4c9e1a7a699a3ef300a6f761abe_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-11</div><div class="title">CS61B 课程笔记（Lecture 02）</div></div></a></div><div><a href="/03%EF%BC%89/" title="CS61B 课程笔记（Lecture 03）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/v2-2ed7f4c9e1a7a699a3ef300a6f761abe_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-12</div><div class="title">CS61B 课程笔记（Lecture 03）</div></div></a></div><div><a href="/04%EF%BC%89/" title="CS61B 课程笔记（Lecture 04）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/2749a496aabc7d650b2912e256582e390a0a636b.jpg@1256w_1246h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-13</div><div class="title">CS61B 课程笔记（Lecture 04）</div></div></a></div><div><a href="/06%EF%BC%89/" title="CS61B 课程笔记（Lecture 06）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/f00af0d55cc81c18403ccbb4957ae6bc298252208.jpg@1256w_1374h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-15</div><div class="title">CS61B 课程笔记（Lecture 06）</div></div></a></div><div><a href="/05%EF%BC%89/" title="CS61B 课程笔记（Lecture 05）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4ccebbc43a0ca31a719afadee2f86b4902402baf.jpg@1256w_786h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-14</div><div class="title">CS61B 课程笔记（Lecture 05）</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%BE%A0%E5%AE%A2-%E6%AD%A6%E4%BE%A0%E5%9C%BA%E6%99%AF-%E6%B8%B8%E6%88%8F.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description">热爱文学的SCUT软件学院学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">856</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">36</div></a></div><a id="card-info-btn" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#chapter-2-processes-and-threads"><span class="toc-text">Chapter 2 Processes and
Threads</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1inter-process-communication-ipc"><span class="toc-text">2.3
进程间通信（Inter-Process Communication, IPC）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%B6%89%E5%8F%8A%E7%9A%84%E4%B8%89%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-text">1.
进程间通信涉及的三个问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5process-synchronization"><span class="toc-text">2. 进程同步（Process
Synchronization）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spooling-%E7%A4%BA%E4%BE%8B%E6%AD%A3%E7%A1%AE%E4%B8%8E%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6"><span class="toc-text">3. Spooling
示例：正确与竞争条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E4%B8%8E%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6"><span class="toc-text">4. 互斥与竞争条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90%E4%B8%8E%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-text">5. 临界资源与临界区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5process-synchronization-and-mutual-exclusion"><span class="toc-text">2.3
进程同步与互斥（Process Synchronization and Mutual
Exclusion）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA%E7%9A%84%E8%A6%81%E6%B1%82"><span class="toc-text">1. 临界区的要求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-text">2. 互斥的实现方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8F%98%E9%87%8Flock-variable%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E9%87%8A"><span class="toc-text">锁变量（Lock
Variable）的深入解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%8F%98%E9%87%8F%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1. 锁变量的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">2. 代码示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">3. 锁变量的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E9%94%81%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">4.
如何解决锁变量的问题？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E5%8F%98%E9%87%8F%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">5. 锁变量的适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#peterson%E7%AE%97%E6%B3%95%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E9%87%8A"><span class="toc-text">Peterson算法的深入解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#peterson%E7%AE%97%E6%B3%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1.
Peterson算法的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">2. 代码示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peterson%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">3. Peterson算法的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peterson%E7%AE%97%E6%B3%95%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">4.
Peterson算法的工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peterson%E7%AE%97%E6%B3%95%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">5.
Peterson算法的局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tsl%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-text">1. TSL的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2"><span class="toc-text">2. 代码示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tsl%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">3. TSL的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tsl%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-text">4. TSL的局限性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tsl%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">5. TSL的工作流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%99%E7%AD%89%E5%BE%85%E7%9A%84%E4%BA%92%E6%96%A5mutual-exclusion-with-busy-waiting"><span class="toc-text">忙等待的互斥（Mutual
Exclusion with Busy Waiting）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%99%E7%AD%89%E5%BE%85%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 忙等待的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%99%E7%AD%89%E5%BE%85%E7%9A%84%E4%BA%92%E6%96%A5%E5%AE%9E%E7%8E%B0"><span class="toc-text">2. 忙等待的互斥实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%99%E7%AD%89%E5%BE%85%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">3. 忙等待的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-text">4. 优先级反转的示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC"><span class="toc-text">5.
如何避免优先级反转？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%A1%E7%9C%A0%E4%B8%8E%E5%94%A4%E9%86%92sleep-and-wakeup"><span class="toc-text">睡眠与唤醒（Sleep and
Wakeup）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9D%A1%E7%9C%A0%E4%B8%8E%E5%94%A4%E9%86%92%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-text">1.
睡眠与唤醒的基本思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98producer-consumer-problem"><span class="toc-text">2.
生产者-消费者问题（Producer-Consumer Problem）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9D%A1%E7%9C%A0%E4%B8%8E%E5%94%A4%E9%86%92%E7%9A%84%E8%87%B4%E5%91%BD%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6"><span class="toc-text">3.
睡眠与唤醒的致命竞争条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%B7%BB%E5%8A%A0%E5%94%A4%E9%86%92%E7%AD%89%E5%BE%85%E4%BD%8D"><span class="toc-text">4.
解决方案：添加唤醒等待位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-text">5. 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphores"><span class="toc-text">信号量（Semaphores）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 信号量的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">2. 信号量的类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">3. 信号量的操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#p%E6%93%8D%E4%BD%9C%E5%92%8Cv%E6%93%8D%E4%BD%9C%E7%9A%84%E8%AF%A6%E7%BB%86%E6%B5%81%E7%A8%8B"><span class="toc-text">4.
P操作和V操作的详细流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">5.
生产者-消费者问题中的信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-text">6. 信号量的总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81mutex-binary-semaphore"><span class="toc-text">互斥锁（Mutex: Binary
Semaphore）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 互斥锁的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2. 互斥锁的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E8%AE%A1%E6%95%B0%E5%99%A8%E8%8C%83%E5%9B%B4"><span class="toc-text">3. 互斥锁的计数器范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">4. 互斥锁的工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-text">5. 互斥锁的总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-8"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">问题分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%88%9D%E5%A7%8B%E5%80%BC%E5%92%8C%E6%93%8D%E4%BD%9C"><span class="toc-text">1.
信号量的初始值和操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%BD%93%E5%89%8D%E5%80%BC%E4%B8%BA-1%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">2.
信号量当前值为-1的含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AD%94%E6%A1%88%E6%98%AFb1"><span class="toc-text">3. 为什么答案是B（1）？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-9"><span class="toc-text">4. 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E7%AD%94%E6%A1%88"><span class="toc-text">最终答案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-text">使用信号量进行进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-text">1. 问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">2. 信号量的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-text">3. 进程的执行流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-text">4. 工作流程详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-10"><span class="toc-text">5. 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">示例：使用信号量解决生产者-消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89-1"><span class="toc-text">1. 信号量的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">2. 进程的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">3. 进程的代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3-1"><span class="toc-text">4. 工作流程详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-11"><span class="toc-text">5. 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quiz-1-%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">Quiz 1:
使用信号量解决生产者-消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-1"><span class="toc-text">1. 问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89-2"><span class="toc-text">2. 信号量的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89-1"><span class="toc-text">3. 进程的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-text">4. 进程的代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3-2"><span class="toc-text">5. 工作流程详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-text">6. 信号量的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-12"><span class="toc-text">7. 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#quiz-1-%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%A7%A3%E5%86%B3%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98-1"><span class="toc-text">Quiz 1:
使用信号量解决生产者-消费者问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-2"><span class="toc-text">1. 问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89-3"><span class="toc-text">2. 信号量的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%AE%9A%E4%B9%89-2"><span class="toc-text">3. 进程的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-text">4. 进程的代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3-3"><span class="toc-text">5. 工作流程详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E4%BD%9C%E7%94%A8-1"><span class="toc-text">6. 信号量的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-13"><span class="toc-text">7. 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8Bmonitors"><span class="toc-text">管程（Monitors）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">1. 管程的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="toc-text">2. 管程的使用规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6"><span class="toc-text">3. 管程的实现机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%A1%E7%A8%8B%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.
生产者-消费者问题的管程实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-text">5. 管程的总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E9%A1%BE%E7%9D%A1%E7%9C%A0%E4%B8%8E%E5%94%A4%E9%86%92sleep-and-wakeup"><span class="toc-text">回顾：睡眠与唤醒（Sleep
and Wakeup）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-text">1. 消费者被中断的场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92message-passing"><span class="toc-text">消息传递（Message
Passing）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8F%AF%E8%83%BD%E6%96%B9%E6%B3%95"><span class="toc-text">1.
进程间通信的可能方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.
生产者-消费者问题的消息传递实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9Cbarriers"><span class="toc-text">屏障（Barriers）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9C%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">1. 屏障的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9C%E7%9A%84%E7%A4%BA%E4%BE%8B%E5%B9%B6%E8%A1%8C%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95"><span class="toc-text">2.
屏障的示例：并行矩阵乘法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E9%97%AE%E9%A2%98"><span class="toc-text">经典的进程间通信问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E9%99%90%E7%BC%93%E5%86%B2%E5%8C%BA%E9%97%AE%E9%A2%98%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">1.
有限缓冲区问题（生产者-消费者问题）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text">2. 哲学家就餐问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-text">3. 读者-写者问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-14"><span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98dining-philosophers-problem"><span class="toc-text">哲学家就餐问题（Dining
Philosophers Problem）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-3"><span class="toc-text">1. 问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-text">2. 问题的挑战</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">3. 非解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">4. 解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">5. 解决方案的代码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-15"><span class="toc-text">6. 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98readers-and-writers-problem"><span class="toc-text">读者-写者问题（Readers
and Writers Problem）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-4"><span class="toc-text">1. 问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">2. 读者优先的解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E8%AF%BB%E8%80%85%E4%BC%98%E5%85%88%E7%9A%84%E5%8F%98%E4%BD%93"><span class="toc-text">3. 弱读者优先的变体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text">4.
读者-写者问题的解决方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">5. 解决方案的工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-16"><span class="toc-text">6. 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%9D%BF%E6%A1%A5%E9%97%AE%E9%A2%98single-plank-bridge-problem"><span class="toc-text">单板桥问题（Single-Plank
Bridge Problem）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0-5"><span class="toc-text">1. 问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%92%8C%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">2. 信号量和变量的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-text">3. 进程的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8Bp1%E7%AC%AC%E4%B8%80%E7%BB%84%E5%A3%AB%E5%85%B5"><span class="toc-text">进程P1：第一组士兵</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8Bp2%E7%AC%AC%E4%BA%8C%E7%BB%84%E5%A3%AB%E5%85%B5"><span class="toc-text">进程P2：第二组士兵</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B%E8%AF%A6%E8%A7%A3-4"><span class="toc-text">4. 工作流程详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-17"><span class="toc-text">5. 总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-text">总结：同步机制与经典问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%9E%E4%BA%89%E6%9D%A1%E4%BB%B6%E4%B8%B4%E7%95%8C%E5%8C%BA%E5%92%8C%E4%BA%92%E6%96%A5"><span class="toc-text">1.
竞争条件、临界区和互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BF%99%E7%AD%89%E5%BE%85%E5%AE%9E%E7%8E%B0%E4%BA%92%E6%96%A5"><span class="toc-text">2. 使用忙等待实现互斥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9D%A1%E7%9C%A0%E4%B8%8E%E5%94%A4%E9%86%92sleep-and-wakeup-1"><span class="toc-text">3. 睡眠与唤醒（Sleep and
Wakeup）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8Fsemaphores-1"><span class="toc-text">4.
信号量（Semaphores）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8Bmonitors-1"><span class="toc-text">5. 管程（Monitors）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%8F%E9%9A%9Cbarriers-1"><span class="toc-text">6. 屏障（Barriers）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92message-passing-1"><span class="toc-text">7. 消息传递（Message
Passing）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98"><span class="toc-text">8. 经典同步问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-18"><span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A12/" title="计算机网络八股2"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%89%91%E5%AE%A2-%E5%8F%A4%E9%A3%8E%E6%8F%92%E7%94%BB.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络八股2"/></a><div class="content"><a class="title" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A12/" title="计算机网络八股2">计算机网络八股2</a><time datetime="2025-05-09T07:06:53.000Z" title="发表于 2025-05-09 15:06:53">2025-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A11/" title="计算机网络八股1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%89%91%E5%AE%A2-%E5%8F%A4%E9%A3%8E%E6%8F%92%E7%94%BB.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机网络八股1"/></a><div class="content"><a class="title" href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%85%AB%E8%82%A11/" title="计算机网络八股1">计算机网络八股1</a><time datetime="2025-05-09T06:05:30.000Z" title="发表于 2025-05-09 14:05:30">2025-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A13/" title="操作系统八股3"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%B8%AD%E5%9B%BD%E9%A3%8E%E5%85%83%E7%B4%A0-%E4%BA%91%E9%9B%BE%E8%83%8C%E6%99%AF.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统八股3"/></a><div class="content"><a class="title" href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A13/" title="操作系统八股3">操作系统八股3</a><time datetime="2025-05-08T16:35:40.000Z" title="发表于 2025-05-09 00:35:40">2025-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A12/" title="操作系统八股2"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%B8%AD%E5%9B%BD%E9%A3%8E%E5%85%83%E7%B4%A0-%E4%BA%91%E9%9B%BE%E8%83%8C%E6%99%AF.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统八股2"/></a><div class="content"><a class="title" href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A12/" title="操作系统八股2">操作系统八股2</a><time datetime="2025-05-08T16:23:58.000Z" title="发表于 2025-05-09 00:23:58">2025-05-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A11/" title="操作系统八股1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E4%B8%AD%E5%9B%BD%E9%A3%8E%E5%85%83%E7%B4%A0-%E4%BA%91%E9%9B%BE%E8%83%8C%E6%99%AF.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统八股1"/></a><div class="content"><a class="title" href="/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%85%AB%E8%82%A11/" title="操作系统八股1">操作系统八股1</a><time datetime="2025-05-08T15:48:05.000Z" title="发表于 2025-05-08 23:48:05">2025-05-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HT1PalaKkPaG1UqAXBhJXIu8-gzGzoHsz',
      appKey: 'iT0TnVVAwf9zuZ7NqwclQItY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="1" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/离散数学/&quot;);" href="javascript:void(0);">离散数学</a><span class="categoryBar-list-count">33</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS61B/&quot;);" href="javascript:void(0);">CS61B</a><span class="categoryBar-list-count">76</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/期末の旅/&quot;);" href="javascript:void(0);">期末の旅</a><span class="categoryBar-list-count">99</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题计划/&quot;);" href="javascript:void(0);">刷题计划</a><span class="categoryBar-list-count">60</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/区域赛の旅/&quot;);" href="javascript:void(0);">区域赛の旅</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Codeforcesの旅/&quot;);" href="javascript:void(0);">Codeforcesの旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/牛客の旅/&quot;);" href="javascript:void(0);">牛客の旅</a><span class="categoryBar-list-count">65</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACMの旅/&quot;);" href="javascript:void(0);">ACMの旅</a><span class="categoryBar-list-count">42</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数学建模/&quot;);" href="javascript:void(0);">数学建模</a><span class="categoryBar-list-count">26</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/前端の旅/&quot;);" href="javascript:void(0);">前端の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构/&quot;);" href="javascript:void(0);">数据结构</a><span class="categoryBar-list-count">47</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_24.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Atcoderの旅/&quot;);" href="javascript:void(0);">Atcoderの旅</a><span class="categoryBar-list-count">53</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_25.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-の旅/&quot;);" href="javascript:void(0);">C++の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_26.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS70の旅/&quot;);" href="javascript:void(0);">CS70の旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_27.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CSAPPの旅/&quot;);" href="javascript:void(0);">CSAPPの旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_28.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">47</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_29.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程基础/&quot;);" href="javascript:void(0);">编程基础</a><span class="categoryBar-list-count">14</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_30.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JAVAの旅/&quot;);" href="javascript:void(0);">JAVAの旅</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_31.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MIT-6-031-Software-Construction/&quot;);" href="javascript:void(0);">MIT 6.031:Software Construction</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_32.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS-110L/&quot;);" href="javascript:void(0);">CS 110L</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_33.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据库の旅/&quot;);" href="javascript:void(0);">数据库の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_34.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/灵魂の旅/&quot;);" href="javascript:void(0);">灵魂の旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_35.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/个人安排/&quot;);" href="javascript:void(0);">个人安排</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_36.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂项/&quot;);" href="javascript:void(0);">杂项</a><span class="categoryBar-list-count">13</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_37.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文学/&quot;);" href="javascript:void(0);">文学</a><span class="categoryBar-list-count">49</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_38.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/力扣の旅/&quot;);" href="javascript:void(0);">力扣の旅</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_39.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机网络/&quot;);" href="javascript:void(0);">计算机网络</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/千里十二行/&quot;);" href="javascript:void(0);">千里十二行</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_41.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/🗡指offer/&quot;);" href="javascript:void(0);">🗡指offer</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_42.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/少年游/&quot;);" href="javascript:void(0);">少年游</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_43.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法提高课/&quot;);" href="javascript:void(0);">算法提高课</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/汇编の旅/&quot;);" href="javascript:void(0);">汇编の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-实训/&quot;);" href="javascript:void(0);">C++实训</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_45.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS知识/&quot;);" href="javascript:void(0);">CS知识</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_46.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编译原理/&quot;);" href="javascript:void(0);">编译原理</a><span class="categoryBar-list-count">22</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_48.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/操作系统/&quot;);" href="javascript:void(0);">操作系统</a><span class="categoryBar-list-count">26</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;诗录/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4b31456c6f0f4489f99177f89e936de7286431045.png@1256w_708h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;诗录/&quot;);" href="javascript:void(0);" alt="">诗录</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;诗录/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;诗兴大发/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;诗兴大发/&quot;);" href="javascript:void(0);" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;诗兴大发/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;TotoroのPlan/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/51d37eba99d243607ddedfff6e91568f617436609.jpg@1256w_1884h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">TotoroのPlan</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;Markdown格式/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.48/img_482_1920x1080_96_null_normal.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;Markdown格式/&quot;);" href="javascript:void(0);" alt="">Markdown格式</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;Markdown格式/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>