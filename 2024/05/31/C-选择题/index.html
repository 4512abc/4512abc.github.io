<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++选择题 | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="选择题 对于常数据成员，下面描述正确的是 【 A 】  A. 常数据成员必须被初始化，并且不能被修改 B. 常数据成员可以不初始化，并且不能被修改 C. 常数据成员可以不初始化，并且可以被修改 D. 常数据成员必须被初始化，并且可以被修改 选项 A 是正确的。常数据成员（const data member）必须在类的构造函数初始化列表中初始化，否则会导致编译错误。一旦被初始化，常数据成员的值就不能">
<meta property="og:type" content="article">
<meta property="og:title" content="C++选择题">
<meta property="og:url" content="http://totorocatcat.top/2024/05/31/C-%E9%80%89%E6%8B%A9%E9%A2%98/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="选择题 对于常数据成员，下面描述正确的是 【 A 】  A. 常数据成员必须被初始化，并且不能被修改 B. 常数据成员可以不初始化，并且不能被修改 C. 常数据成员可以不初始化，并且可以被修改 D. 常数据成员必须被初始化，并且可以被修改 选项 A 是正确的。常数据成员（const data member）必须在类的构造函数初始化列表中初始化，否则会导致编译错误。一旦被初始化，常数据成员的值就不能">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.likepoems.com/resource/pc/a6d651fa256154756b47262c450a056f4.jpg">
<meta property="article:published_time" content="2024-05-31T05:29:21.000Z">
<meta property="article:modified_time" content="2024-05-31T05:42:00.797Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="有趣">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.likepoems.com/resource/pc/a6d651fa256154756b47262c450a056f4.jpg"><link rel="shortcut icon" href="https://source.fomal.cc/img/default_cover_227.webp"><link rel="canonical" href="http://totorocatcat.top/2024/05/31/C-%E9%80%89%E6%8B%A9%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":765,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++选择题',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-05-31 13:42:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">647</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://img.likepoems.com/resource/pc/a6d651fa256154756b47262c450a056f4.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++选择题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-31T05:29:21.000Z" title="发表于 2024-05-31 13:29:21">2024-05-31</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-31T05:42:00.797Z" title="更新于 2024-05-31 13:42:00">2024-05-31</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%9F%E6%9C%AB%E3%81%AE%E6%97%85/">期末の旅</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>71分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++选择题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><ol>
<li>对于常数据成员，下面描述正确的是 【 A 】</li>
</ol>
<p>A. 常数据成员必须被初始化，并且不能被修改</p>
<p>B. 常数据成员可以不初始化，并且不能被修改</p>
<p>C. 常数据成员可以不初始化，并且可以被修改</p>
<p>D. 常数据成员必须被初始化，并且可以被修改</p>
<p>选项 A 是正确的。常数据成员（const data member）必须在类的构造函数初始化列表中初始化，否则会导致编译错误。一旦被初始化，常数据成员的值就不能再被修改。因此，选项 A 描述了常数据成员的正确特性：常数据成员必须被初始化，并且不能被修改。</p>
<hr>
<ol>
<li>在C++中，使用流进行输入输出，其中用于定义文件输入流对象的类是 【 B 】</li>
</ol>
<p>A. <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=ios&amp;spm=1001.2101.3001.7020">ios</a> B. ifstream C. ofstream D. istrstream</p>
<blockquote>
<p>在 C++ 中，用于定义文件输入流对象的类是 <code>B. ifstream</code>。</p>
<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><ul>
<li><p><strong>A. ios</strong>: <code>ios</code> 是一个基类，提供基本的输入输出功能。它是 <code>istream</code> 和 <code>ostream</code> 的基类，并不专门用于文件输入流。</p>
</li>
<li><p><strong>B. ifstream</strong>: <code>ifstream</code> 是一个标准库类，专门用于从文件读取数据，即文件输入流。通过 <code>ifstream</code> 对象，可以打开文件并读取内容。</p>
</li>
<li><p><strong>C. ofstream</strong>: <code>ofstream</code> 是一个标准库类，专门用于向文件写入数据，即文件输出流。通过 <code>ofstream</code> 对象，可以打开文件并写入内容。</p>
</li>
<li><p><strong>D. istrstream</strong>: <code>istrstream</code> 是一个旧的标准库类，专门用于从字符串读取数据，并不用于文件输入流。它已被 <code>istringstream</code> 取代。</p>
</li>
</ul>
<p>因此，<code>ifstream</code> 是用于定义文件输入流对象的类，正确答案是 <strong>B</strong>。</p>
</blockquote>
<hr>
<ol>
<li>下列关于异常的叙述错误的是【 D 】</li>
</ol>
<p>A. 只要是编程者认为是异常的都可当异常抛出</p>
<p>B. 硬件故障也可当异常抛出</p>
<p>C. 运行错属于异常</p>
<p>D. 编译错属于异常，可以抛出</p>
<p>在 C++ 中，关于异常的处理有一些特定的原则。以下是对各个选项的解释：</p>
<ul>
<li><p><strong>A. 只要是编程者认为是异常的都可当异常抛出</strong>:</p>
<ul>
<li>正确。编程者可以定义并抛出任何他们认为是异常的情况。这可以包括逻辑错误、输入错误等。</li>
</ul>
</li>
<li><p><strong>B. 硬件故障也可当异常抛出</strong>:</p>
<ul>
<li>正确。在某些情况下，硬件故障（如内存不足、磁盘故障）可以通过异常处理机制进行处理。</li>
</ul>
</li>
<li><p><strong>C. 运行错属于异常</strong>:</p>
<ul>
<li>正确。运行时错误（如除零、空指针访问、越界访问）通常被视为异常，可以通过异常机制捕获和处理。</li>
</ul>
</li>
<li><p><strong>D. 编译错属于异常，可以抛出</strong>:</p>
<ul>
<li>错误。编译错误是指在编译期间检测到的语法或语义错误。这些错误是在程序运行之前发生的，并不能通过异常处理机制来捕捉或抛出。异常处理机制主要用于处理程序运行时发生的错误，而不是编译时错误。</li>
</ul>
</li>
</ul>
<p>因此，正确答案是 <strong>D</strong>。编译错误不能作为异常抛出，因为异常处理机制是在程序运行时才发挥作用，而编译错误发生在程序运行之前。</p>
<hr>
<ol>
<li>在面向对象的程序设计中，基类可以为其派生类提供一组公共的行为，而各个派生类可以为这组公共行为提供不同的实现，从而使得派生类的对象在执行这些公共行为时会有不同的表现，这种特性称为面向对象的【 D 】</li>
</ol>
<p>A. 封装性 B. 消息性 C. 继承性 D. 多态性</p>
<p>在面向对象的程序设计中，基类为其派生类提供一组公共的行为，各个派生类可以为这些行为提供不同的实现，使得派生类对象在执行这些行为时表现不同，这种特性称为 <strong>多态性</strong>。让我们看看各个选项的解释：</p>
<ul>
<li><p><strong>A. 封装性</strong>:</p>
<ul>
<li>封装性（Encapsulation）是指将数据和操作这些数据的函数（或方法）捆绑在一起，并对外界隐藏实现的细节。封装通过访问控制（如 <code>private</code>、<code>protected</code>、<code>public</code> 访问修饰符）来实现。</li>
</ul>
</li>
<li><p><strong>B. 消息性</strong>:</p>
<ul>
<li>消息性通常是指对象之间通过消息传递进行通信。在面向对象编程中，对象通过调用彼此的方法（发送消息）来进行互动和协作。</li>
</ul>
</li>
<li><p><strong>C. 继承性</strong>:</p>
<ul>
<li>继承性（Inheritance）是指一个类（派生类）继承另一个类（基类）的属性和行为，使得派生类可以重用基类的代码。继承是面向对象编程的基本特性之一，允许类层次结构的创建。</li>
</ul>
</li>
<li><p><strong>D. 多态性</strong>:</p>
<ul>
<li>多态性（Polymorphism）是指相同的操作在不同的对象上有不同的实现。通过多态性，基类定义的接口可以在派生类中有不同的实现。多态性通常通过虚函数和继承来实现，使得基类的指针或引用可以指向派生类对象，并在运行时决定调用哪个类的实现。</li>
</ul>
</li>
</ul>
<p>在题目中，基类为派生类提供一组公共行为，而各个派生类为这些行为提供不同的实现，使得派生类对象在执行这些行为时表现不同，这正是多态性的体现。因此，正确答案是 <strong>D. 多态性</strong>。</p>
<hr>
<ol>
<li>关于域的描述中，错误的是【 C 】</li>
</ol>
<p>A. 一个类是一个独立的域</p>
<p>B. 派生类域被自动嵌套在基类类域中</p>
<p>C. 域操作符::可以被重载</p>
<p>D. 不同域中可以定义同名变量和函数</p>
<p>让我们仔细分析每个选项，以确定哪个选项是关于域的错误描述。</p>
<h3 id="A-一个类是一个独立的域"><a href="#A-一个类是一个独立的域" class="headerlink" title="A. 一个类是一个独立的域"></a>A. 一个类是一个独立的域</h3><ul>
<li><strong>正确</strong>。在 C++ 中，每个类都形成了一个独立的作用域或域。类的成员变量和成员函数都在这个域内定义。</li>
</ul>
<h3 id="B-派生类域被自动嵌套在基类类域中"><a href="#B-派生类域被自动嵌套在基类类域中" class="headerlink" title="B. 派生类域被自动嵌套在基类类域中"></a>B. 派生类域被自动嵌套在基类类域中</h3><ul>
<li><strong>正确</strong>。当一个类派生自另一个类时，派生类继承了基类的成员，派生类的作用域包含了基类的作用域。这意味着基类的成员在派生类中是可见的（取决于访问控制修饰符）。</li>
</ul>
<h3 id="C-域操作符-可以被重载"><a href="#C-域操作符-可以被重载" class="headerlink" title="C. 域操作符::可以被重载"></a>C. 域操作符::可以被重载</h3><ul>
<li><strong>错误</strong>。域操作符 <code>::</code> 是一个固有的运算符，不能被重载。它用于限定作用域，指明类或命名空间内的成员。</li>
</ul>
<h3 id="D-不同域中可以定义同名变量和函数"><a href="#D-不同域中可以定义同名变量和函数" class="headerlink" title="D. 不同域中可以定义同名变量和函数"></a>D. 不同域中可以定义同名变量和函数</h3><ul>
<li><strong>正确</strong>。不同作用域（如不同类、不同命名空间）中可以定义同名的变量和函数。在不同作用域内定义的同名实体互不干扰。</li>
</ul>
<p>因此，关于域的错误描述是 <strong>C. 域操作符::可以被重载</strong>。域操作符 <code>::</code> 是一个不可重载的运算符，用于在不同作用域间进行名称解析。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NS &#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::value = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; NS::value &lt;&lt; std::endl; <span class="comment">// 使用域操作符访问命名空间NS中的value</span></span><br><span class="line">    std::cout &lt;&lt; MyClass::value &lt;&lt; std::endl; <span class="comment">// 使用域操作符访问类MyClass中的value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>::</code> 用于访问命名空间和类中的静态成员，而不能被重载。</p>
<hr>
<ol>
<li>下列对变量的引用中错误的是【 C 】</li>
</ol>
<p>A. inta; int &amp;p = a;</p>
<p>B. chara; char *p = &a;</p>
<p>C. inta; int &p; p = a;</p>
<p>D. floata; float p=a;</p>
<p>让我们逐一分析每个选项，以确定哪个选项中对变量的引用是错误的。</p>
<h3 id="A-int-a-int-amp-p-a"><a href="#A-int-a-int-amp-p-a" class="headerlink" title="A. int a; int &amp;p = a;"></a>A. <code>int a; int &amp;p = a;</code></h3><ul>
<li><strong>正确</strong>。这是一个合法的引用声明。<code>p</code> 是对 <code>a</code> 的引用，这样 <code>p</code> 和 <code>a</code> 就代表同一个变量。</li>
</ul>
<h3 id="B-char-a-char-p-amp-a"><a href="#B-char-a-char-p-amp-a" class="headerlink" title="B. char a; char *p = &amp;a;"></a>B. <code>char a; char *p = &amp;a;</code></h3><ul>
<li><strong>正确</strong>。这是一个合法的指针声明。<code>p</code> 是指向 <code>a</code> 的指针，它存储了 <code>a</code> 的地址。</li>
</ul>
<h3 id="C-int-a-int-amp-p-p-a"><a href="#C-int-a-int-amp-p-p-a" class="headerlink" title="C. int a; int &amp;p; p = a;"></a>C. <code>int a; int &amp;p; p = a;</code></h3><ul>
<li><strong>错误</strong>。这个声明是错误的。引用必须在声明时进行初始化，而这里 <code>int &amp;p;</code> 声明了一个引用但没有进行初始化，这在 C++ 中是不合法的。</li>
</ul>
<h3 id="D-float-a-float-p-a"><a href="#D-float-a-float-p-a" class="headerlink" title="D. float a; float p = a;"></a>D. <code>float a; float p = a;</code></h3><ul>
<li><strong>正确</strong>。这是一个合法的变量赋值。<code>p</code> 是一个新的 <code>float</code> 类型变量，它的值被初始化为 <code>a</code> 的值。</li>
</ul>
<p>综上所述，选项 <strong>C</strong> 是错误的。以下是对引用初始化的详细解释：</p>
<h4 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h4><ul>
<li>在 C++ 中，引用（reference）必须在声明时进行初始化，引用一旦绑定到一个变量，就不能再更改引用的绑定对象。</li>
<li>选项 C 中，<code>int &amp;p;</code> 试图声明一个引用，但没有进行初始化，这在 C++ 中是不允许的。</li>
</ul>
<p>为了使选项 C 成为合法的代码，可以将其修改为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a;</span><br><span class="line"><span class="type">int</span> &amp;p = a; <span class="comment">// 正确的引用声明和初始化</span></span><br></pre></td></tr></table></figure>
<p>总之，引用必须在声明时初始化，并且一旦初始化后就不能更改其引用的对象。</p>
<hr>
<ol>
<li>下面【 A 】的叙述不符合赋值兼容规则。</li>
</ol>
<p>A. 基类的对象可以赋值派生类的对象</p>
<p>B. 派生类指针可以指向基类对象</p>
<p>C. 派生类的对象可以初始化基类的对象</p>
<p>D. 派生类的对象的地址可以赋值给指向基类的指针</p>
<p>在面向对象编程中，赋值兼容性规则决定了哪些对象和指针可以被赋值或初始化。我们逐一分析每个选项：</p>
<h3 id="A-基类的对象可以赋值派生类的对象"><a href="#A-基类的对象可以赋值派生类的对象" class="headerlink" title="A. 基类的对象可以赋值派生类的对象"></a>A. 基类的对象可以赋值派生类的对象</h3><ul>
<li><strong>错误</strong>。这违反了赋值兼容规则。在 C++ 中，不能将派生类对象赋值给基类对象。因为派生类对象通常包含更多数据成员，而基类对象只包含它自己定义的成员，导致潜在的数据丢失。</li>
</ul>
<h3 id="B-派生类指针可以指向基类对象"><a href="#B-派生类指针可以指向基类对象" class="headerlink" title="B. 派生类指针可以指向基类对象"></a>B. 派生类指针可以指向基类对象</h3><ul>
<li><strong>错误</strong>。这也是不正确的。派生类指针不能指向基类对象，因为派生类通常具有比基类更多的成员，基类对象无法满足派生类的所有要求。</li>
</ul>
<h3 id="C-派生类的对象可以初始化基类的对象"><a href="#C-派生类的对象可以初始化基类的对象" class="headerlink" title="C. 派生类的对象可以初始化基类的对象"></a>C. 派生类的对象可以初始化基类的对象</h3><ul>
<li><strong>错误</strong>。这是不正确的，类似于 A 的情况。派生类对象包含比基类对象更多的信息，不能用派生类对象来初始化基类对象。</li>
</ul>
<h3 id="D-派生类的对象的地址可以赋值给指向基类的指针"><a href="#D-派生类的对象的地址可以赋值给指向基类的指针" class="headerlink" title="D. 派生类的对象的地址可以赋值给指向基类的指针"></a>D. 派生类的对象的地址可以赋值给指向基类的指针</h3><ul>
<li><strong>正确</strong>。这是符合赋值兼容规则的。因为派生类对象包含所有基类的成员，所以指向基类的指针可以指向派生类对象，能够访问到基类的部分。</li>
</ul>
<p>综上所述，不符合赋值兼容规则的选项是 <strong>A</strong>：</p>
<h4 id="解释：-2"><a href="#解释：-2" class="headerlink" title="解释："></a>解释：</h4><ul>
<li>在面向对象编程中，基类的对象不能直接赋值给派生类的对象。这是因为派生类可能会扩展基类，添加新的成员或者方法，而基类并不具备这些成员和方法，因此赋值操作将会导致不兼容的问题。</li>
</ul>
<p>下面是一个例子，展示为什么选项 A 是错误的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> baseValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> derivedValue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line">    Base baseObj;</span><br><span class="line"></span><br><span class="line">    baseObj = derivedObj; <span class="comment">// 合法：基类对象可以从派生类对象赋值</span></span><br><span class="line">    derivedObj = baseObj; <span class="comment">// 不合法：派生类对象不能从基类对象赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在上述代码中，<code>baseObj = derivedObj</code> 是合法的，因为 <code>baseObj</code> 只关心 <code>Base</code> 部分。</li>
<li><code>derivedObj = baseObj</code> 是不合法的，因为 <code>baseObj</code> 不包含 <code>Derived</code> 类的成员 <code>derivedValue</code>。</li>
</ul>
<p>因此，选项 <strong>A</strong> 不符合赋值兼容规则。</p>
<hr>
<ol>
<li>构造函数不具备的特征的是【 D 】</li>
</ol>
<p>A.构造函数的函数名与类名相同</p>
<p>B.构造函数可以重载</p>
<p>C.构造函数可以设置默认参数</p>
<p>D.构造函数必须指定返回类型</p>
<p>构造函数在 C++ 中是用来初始化对象的特殊成员函数。让我们分析每个选项，以确定哪个特征是不正确的：</p>
<h3 id="A-构造函数的函数名与类名相同"><a href="#A-构造函数的函数名与类名相同" class="headerlink" title="A. 构造函数的函数名与类名相同"></a>A. 构造函数的函数名与类名相同</h3><ul>
<li><strong>正确</strong>。构造函数的名称必须与类名完全相同，这样编译器才能识别它为构造函数。例如，如果类名是 <code>MyClass</code>，那么构造函数的名称也必须是 <code>MyClass</code>。</li>
</ul>
<h3 id="B-构造函数可以重载"><a href="#B-构造函数可以重载" class="headerlink" title="B. 构造函数可以重载"></a>B. 构造函数可以重载</h3><ul>
<li><strong>正确</strong>。构造函数可以有多个重载版本，只要它们有不同的参数列表。这样可以在创建对象时提供不同的初始化方式。</li>
</ul>
<h3 id="C-构造函数可以设置默认参数"><a href="#C-构造函数可以设置默认参数" class="headerlink" title="C. 构造函数可以设置默认参数"></a>C. 构造函数可以设置默认参数</h3><ul>
<li><p><strong>正确</strong>。构造函数可以接受默认参数，这样在创建对象时可以选择性地提供参数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x = <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 构造函数的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="D-构造函数必须指定返回类型"><a href="#D-构造函数必须指定返回类型" class="headerlink" title="D. 构造函数必须指定返回类型"></a>D. 构造函数必须指定返回类型</h3><ul>
<li><p><strong>错误</strong>。构造函数没有返回类型，包括 <code>void</code>。它们的唯一目的是初始化对象，不返回任何值。下面是一个构造函数的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// 构造函数的实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果在构造函数中指定返回类型，会导致编译错误。例如，下面的代码是错误的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123; <span class="comment">// 错误：构造函数不能有返回类型</span></span><br><span class="line">        <span class="comment">// 构造函数的实现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>因此，选项 <strong>D</strong> 是不正确的，因为构造函数不能有返回类型，这是它们的一个重要特征。</p>
<hr>
<ol>
<li>关于虚函数的描述中，正确的是【 D 】</li>
</ol>
<p>A. 虚函数是一个static类型的成员函数</p>
<p>B. 虚函数是一个友元函数</p>
<p>C. 基类中说明了虚函数后，派生类中与其对应的函数必须再次说明为虚函数</p>
<p>D. 派生类的虚函数与基类的虚函数具有相同的参数个数和类型</p>
<p>虚函数是 C++ 中的一种特殊成员函数，允许派生类重写，从而实现运行时的多态性。让我们分析每个选项，以确定哪个描述是正确的：</p>
<h3 id="A-虚函数是一个-static-类型的成员函数"><a href="#A-虚函数是一个-static-类型的成员函数" class="headerlink" title="A. 虚函数是一个 static 类型的成员函数"></a>A. 虚函数是一个 static 类型的成员函数</h3><ul>
<li><strong>错误</strong>。虚函数不能是 <code>static</code> 类型的成员函数。静态成员函数是与类本身关联的，而不是与具体对象关联的。虚函数依赖于对象的动态类型，而静态成员函数不具有这种行为。</li>
</ul>
<h3 id="B-虚函数是一个友元函数"><a href="#B-虚函数是一个友元函数" class="headerlink" title="B. 虚函数是一个友元函数"></a>B. 虚函数是一个友元函数</h3><ul>
<li><strong>错误</strong>。虚函数是类的成员函数，而不是友元函数。友元函数是外部函数，它们被授予访问类的私有和保护成员的权限，但它们不能是虚函数。</li>
</ul>
<h3 id="C-基类中说明了虚函数后，派生类中与其对应的函数必须再次说明为虚函数"><a href="#C-基类中说明了虚函数后，派生类中与其对应的函数必须再次说明为虚函数" class="headerlink" title="C. 基类中说明了虚函数后，派生类中与其对应的函数必须再次说明为虚函数"></a>C. 基类中说明了虚函数后，派生类中与其对应的函数必须再次说明为虚函数</h3><ul>
<li><strong>错误</strong>。当基类中声明一个虚函数后，派生类中与其对应的函数自动是虚函数。派生类中可以选择性地使用 <code>virtual</code> 关键字，但这不是必须的。</li>
</ul>
<h3 id="D-派生类的虚函数与基类的虚函数具有相同的参数个数和类型"><a href="#D-派生类的虚函数与基类的虚函数具有相同的参数个数和类型" class="headerlink" title="D. 派生类的虚函数与基类的虚函数具有相同的参数个数和类型"></a>D. 派生类的虚函数与基类的虚函数具有相同的参数个数和类型</h3><ul>
<li><strong>正确</strong>。派生类重写基类的虚函数时，必须具有相同的参数个数和类型以及相同的返回类型。这样才能确保在通过基类指针或引用调用时，正确的函数能够在运行时被调用。</li>
</ul>
<p>为了更清楚地解释，以下是一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base show&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="comment">// 可以省略 &#x27;virtual&#x27; 关键字，依然是虚函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived show&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* b = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    b-&gt;<span class="built_in">show</span>(); <span class="comment">// 调用的是 Derived 类的 show 方法</span></span><br><span class="line">    <span class="keyword">delete</span> b;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，基类 <code>Base</code> 定义了一个虚函数 <code>show</code>。派生类 <code>Derived</code> 重写了这个虚函数。在 <code>main</code> 函数中，通过基类指针 <code>b</code> 调用 <code>show</code> 函数，实际调用的是派生类 <code>Derived</code> 的 <code>show</code> 函数。</p>
<p>因此，选项 <strong>D</strong> 是正确的，因为在派生类中重写基类的虚函数时，必须具有相同的参数个数和类型，以保证多态性行为的正确实现。</p>
<hr>
<ol>
<li>下列关于静态数据成员的说法，不正确的是【 C 】</li>
</ol>
<p>A. 类中定义的公用静态数据成员，可以通过类的对象来访问</p>
<p>B. 类中定义的所有静态数据成员，都必须在类外初始化</p>
<p>C. 静态数据成员不是所有对象所共用的</p>
<p>D. 普通的成员函数可以直接访问类中的静态数据成员</p>
<p>在 C++ 中，静态数据成员是属于类本身，而不是类的具体对象。我们来分析每个选项，找出不正确的描述：</p>
<h3 id="A-类中定义的公用静态数据成员，可以通过类的对象来访问"><a href="#A-类中定义的公用静态数据成员，可以通过类的对象来访问" class="headerlink" title="A. 类中定义的公用静态数据成员，可以通过类的对象来访问"></a>A. 类中定义的公用静态数据成员，可以通过类的对象来访问</h3><ul>
<li><p><strong>正确</strong>。公用（public）静态数据成员可以通过类的对象来访问。虽然静态数据成员属于类本身，但它们仍然可以通过对象进行访问。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    cout &lt;&lt; obj.value &lt;&lt; endl; <span class="comment">// 通过对象访问静态数据成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="B-类中定义的所有静态数据成员，都必须在类外初始化"><a href="#B-类中定义的所有静态数据成员，都必须在类外初始化" class="headerlink" title="B. 类中定义的所有静态数据成员，都必须在类外初始化"></a>B. 类中定义的所有静态数据成员，都必须在类外初始化</h3><ul>
<li><p><strong>正确</strong>。所有静态数据成员必须在类外进行定义和初始化。这是因为静态数据成员在整个类的生命周期内只存在一个实例，需要在类外进行定义。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::value = <span class="number">10</span>; <span class="comment">// 在类外初始化</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="C-静态数据成员不是所有对象所共用的"><a href="#C-静态数据成员不是所有对象所共用的" class="headerlink" title="C. 静态数据成员不是所有对象所共用的"></a>C. 静态数据成员不是所有对象所共用的</h3><ul>
<li><p><strong>不正确</strong>。静态数据成员是所有对象所共用的。无论创建了多少个类的对象，静态数据成员在所有对象中只有一个共享实例。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj1;</span><br><span class="line">    MyClass obj2;</span><br><span class="line">    obj1.value = <span class="number">20</span>;</span><br><span class="line">    cout &lt;&lt; obj2.value &lt;&lt; endl; <span class="comment">// 输出 20，obj2 也共享同一个静态数据成员</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码中，<code>obj1</code> 和 <code>obj2</code> 共享同一个静态数据成员 <code>value</code>。</p>
</li>
</ul>
<h3 id="D-普通的成员函数可以直接访问类中的静态数据成员"><a href="#D-普通的成员函数可以直接访问类中的静态数据成员" class="headerlink" title="D. 普通的成员函数可以直接访问类中的静态数据成员"></a>D. 普通的成员函数可以直接访问类中的静态数据成员</h3><ul>
<li><p><strong>正确</strong>。普通的成员函数可以直接访问类中的静态数据成员，就像访问普通的成员变量一样。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        value = val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> MyClass::value = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">setValue</span>(<span class="number">20</span>);</span><br><span class="line">    cout &lt;&lt; MyClass::value &lt;&lt; endl; <span class="comment">// 输出 20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>因此，选项 <strong>C</strong> 是不正确的，因为静态数据成员是所有对象所共享的，这一点与选项的描述相反。</p>
<hr>
<ol>
<li>下列关于运算符重载的描述中，正确的是【 D 】</li>
</ol>
<p>A. 运算符重载可以改变操作数的个数</p>
<p>B. 运算符重载可以改变优先级</p>
<p>C. 运算符重载可以改变结合性</p>
<p>D. 运算符重载不可以改变语法结构</p>
<p>运算符重载是 C++ 中的一种功能，允许程序员为用户定义的类型重新定义标准运算符的行为。通过运算符重载，可以使自定义类型与内置类型一样自然地使用运算符。让我们分析每个选项，找出正确的描述：</p>
<h3 id="A-运算符重载可以改变操作数的个数"><a href="#A-运算符重载可以改变操作数的个数" class="headerlink" title="A. 运算符重载可以改变操作数的个数"></a>A. 运算符重载可以改变操作数的个数</h3><ul>
<li><strong>不正确</strong>。运算符重载不能改变运算符的操作数个数。例如，二元运算符如 <code>+</code> 和 <code>-</code> 仍然需要两个操作数，一元运算符如 <code>++</code> 和 <code>--</code> 仍然只接受一个操作数。只能为运算符定义原本接受的操作数。</li>
</ul>
<h3 id="B-运算符重载可以改变优先级"><a href="#B-运算符重载可以改变优先级" class="headerlink" title="B. 运算符重载可以改变优先级"></a>B. 运算符重载可以改变优先级</h3><ul>
<li><strong>不正确</strong>。运算符重载不能改变运算符的优先级。运算符的优先级是由语言定义的，不能通过重载来改变。例如，乘法运算符 <code>*</code> 的优先级始终高于加法运算符 <code>+</code>，无论如何重载这些运算符。</li>
</ul>
<h3 id="C-运算符重载可以改变结合性"><a href="#C-运算符重载可以改变结合性" class="headerlink" title="C. 运算符重载可以改变结合性"></a>C. 运算符重载可以改变结合性</h3><ul>
<li><strong>不正确</strong>。运算符重载不能改变运算符的结合性。结合性决定了在没有括号时，具有相同优先级的运算符是从左向右（左结合性）还是从右向左（右结合性）进行计算。例如，加法运算符 <code>+</code> 和减法运算符 <code>-</code> 都是左结合性的，赋值运算符 <code>=</code> 是右结合性的，这些性质不能通过重载来改变。</li>
</ul>
<h3 id="D-运算符重载不可以改变语法结构"><a href="#D-运算符重载不可以改变语法结构" class="headerlink" title="D. 运算符重载不可以改变语法结构"></a>D. 运算符重载不可以改变语法结构</h3><ul>
<li><strong>正确</strong>。运算符重载不能改变运算符的语法结构。运算符的语法结构在 C++ 中是固定的，运算符重载只能改变运算符的行为，而不能改变其语法。例如，重载 <code>+</code> 运算符后，它仍然需要两个操作数，并且其表达式结构仍然是 <code>a + b</code>。</li>
</ul>
<h4 id="解释：-3"><a href="#解释：-3" class="headerlink" title="解释："></a>解释：</h4><p>运算符重载的主要目的是为了使自定义类型能够与内置类型一样自然地使用标准运算符，但它的作用范围是有限的。具体地说，运算符重载可以改变运算符的行为，使其适用于自定义类型，但不能改变以下特性：</p>
<ul>
<li><strong>操作数个数</strong>：运算符的操作数个数是固定的，如二元运算符总是需要两个操作数。</li>
<li><strong>优先级</strong>：运算符的优先级在语言标准中已经定义，不能通过重载来改变。</li>
<li><strong>结合性</strong>：运算符的结合性（左结合或右结合）也是固定的，不能通过重载来改变。</li>
<li><strong>语法结构</strong>：运算符的语法结构不能改变。运算符重载只能在运算符允许的语法结构范围内工作。</li>
</ul>
<p>因此，选项 <strong>D</strong> 是正确的，运算符重载不可以改变运算符的语法结构。</p>
<hr>
<ol>
<li>有关内联函数的描述，正确的是【 A 】</li>
</ol>
<p>A. 内联函数可以提高程序效率</p>
<p>B. 内联函数的调用过程与普通函数一样</p>
<p>C. 只要用 inline 关键字声明的函数都是内联函数</p>
<p>D. 全局函数不能声明为内联函数</p>
<p>选项 A 正确。下面是对每个选项的解释：</p>
<p>A. <strong>内联函数可以提高程序效率</strong>：内联函数的主要作用是通过将函数的代码插入到调用点处来减少函数调用的开销，从而提高程序的效率。</p>
<p>B. <strong>内联函数的调用过程与普通函数一样</strong>：这是不正确的。与普通函数不同，内联函数的调用过程不涉及函数调用的栈帧压栈、参数传递和返回地址等操作，而是在调用点处直接将函数体展开，因此内联函数的调用过程与普通函数有所不同。</p>
<p>C. <strong>只要用 inline 关键字声明的函数都是内联函数</strong>：这也是不正确的。使用 <code>inline</code> 关键字声明的函数只是建议编译器将其作为内联函数进行处理，但并不一定会被编译器采纳为内联函数。编译器可以自行决定是否将函数内联，通常取决于函数的大小、调用频率等因素。</p>
<p>D. <strong>全局函数不能声明为内联函数</strong>：这个说法是不准确的。事实上，全局函数也可以声明为内联函数。内联函数的定义并不限制在类内部，任何函数都可以声明为内联函数。然而，通常情况下，内联函数更适合用于小巧简单的函数，而全局函数通常不太适合作为内联函数。</p>
<p>因此，选项 A 是正确的，内联函数可以提高程序效率。</p>
<hr>
<ol>
<li>下列操作符中不能被重载的是【 D 】</li>
</ol>
<p>A. -&gt;</p>
<p>B. *</p>
<p>C. %</p>
<p>D. ?:</p>
<p>选项 D 正确。以下是每个选项的解释：</p>
<p>A. <strong>-&gt;</strong>：箭头运算符可以被重载。它通常用于访问类或结构体的成员指针。</p>
<p>B. <strong>*</strong>：解引用运算符（*）可以被重载。它用于访问指针所指向的对象。</p>
<p>C. <strong>%</strong>：取模运算符（%）可以被重载。它用于计算两个数相除后的余数。</p>
<p>D. <strong>?:</strong>：条件运算符（?:）是一个三元运算符，不能被重载。它用于根据条件选择执行不同的操作。</p>
<p>因此，选项 D 描述了一个不能被重载的运算符。</p>
<hr>
<ol>
<li>如果一个函数的声明是int fun(char*)，则下列函数声明中，错误地重载了该函数的是【 B 】</li>
</ol>
<p>A. int fun (char*, int)</p>
<p>B. void fun (char*)</p>
<p>C. int fun (int)</p>
<p>D. void fun (char*, int)</p>
<p>选项 B 错误地重载了函数。</p>
<p>在 C++ 中，函数重载要求函数在参数数量或参数类型上有所区别。在这个问题中，原始函数的声明是 <code>int fun(char*)</code>。因此，正确的重载应该涉及参数数量或参数类型的变化。</p>
<p>让我们逐个检查选项：</p>
<p>A. <code>int fun(char*, int)</code>：这是正确的函数重载，因为它有两个参数，其中一个是 <code>char*</code> 类型。</p>
<p>B. <code>void fun(char*)</code>：这个选项与原始函数的声明相同，参数类型也相同，所以不是正确的重载。</p>
<p>C. <code>int fun(int)</code>：这个选项与原始函数的声明在参数类型上有所不同，因为它的参数是 <code>int</code> 类型，所以它是正确的重载。</p>
<p>D. <code>void fun(char*, int)</code>：这是正确的函数重载，因为它有两个参数，其中一个是 <code>char*</code> 类型。</p>
<p>因此，选项 B 是错误的，因为它没有改变参数类型或数量，与原始函数的声明相同。</p>
<hr>
<ol>
<li>下面是关于派生类构造函数的执行顺序的叙述：①执行派生类的构造函数函数体中的内容。②按照基类被继承时声明的顺序（从左向右）执行基类的构造函数。③按照内嵌成员对象在类中声明的顺序执行它们的构造函数。上述执行步骤的正确排序是【 D 】</li>
</ol>
<p>A. ①②③ B. ②①③ C. ③②① D. ②③①</p>
<p>正确的顺序是 D. ②③①。</p>
<ol>
<li>按照基类被继承时声明的顺序（从左向右）执行基类的构造函数。这是因为派生类的构造函数在执行时，需要先初始化其基类部分，按照继承顺序从左到右依次执行基类的构造函数。</li>
<li>按照内嵌成员对象在类中声明的顺序执行它们的构造函数。在派生类中，如果有成员对象，则会按照它们在类中声明的顺序执行构造函数。这确保了成员对象在使用前已经正确初始化。</li>
<li>执行派生类的构造函数函数体中的内容。一旦基类的构造函数和成员对象的构造函数都执行完毕，就会执行派生类的构造函数体中的内容，完成派生类对象的构造过程。</li>
</ol>
<hr>
<ol>
<li>设A是一个有不带参数的构造函数的类，fun是一个如下定义的函数：Afun(A&amp;a){returna;}则在执行程序段{Aa; fun(a); }时，对A类的：①构造函数，②析构函数，③拷贝构造函数的调用顺序是【 B 】</li>
</ol>
<p>A. ①③③②②② B. ①③②②</p>
<p>C. ①②③② D. ①②③③②②</p>
<p>在执行程序段 <code>&#123; A a; fun(a); &#125;</code> 时，对类 A 的构造函数、拷贝构造函数和析构函数的调用顺序是：</p>
<ol>
<li>构造函数：①</li>
<li>拷贝构造函数：③</li>
<li>析构函数：②</li>
</ol>
<p>首先，构造函数①被调用来创建对象 a。然后，将对象 a 作为参数传递给函数 fun，这里会触发拷贝构造函数③的调用，因为参数 a 是通过值传递的，所以会调用拷贝构造函数来创建 fun 函数的参数。最后，在程序块结束时，对象 a 被销毁，因此析构函数②会被调用。</p>
<hr>
<ol>
<li>在公有派生类的成员函数不能直接访问基类中继承来的某个成员，则该成员一定是基类中的【 A 】</li>
</ol>
<p>A. 私有成员 B. 公有成员</p>
<p>C. 保护成员 D. 保护成员或私有成员</p>
<p>正确答案是 A. 私有成员。</p>
<p>在 C++ 中，派生类的成员函数可以访问基类中的公有和保护成员，但不能直接访问基类中的私有成员。这是因为私有成员只能在其所在的类内部访问，派生类无法直接访问基类的私有成员。</p>
<hr>
<ol>
<li>所谓数据封装就是将一组数据和与这组数据有关操作组装在一起，形成一个实体，这实体也就是【 C 】</li>
</ol>
<p>A. 函数体 B. 对象 C. 类 D. 数据块</p>
<p>正确答案是 C. 类。</p>
<p>数据封装是面向对象编程中的一个重要概念，它指的是将数据和操作数据的函数捆绑在一起形成一个单独的单元，这个单元就是类。类是面向对象编程的基本构建块，它封装了数据和操作数据的方法，提供了一种抽象的数据类型。通过封装，类隐藏了其内部的实现细节，使得外部程序只能通过类的公共接口来访问和操作数据，从而提高了程序的安全性和可维护性。</p>
<hr>
<ol>
<li>关于运算符重载，下列表述中正确的是【 B 】</li>
</ol>
<p>A. 可以通过运算符重载来创建C++中原来没有的运算符</p>
<p>B. 在类型转换函数的定义中不需要声明返回类型</p>
<p>C. 运算符函数的返回类型不能声明为基本数据类型</p>
<p>D. C++已有的任何运算符都可以重载</p>
<p>正确答案是 B. 在类型转换函数的定义中不需要声明返回类型。</p>
<p>解释：</p>
<ul>
<li>选项 A：运算符重载允许程序员重新定义已有的运算符的含义，但不能创建新的运算符。</li>
<li>选项 B：在类型转换函数的定义中，不需要声明返回类型。类型转换函数是一种特殊的成员函数，用于自定义类型转换规则。它们没有返回类型，其返回类型由转换目标类型隐式确定。</li>
<li>选项 C：运算符函数的返回类型可以声明为基本数据类型，也可以声明为类类型。</li>
<li>选项 D：C++中已有的任何运算符都可以重载，但有一些运算符有一定的限制，比如逗号运算符不能重载。</li>
</ul>
<hr>
<ol>
<li>下列关于静态数据成员的特性的叙述中，错误的是【 C 】</li>
</ol>
<p>A. 说明静态数据成员时前边要加修饰符static</p>
<p>B. 静态数据成员要在类体外进行初始化</p>
<p>C. 静态数据成员不是所有对象所共有的</p>
<p>D. 初始化静态数据成员时，要在其名称前加类名和作用域运算符</p>
<p>正确答案是 C. 静态数据成员不是所有对象所共有的。</p>
<p>解释：</p>
<ul>
<li>选项 A：说明静态数据成员时需要加上 <code>static</code> 修饰符，以便标识这是一个静态成员。</li>
<li>选项 B：静态数据成员的初始化通常在类外进行，因为它只有一个实例，而不是每个对象都有自己的副本。</li>
<li>选项 C：静态数据成员是属于类的，而不是属于类的每个对象。因此，它们不是所有对象所共有的，而是被所有对象所共享的。</li>
<li>选项 D：在初始化静态数据成员时，确实要在其名称前加上类名和作用域运算符，以便指明这是属于哪个类的静态成员。</li>
</ul>
<hr>
<ol>
<li>为了使类中的某个成员不能被类的对象通过成员操作符访问，则不能把该成员的访问权限定义为【 AD 】。</li>
</ol>
<p>A.public B.protected C.private D.static</p>
<p>正确答案是 A 和 D。</p>
<p>解释：</p>
<ul>
<li>A. public：将成员定义为公有的，可以通过对象的成员操作符直接访问。</li>
<li>D. static：静态成员不是特定对象的一部分，而是与类本身相关联的，因此也可以通过类名和作用域运算符直接访问。</li>
</ul>
<p>如果将成员的访问权限定义为 protected 或 private，则不能通过对象的成员操作符直接访问，但可以通过类的成员函数进行访问。</p>
<hr>
<ol>
<li>在用关键字class定义的类中，以下叙述正确的是【 A 】</li>
</ol>
<p>A. 在类中，不作特别说明的数据成员均为私有类型</p>
<p>B. 在类中，不作特别说明的数据成员均为公有类型</p>
<p>C. 类成员的定义必须是成员变量定义在前，成员函数定义在后</p>
<p>D. 类的成员定义必须放在类定义体内部</p>
<p>正确答案是 A. </p>
<p>解释：</p>
<p>A. 在使用关键字 class 定义的类中，如果不作特别说明，数据成员默认是私有类型的，即类的数据成员默认的访问权限是 private。这意味着在类的外部无法直接访问这些数据成员，而需要通过类的公有成员函数来访问或修改。</p>
<p>B. 这个说法是错误的，因为在使用关键字 class 定义的类中，默认情况下数据成员是私有的，而不是公有的。</p>
<p>C. 类成员的定义顺序没有严格要求，可以先定义成员函数，后定义成员变量。</p>
<p>D. 类的成员定义可以放在类定义体外部，但需要使用作用域解析运算符指明所属的类。</p>
<hr>
<ol>
<li>下列情况中，不会调用复制构造函数的是【 C 】</li>
</ol>
<p>A. 函数的返回值是类的对象，函数执行返回调用时</p>
<p>B. 函数的形参是类的对象，调用函数进行形参和实参相结合</p>
<p>C. 将类的一个对象赋值给该类的另一个对象时</p>
<p>D. 用一个对象去初始化同一类的另一个新对象时</p>
<p>正确答案是 C. </p>
<p>解释：</p>
<p>C. 将类的一个对象赋值给该类的另一个对象时不会调用复制构造函数。这是因为赋值操作符（<code>=</code>）执行的是赋值操作，而不是对象的创建或初始化操作。因此，在这种情况下，会调用类的默认赋值运算符重载函数，而不是复制构造函数。</p>
<p>A. 当函数的返回值是类的对象时，在函数执行返回调用时，会调用复制构造函数来创建返回值对象的一个副本。</p>
<p>B. 当函数的形参是类的对象，并且调用函数进行形参和实参相结合时，会调用复制构造函数来创建形参对象的一个副本。</p>
<p>D. 当用一个对象去初始化同一类的另一个新对象时，也会调用复制构造函数。</p>
<hr>
<ol>
<li>下列关于抽象类描述不正确的是【 D 】</li>
</ol>
<p>A. 抽象类不能定义对象</p>
<p>B. 其派生类没有定义纯虚函数，则仍是抽象类。”</p>
<p>C. 其派生类定义所有纯虚函数，则是具体类</p>
<p>D. 不能定义指向抽象类的指针变量</p>
<p>正确答案是 D. </p>
<p>解释：</p>
<p>D. 错误。可以定义指向抽象类的指针变量。指向抽象类的指针变量可以用来指向其派生类的对象，从而实现多态性。抽象类的指针变量可以在程序中用来管理多个不同派生类对象的集合。</p>
<hr>
<ol>
<li>下列关于常成员和常对象的叙述中，正确的是【 A 】</li>
</ol>
<p>A. 通过常对象只能调用其常成员函数</p>
<p>B. 常成员函数只能由常对象调用</p>
<p>C.通 过常成员函数可以修改常成员数据的值</p>
<p>D. 常成员函数可以通过类名来调用</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mylinux/archive/2013/05/02/3055372.html">https://www.cnblogs.com/mylinux/archive/2013/05/02/3055372.html</a></p>
<p>A. 正确。通过常对象只能调用其常成员函数是正确的。常对象被声明为常量，意味着它的状态不能被修改。因此，只能调用常成员函数，这些函数不会修改对象的状态，从而保证了常对象的常量性质。</p>
<hr>
<ol>
<li>关于成员函数特征的下列叙述中，错误的是【 A 】</li>
</ol>
<p>A. 成员函数一定是内联函数</p>
<p>B. 成员函数可以重载</p>
<p>C. 成员函数可以设置缺省参数值</p>
<p>D. 成员函数可以是静态的</p>
<p>A. 错误。成员函数不一定是内联函数。虽然在类定义中声明的函数默认情况下是内联的，但并不是所有的成员函数都是内联函数。只有在函数定义的时候使用了 <code>inline</code> 关键字，或者在类定义体内直接定义的函数，才是内联函数。</p>
<hr>
<ol>
<li>下面关于友元函数和友元类的叙述中，错误的是【 C 】</li>
</ol>
<p>A. 如果在类A中把类B的某个函数声明为自己的友元函数，那么在类A的定义之前一定要有类B的完整定义</p>
<p>B. 如果在类A中把类B声明为自己的友元类，那么在类A的定义之前可以仅有类B的前向声明，而不必有类B的完整定义</p>
<p>C. 如果将类B声明为类A的友元，那么类A也就成为类B的友元</p>
<p>D. 如果将类B声明为类A的友元，那么类B中的函数可以访问类A的全部成员</p>
<p>C 错误。将类 B 声明为类 A 的友元并不意味着类 A 也成为类 B 的友元。友元关系是单向的。因此，尽管类 A 可以访问类 B 的私有成员（如果类 B 将类 A 声明为友元），但类 B 不能自动访问类 A 的私有成员。</p>
<hr>
<ol>
<li>程序中重载了C++流运算符&lt;&lt;，它是【 D 】</li>
</ol>
<p>A.用于输出操作的成员函数</p>
<p>B.用于输入操作的成员函数</p>
<p>C.用于输入操作的非成员函数</p>
<p>D.用于输出操作的非成员函数</p>
<p>D. 用于输出操作的非成员函数。在 C++ 中，通常通过重载流插入运算符 <code>&lt;&lt;</code> 来实现自定义类型的输出操作符重载。这个重载函数一般不是类的成员函数，而是一个非成员函数。</p>
<hr>
<ol>
<li>下列字符常量的写法中错误的是【 C 】</li>
</ol>
<p>A. ‘\105’ B. ‘*’ C. “” D. ‘\n’</p>
<p>C. “”。在 C++ 中，双引号 <code>&quot;&quot;</code> 表示字符串常量，而不是字符常量。正确的字符常量应该使用单引号 <code>&#39;&#39;</code>，例如 <code>&#39;A&#39;</code> 或者 <code>&#39;\n&#39;</code>。</p>
<hr>
<ol>
<li>下列关于静态数据成员的描述中，正确的是【 A 】</li>
</ol>
<p>A. 静态数据成员是类的所有对象共享的数据</p>
<p>B. 类的每个对象都有自己的静态数据成员</p>
<p>C. 类的不同对象有不同的静态数据成员</p>
<p>D. 静态数据成员不能通过类的对象调用</p>
<p>A. 静态数据成员是类的所有对象共享的数据。静态数据成员是属于类的，而不是属于类的每个对象的。因此，不需要创建类的对象就可以访问静态数据成员，而是使用类名和作用域解析运算符即可。</p>
<hr>
<ol>
<li>设A是一个类，且语句“A*p=newA[10];”是能够正确执行的，则下列关于该语句的执行的叙述最恰当的是【 D 】</li>
</ol>
<p>A. 类A有不带参数的构造函数，且构造函数被调用10次</p>
<p>B. 类A有拷贝构造函数，且拷贝构造函数被调用10次</p>
<p>C. 类A有这样的构造函数，其每个参数都有默认的形参值，且该构造函数被调用10次</p>
<p>D. A和C皆有可能。</p>
<p>如果语句“A*p=newA[10];”能够正确执行，那么说明类A至少有一个可以接受零个参数的构造函数，因为在这种情况下，不需要为对象构造函数提供参数。</p>
<p>所以，选项 A 是不正确的，因为它假设类 A 必须有不带参数的构造函数。</p>
<p>而选项 C 是正确的，因为它描述了一种可能的情况，即类 A 可能有一个构造函数，其每个参数都有默认的形参值，这样的构造函数被调用了 10 次，用于初始化指针数组中的每个元素。</p>
<hr>
<ol>
<li>如果派生类中有指针类型的数据成员，该数据成员指向的内存空间需要动态申请，并且需要在构造函数中初始化该数据成员，在析构函数中回收该成员可能指向的内存空间。此时，如果存在通过基类的指针删除派生类的对象的情况，则需要【 B 】</li>
</ol>
<p>A. 将基类的构造函数声明为虚函数</p>
<p>B. 将基类的析构函数声明为虚函数</p>
<p>C. 将派生类的构造函数声明为虚函数</p>
<p>D. 将派生类的析构函数声明为纯虚函数</p>
<p>选项 B 是正确的。当通过基类的指针删除派生类的对象时，如果基类的析构函数不是虚函数，那么只会调用基类的析构函数，而不会调用派生类的析构函数。这可能导致派生类的动态分配的资源没有得到释放，造成内存泄漏。声明基类的析构函数为虚函数可以解决这个问题，确保在通过基类指针删除派生类对象时会调用派生类的析构函数，从而释放派生类的资源。</p>
<hr>
<ol>
<li>在类 object 中，以下定义会出现编译错误的是【 C 】</li>
</ol>
<p>A. static object a;</p>
<p>B. object a;</p>
<p>C. static object *pa;</p>
<p>D. object* pa;</p>
<p>选项 C 会导致编译错误。在类内部定义静态成员时，如果是指针类型的静态成员，编译器不知道该指针所指向的对象的大小，因此无法在类内部直接定义它，需要在类的外部进行定义和初始化。</p>
<hr>
<ol>
<li>运算符“&gt;”被友元重载，则表达式“obj1&gt;obj2”被编译器解释为【 A 】</li>
</ol>
<p>A. operator &gt; (obj1,obj2)</p>
<p>B. &gt; (obj1,obj2)</p>
<p>C. obj2.operator &gt; (obj1)</p>
<p>D. obj1.operator &gt; (obj2)</p>
<ol>
<li>关于友元，下列说法错误的是【 A 】</li>
</ol>
<p>A. 如果类A是类B的友元，则类B也是类A的友元</p>
<p>B. 如果函数fun()被说明为类A的友元，那么在fun()中可以访问类A的私有成员</p>
<p>C. 友元关系不能被继承</p>
<p>D. 如果类A是类B的友元，那么类A的所有成员函数都是类B的友元</p>
<ol>
<li>面向对象系统具有【 A 】 、继承性和多态性三种基本特性。</li>
</ol>
<p>A. 封装性</p>
<p>B. 消息性</p>
<p>C. 维护性</p>
<p>D. 动态性</p>
<blockquote>
<ol>
<li><p>运算符”&gt;”被友元重载时，表达式”obj1 &gt; obj2”被编译器解释为选项 A 中的形式，即调用了名为”operator&gt;”的友元函数。</p>
</li>
<li><p>关于友元，错误的说法是选项 A。友元关系不具有传递性，如果类 A 是类 B 的友元，并不意味着类 B 自动成为类 A 的友元。</p>
</li>
<li><p>面向对象系统具有封装性、继承性和多态性这三种基本特性。其中，封装性指的是将数据和操作数据的方法捆绑在一起形成类，实现了数据隐藏和安全性；继承性允许一个类继承另一个类的特性；多态性指的是同一个消息被不同的对象接收时会产生不同的行为。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>从基类 public 派生一个类，基类 protected 成员成为派生类【 B 】 成员。</li>
</ol>
<p>A. public</p>
<p>B. protected</p>
<p>C. private</p>
<p>D. virtual</p>
<ol>
<li>下列关于虚函数的描述中，正确的是【 C 】</li>
</ol>
<p>A.虚函数可以是一个static类型的成员函数</p>
<p>B.虚函数可以是非成员函数</p>
<p>C.基类中说明了虚函数后，派生类中其对应的函数可以不必说明为虚函数</p>
<p>D.派生类的虚函数与基类的虚函数具有不同的参数个数和类型</p>
<ol>
<li>this指针存在的目的是【 C 】</li>
</ol>
<p>A. 保证基类共有成员在子类中可以被访问</p>
<p>B. 保证基类保护成员在子类中可以被访问</p>
<p>C. 保证每个对象拥有自己的数据成员，但共享处理这些数据成员的代码</p>
<p>D. 保证基类私有成员在子类中可以被访问</p>
<blockquote>
<ol>
<li><p>从基类 public 派生一个类，基类 protected 成员成为派生类 <strong>protected</strong> 成员。</p>
</li>
<li><p>下列关于虚函数的描述中，正确的是 <strong>C. 基类中说明了虚函数后，派生类中其对应的函数可以不必说明为虚函数。</strong> 虚函数在基类中声明为虚函数后，在派生类中可以选择是否再次声明为虚函数。</p>
</li>
<li><p>this 指针存在的目的是 <strong>C. 保证每个对象拥有自己的数据成员，但共享处理这些数据成员的代码。</strong> this 指针是一个隐含于每个成员函数中的指针，指向当前对象。它的主要目的是在成员函数中访问当前对象的数据成员和成员函数。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>以下成员函数表示纯虚函数的是【 C 】</li>
</ol>
<p>A.virtual int vf (int);</p>
<p>B.void vf (int) = 0;</p>
<p>C.virtual void vf () = 0;</p>
<p>D.virtual void vf (int) {}</p>
<ol>
<li>对于一组功能相同但处理数据类型不同的函数可以通过【 B 】抽象为同一段代码。</li>
</ol>
<p>A. 类模板</p>
<p>B. 函数模板</p>
<p>C. 函数重载</p>
<p>D. 虚函数</p>
<ol>
<li>C++标准库中的类、结构以及相关函数等被定义在名字空间 【 D 】中。</li>
</ol>
<p>A. cplus</p>
<p>B. news</p>
<p>C. std</p>
<p>D. namespace</p>
<blockquote>
<ol>
<li><p>以下成员函数表示纯虚函数的是 <strong>C. virtual void vf() = 0;</strong>。纯虚函数在声明时用 “= 0” 来标记，没有函数体，只有函数声明，因此类无法实例化对象，而是作为抽象基类存在。</p>
</li>
<li><p>对于一组功能相同但处理数据类型不同的函数可以通过 <strong>B. 函数模板</strong> 抽象为同一段代码。函数模板可以定义一种通用的函数形式，使得函数可以接受不同类型的参数，实现了代码的复用和泛化。</p>
</li>
<li><p>C++标准库中的类、结构以及相关函数等被定义在名字空间 <strong>C. std</strong> 中。标准C++库中的所有内容都被放置在 std 命名空间中，以避免命名冲突和提供统一的命名规范。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>已知在一个类体中包含如下函数原型: Volume operator-(Volume)const;，</li>
</ol>
<p>下列关于这个函数的叙述中，错误的是【 B 】</p>
<p>A. 这是运算符-的重载运算符函数</p>
<p>B. 这个函数所重载的运算符是一个一元运算符</p>
<p>C. 这是一个成员函数</p>
<p>D. 这个函数不改变类的任何数据成员的值</p>
<ol>
<li>在下列函数原型中，可以作为类AA构造函数的是【 D 】</li>
</ol>
<p>A. void AA(int); B. int AA();</p>
<p>C. AA(int)const; D. AA(int);</p>
<ol>
<li>下面四个选项中，【 A 】是用来声明虚函数的。</li>
</ol>
<p>A. virtual B. public</p>
<p>C. include D. using namespace</p>
<blockquote>
<ol>
<li><p>错误的是 <strong>B. 这个函数所重载的运算符是一个一元运算符</strong>。因为函数原型中的 <code>operator-</code> 是一个二元运算符，而不是一元运算符。</p>
</li>
<li><p>可以作为类 AA 构造函数的是 <strong>D. AA(int);</strong>。构造函数没有返回类型，且名称必须与类名相同，因此只有选项 D 是符合构造函数的命名规范的。</p>
</li>
<li><p>用来声明虚函数的是 <strong>A. virtual</strong>。在函数声明或定义前加上 <code>virtual</code> 关键字可以将其声明为虚函数，使得该函数可以在派生类中被重写。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>实现运行时的多态性要使用【 D 】</li>
</ol>
<p>A. 重载函数 B. 构造函数</p>
<p>C. 析构函数 D.虚函数</p>
<ol>
<li>要实现动态联编，必须通过【 A 】调用虚函数</li>
</ol>
<p>A. 对象指针 B. 成员名限定</p>
<p>C. 对象名 D. 派生类名</p>
<ol>
<li>以下【 C 】成员函数表示纯虚函数</li>
</ol>
<p>A. virtual int vf(int); B. void vf(int)=0;\n\n C. virtual void vf()=0; D. virtual void vf(int)</p>
<ol>
<li>在表达式 x+y<em>z中， + 是作为成员函数重载的运算符，</em> 是作为非成员函数重载的运算符。则 operator+ 有<strong>_ 个参数，operator* 有_</strong> 参数。【 C 】</li>
</ol>
<p>A. 2、2 B. 2、1 C. 1、2 D. 1、1</p>
<ol>
<li><p>实现运行时的多态性要使用 <strong>D. 虚函数</strong>。虚函数允许在派生类中重写基类的函数，从而实现基类指针或引用指向派生类对象时的多态行为。</p>
</li>
<li><p>要实现动态联编，必须通过 <strong>A. 对象指针</strong> 调用虚函数。使用对象指针可以在运行时确定调用的是哪个类的虚函数，实现动态联编。</p>
</li>
<li><p>以下 <strong>C. virtual void vf()=0;</strong> 成员函数表示纯虚函数。在函数声明或定义中使用 “= 0” 将函数声明为纯虚函数，即没有实现，必须在派生类中重写。</p>
</li>
<li><p>在表达式 <code>x+y*z</code> 中，<code>+</code> 是作为成员函数重载的运算符，<code>*</code> 是作为非成员函数重载的运算符。则 <code>operator+</code> 有 <strong>1</strong> 个参数，<code>operator*</code> 有 <strong>2</strong> 个参数。</p>
</li>
</ol>
<hr>
<ol>
<li>一个类的友元函数或友元类可以访问该类的【 C 】</li>
</ol>
<p>A. 私有成员 B. 保护成员</p>
<p>C. 所有成员 D. 公有成员</p>
<ol>
<li>对C++语言和C语言的兼容性，其中描述正确的是【 B 】</li>
</ol>
<p>A. C兼容C++</p>
<p>B. C++兼容C</p>
<p>C. C++不兼容C</p>
<p>D.C++部分兼容C</p>
<ol>
<li>关于公有继承，下列说法错误的是【 D 】</li>
</ol>
<p>A. 基类的公有成员和保护成员被继承后作为派生类的公有成员和保护成员</p>
<p>B. 派生类的其他成员可以直接访问基类的公有成员和保护成员</p>
<p>C. 派生类成员和对象都无法访问基类的私有成员</p>
<p>D. 派生类的对象可以访问基类的私有成员</p>
<blockquote>
<ol>
<li><p>一个类的友元函数或友元类可以访问该类的 <strong>C. 所有成员</strong>。友元函数或友元类可以访问该类的私有、保护和公有成员。</p>
</li>
<li><p>对C++语言和C语言的兼容性，其中描述正确的是 <strong>B. C++兼容C</strong>。C++语言是在C语言的基础上发展而来的，并且保留了对C语言的兼容性。</p>
</li>
<li><p>关于公有继承，下列说法错误的是 <strong>D. 派生类的对象可以访问基类的私有成员</strong>。派生类的对象无法直接访问基类的私有成员，私有成员只能由基类的成员函数或友元函数访问。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>关于new运算符的下列描述中，【 D 】是错误的</li>
</ol>
<p>A.它可以用来动态创建对象和对象数组</p>
<p>B.使用它创建的对象或对象数组可以使用运算符delete删除</p>
<p>C.使用它创建对象时要调用构造函数</p>
<p>D.使用它创建数组时必须指定初始值</p>
<ol>
<li>面向对象程序设计数据与【 A 】放在一起，作为一个相互依存、不可分割的整体来处理。</li>
</ol>
<p>A. 对数据的操作 B. 信息</p>
<p>C. 数据隐藏 D. 数据抽象</p>
<ol>
<li>在类中说明的成员可以使用关键字的是【 A 】</li>
</ol>
<p>A. public B. extern C. cpu D. register</p>
<blockquote>
<ol>
<li><p>关于new运算符的下列描述中，【 D 】是错误的：<strong>使用它创建数组时必须指定初始值</strong>。使用new运算符创建数组时，并不需要为数组元素指定初始值。例如，<code>int *arr = new int[10];</code> 就创建了一个包含10个int类型元素的数组，但没有为这些元素指定初始值。</p>
</li>
<li><p>面向对象程序设计中，数据与 <strong>B. 信息</strong> 放在一起，作为一个相互依存、不可分割的整体来处理。对象不仅仅是数据的集合，还包含了操作这些数据的方法，因此可以被视为信息的集合。</p>
</li>
<li><p>在类中说明的成员可以使用关键字 <strong>A. public</strong>。public关键字用于声明在类的外部和类的派生类中都可以访问的成员。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>下列关于C++语言类的描述中错误的是【 C 】</li>
</ol>
<p>A. 类用于描述事物的属性和对事物的操作</p>
<p>B. 类与类之间通过封装而具有明确的独立性</p>
<p>C. 类与类之间必须是平等的关系，而不能组成层次结构</p>
<p>D. 类与类之间必须是平等的关系，而不能组成层次结</p>
<ol>
<li>下面关于类中概念的描述中错误的是【 D 】</li>
</ol>
<p>A. 类是抽象数据类型的实现</p>
<p>B. 类是具有共同行为的若干对象的统一描述体</p>
<p>C.类是创建对象的模板</p>
<p>D. 类就是C语言中的结构体类型</p>
<ol>
<li>作用域运算符的功能是【 C 】</li>
</ol>
<p>A. 标识作用域的级别</p>
<p>B. 指出其大小</p>
<p>C. 标识某个成员是属于哪一个类</p>
<p>D. 给出的范围</p>
<blockquote>
<ol>
<li><p>下列关于C++语言类的描述中错误的是 <strong>C. 类与类之间必须是平等的关系，而不能组成层次结构</strong>。在C++中，类与类之间可以通过继承形成层次结构，其中派生类可以继承基类的属性和方法，并且可以添加自己的属性和方法，因此类与类之间不一定要平等，可以形成层次结构。</p>
</li>
<li><p>下面关于类中概念的描述中错误的是 <strong>D. 类就是C语言中的结构体类型</strong>。在C++中，类是更加强大和复杂的概念，它不仅仅是C语言中的结构体类型的扩展，还包括了封装、继承、多态等特性，可以用来描述事物的属性和行为，是抽象数据类型的一种实现方式。</p>
</li>
<li><p>作用域运算符的功能是 <strong>C. 标识某个成员是属于哪一个类</strong>。作用域运算符(::)用于指定成员的作用域，可以用来访问命名空间、类、结构体等的成员。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>下列关于模板的叙述中，错误的是【 B 】</li>
</ol>
<p>A. 在一定条件下函数模板的实参可以省略</p>
<p>B. 类模板不能有数据成员</p>
<p>C. 在模板声明中用&lt; &gt;括起来的部分是模板的形参表</p>
<p>D. 模板声明中的第一个符号总是关键字template</p>
<ol>
<li>下列关于C++函数的叙述中，正确的是【 D 】</li>
</ol>
<p>A. 每个函数都必须有参数</p>
<p>B. 每个函数都必须返回一个值</p>
<p>C. 函数在被调用之前可以不先声明</p>
<p>D. 函数可以自己调用自己</p>
<ol>
<li>下列带缺省值参数的函数说明中，正确的说明是【 A 】</li>
</ol>
<p>A. int Fun(int x, int y=2, int z=3);</p>
<p>B. int Fun(int x=1, int y, int z);</p>
<p>C. int Fun(int x=1, int y, int z=3);</p>
<p>D. int Fun(int x, int y=2, int z);</p>
<blockquote>
<ol>
<li><p>下列关于模板的叙述中，错误的是 <strong>B. 类模板不能有数据成员</strong>。类模板可以有数据成员，不仅可以有数据成员，还可以有成员函数和其他类模板成员。</p>
</li>
<li><p>下列关于C++函数的叙述中，正确的是 <strong>D. 函数可以自己调用自己</strong>。这种函数调用方式称为递归调用，函数在其函数体内部调用自身的过程称为递归。递归是一种常用的编程技巧，在一些情况下可以简化问题的解决方法。</p>
</li>
<li><p>下列带缺省值参数的函数说明中，正确的说明是 <strong>A. int Fun(int x, int y=2, int z=3);</strong>。这个函数说明中，x是普通参数，y和z是带有缺省值的参数，调用该函数时，可以省略y和z的实参，此时y默认为2，z默认为3。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>假定A为一个类，f()为该类公有的函数成员，a1为该类的一个对象，则\n访问a1对象中函数成员f()的格式为( B )。</li>
</ol>
<p>A. a1.f B. a1.f() C. a1-&gt;f() D.（a1）.f ()</p>
<ol>
<li>下列关于运算符重载的叙述中，正确的是【 B 】</li>
</ol>
<p>A. 通过运算符重载，可以定义新的运算符</p>
<p>B.有的运算符只能作为成员函数重载</p>
<p>C. 若重载运算符+，则相应的运算符函数名是+</p>
<p>D. 重载二元运算符时，必须声明两个形参\n\n</p>
<ol>
<li>假定AA为一个类，a()为该类公有的函数成员，x为该类的一个对象，则访问x对象中函数成员a()的格式为【 B 】</li>
</ol>
<p>A. x.a B.x.a() C.x-&gt;a D. x-&gt;a()</p>
<blockquote>
<ol>
<li><p>访问a1对象中函数成员f()的格式为 <strong>B. a1.f()</strong>。在C++中，成员函数通过成员操作符”.”来调用，因此正确的方式是对象名后跟成员函数名，然后加上一对圆括号。</p>
</li>
<li><p>下列关于运算符重载的叙述中，正确的是 <strong>B. 有的运算符只能作为成员函数重载</strong>。在C++中，有些运算符只能通过成员函数重载，例如赋值运算符（=）、下标运算符（[]）等；而有些运算符可以通过成员函数重载也可以通过全局函数重载，例如算术运算符（+、-、*等）。</p>
</li>
<li><p>访问x对象中函数成员a()的格式为 <strong>B. x.a()</strong>。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>下列关于构造函数的特点，其中描述错误的是【 B 】。</li>
</ol>
<p>A. 构造函数是一种成员函数，它具有一般成员函数的特点</p>
<p>B. 构造函数必须指明其类型</p>
<p>C. 构造函数的名称与其类名相同</p>
<p>D. 一个类中可以定义一个或多个构造函数</p>
<ol>
<li>假设Class Y: public X，即类Y是类X的派生类，则定义一个Y类的对象时和删除Y类对象时，调用构造函数和析构函数的次序分别为【 A 】</li>
</ol>
<p>A. X,Y；Y,X B. X,Y；X,Y</p>
<p>C. Y,X；X,Y D. Y,X；Y,X</p>
<ol>
<li>对使用new申请的存储空间，释放时必须使用【 C 】</li>
</ol>
<p>A. free B. release C. delete D. malloc</p>
<blockquote>
<ol>
<li><p>构造函数的特点中，描述错误的是 <strong>B. 构造函数必须指明其类型</strong>。构造函数不需要指明返回类型，包括不指定返回类型，也不需要声明为 void。</p>
</li>
<li><p>假设 Class Y: public X，即类 Y 是类 X 的派生类，则定义一个 Y 类的对象时和删除 Y 类对象时，调用构造函数和析构函数的次序分别为 <strong>C. Y,X；X,Y</strong>。在创建对象时，先调用派生类的构造函数，然后调用基类的构造函数；在删除对象时，先调用派生类的析构函数，然后调用基类的析构函数。</p>
</li>
<li><p>对使用 new 申请的存储空间，释放时必须使用 <strong>C. delete</strong>。对于使用 new 申请的内存空间，在不再需要时应使用 delete 运算符将其释放，而不是使用 free、release 或 malloc。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>下列叙述错误的是【 D 】。</li>
</ol>
<p>A. catch（…）语句可捕获所有类型的异常</p>
<p>B．一个try语句可以有多个catch语句</p>
<p>C．catch（…）语句可以放在catch语句组的中间</p>
<p>D．程序中try语句与catch语句是一个整体，缺一不可</p>
<ol>
<li>所谓的数据封装就是将数据和对这些数据相关的操作组装在一起，形成一个实体，这个实体我可可以称为【 A 】</li>
</ol>
<p>A. 类 B. 函数 C. 对象 D. 数据块</p>
<ol>
<li>有关类和结构体的关系，错误的是【 B 】</li>
</ol>
<p>A. 结构体一般只有数据成员，通常不会加入函数方法</p>
<p>B. 类一般只有函数方法，通常不会包含数据成员</p>
<p>C. 类的成员默认都是私有的</p>
<p>D. 结构体的成员默认都是公开的</p>
<blockquote>
<ol>
<li><p>下列叙述错误的是 <strong>D. 程序中 try 语句与 catch 语句是一个整体，缺一不可</strong>。在 C++ 中，try 语句块和 catch 语句块是分开的，try 用于包含可能引发异常的代码块，而 catch 用于捕获并处理异常。即使在某些情况下可能不需要 catch 块，try 块本身仍然是合法的。</p>
</li>
<li><p>所谓的数据封装就是将数据和对这些数据相关的操作组装在一起，形成一个实体，这个实体我可以称为 <strong>A. 类</strong>。数据封装是面向对象编程中的一个重要概念，它通过将数据和相关操作封装在一个实体中，提供了更好的数据保护和控制，同时也增强了代码的可维护性和可扩展性。</p>
</li>
<li><p>有关类和结构体的关系，错误的是 <strong>B. 类一般只有函数方法，通常不会包含数据成员</strong>。类和结构体都可以包含数据成员和函数成员，它们的主要区别在于默认的成员访问权限。在类中，默认情况下成员是私有的，而在结构体中，默认情况下成员是公有的。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>类的构造函数被自动调用执行的情况是在定义类的【 C 】</li>
</ol>
<p>A.成员函数时 B.数据成员时</p>
<p>C.对象时 D.友元函数时</p>
<ol>
<li>关于this指针使用说法正确的是【 A 】</li>
</ol>
<p>A. 保证每个对象拥有自己的数据成员，但共享处理这些数据的代码</p>
<p>B. 保证基类私有成员在子类中可以被访问。</p>
<p>C. 保证基类保护成员在子类中可以被访问。</p>
<p>D. 保证基类公有成员在子类中可以被访问。</p>
<ol>
<li>下面对静态数据成员的描述中，正确的是【 C 】</li>
</ol>
<p>A. 静态数据成员可以在类体内进行初始化</p>
<p>B. 静态数据成员不可以被类的对象调用</p>
<p>C. 静态数据成员可以直接用类名调用</p>
<p>D. 静态数据成员不能受private控制符的作用</p>
<blockquote>
<ol>
<li><p>类的构造函数被自动调用执行的情况是在定义类的 <strong>C. 对象时</strong>。当创建类的对象时，其构造函数会自动被调用以初始化对象的状态。</p>
</li>
<li><p>关于 this 指针使用的说法正确的是 <strong>A. 保证每个对象拥有自己的数据成员，但共享处理这些数据的代码</strong>。this 指针是一个指向当前对象的指针，在成员函数中使用它可以访问当前对象的数据成员和成员函数。</p>
</li>
<li><p>下面对静态数据成员的描述中，正确的是 <strong>C. 静态数据成员可以直接用类名调用</strong>。静态数据成员属于类本身而不是类的对象，因此可以使用类名直接访问。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>下面对友元函数的描述中正确的是【 C 】</li>
</ol>
<p>A. 友元函数的实现必须在类的内部定义</p>
<p>B. 友元函数是类的成员函数</p>
<p>C. 在类中必须用friend声明友元函数</p>
<p>D.友元函数不能访问类的私有成员</p>
<ol>
<li>如果类A被说明成类B的友元，则【 D 】</li>
</ol>
<p>A. 类B也一定是类A的友元</p>
<p>B. 类B的成员即类A的成员</p>
<p>C. 类A的成员即类B的成员</p>
<p>D. 类A的成员函数可以访问类B的成员</p>
<ol>
<li>有关多态性说法不正确的是【 C 】</li>
</ol>
<p>A. C++语言的多态性分为编译时的多态性和运行时的多态性</p>
<p>B. 编译时的多态性可通过函数重载实现</p>
<p>C. 运行时的多态性可通过模板和虚函数实现</p>
<p>D. 实现运行时多态性的机制称为动态多态性</p>
<blockquote>
<ol>
<li><p>下面对友元函数的描述中正确的是 <strong>C. 在类中必须用 friend 声明友元函数</strong>。在类中使用 <code>friend</code> 关键字声明的函数可以访问该类的私有成员。</p>
</li>
<li><p>如果类 A 被声明成类 B 的友元，则 <strong>D. 类 A 的成员函数可以访问类 B 的成员</strong>。这意味着类 A 的成员函数可以访问类 B 的私有成员。</p>
</li>
<li><p>有关多态性说法不正确的是 <strong>C. 运行时的多态性可通过模板和虚函数实现</strong>。实现运行时多态性的主要机制是虚函数，而不是模板。模板主要用于实现编译时的多态性。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>对基类和派生类的关系描述中，错误的是【 B 】</li>
</ol>
<p>A. 派生类是基类的具体化</p>
<p>B. 基类继承了派生类的属性</p>
<p>C. 派生类是基类定义的延续</p>
<p>D. 派生类是基类的特殊化</p>
<ol>
<li>所谓多态性是指 【 B 】</li>
</ol>
<p>A. 不同的对象调用不同名称的函数</p>
<p>B. 不同的对象调用相同名称的函数</p>
<p>C. 一个对象调用相同名称的函数</p>
<p>D. 一个对象调用不同名称的对象</p>
<ol>
<li>下列打开文件的表达式中，错误的是【 A 】</li>
</ol>
<p>A. cout.open(“C:\vc\abc.txt”,ios::binary);</p>
<p>B. ifstream ifile (“C:\vc\abc.txt”);</p>
<p>C. fstream iofile;iofile.open(“abc.txt”,ios::ate);</p>
<p>D. <a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=ofstream&amp;spm=1001.2101.3001.7020">ofstream</a> ofile; ofile.open(“C:\vc\abc.txt”,ios::binary);</p>
<blockquote>
<ol>
<li><p>对基类和派生类的关系描述中，错误的是 <strong>B. 基类继承了派生类的属性</strong>。事实上，基类不会继承派生类的属性，因为派生类是基类的延伸或特殊化，而不是相反。</p>
</li>
<li><p>所谓多态性是指 <strong>B. 不同的对象调用相同名称的函数</strong>。多态性允许不同对象调用相同名称的函数时表现出不同的行为，这是面向对象编程中的一个重要概念。</p>
</li>
<li><p>下列打开文件的表达式中，错误的是 <strong>A. cout.open(“C:\vc\abc.txt”, ios::binary)</strong>。<code>cout</code> 是 C++ 标准输出流，通常不能使用 <code>open()</code> 函数打开文件。通常情况下，应该使用文件流对象如 <code>ifstream</code> 或 <code>ofstream</code> 来打开文件。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>以下有关析构函数的叙述，不正确的是【 A 】</li>
</ol>
<p>A. 析构函数和构造函数一样可以有形参</p>
<p>B. 析构函数名前必须冠有符号“~”</p>
<p>C. 析构函数不允许用返回值</p>
<p>D. 在一个类只能定义一个析构函数</p>
<ol>
<li>对类的构造函数和析构函数描述正确的是【 B 】</li>
</ol>
<p>A. 构造函数不能重载，析构函数可以重载</p>
<p>B. 构造函数可以重载，析构函数不能重载</p>
<p>C. 构造函数可以重载，析构函数也可以重载</p>
<p>D. 构造函数不能重载，析构函数也不能重载</p>
<ol>
<li>下列描述中，成员函数中包括【 B 】的类肯定是抽象类。</li>
</ol>
<p>A. virtual void draw();</p>
<p>B. virtual void draw() = 0;</p>
<p>C. virtual void draw(){}</p>
<p>D. void draw() = 0;</p>
<blockquote>
<ol>
<li><p>以下有关析构函数的叙述，不正确的是 <strong>A. 析构函数和构造函数一样可以有形参</strong>。析构函数没有参数，因此不能带有形参。</p>
</li>
<li><p>对类的构造函数和析构函数描述正确的是 <strong>C. 构造函数可以重载，析构函数也可以重载</strong>。构造函数和析构函数都可以重载。重载构造函数可以提供多个不同参数的构造方式，而重载析构函数则是指在同一个类中可以有多个不同版本的析构函数，但它们的函数名都相同。</p>
</li>
<li><p>下列描述中，成员函数中包括 <strong>B. virtual void draw() = 0;</strong> 的类肯定是抽象类。这是因为含有纯虚函数的类是抽象类，而纯虚函数就是在成员函数后面添加 <code>= 0</code> 来声明的。抽象类不能直接实例化，只能作为基类来派生新的类。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>下列关于C++函数的叙述中，正确的是【 C 】</li>
</ol>
<p>A. 每个函数至少要具有一个参数</p>
<p>B. 每个函数都必须返回一个值</p>
<p>C. 函数在被调用之前必须先声明</p>
<p>D.函数不能自己调用自己</p>
<ol>
<li>下列关于类和对象的叙述中，错误的是【 A 】</li>
</ol>
<p>A. 一个类只能有一个对象</p>
<p>B. 对象是类的具体实例</p>
<p>C. 类是对某一类对象的抽象</p>
<p>D. 类和对象的关系是一种数据类型与变量的关系</p>
<ol>
<li>假定 A 为一个类，则执行 A a1 ；语句时将自动调用该类的【 B 】</li>
</ol>
<p>A. 有参构造函数 B. 无参构造函数</p>
<p>C.拷贝构造函数 D. 赋值构造函数</p>
<blockquote>
<ol>
<li><p>下列关于C++函数的叙述中，正确的是【 C 】：函数在被调用之前必须先声明。在函数使用之前，需要在当前作用域内进行函数声明或者函数定义，以便编译器能够正确识别和解析函数。</p>
</li>
<li><p>下列关于类和对象的叙述中，错误的是【 A 】：一个类只能有一个对象。一个类可以创建多个对象，每个对象都是这个类的一个实例。</p>
</li>
<li><p>假定 A 为一个类，则执行 A a1；语句时将自动调用该类的【 B 】：无参构造函数。当定义一个对象时，如果没有显式提供构造函数参数，将会自动调用该类的无参构造函数来初始化对象。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>通常，拷贝构造函数的形参是【 D 】</li>
</ol>
<p>A. 本类对象名 B. 本类对象的指针名</p>
<p>C. 本类对象的成员名 D. 本类对象的引用名</p>
<ol>
<li>下列不是类的成员函数的是【 B 】</li>
</ol>
<p>A. 构造函数 B. 友元函数</p>
<p>C. 析构函数 D. 拷贝构造函数</p>
<ol>
<li>下面描述中，表达错误的是【 A 】</li>
</ol>
<p>A. 公用继承时基类中的private成员在派生类中仍是private的</p>
<p>B. 公用继承时基类中的public成员在派生类中仍是public的</p>
<p>C. 公用继承时基类中的protected成员在派生类中仍是protected的</p>
<p>D. 私有继承时基类中的public成员在派生类中是private的</p>
<blockquote>
<ol>
<li><p>通常，拷贝构造函数的形参是【 D 】本类对象的引用名。拷贝构造函数的主要任务是根据给定的对象创建一个新的对象，因此通常接受一个本类对象的引用作为参数，以便从现有对象中复制数据到新对象中。</p>
</li>
<li><p>下列不是类的成员函数的是【 B 】友元函数。友元函数是类的友元，而不是类的成员函数。友元函数不属于类的成员函数，但它可以访问类的私有成员。</p>
</li>
<li><p>下面描述中，表达错误的是【 A 】公用继承时基类中的private成员在派生类中仍是private的。在公有继承中，基类中的私有成员不会在派生类中继承，因此在派生类中是无法访问基类的私有成员的。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>带默认参数的函数原型声明若有：void fun(int a,int b=7,char z=’’);下面函数调用中，不合法的是【 C 】</li>
</ol>
<p>A. fun(1); B. fun(1,2);</p>
<p>C. fun( ); D. fun(1,2,‘a’);</p>
<ol>
<li>cout是I0流库预定义的【 B 】</li>
</ol>
<p>A. 类 B. 对象 C. 包含文件 D. 常量</p>
<ol>
<li>C++中解决命名冲突的机制是【 D 】</li>
</ol>
<p>A.虚基类 B.虚函数 C.函数重载 D.名称空间</p>
<ol>
<li>下面关于命名空间的说法，错误的是【 A 】</li>
</ol>
<p>A. 一个命名空间对应多个命名作用域</p>
<p>B. 一个命名空间中的标识符命名作用域相同</p>
<p>C. 一个命名空间中可以集合很多不同的标识符</p>
<p>D. 命名空间的引入让程序员可以在不同的模块中使用相同名字表示不同事物</p>
<blockquote>
<ol>
<li><p>函数原型声明 <code>void fun(int a, int b=7, char z=&#39;&#39;)</code> 中带有默认参数，允许在函数调用时省略默认参数。因此，合法的函数调用是 A、B 和 D。不合法的是【 C 】，因为在省略所有参数的情况下，无法确定默认参数的值。</p>
</li>
<li><p>是的，cout 是 I/O 流库预定义的【 B 】对象。它用于标准输出，是 C++ 标准库中的输出流对象。</p>
</li>
<li><p>C++ 中解决命名冲突的机制是【 D 】名称空间。通过名称空间，可以将标识符分组，以避免冲突。</p>
</li>
<li><p>关于命名空间的说法错误的是【 A 】。一个命名空间对应一个命名作用域，而不是多个。命名空间提供了一个独立的作用域，使得其中的标识符可以在其中进行声明和定义，避免与其他作用域中的标识符冲突。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>关键字【 C 】说明对象或变量初始化后不会被修改。</li>
</ol>
<p>A. static B. public C. const D.inline</p>
<ol>
<li>下面有关重载函数的说法中正确的是【 C 】</li>
</ol>
<p>A. 重载函数必须具有不同的返回值类型</p>
<p>B. 重载函数形参个数必须不同</p>
<p>C. 重载函数必须有不同的形参列表</p>
<p>D. 重载函数名可以不同</p>
<ol>
<li>对基类和派生类的关系描述中，错误的是【 B 】</li>
</ol>
<p>A.派生类是基类的具体化</p>
<p>B.基类继承了派生类的属性</p>
<p>C.派生类是基类定义的延续</p>
<p>D.派生类是基类的特殊化</p>
<blockquote>
<ol>
<li><p>关键字【 C 】说明对象或变量初始化后不会被修改。正确答案是 C. const。const 关键字用于声明常量，表示对象或变量被初始化后，其值不能被修改。</p>
</li>
<li><p>下面有关重载函数的说法中正确的是【 C 】。重载函数必须有不同的形参列表，这是 C++ 中函数重载的基本规则。通过在同一作用域中定义多个函数，它们的形参列表必须不同，可以是参数个数不同、参数类型不同或者参数顺序不同。</p>
</li>
<li><p>对基类和派生类的关系描述中，错误的是【 B 】。基类是派生类的具体化，即派生类是基类的具体实现或扩展。基类定义了派生类的通用属性和行为，而派生类可以添加新的成员或重定义基类成员，从而形成更具体的类。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>下列关于多继承二义性的描述中，错误的是【 B 】</li>
</ol>
<p>A. 一个派生类的两个基类中都有某个同名成员，派生类中这个成员的访问可能出现二义性。</p>
<p>B. 基类和派生类中同时出现的同名函数，也存在二义性问题。</p>
<p>C. 解决二义性的最常用的方法是对成员名的限定法</p>
<p>D. 一个派生类是从两个基类派生出来的，而这两个基类又有一个共同的基类，对该基类成员进行访问时，可能出现二义性。</p>
<ol>
<li>下列有关C++类的说法中，不正确的是【 D 】</li>
</ol>
<p>A. 类是一种用户自定义的数据类型</p>
<p>B. 只有类中的成员函数或类的友元函数才能存取类中的私有成员</p>
<p>C. 在类中，如果不做特别说明，所有成员的访问权限均为私有的</p>
<p>D. 在类中，如果不做特别说明，所有成员的访问权限均为公用的</p>
<ol>
<li>C++ 中对于类中定义的成员,其默认的访问权限为【 C 】</li>
</ol>
<p>A. public B. protected C. private D. static</p>
<blockquote>
<ol>
<li><p>下列关于多继承二义性的描述中，错误的是【 B 】。基类和派生类中同时出现的同名函数，并不会导致二义性问题。因为在派生类中，对于成员函数的调用会根据函数的参数类型和数量进行匹配，而不是根据函数在基类中的位置。</p>
</li>
<li><p>下列有关 C++ 类的说法中，不正确的是【 D 】。在 C++ 中，默认情况下，所有成员的访问权限均为私有的，而不是公用的。所以，D 选项中的描述是错误的。</p>
</li>
<li><p>C++ 中对于类中定义的成员，默认的访问权限为【 C. private】。这意味着如果在类中不做特别说明，所有的成员（包括数据成员和成员函数）都会被默认设置为私有的，只能在类内部访问，无法在类外部直接访问。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>下列关于类的访问权限的描述中,错误的是【 D 】</li>
</ol>
<p>A. 说明为公有的成员可以被程序中的任何代码访问</p>
<p>B. 说明为私有的成员只能被类的成员和说明为友元类的成员函数访问</p>
<p>C. 说明为保护的成员,除了能被本身的成员函数和说明为友元类的成员函数访问外,该类的派生类的成员也可以访问</p>
<p>D. 类的所有成员都可以被程序中的任何代码访问</p>
<p>错误的描述是【D】。类的所有成员都不是可以被程序中的任何代码访问的。默认情况下，类的成员的访问权限是私有的，这意味着除了类的成员函数和友元函数外，其他代码无法直接访问私有成员。公有成员可以被程序中的其他代码访问，但私有成员只能在类的内部使用，而保护成员除了在类的内部和友元函数中使用外，还可以被派生类的成员函数访问。</p>
<hr>
<h2 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h2><ol>
<li>构造函数、析构函数能被继承或取地址（×）</li>
<li>构造函数可以重载，但析构函数只有一个（√）</li>
<li>返回值类型为引用类型的函数可以返回局部变量（×）</li>
<li>静态成员函数没有this指针（√）</li>
<li>静态成员函数可以直接访问非静态成员变量（×）</li>
</ol>
<blockquote>
<ol>
<li><p>构造函数和析构函数不能被继承或取地址。它们是特殊的成员函数，不会被继承到派生类中，因此也不能通过派生类对象或指针进行调用。</p>
</li>
<li><p>构造函数可以重载，允许存在多个构造函数，它们之间通过参数列表的不同来区分。而析构函数在一个类中只能有一个，不能重载。</p>
</li>
<li><p>返回值类型为引用类型的函数不应该返回局部变量的引用，因为局部变量在函数执行完毕后会被销毁，引用指向的内存可能已经无效，导致未定义的行为。</p>
</li>
<li><p>静态成员函数不具有this指针，因为this指针指向当前对象，而静态成员函数是属于类的，而不是属于具体的对象的。因此，静态成员函数内部无法使用this指针。</p>
</li>
<li><p>静态成员函数可以直接访问静态成员变量，但不能直接访问非静态成员变量。因为静态成员变量属于类，生命周期独立于任何对象，而非静态成员变量属于对象，需要通过对象才能访问。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>const类型的变量声明时可以不用初始化（×）</li>
<li>const类型的对象只能访问const类型的成员函数，构造函数、析构函数除外（√）</li>
<li>const类型的对象如果作为实参，只能传递给const类型的形参（√）</li>
<li>volatile类型的对象只能访问volatile类型的成员函数，构造函数、析构函数除外（√）</li>
<li>复合类调用构造函数时，成员对象的构造函数调用顺序取决于复合类的构造函数初始化列表（×）</li>
</ol>
<blockquote>
<ol>
<li><p>错误。const类型的变量声明时必须进行初始化，否则会导致编译错误。</p>
</li>
<li><p>正确。const类型的对象只能调用const类型的成员函数，因为const对象保证了在成员函数内部不会修改对象的状态，而构造函数和析构函数则是特殊的成员函数，可以在const对象中调用。</p>
</li>
<li><p>正确。const类型的对象只能传递给const类型的形参，这是因为const对象保证了在函数内部不会被修改，传递给非const形参可能导致const对象被修改，与const的语义相违背。</p>
</li>
<li><p>正确。volatile类型的对象只能调用volatile类型的成员函数，因为volatile修饰的对象表示其值可能在未经同步的情况下被外部因素改变，非volatile成员函数可能会导致编译器对对象的优化，与volatile的语义相违背。</p>
</li>
<li><p>错误。复合类调用构造函数时，成员对象的构造函数调用顺序不仅仅取决于复合类的构造函数初始化列表，还受到成员对象在类中声明的顺序影响。成员对象的构造函数调用顺序与它们在类中声明的顺序一致，而不是与初始化列表中的顺序一致。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>作为友元的类或类的函数，必须先声明后使用（√）</li>
<li>友元关系可以继承（×）</li>
</ol>
<blockquote>
<ol>
<li><p>正确。作为友元的类或类的函数，在使用之前必须先进行声明，以便编译器知道这些类或函数是友元，可以访问被声明为友元的类的私有成员。</p>
</li>
<li><p>错误。友元关系不能继承。即使派生类继承了基类，基类的友元关系并不会自动转移到派生类中。友元关系仅仅存在于类的声明范围内，不具有继承性。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>重载函数允许只有返回值类型不同（×）</li>
</ol>
<hr>
<ol>
<li>可以重载C++中不存在的运算符（×）</li>
<li>运算符重载可以改变优先级（×）</li>
<li>运算符重载不改变操作数个数（√）</li>
<li>不能重载的运算符有 ？: :: . # ## .<em> -&gt;</em> *</li>
<li>返回值为临时对象的重载运算符有 后缀++ 后缀— + - * / %</li>
<li>返回值为引用类型的重载运算符有 前缀++ 前缀— = [] () &lt;&lt; &gt;&gt;</li>
<li>必须以友元方式重载的运算符有 &lt;&lt; &gt;&gt;</li>
<li>必须以成员函数方式重载的运算符有 = [] () -&gt;</li>
<li>派生类对象可用在基类对象使用的任何场合，如派生类对象可以赋值给基类对象、基类指针或基类引用，但此时这一基类的对象、指针或引用只能访问基类成员</li>
<li>复合类或派生类的定义前需要包含成员对象所在类或基类的定义</li>
<li>派生类构造函数的执行顺序：基类的构造函数（都为或都不为虚基类时按继承时声明的顺序）-&gt; 内嵌成员对象的构造函数（按成员对象在类中声明的顺序）-&gt; 自身类的构造函数</li>
<li>派生类对象在调用其基类的构造函数时，若其有多个在同一层次上的基类，则虚基类的构造先于非虚基类的构造</li>
<li>派生类和基类的虚函数原型可以不一致（×）</li>
</ol>
<blockquote>
<ol>
<li><p>正确。运算符重载允许程序员为 C++ 中已有的运算符赋予新的含义，即使这些运算符在原生语言中并不存在。</p>
</li>
<li><p>错误。运算符重载不能改变运算符的优先级和结合性，它们仍然遵循原生语言中的优先级和结合性规则。</p>
</li>
<li><p>正确。运算符重载不改变操作数的个数，即一个运算符仍然只能对应特定数量的操作数。</p>
</li>
<li><p>正确。C++ 中有一些运算符是不能被重载的，包括条件运算符（?:）、作用域解析运算符（::）、成员选择运算符（.）、成员指针运算符（.*）、宏替换运算符（#、##）等。</p>
</li>
<li><p>正确。返回临时对象的重载运算符包括后缀递增（后缀++）、后缀递减（后缀—）、一元加法（+）、一元减法（-）、一元乘法（*）、一元除法（/）、取模（%）等。</p>
</li>
<li><p>正确。返回引用类型的重载运算符包括前缀递增（前缀++）、前缀递减（前缀—）、赋值（=）、下标访问（[]）、函数调用（()）、位左移（&lt;&lt;）、位右移（&gt;&gt;）等。</p>
</li>
<li><p>错误。并不是所有需要重载的运算符都必须以友元方式重载，某些运算符可以以成员函数方式重载，具体取决于运算符的使用场景和需求。</p>
</li>
<li><p>错误。同样，并不是所有需要重载的运算符都必须以成员函数方式重载，某些运算符可以以友元方式重载，具体取决于运算符的使用场景和需求。</p>
</li>
<li><p>正确。派生类对象可以用在基类对象的任何场合，但此时只能访问基类的成员，不能访问派生类特有的成员。</p>
</li>
<li><p>正确。在定义复合类或派生类之前，需要包含成员对象所在类或基类的定义，以确保在构造函数中可以正确初始化这些成员对象。</p>
</li>
<li><p>正确。派生类构造函数的执行顺序是：基类的构造函数（按继承顺序）-&gt; 成员对象的构造函数（按声明顺序）-&gt; 自身类的构造函数。</p>
</li>
<li><p>正确。当派生类拥有多个在同一层次上的基类时，虚基类的构造先于非虚基类的构造。这是因为虚基类只会在派生类的对象中存在一份拷贝，而非虚基类会在派生类的对象中存在多份拷贝，因此虚基类的构造必须先于非虚基类的构造。</p>
</li>
<li><p>错误。派生类和基类的虚函数原型必须一致，否则派生类的函数将无法覆盖基类的虚函数。在C++中，如果派生类中的虚函数与基类中的虚函数原型不一致，编译器会将其视为一个新的虚函数而不是对基类的虚函数进行重载或覆盖。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>虚函数可以为static类型（×）</li>
</ol>
<p>静态函数、内联函数、构造函数不可以是虚函数</p>
<hr>
<ol>
<li>在普通函数调用虚函数时，实际调用的是this指针指向的对象所在类的虚函数（√）</li>
<li>在基类的构造函数或析构函数中调用虚函数，调用的是基类的虚函数（√）</li>
<li>虚特性不可以继承（×）</li>
<li>实现多态的两种方式：重载、虚函数</li>
<li>纯虚函数是空函数（×）</li>
<li>函数调用的匹配原则：</li>
</ol>
<p>① 寻找完全匹配的函数</p>
<p>② 函数模板实例化后匹配</p>
<p>③ 重载函数参数隐式类型转化后匹配</p>
<p>④ 在上述某一步找到两个及以上匹配的函数或三步都找不到匹配的函数时，则程序出错</p>
<blockquote>
<ol>
<li><p>正确。在普通函数调用虚函数时，实际调用的是通过this指针指向的对象所在类的虚函数，而不是调用对象的类型。</p>
</li>
<li><p>正确。在基类的构造函数或析构函数中调用虚函数时，由于在对象的构造或析构阶段，派生类对象还没有构造或已经析构，因此调用的是基类的虚函数版本，而不是派生类的。</p>
</li>
<li><p>错误。虚特性可以继承。当基类中的成员函数被声明为虚函数时，派生类将继承这一虚函数，并可以选择是否重写该虚函数。</p>
</li>
<li><p>正确。实现多态的两种方式包括函数重载和虚函数。函数重载允许同一个函数名拥有多个定义，根据实参的不同进行选择；而虚函数可以在基类和派生类之间形成多态，使得在运行时根据对象的实际类型调用对应的函数。</p>
</li>
<li><p>错误。纯虚函数是在基类中声明但没有定义实现的虚函数，派生类必须重写该函数以使得派生类变得可实例化。纯虚函数在语法上可以是纯虚函数，但其实际功能上不是空函数，它是一个抽象接口，用于规范派生类的行为。</p>
</li>
</ol>
</blockquote>
<hr>
<ol>
<li>析构函数不可以主动调用</li>
</ol>
<p>//主动调用析构函数后，程序最终还会再次调用析构函数</p>
<ol>
<li>友元函数的定义必须在类外（×）</li>
</ol>
<p>//友元函数的定义可以在类内或类外</p>
<ol>
<li>静态成员函数的定义在类外时，需要加上static关键字（×）</li>
<li>在类中定义的函数是内联函数（√）</li>
</ol>
<p>//类中的内联函数实现有两种方式，一种是在类中进行定义；另一种是在类外进行定义，函数定义前加上incline关键字。注意第二种方式的函数定义需要放在头文件</p>
<ol>
<li>定义引用类型的变量时必须初始化（√）</li>
<li>在调用派生类的拷贝构造函数时，其基类的构造函数不会被调用（×）</li>
</ol>
<p>40.在异常处理机制中，throw的变量一定会被catch（×）</p>
<blockquote>
<ol>
<li><p>错误。析构函数是在对象被销毁时自动调用的，程序员不能显式地调用析构函数。主动调用析构函数是不允许的，因为析构函数的调用是由系统自动管理的。</p>
</li>
<li><p>错误。友元函数的定义可以在类内或类外，取决于是否需要访问类的私有成员。如果友元函数需要访问类的私有成员，则必须在类的声明内部进行声明和定义；如果不需要访问私有成员，则可以在类外部进行声明和定义。</p>
</li>
<li><p>错误。静态成员函数的定义在类外时，不需要再加上static关键字。静态成员函数的定义只需要在类内部声明时加上static关键字，在类外部的定义时不需要加上。</p>
</li>
<li><p>正确。在类中定义的函数默认情况下是内联函数。编译器在编译时会尝试将其内联展开，以减少函数调用的开销。但如果函数定义过于复杂或者包含递归调用等情况，编译器可能不会内联函数。</p>
</li>
<li><p>正确。定义引用类型的变量时必须进行初始化，因为引用类型的变量必须引用一个已存在的对象。</p>
</li>
<li><p>错误。在调用派生类的拷贝构造函数时，其基类的构造函数会被调用。派生类的拷贝构造函数会自动调用基类的拷贝构造函数，以确保基类部分也能被正确地复制构造。</p>
</li>
<li><p>错误。在异常处理机制中，throw的变量不一定会被catch。如果在try块中抛出了异常，但没有在相应的catch块中进行捕获，或者在try块外抛出了异常，则这个异常可能会导致程序的异常终止。</p>
</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.totorocatcat.top/">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/2024/05/31/C-%E9%80%89%E6%8B%A9%E9%A2%98/">http://totorocatcat.top/2024/05/31/C-%E9%80%89%E6%8B%A9%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%89%E8%B6%A3/">有趣</a></div><div class="post_share"><div class="social-share" data-image="https://img.likepoems.com/resource/pc/a6d651fa256154756b47262c450a056f4.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/05/31/%E3%80%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1c-%E3%80%8B%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7%EF%BC%88A%EF%BC%89/" title="《面向对象程序设计c++》期末考试试卷（A）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.likepoems.com/resource/pc/6bae5e3efe20b263e8ca6287820741ff2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《面向对象程序设计c++》期末考试试卷（A）</div></div></a></div><div class="next-post pull-right"><a href="/2024/05/31/%E3%80%8A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1C-%E3%80%8B%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E8%AF%95%E5%8D%B7/" title="《面向对象程序设计C++》期末考试试卷"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.98qy.com/sjbz/img/28.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《面向对象程序设计C++》期末考试试卷</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/01/C-%E5%85%AB%E8%82%A1/" title="C++八股"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.likepoems.com/resource/pc/b702fcf4480034312d58d6f56e30d7624.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-01</div><div class="title">C++八股</div></div></a></div><div><a href="/2024/05/31/C-%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95-1/" title="C++期末考试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/%E5%9B%BE%E5%8C%85webp/%E5%8A%A8%E6%BC%AB%E7%BB%BC%E5%90%881/86815-106.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-31</div><div class="title">C++期末考试</div></div></a></div><div><a href="/2024/05/31/C-%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/" title="C++期末考试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.likepoems.com/resource/pc/68e21cc80a435c28fdf4c47e4652ebc17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-31</div><div class="title">C++期末考试</div></div></a></div><div><a href="/2024/06/03/C-%E7%BB%83%E4%B9%A0%E9%A2%983/" title="C++练习题3"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/%E5%9B%BE%E5%8C%85webp/%E5%8A%A8%E6%BC%AB%E7%BB%BC%E5%90%881/73207-106.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-03</div><div class="title">C++练习题3</div></div></a></div><div><a href="/2024/06/03/C-%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%882%EF%BC%89/" title="C++练习题2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.51/img_513_1920x1080_72_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-03</div><div class="title">C++练习题2</div></div></a></div><div><a href="/2024/06/02/C-%E9%80%89%E6%8B%A9%E9%A2%98%E5%8A%A0%E8%AE%AD/" title="C++选择题加训"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.37/img_371_3840x2160_72_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-02</div><div class="title">C++选择题加训</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description">敲代码的SCUT学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">647</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">31</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">选择题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">1.1.</span> <span class="toc-text">解释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E4%B8%80%E4%B8%AA%E7%B1%BB%E6%98%AF%E4%B8%80%E4%B8%AA%E7%8B%AC%E7%AB%8B%E7%9A%84%E5%9F%9F"><span class="toc-number">1.2.</span> <span class="toc-text">A. 一个类是一个独立的域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%9F%9F%E8%A2%AB%E8%87%AA%E5%8A%A8%E5%B5%8C%E5%A5%97%E5%9C%A8%E5%9F%BA%E7%B1%BB%E7%B1%BB%E5%9F%9F%E4%B8%AD"><span class="toc-number">1.3.</span> <span class="toc-text">B. 派生类域被自动嵌套在基类类域中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%9F%9F%E6%93%8D%E4%BD%9C%E7%AC%A6-%E5%8F%AF%E4%BB%A5%E8%A2%AB%E9%87%8D%E8%BD%BD"><span class="toc-number">1.4.</span> <span class="toc-text">C. 域操作符::可以被重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E4%B8%8D%E5%90%8C%E5%9F%9F%E4%B8%AD%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%90%8C%E5%90%8D%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">D. 不同域中可以定义同名变量和函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-int-a-int-amp-p-a"><span class="toc-number">1.6.</span> <span class="toc-text">A. int a; int &amp;p &#x3D; a;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-char-a-char-p-amp-a"><span class="toc-number">1.7.</span> <span class="toc-text">B. char a; char *p &#x3D; &amp;a;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-int-a-int-amp-p-p-a"><span class="toc-number">1.8.</span> <span class="toc-text">C. int a; int &amp;p; p &#x3D; a;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-float-a-float-p-a"><span class="toc-number">1.9.</span> <span class="toc-text">D. float a; float p &#x3D; a;</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A-1"><span class="toc-number">1.9.1.</span> <span class="toc-text">解释：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%B5%8B%E5%80%BC%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.10.</span> <span class="toc-text">A. 基类的对象可以赋值派生类的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%8C%87%E9%92%88%E5%8F%AF%E4%BB%A5%E6%8C%87%E5%90%91%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.11.</span> <span class="toc-text">B. 派生类指针可以指向基类对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.12.</span> <span class="toc-text">C. 派生类的对象可以初始化基类的对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%AF%E4%BB%A5%E8%B5%8B%E5%80%BC%E7%BB%99%E6%8C%87%E5%90%91%E5%9F%BA%E7%B1%BB%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">1.13.</span> <span class="toc-text">D. 派生类的对象的地址可以赋值给指向基类的指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A-2"><span class="toc-number">1.13.1.</span> <span class="toc-text">解释：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E5%90%8D%E4%B8%8E%E7%B1%BB%E5%90%8D%E7%9B%B8%E5%90%8C"><span class="toc-number">1.14.</span> <span class="toc-text">A. 构造函数的函数名与类名相同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E9%87%8D%E8%BD%BD"><span class="toc-number">1.15.</span> <span class="toc-text">B. 构造函数可以重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">1.16.</span> <span class="toc-text">C. 构造函数可以设置默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%8C%87%E5%AE%9A%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.17.</span> <span class="toc-text">D. 构造函数必须指定返回类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E8%99%9A%E5%87%BD%E6%95%B0%E6%98%AF%E4%B8%80%E4%B8%AA-static-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">1.18.</span> <span class="toc-text">A. 虚函数是一个 static 类型的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E8%99%9A%E5%87%BD%E6%95%B0%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.19.</span> <span class="toc-text">B. 虚函数是一个友元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%9F%BA%E7%B1%BB%E4%B8%AD%E8%AF%B4%E6%98%8E%E4%BA%86%E8%99%9A%E5%87%BD%E6%95%B0%E5%90%8E%EF%BC%8C%E6%B4%BE%E7%94%9F%E7%B1%BB%E4%B8%AD%E4%B8%8E%E5%85%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E5%86%8D%E6%AC%A1%E8%AF%B4%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.20.</span> <span class="toc-text">C. 基类中说明了虚函数后，派生类中与其对应的函数必须再次说明为虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E6%B4%BE%E7%94%9F%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E5%9F%BA%E7%B1%BB%E7%9A%84%E8%99%9A%E5%87%BD%E6%95%B0%E5%85%B7%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%AA%E6%95%B0%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.21.</span> <span class="toc-text">D. 派生类的虚函数与基类的虚函数具有相同的参数个数和类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%AC%E7%94%A8%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E7%B1%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%9D%A5%E8%AE%BF%E9%97%AE"><span class="toc-number">1.22.</span> <span class="toc-text">A. 类中定义的公用静态数据成员，可以通过类的对象来访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E6%89%80%E6%9C%89%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%EF%BC%8C%E9%83%BD%E5%BF%85%E9%A1%BB%E5%9C%A8%E7%B1%BB%E5%A4%96%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.23.</span> <span class="toc-text">B. 类中定义的所有静态数据成员，都必须在类外初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E4%B8%8D%E6%98%AF%E6%89%80%E6%9C%89%E5%AF%B9%E8%B1%A1%E6%89%80%E5%85%B1%E7%94%A8%E7%9A%84"><span class="toc-number">1.24.</span> <span class="toc-text">C. 静态数据成员不是所有对象所共用的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E6%99%AE%E9%80%9A%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%B1%BB%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">1.25.</span> <span class="toc-text">D. 普通的成员函数可以直接访问类中的静态数据成员</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#A-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E6%93%8D%E4%BD%9C%E6%95%B0%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="toc-number">1.26.</span> <span class="toc-text">A. 运算符重载可以改变操作数的个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.27.</span> <span class="toc-text">B. 运算符重载可以改变优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E7%BB%93%E5%90%88%E6%80%A7"><span class="toc-number">1.28.</span> <span class="toc-text">C. 运算符重载可以改变结合性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#D-%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E4%B8%8D%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E8%AF%AD%E6%B3%95%E7%BB%93%E6%9E%84"><span class="toc-number">1.29.</span> <span class="toc-text">D. 运算符重载不可以改变语法结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A-3"><span class="toc-number">1.29.1.</span> <span class="toc-text">解释：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">判断题</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%89%E6%8B%A9%E9%A2%98/" title="数据结构之二叉树的遍历和线索二叉树选择题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/7580ab121e73175551c16369691479a955200ed5.jpg@1256w_890h_!web-article-pic.avif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构之二叉树的遍历和线索二叉树选择题"/></a><div class="content"><a class="title" href="/2024/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%89%E6%8B%A9%E9%A2%98/" title="数据结构之二叉树的遍历和线索二叉树选择题">数据结构之二叉树的遍历和线索二叉树选择题</a><time datetime="2024-10-08T02:14:56.000Z" title="发表于 2024-10-08 10:14:56">2024-10-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/07/%E5%93%81%E4%BA%BA%E7%94%9F/" title="品人生"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230624173703.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="品人生"/></a><div class="content"><a class="title" href="/2024/10/07/%E5%93%81%E4%BA%BA%E7%94%9F/" title="品人生">品人生</a><time datetime="2024-10-07T15:53:37.000Z" title="发表于 2024-10-07 23:53:37">2024-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构之二叉树"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/ed91067e550b1488f557d470c745dc39395143382.jpg@1256w_708h_!web-article-pic.avif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构之二叉树"/></a><div class="content"><a class="title" href="/2024/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/" title="数据结构之二叉树">数据结构之二叉树</a><time datetime="2024-10-07T15:46:03.000Z" title="发表于 2024-10-07 23:46:03">2024-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/07/%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/" title="数组结构之树的概念与性质"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/067847fa515348a8ac9357b2ce139a9c59dcb48a.jpg@1256w_1766h_!web-article-pic.avif" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数组结构之树的概念与性质"/></a><div class="content"><a class="title" href="/2024/10/07/%E6%95%B0%E7%BB%84%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%80%A7%E8%B4%A8/" title="数组结构之树的概念与性质">数组结构之树的概念与性质</a><time datetime="2024-10-07T14:29:14.000Z" title="发表于 2024-10-07 22:29:14">2024-10-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%B2/" title="数据结构之串"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.64/img_649_702x1000_300_null_normal.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构之串"/></a><div class="content"><a class="title" href="/2024/10/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%B8%B2/" title="数据结构之串">数据结构之串</a><time datetime="2024-10-07T11:41:21.000Z" title="发表于 2024-10-07 19:41:21">2024-10-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HT1PalaKkPaG1UqAXBhJXIu8-gzGzoHsz',
      appKey: 'iT0TnVVAwf9zuZ7NqwclQItY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="1" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="只此无为身，且前行,忘记过去的人注定重蹈覆辙,我是我，我靠自己站立，我会做好自身,如果我睡大觉，谁给我摘月亮呢,假期和朋友，是人生中顶好的两样东西啊。,去爱，去失去，要不负相遇,没什么想不想通的，只是固执而已,我们深爱星辰，乃至不惧夜的黑,吃，喝，享受幸福，接受奇迹,浊水若长流，自清澄,雅俗共赏,总会有什么也不想的幸福时刻吧,时间顺流而下，生活逆流而上,悟已往之不谏，知来者之可追,希望你的小世界里,山花烂漫,茶酒俱全,安宁清淡,明朗欢愉" data-fontsize="20px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/期末の旅/&quot;);" href="javascript:void(0);">期末の旅</a><span class="categoryBar-list-count">39</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACMの旅/&quot;);" href="javascript:void(0);">ACMの旅</a><span class="categoryBar-list-count">66</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/区域赛の旅/&quot;);" href="javascript:void(0);">区域赛の旅</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Codeforcesの旅/&quot;);" href="javascript:void(0);">Codeforcesの旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数学建模/&quot;);" href="javascript:void(0);">数学建模</a><span class="categoryBar-list-count">31</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/牛客の旅/&quot;);" href="javascript:void(0);">牛客の旅</a><span class="categoryBar-list-count">65</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题计划/&quot;);" href="javascript:void(0);">刷题计划</a><span class="categoryBar-list-count">42</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/前端の旅/&quot;);" href="javascript:void(0);">前端の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Atcoderの旅/&quot;);" href="javascript:void(0);">Atcoderの旅</a><span class="categoryBar-list-count">53</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-の旅/&quot;);" href="javascript:void(0);">C++の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CSAPPの旅/&quot;);" href="javascript:void(0);">CSAPPの旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_24.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS知识/&quot;);" href="javascript:void(0);">CS知识</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_25.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程基础/&quot;);" href="javascript:void(0);">编程基础</a><span class="categoryBar-list-count">21</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_26.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JAVAの旅/&quot;);" href="javascript:void(0);">JAVAの旅</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_27.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/个人安排/&quot;);" href="javascript:void(0);">个人安排</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_28.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂项/&quot;);" href="javascript:void(0);">杂项</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_29.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文学/&quot;);" href="javascript:void(0);">文学</a><span class="categoryBar-list-count">49</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_30.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/力扣の旅/&quot;);" href="javascript:void(0);">力扣の旅</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_31.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/🗡指offer/&quot;);" href="javascript:void(0);">🗡指offer</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_32.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/少年游/&quot;);" href="javascript:void(0);">少年游</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_33.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法提高课/&quot;);" href="javascript:void(0);">算法提高课</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_34.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构/&quot;);" href="javascript:void(0);">数据结构</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_35.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/汇编の旅/&quot;);" href="javascript:void(0);">汇编の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_36.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/灵魂の旅/&quot;);" href="javascript:void(0);">灵魂の旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_37.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/离散数学/&quot;);" href="javascript:void(0);">离散数学</a><span class="categoryBar-list-count">11</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_38.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-实训/&quot;);" href="javascript:void(0);">C++实训</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_39.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS61B/&quot;);" href="javascript:void(0);">CS61B</a><span class="categoryBar-list-count">76</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_41.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MIT-6-031-Software-Construction/&quot;);" href="javascript:void(0);">MIT 6.031:Software Construction</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_42.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS70の旅/&quot;);" href="javascript:void(0);">CS70の旅</a><span class="categoryBar-list-count">25</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_43.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/千里十二行/&quot;);" href="javascript:void(0);">千里十二行</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/51d37eba99d243607ddedfff6e91568f617436609.jpg@1256w_1884h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">TotoroのPlan</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>