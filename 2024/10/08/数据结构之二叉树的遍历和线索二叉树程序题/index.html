<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构之二叉树的遍历和线索二叉树程序题 | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="方便大二看（）">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构之二叉树的遍历和线索二叉树程序题">
<meta property="og:url" content="http://totorocatcat.top/2024/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A8%8B%E5%BA%8F%E9%A2%98/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="方便大二看（）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/598fbde0bcb1378156ac7a1118bc74d1dbbc7803.jpg@1256w_1376h_!web-article-pic.avif">
<meta property="article:published_time" content="2024-10-08T03:42:45.000Z">
<meta property="article:modified_time" content="2024-10-08T03:44:00.210Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="提高">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/598fbde0bcb1378156ac7a1118bc74d1dbbc7803.jpg@1256w_1376h_!web-article-pic.avif"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/b5ca6e582a7a45e6fde46e616eeb68e.png"><link rel="canonical" href="http://totorocatcat.top/2024/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A8%8B%E5%BA%8F%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":765,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构之二叉树的遍历和线索二叉树程序题',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-10-08 11:44:00'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">746</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/598fbde0bcb1378156ac7a1118bc74d1dbbc7803.jpg@1256w_1376h_!web-article-pic.avif')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构之二叉树的遍历和线索二叉树程序题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-08T03:42:45.000Z" title="发表于 2024-10-08 11:42:45">2024-10-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-10-08T03:44:00.210Z" title="更新于 2024-10-08 11:44:00">2024-10-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>50分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构之二叉树的遍历和线索二叉树程序题"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构之二叉树的遍历和线索二叉树程序题"><a href="#数据结构之二叉树的遍历和线索二叉树程序题" class="headerlink" title="数据结构之二叉树的遍历和线索二叉树程序题"></a>数据结构之二叉树的遍历和线索二叉树程序题</h1><h2 id="01-若某非空二叉树的先序序列和后序序列正好相反，则该二叉树的形态是什么？"><a href="#01-若某非空二叉树的先序序列和后序序列正好相反，则该二叉树的形态是什么？" class="headerlink" title="01. 若某非空二叉树的先序序列和后序序列正好相反，则该二叉树的形态是什么？"></a><strong>01. 若某非空二叉树的先序序列和后序序列正好相反，则该二叉树的形态是什么？</strong></h2><p><strong>01. 【解答】</strong></p>
<p>二叉树的先序遍历顺序是 NLR（根-左-右），而后序遍历顺序是 LRN（左-右-根）。要使先序序列与后序序列的反序相同，即满足 $NLR = NRL$（后序序列的反序），必须满足左子树或右子树为空。</p>
<p>也就是说，所有的非叶结点只能有一个孩子（要么只有左孩子，要么只有右孩子），这就意味着该二叉树每一层只有一个结点。因此，这棵树的形态是一条“长链”，其高度等于结点的个数。</p>
<p><strong>示例：</strong></p>
<p>以 3 个结点 $a, b, c$ 为例，假设结点的排列形态如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a</span><br><span class="line"> \</span><br><span class="line">  b</span><br><span class="line">   \</span><br><span class="line">    c</span><br></pre></td></tr></table></figure>
<p>这是一棵形态为“右斜”链状的二叉树，其每个结点只有一个右孩子（或可以是左孩子），每层只有一个结点。</p>
<h2 id="02-若某非空二叉树的先序序列和后序序列正好相同，则该二叉树的形态是什么？"><a href="#02-若某非空二叉树的先序序列和后序序列正好相同，则该二叉树的形态是什么？" class="headerlink" title="02. 若某非空二叉树的先序序列和后序序列正好相同，则该二叉树的形态是什么？"></a><strong>02. 若某非空二叉树的先序序列和后序序列正好相同，则该二叉树的形态是什么？</strong></h2><p><strong>02.【解答】</strong></p>
<p>二叉树的先序遍历顺序是 NLR（根-左-右），而后序遍历顺序是 LRN（左-右-根）。要使先序序列与后序序列完全相同，即 $NLR = LRN$，这意味着左子树 $L$ 和右子树 $R$ 都必须为空。</p>
<p>因此，满足这一条件的二叉树只有一个根结点，也就是说，这棵二叉树是一个 <strong>只有根结点的树</strong>，没有左子树或右子树。</p>
<hr>
<h2 id="03：编写后序遍历二叉树的非递归算法。"><a href="#03：编写后序遍历二叉树的非递归算法。" class="headerlink" title="03：编写后序遍历二叉树的非递归算法。"></a><strong>03</strong>：编写后序遍历二叉树的非递归算法。</h2><p><strong>03.【解答】</strong></p>
<p><strong>算法思想</strong>：<br>后序遍历的顺序是：<strong>先左子树 -&gt; 再右子树 -&gt; 最后根结点</strong>。对于非递归遍历，需要借助栈来记录结点，并且还要额外设置一个辅助指针来追踪最近访问过的结点，以确定是从左子树返回还是从右子树返回。</p>
<p><strong>步骤分析</strong>：</p>
<ol>
<li>从根节点开始，沿着左子树依次将结点压入栈，直到左子树为空。</li>
<li>如果栈顶结点的右子树存在且未被访问过，则转向右子树继续执行步骤1；否则，弹出栈顶结点并访问它，记录为已访问。</li>
<li>重复上述过程，直到栈为空，整个树都被遍历完。</li>
</ol>
<p><strong>关键点</strong>：</p>
<ul>
<li>辅助指针 <code>r</code>：用于标记上一次访问的结点，用来判断是从左子树返回还是从右子树返回。</li>
<li>栈：用来存储当前访问路径上的结点。</li>
<li>需要注意的是，出栈访问完一个结点后，应将 <code>p</code> 置为 <code>NULL</code>，以避免重复处理。</li>
</ul>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    BiTree *data;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Stack *s)</span> &#123;</span><br><span class="line">    s-&gt;data = (BiTree *)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(BiTree));  <span class="comment">// 假设栈的大小为100</span></span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(Stack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(Stack *s, BiTree node)</span> &#123;</span><br><span class="line">    s-&gt;data[++s-&gt;top] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(Stack *s, BiTree *node)</span> &#123;</span><br><span class="line">    *node = s-&gt;data[s-&gt;top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GetTop</span><span class="params">(Stack *s, BiTree *node)</span> &#123;</span><br><span class="line">    *node = s-&gt;data[s-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">char</span> data)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, data);  <span class="comment">// 输出访问的结点数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    InitStack(&amp;s);</span><br><span class="line">    BiTree p = T;</span><br><span class="line">    BiTree r = <span class="literal">NULL</span>;  <span class="comment">// 记录最近访问的结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">NULL</span> || !IsEmpty(&amp;s)) &#123;</span><br><span class="line">        <span class="comment">// 走到最左边的结点</span></span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Push(&amp;s, p);</span><br><span class="line">            p = p-&gt;lchild;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 读取栈顶结点（但不出栈）</span></span><br><span class="line">            GetTop(&amp;s, &amp;p);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span> &amp;&amp; p-&gt;rchild != r) &#123;</span><br><span class="line">                <span class="comment">// 如果右子树存在且未被访问过，则转向右子树</span></span><br><span class="line">                p = p-&gt;rchild;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则，弹出栈顶结点并访问</span></span><br><span class="line">                Pop(&amp;s, &amp;p);</span><br><span class="line">                visit(p-&gt;data);</span><br><span class="line">                r = p;  <span class="comment">// 记录最近访问的结点</span></span><br><span class="line">                p = <span class="literal">NULL</span>;  <span class="comment">// 结点访问完后重置 p</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法解释</strong>：</p>
<ul>
<li>初始化栈和指针，<code>p</code> 指向树的根结点，<code>r</code> 用来记录最近访问的结点。</li>
<li>首先沿着左子树一路向下，将所有结点压入栈，直到遇到空结点。</li>
<li>当左子树走到底后，检查栈顶元素。如果其右子树存在且未访问过，则转向右子树；否则，访问该结点并从栈中弹出。</li>
<li>通过辅助指针 <code>r</code>，避免重复访问结点。</li>
<li>最后，输出后序遍历的顺序。</li>
</ul>
<p><strong>注意</strong>：</p>
<ul>
<li>每当一个结点访问完后，相当于其子树遍历完，必须将 <code>p</code> 置为 <code>NULL</code>，以防止重复处理。</li>
<li>使用 <code>visit</code> 函数来输出结点的值，模拟结点的访问过程。</li>
</ul>
<p><strong>后序遍历示例输出</strong>：<br>假设给定的二叉树结构如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \</span><br><span class="line">D   E</span><br></pre></td></tr></table></figure><br>其后序遍历顺序为：<code>D E B C A</code></p>
<h2 id="04：试给出二叉树的自下而上、从右到左的层次遍历算法。"><a href="#04：试给出二叉树的自下而上、从右到左的层次遍历算法。" class="headerlink" title="04：试给出二叉树的自下而上、从右到左的层次遍历算法。"></a><strong>04</strong>：试给出二叉树的自下而上、从右到左的层次遍历算法。</h2><p><strong>04.【解答】</strong></p>
<p><strong>算法思想</strong>：<br>一般的二叉树层次遍历是自上而下、从左到右的，然而在这个问题中，我们需要实现自下而上、从右到左的遍历顺序。为了实现这一目标，可以利用原有的层次遍历算法，通过将每个结点的指针入栈，最后再从栈中依次访问这些结点，即可得到所需的遍历顺序。</p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li><strong>将根结点入队列</strong>：首先，检查二叉树是否为空。如果不为空，将根结点入队列。</li>
<li><strong>出队列并遍历元素</strong>：从队列中出队一个元素，并访问（遍历）该元素。</li>
<li><strong>将孩子结点入队列</strong>：<ul>
<li>依次将出队元素的左孩子和右孩子入队列。注意，左孩子先入队，右孩子后入队，这样在后续的处理时才能实现从右到左的访问顺序。</li>
</ul>
</li>
<li><strong>重复以上过程</strong>：如果队列不为空，继续从队列中出队并处理结点，直到队列为空。</li>
</ol>
<p><strong>最后一步</strong>：将所有入栈的结点从栈顶开始依次访问，最终得到自下而上、从右到左的遍历顺序。</p>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">    BiTree *data;</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> &#123;</span></span><br><span class="line">    BiTree *data;</span><br><span class="line">    <span class="type">int</span> front, rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitStack</span><span class="params">(Stack *s)</span> &#123;</span><br><span class="line">    s-&gt;data = (BiTree *)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(BiTree));  <span class="comment">// 假设栈的大小为100</span></span><br><span class="line">    s-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmptyStack</span><span class="params">(Stack *s)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Push</span><span class="params">(Stack *s, BiTree node)</span> &#123;</span><br><span class="line">    s-&gt;data[++s-&gt;top] = node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Pop</span><span class="params">(Stack *s, BiTree *node)</span> &#123;</span><br><span class="line">    *node = s-&gt;data[s-&gt;top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">visit</span><span class="params">(<span class="type">char</span> data)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c &quot;</span>, data);  <span class="comment">// 输出访问的结点数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(Queue *q)</span> &#123;</span><br><span class="line">    q-&gt;data = (BiTree *)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(BiTree));  <span class="comment">// 假设队列的大小为100</span></span><br><span class="line">    q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmptyQueue</span><span class="params">(Queue *q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == q-&gt;rear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(Queue *q, BiTree node)</span> &#123;</span><br><span class="line">    q-&gt;data[q-&gt;rear++] = node;  <span class="comment">// 入队</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeQueue</span><span class="params">(Queue *q, BiTree *node)</span> &#123;</span><br><span class="line">    *node = q-&gt;data[q-&gt;front++];  <span class="comment">// 出队</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InvertLevel</span><span class="params">(BiTree bt)</span> &#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    Queue Q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        InitStack(&amp;s);</span><br><span class="line">        InitQueue(&amp;Q);</span><br><span class="line">        EnQueue(&amp;Q, bt);  <span class="comment">// 将根结点入队</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自上而下层次遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!IsEmptyQueue(&amp;Q)) &#123;</span><br><span class="line">            BiTree p;</span><br><span class="line">            DeQueue(&amp;Q, &amp;p);  <span class="comment">// 出队</span></span><br><span class="line">            Push(&amp;s, p);  <span class="comment">// 入栈</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 依次将左右孩子入队，左孩子先入，右孩子后入</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;lchild) &#123;</span><br><span class="line">                EnQueue(&amp;Q, p-&gt;lchild);  <span class="comment">// 若左孩子不空，则入队</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rchild) &#123;</span><br><span class="line">                EnQueue(&amp;Q, p-&gt;rchild);  <span class="comment">// 若右孩子不空，则入队</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 自下而上、从右到左的层次遍历</span></span><br><span class="line">        <span class="keyword">while</span> (!IsEmptyStack(&amp;s)) &#123;</span><br><span class="line">            BiTree p;</span><br><span class="line">            Pop(&amp;s, &amp;p);  <span class="comment">// 从栈中弹出结点</span></span><br><span class="line">            visit(p-&gt;data);  <span class="comment">// 访问结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><ol>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li><code>BiTNode</code> 结构体表示二叉树的结点，包含数据和指向左右孩子的指针。</li>
<li><code>Stack</code> 和 <code>Queue</code> 结构体用于实现栈和队列功能，分别用于存储树的结点指针。</li>
</ul>
</li>
<li><p><strong>初始化栈和队列</strong>：</p>
<ul>
<li><code>InitStack</code> 和 <code>InitQueue</code> 函数用于初始化栈和队列，分配内存空间。</li>
</ul>
</li>
<li><p><strong>层次遍历</strong>：</p>
<ul>
<li>使用队列进行自上而下的层次遍历，将访问到的结点压入栈中。</li>
<li>注意左右孩子入队的顺序：先左后右，以确保后续弹栈时能实现从右到左的访问顺序。</li>
</ul>
</li>
<li><p><strong>栈的逆序访问</strong>：</p>
<ul>
<li>一旦完成了队列的遍历，栈中的结点按自下而上的顺序排列，依次弹出并访问。</li>
</ul>
</li>
</ol>
<h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><p>通过这个算法，可以实现二叉树的自下而上、从右到左的层次遍历。例如，给定如下的二叉树：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A</span><br><span class="line">   / \</span><br><span class="line">  B   C</span><br><span class="line"> / \</span><br><span class="line">D   E</span><br></pre></td></tr></table></figure>
<p>其自下而上、从右到左的层次遍历结果为：<code>D E B C A</code>。</p>
<h2 id="05：假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。"><a href="#05：假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。" class="headerlink" title="05：假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。"></a><strong>05</strong>：假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。</h2><p><strong>05.【解答】</strong></p>
<p><strong>算法思想</strong>：<br>采用层次遍历的算法，通过记录当前结点所在的层数来计算二叉树的高度。具体思路是设置变量 <code>level</code> 用于记录当前层的层数，设置变量 <code>last</code> 指向当前层的最右结点。每次在遍历出队时，与 <code>last</code> 指针进行比较，如果两者相等，则说明当前层已遍历完成，层数 <code>level</code> 加 1，并更新 <code>last</code> 为下一层的最右结点，直到遍历完成。最终 <code>level</code> 的值即为二叉树的高度。</p>
<p><strong>具体步骤</strong>：</p>
<ol>
<li><strong>初始化</strong>：检查树是否为空。如果为空，则高度为 0。</li>
<li><strong>设置变量</strong>：<ul>
<li><code>front</code> 和 <code>rear</code> 用于管理队列，分别表示队列的前后指针。</li>
<li><code>last</code> 指向当前层的最右结点，初始为 0。</li>
<li><code>level</code> 记录当前层数，初始为 0。</li>
</ul>
</li>
<li><strong>将根结点入队</strong>：将根结点加入队列。</li>
<li><strong>遍历队列</strong>：使用循环遍历队列：<ul>
<li>出队一个结点，访问它。</li>
<li>如果该结点的左孩子存在，将左孩子入队。</li>
<li>如果该结点的右孩子存在，将右孩子入队。</li>
<li>每当出队的结点的索引等于 <code>last</code> 时，说明当前层遍历完毕，层数 <code>level</code> 加 1，并更新 <code>last</code> 为当前队列的尾指针。</li>
</ul>
</li>
<li><strong>返回高度</strong>：当队列遍历完成后，返回 <code>level</code> 的值作为二叉树的高度。</li>
</ol>
<p><strong>代码实现</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100  <span class="comment">// 假设队列最大容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Btdepth</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    <span class="comment">// 采用层次遍历的非递归方法求解二叉树的高度</span></span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 树空，高度为0</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> front = <span class="number">-1</span>, rear = <span class="number">-1</span>;  <span class="comment">// 队列指针</span></span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>;  <span class="comment">// last指向当前层的最右结点</span></span><br><span class="line">    <span class="type">int</span> level = <span class="number">0</span>;  <span class="comment">// 记录层数</span></span><br><span class="line">    BiTree Q[MaxSize];  <span class="comment">// 队列，存储二叉树结点的指针</span></span><br><span class="line">    </span><br><span class="line">    Q[++rear] = T;  <span class="comment">// 将根结点入队</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear) &#123;  <span class="comment">// 队不空，则循环</span></span><br><span class="line">        BiTree p = Q[++front];  <span class="comment">// 队列元素出队，即正在访问的结点</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 左孩子入队</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild) &#123;</span><br><span class="line">            Q[++rear] = p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 右孩子入队</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild) &#123;</span><br><span class="line">            Q[++rear] = p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理该层的最右结点</span></span><br><span class="line">        <span class="keyword">if</span> (front == last) &#123;</span><br><span class="line">            level++;  <span class="comment">// 层数增1</span></span><br><span class="line">            last = rear;  <span class="comment">// last指向下层</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> level;  <span class="comment">// 返回树的高度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解释：-1"><a href="#解释：-1" class="headerlink" title="解释："></a>解释：</h3><ol>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li><code>BiTNode</code> 结构体表示二叉树的结点，包含数据和指向左右孩子的指针。</li>
<li>使用数组 <code>Q</code> 来模拟队列，容量为 <code>MaxSize</code>。</li>
</ul>
</li>
<li><p><strong>初始化</strong>：</p>
<ul>
<li>首先检查二叉树是否为空，如果为空，则高度为 0。</li>
</ul>
</li>
<li><p><strong>层次遍历</strong>：</p>
<ul>
<li>将根结点入队，开始层次遍历。</li>
<li>在遍历过程中，出队结点并访问它，依次将左右孩子入队。</li>
<li>每当出队的结点的索引与 <code>last</code> 相等时，说明当前层已经遍历完毕，更新层数并设置 <code>last</code> 为当前队列的尾指针。</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>完成遍历后，返回变量 <code>level</code> 的值作为二叉树的高度。</li>
</ul>
</li>
</ol>
<h3 id="结果：-1"><a href="#结果：-1" class="headerlink" title="结果："></a>结果：</h3><p>这个算法可以高效地计算出二叉树的高度，时间复杂度为 $O(n)$，其中 $n$ 是树中结点的数量，因为每个结点都被访问了一次。对于结构较大的树，采用此非递归方法可以避免函数调用栈的深度限制。 </p>
<p>通过这种方法，可以得到二叉树的高度，同时该算法也可以用于求某层的结点个数、每层的结点个数和树的最大宽度等问题，思路类似。</p>
<h2 id="06：设一棵二叉树中各结点的值互不相同，其先序遍历序列和中序遍历序列分别存于两个一维数组-A-1-n-和-B-1-n-中，试编写算法建立该二叉树的二叉链表。"><a href="#06：设一棵二叉树中各结点的值互不相同，其先序遍历序列和中序遍历序列分别存于两个一维数组-A-1-n-和-B-1-n-中，试编写算法建立该二叉树的二叉链表。" class="headerlink" title="06：设一棵二叉树中各结点的值互不相同，其先序遍历序列和中序遍历序列分别存于两个一维数组 $A[1..n]$ 和 $B[1..n]$ 中，试编写算法建立该二叉树的二叉链表。"></a><strong>06</strong>：设一棵二叉树中各结点的值互不相同，其先序遍历序列和中序遍历序列分别存于两个一维数组 $A[1..n]$ 和 $B[1..n]$ 中，试编写算法建立该二叉树的二叉链表。</h2><p><strong>06.【解答】</strong></p>
<p><strong>算法思想</strong>：<br>由先序序列和中序序列可以唯一确定一棵二叉树。具体步骤如下：</p>
<ol>
<li>根据先序序列确定树的根结点。</li>
<li>在中序序列中找到根结点，并划分出左、右子树的结点。</li>
<li>根据左、右子树结点在先序序列中的次序确定子树的根结点。</li>
<li>递归建立左子树和右子树，直到每棵子树只有一个结点（即该子树的根结点）。</li>
</ol>
<h3 id="步骤详解："><a href="#步骤详解：" class="headerlink" title="步骤详解："></a>步骤详解：</h3><ul>
<li><strong>根结点</strong>：在先序遍历中，第一个结点即为根结点。</li>
<li><strong>划分子树</strong>：在中序遍历中，根结点左边的结点属于左子树，右边的结点属于右子树。</li>
<li><strong>递归建立</strong>：根据划分得到的左子树和右子树的长度，递归调用建立二叉树的函数。</li>
</ul>
<h3 id="算法实现如下："><a href="#算法实现如下：" class="headerlink" title="算法实现如下："></a>算法实现如下：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;  <span class="comment">// 假设结点的值类型为字符</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line">BiTree <span class="title function_">PreInCreat</span><span class="params">(ElemType A[], ElemType B[], <span class="type">int</span> l1, <span class="type">int</span> h1, <span class="type">int</span> l2, <span class="type">int</span> h2)</span> &#123;</span><br><span class="line">    <span class="comment">// l1, h1 为先序的第一和最后一个结点下标</span></span><br><span class="line">    <span class="comment">// l2, h2 为中序的第一和最后一个结点下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (l1 &gt; h1 || l2 &gt; h2) <span class="keyword">return</span> <span class="literal">NULL</span>;  <span class="comment">// 如果范围不合法，则返回空</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建根结点</span></span><br><span class="line">    BiTree root = (BiTNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">    root-&gt;data = A[l1];  <span class="comment">// 先序第一个结点为根结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在中序序列中查找根结点</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = l2; i &lt;= h2; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (B[i] == root-&gt;data) <span class="keyword">break</span>;  <span class="comment">// 找到根结点在中序中的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 左子树的长度</span></span><br><span class="line">    <span class="type">int</span> llen = i - l2;  </span><br><span class="line">    <span class="comment">// 右子树的长度</span></span><br><span class="line">    <span class="type">int</span> rlen = h2 - i;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归建立左子树</span></span><br><span class="line">    <span class="keyword">if</span> (llen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;lchild = PreInCreat(A, B, l1 + <span class="number">1</span>, l1 + llen, l2, i - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;lchild = <span class="literal">NULL</span>;  <span class="comment">// 左子树为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归建立右子树</span></span><br><span class="line">    <span class="keyword">if</span> (rlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        root-&gt;rchild = PreInCreat(A, B, h1 - rlen + <span class="number">1</span>, h1, i + <span class="number">1</span>, h2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        root-&gt;rchild = <span class="literal">NULL</span>;  <span class="comment">// 右子树为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;  <span class="comment">// 返回根结点指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解释：-2"><a href="#解释：-2" class="headerlink" title="解释："></a>解释：</h3><ol>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li><code>BiTNode</code> 结构体表示二叉树的结点，包含结点的数据和指向左右孩子的指针。</li>
</ul>
</li>
<li><p><strong>函数参数</strong>：</p>
<ul>
<li><code>A[]</code> 是先序遍历的数组。</li>
<li><code>B[]</code> 是中序遍历的数组。</li>
<li><code>l1, h1</code> 分别表示先序数组的开始和结束下标。</li>
<li><code>l2, h2</code> 分别表示中序数组的开始和结束下标。</li>
</ul>
</li>
<li><p><strong>基础条件</strong>：</p>
<ul>
<li>如果当前子树范围无效（<code>l1 &gt; h1</code> 或 <code>l2 &gt; h2</code>），返回 <code>NULL</code>，表示没有子树。</li>
</ul>
</li>
<li><p><strong>建立根结点</strong>：</p>
<ul>
<li>根据先序数组的当前下标创建根结点。</li>
</ul>
</li>
<li><p><strong>查找根结点</strong>：</p>
<ul>
<li>在中序数组中找到根结点的位置，以便确定左、右子树的结点。</li>
</ul>
</li>
<li><p><strong>递归调用</strong>：</p>
<ul>
<li>使用分割得到的下标递归建立左子树和右子树。</li>
</ul>
</li>
</ol>
<h3 id="结果：-2"><a href="#结果：-2" class="headerlink" title="结果："></a>结果：</h3><p>通过这种方法，可以根据给定的先序和中序遍历序列构建出对应的二叉树。由于先序和中序序列的唯一性，算法的结果是确定的，时间复杂度为 $O(n^2)$（在每次查找根结点的过程中遍历中序数组），但可以通过使用哈希表优化到 $O(n)$。</p>
<h2 id="07：给定一个二叉树，判断其是否为完全二叉树。"><a href="#07：给定一个二叉树，判断其是否为完全二叉树。" class="headerlink" title="07：给定一个二叉树，判断其是否为完全二叉树。"></a><strong>07</strong>：给定一个二叉树，判断其是否为完全二叉树。</h2><p><strong>07.【解答】</strong></p>
<p><strong>算法思想</strong>：<br>根据完全二叉树的定义，完全二叉树是指在二叉树的每一层上都被完全填满，除了最后一层的结点外，最后一层的结点都在左边。</p>
<p>判断一个给定的二叉树是否为完全二叉树的算法步骤如下：</p>
<ol>
<li>采用层次遍历的方式，将所有结点（包括空结点）加入队列。</li>
<li>遇到空结点时，检查其后是否有非空结点。如果有，则该二叉树不是完全二叉树。</li>
<li>如果遍历完成没有发现不符合的条件，则该二叉树是完全二叉树。</li>
</ol>
<h3 id="算法实现如下：-1"><a href="#算法实现如下：-1" class="headerlink" title="算法实现如下："></a>算法实现如下：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span> &#123;</span></span><br><span class="line">    BiTree node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QueueNode</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125; QueueNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    QueueNode* front;</span><br><span class="line">    QueueNode* rear;</span><br><span class="line">&#125; Queue;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    q-&gt;front = q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnQueue</span><span class="params">(Queue* q, BiTree node)</span> &#123;</span><br><span class="line">    QueueNode* newNode = (QueueNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QueueNode));</span><br><span class="line">    newNode-&gt;node = node;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear) &#123;</span><br><span class="line">        q-&gt;rear-&gt;next = newNode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        q-&gt;front = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    q-&gt;rear = newNode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">BiTree <span class="title function_">DeQueue</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    QueueNode* temp = q-&gt;front;</span><br><span class="line">    BiTree node = temp-&gt;node;</span><br><span class="line">    q-&gt;front = temp-&gt;next;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断队列是否为空</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">IsEmpty</span><span class="params">(Queue* q)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;front == <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断给定二叉树是否为完全二叉树</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">IsComplete</span><span class="params">(BiTree T)</span> &#123;</span><br><span class="line">    Queue Q;</span><br><span class="line">    InitQueue(&amp;Q);  <span class="comment">// 初始化队列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!T) <span class="keyword">return</span> <span class="number">1</span>;  <span class="comment">// 空树视为完全二叉树</span></span><br><span class="line"></span><br><span class="line">    EnQueue(&amp;Q, T);  <span class="comment">// 将根结点入队</span></span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> isComplete = <span class="literal">true</span>;  <span class="comment">// 用于标记是否为完全二叉树</span></span><br><span class="line">    <span class="type">bool</span> end = <span class="literal">false</span>;  <span class="comment">// 标记是否已遇到空结点</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!IsEmpty(&amp;Q)) &#123;</span><br><span class="line">        BiTree p = DeQueue(&amp;Q);  <span class="comment">// 出队当前结点</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end) &#123;</span><br><span class="line">                isComplete = <span class="literal">false</span>;  <span class="comment">// 遇到非空结点，标记为非完全二叉树</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            EnQueue(&amp;Q, p-&gt;lchild);  <span class="comment">// 左孩子入队</span></span><br><span class="line">            EnQueue(&amp;Q, p-&gt;rchild);  <span class="comment">// 右孩子入队</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = <span class="literal">true</span>;  <span class="comment">// 遇到空结点，之后不能再有非空结点</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isComplete;  <span class="comment">// 返回结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解释：-3"><a href="#解释：-3" class="headerlink" title="解释："></a>解释：</h3><ol>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li><code>BiTNode</code> 结构体表示二叉树的结点，包含结点的数据和指向左右孩子的指针。</li>
<li><code>QueueNode</code> 用于实现队列，包含指向二叉树结点的指针。</li>
<li><code>Queue</code> 结构体用于管理队列。</li>
</ul>
</li>
<li><p><strong>函数说明</strong>：</p>
<ul>
<li><code>InitQueue()</code>：初始化队列。</li>
<li><code>EnQueue()</code>：将结点入队。</li>
<li><code>DeQueue()</code>：将队头结点出队。</li>
<li><code>IsEmpty()</code>：判断队列是否为空。</li>
</ul>
</li>
<li><p><strong>判断逻辑</strong>：</p>
<ul>
<li>如果树为空，返回 <code>true</code>，认为空树是完全二叉树。</li>
<li>使用一个标志 <code>end</code>，初始为 <code>false</code>，用于表示是否遇到了空结点。</li>
<li>在遍历中：<ul>
<li>若当前结点非空且 <code>end</code> 标志已被设置，则树不是完全二叉树。</li>
<li>如果当前结点为空，则将 <code>end</code> 设置为 <code>true</code>，后续结点都不能是非空结点。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>复杂度</strong>：</p>
<ul>
<li>时间复杂度为 $O(n)$，因为每个结点只被访问一次。</li>
<li>空间复杂度为 $O(n)$，由于使用了队列来存储结点。</li>
</ul>
</li>
</ol>
<h2 id="08：计算一棵给定二叉树中的所有双分支结点个数。"><a href="#08：计算一棵给定二叉树中的所有双分支结点个数。" class="headerlink" title="08：计算一棵给定二叉树中的所有双分支结点个数。"></a><strong>08</strong>：计算一棵给定二叉树中的所有双分支结点个数。</h2><p><strong>08.【解答】</strong></p>
<p><strong>算法思想</strong>：<br>双分支结点是指一个结点的左子树和右子树都不为空的结点。为了计算双分支结点的个数，可以使用递归的方法来遍历整棵二叉树，并在遍历过程中判断每个结点是否为双分支结点。</p>
<h3 id="递归模型："><a href="#递归模型：" class="headerlink" title="递归模型："></a>递归模型：</h3><p>设函数 $f(b)$ 表示二叉树 $b$ 中的双分支结点个数。</p>
<ol>
<li>如果 $b$ 为空（即树为空），返回 0。</li>
<li>如果 $b$ 是双分支结点（即 $b$ 的左孩子和右孩子均不为空），返回 $f(b-&gt;lchild) + f(b-&gt;rchild) + 1$。</li>
<li>否则，返回 $f(b-&gt;lchild) + f(b-&gt;rchild)$（即 $b$ 不是双分支结点）。</li>
</ol>
<h3 id="算法实现如下：-2"><a href="#算法实现如下：-2" class="headerlink" title="算法实现如下："></a>算法实现如下：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算双分支结点个数的递归函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">DSonNodes</span><span class="params">(BiTree b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  <span class="comment">// 空树，双分支结点数为 0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;lchild != <span class="literal">NULL</span> &amp;&amp; b-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 结点是双分支结点</span></span><br><span class="line">        <span class="keyword">return</span> DSonNodes(b-&gt;lchild) + DSonNodes(b-&gt;rchild) + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 结点是单分支结点或叶子结点</span></span><br><span class="line">        <span class="keyword">return</span> DSonNodes(b-&gt;lchild) + DSonNodes(b-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解释：-4"><a href="#解释：-4" class="headerlink" title="解释："></a>解释：</h3><ol>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li><code>BiTNode</code> 结构体表示二叉树的结点，包含结点的数据和指向左右孩子的指针。</li>
</ul>
</li>
<li><p><strong>函数说明</strong>：</p>
<ul>
<li><code>DSonNodes(BiTree b)</code>：计算以结点 $b$ 为根的子树中的双分支结点个数。<ul>
<li>若当前结点为空，返回 0。</li>
<li>若当前结点是双分支结点，递归计算其左右子树的双分支结点个数，并加 1。</li>
<li>否则，递归计算左右子树的双分支结点个数。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>复杂度</strong>：</p>
<ul>
<li>时间复杂度为 $O(n)$，因为每个结点只被访问一次。</li>
<li>空间复杂度为 $O(h)$，其中 $h$ 为树的高度，用于递归调用的栈空间。</li>
</ul>
</li>
</ol>
<h2 id="09：编写一个函数，将树B（采用链式结构存储的二叉树）中所有结点的左、右子树进行交换。"><a href="#09：编写一个函数，将树B（采用链式结构存储的二叉树）中所有结点的左、右子树进行交换。" class="headerlink" title="09：编写一个函数，将树B（采用链式结构存储的二叉树）中所有结点的左、右子树进行交换。"></a><strong>09</strong>：编写一个函数，将树B（采用链式结构存储的二叉树）中所有结点的左、右子树进行交换。</h2><p><strong>09.【解答】</strong></p>
<p><strong>算法思想</strong>：<br>采用递归算法实现交换二叉树的左、右子树。我们可以使用后序遍历的思想来进行交换操作，即在递归遍历到结点时，首先交换其左右子树，然后再进行左、右孩子的交换。具体步骤如下：</p>
<ol>
<li>递归到当前结点的左孩子和右孩子。</li>
<li>交换当前结点的左右子树。</li>
<li>当结点为空时，递归结束。</li>
</ol>
<h3 id="算法实现如下：-3"><a href="#算法实现如下：-3" class="headerlink" title="算法实现如下："></a>算法实现如下：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 结点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span>  <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span>  <span class="comment">// 右孩子</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换二叉树的左、右子树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(BiTree b)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;  <span class="comment">// 递归结束条件</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 先递归交换左、右子树</span></span><br><span class="line">    swap(b-&gt;lchild);</span><br><span class="line">    swap(b-&gt;rchild);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换当前结点的左、右孩子</span></span><br><span class="line">    BiTree temp = b-&gt;lchild;  <span class="comment">// 暂存左子树</span></span><br><span class="line">    b-&gt;lchild = b-&gt;rchild;     <span class="comment">// 将右子树赋给左子树</span></span><br><span class="line">    b-&gt;rchild = temp;          <span class="comment">// 将暂存的左子树赋给右子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例：创建一个简单的二叉树并交换其左右子树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">printTree</span><span class="params">(BiTree b, <span class="type">int</span> level)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    printTree(b-&gt;rchild, level + <span class="number">1</span>);  <span class="comment">// 先打印右子树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; level; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;    &quot;</span>);  <span class="comment">// 缩进表示树的层级</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, b-&gt;data);  <span class="comment">// 打印当前结点</span></span><br><span class="line">    printTree(b-&gt;lchild, level + <span class="number">1</span>);  <span class="comment">// 后打印左子树</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解释：-5"><a href="#解释：-5" class="headerlink" title="解释："></a>解释：</h3><ol>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li><code>BiTNode</code> 结构体表示二叉树的结点，包含结点的数据和指向左右孩子的指针。</li>
</ul>
</li>
<li><p><strong>函数说明</strong>：</p>
<ul>
<li><code>swap(BiTree b)</code>：递归交换以结点 $b$ 为根的子树的左、右子树。<ul>
<li>若当前结点为空，返回。</li>
<li>先递归交换左子树和右子树。</li>
<li>使用一个临时指针存储左子树，然后进行左右孩子的交换。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>打印函数</strong>：</p>
<ul>
<li><code>printTree(BiTree b, int level)</code>：用于以层次结构的形式打印二叉树。</li>
</ul>
</li>
<li><p><strong>复杂度</strong>：</p>
<ul>
<li>时间复杂度为 $O(n)$，因为每个结点只被访问一次。</li>
<li>空间复杂度为 $O(h)$，其中 $h$ 为树的高度，用于递归调用的栈空间。</li>
</ul>
</li>
</ol>
<h2 id="10：假设二叉树采用链式结构存储，设计一个算法，求先序遍历序列中第-k-个结点的值（-1-leq-k-leq-二叉树中结点个数）。"><a href="#10：假设二叉树采用链式结构存储，设计一个算法，求先序遍历序列中第-k-个结点的值（-1-leq-k-leq-二叉树中结点个数）。" class="headerlink" title="10：假设二叉树采用链式结构存储，设计一个算法，求先序遍历序列中第 $ k $ 个结点的值（$ 1 \leq k \leq $ 二叉树中结点个数）。"></a><strong>10</strong>：假设二叉树采用链式结构存储，设计一个算法，求先序遍历序列中第 $ k $ 个结点的值（$ 1 \leq k \leq $ 二叉树中结点个数）。</h2><p><strong>10.【解答】</strong></p>
<p><strong>算法思想</strong>：</p>
<ol>
<li>使用全局变量 $ i $ 来跟踪当前访问的结点的顺序。</li>
<li>利用先序遍历的特性：首先访问根结点，然后是左子树，最后是右子树。</li>
<li>当访问到第 $ k $ 个结点时，返回该结点的值。</li>
<li>当二叉树为空时，返回特殊字符 <code>&#39;#&#39;</code> 表示结点不存在。</li>
</ol>
<h3 id="递归模型"><a href="#递归模型" class="headerlink" title="递归模型"></a>递归模型</h3><p>设函数 <code>PreNode(b, k)</code> 为在二叉树 <code>b</code> 中查找第 $ k $ 个先序遍历结点的值：</p>
<ul>
<li>当 $ b $ 为空时，返回特殊字符 <code>&#39;#&#39;</code>。</li>
<li>当 $ i = k $ 时，返回结点值 $ b-&gt;data $。</li>
<li>否则，递归访问左子树和右子树。</li>
</ul>
<h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 结点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span>  <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span>  <span class="comment">// 右孩子</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历序号的全局变量</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找二叉树先序遍历序列中第k个结点的值</span></span><br><span class="line"><span class="type">char</span> <span class="title function_">PreNode</span><span class="params">(BiTree b, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;#&#x27;</span>;  <span class="comment">// 空结点，则返回特殊字符</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查当前结点是否为第k个结点</span></span><br><span class="line">    <span class="keyword">if</span> (i == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> b-&gt;data;  <span class="comment">// 找到第k个结点，返回结点值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    i++;  <span class="comment">// 访问下一个结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在左子树中查找</span></span><br><span class="line">    <span class="type">char</span> ch = PreNode(b-&gt;lchild, k);</span><br><span class="line">    <span class="keyword">if</span> (ch != <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ch;  <span class="comment">// 在左子树中找到，返回该值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在右子树中查找</span></span><br><span class="line">    <span class="keyword">return</span> PreNode(b-&gt;rchild, k);  <span class="comment">// 在右子树中查找</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解释：-6"><a href="#解释：-6" class="headerlink" title="解释："></a>解释：</h3><ol>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li><code>BiTNode</code> 结构体表示二叉树的结点，包含数据和指向左右孩子的指针。</li>
</ul>
</li>
<li><p><strong>函数说明</strong>：</p>
<ul>
<li><code>PreNode(BiTree b, int k)</code>：递归查找二叉树 <code>b</code> 中第 $ k $ 个先序遍历结点的值。<ul>
<li>如果当前结点为空，返回特殊字符 <code>&#39;#&#39;</code>。</li>
<li>如果当前结点是第 $ k $ 个结点，返回结点值。</li>
<li>否则，递归访问左子树和右子树，返回找到的值。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>复杂度</strong>：</p>
<ul>
<li>时间复杂度为 $ O(n) $，每个结点都可能被访问一次。</li>
<li>空间复杂度为 $ O(h) $，其中 $ h $ 为树的高度，主要用于递归调用的栈空间。</li>
</ul>
</li>
</ol>
<h2 id="11：已知二叉树以链式结构存储，编写算法完成：对于树中每个元素值为-x-的结点，删去以-x-为根的子树，并释放相应的空间。"><a href="#11：已知二叉树以链式结构存储，编写算法完成：对于树中每个元素值为-x-的结点，删去以-x-为根的子树，并释放相应的空间。" class="headerlink" title="11：已知二叉树以链式结构存储，编写算法完成：对于树中每个元素值为 $ x $ 的结点，删去以 $ x $ 为根的子树，并释放相应的空间。"></a><strong>11</strong>：已知二叉树以链式结构存储，编写算法完成：对于树中每个元素值为 $ x $ 的结点，删去以 $ x $ 为根的子树，并释放相应的空间。</h2><p><strong>11.【解答】</strong></p>
<p><strong>算法思想</strong>：</p>
<ol>
<li><strong>后序遍历</strong>：要删除以 $ x $ 为根的子树，首先需要删除其左右子树，然后才能删除根结点本身。</li>
<li><strong>层次遍历</strong>：通过层次遍历（广度优先遍历）来找到每个结点的父结点，以便在删除子树时可以将父结点的指针置为 <code>NULL</code>。</li>
</ol>
<h3 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h3><ol>
<li>定义函数 <code>DeleteXTree(BiTree &amp;bt)</code> 用于递归删除以 $ bt $ 为根的子树。</li>
<li>定义函数 <code>Search(BiTree bt, ElemType x)</code> 用于遍历树，查找值为 $ x $ 的结点，并调用 <code>DeleteXTree</code> 删除其子树。</li>
<li>使用队列来实现层次遍历。</li>
</ol>
<h3 id="算法实现-1"><a href="#算法实现-1" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 结点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span>  <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span>  <span class="comment">// 右孩子</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除以bt为根的子树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteXTree</span><span class="params">(BiTree &amp;bt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bt) &#123;</span><br><span class="line">        DeleteXTree(bt-&gt;lchild);  <span class="comment">// 删除左子树</span></span><br><span class="line">        DeleteXTree(bt-&gt;rchild);  <span class="comment">// 删除右子树</span></span><br><span class="line">        <span class="built_in">free</span>(bt);  <span class="comment">// 释放当前结点</span></span><br><span class="line">        bt = <span class="literal">NULL</span>; <span class="comment">// 将当前结点指针置为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在二叉树上查找所有以x为元素值的结点，并删除以其为根的子树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Search</span><span class="params">(BiTree bt, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bt == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用队列进行层次遍历</span></span><br><span class="line">    BiTree *<span class="built_in">queue</span> = (BiTree *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTree) * <span class="number">100</span>); <span class="comment">// 假设队列最大容量为100</span></span><br><span class="line">    <span class="type">int</span> front = <span class="number">0</span>, rear = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>[rear++] = bt;  <span class="comment">// 入队根结点</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (front &lt; rear) &#123;</span><br><span class="line">        BiTree p = <span class="built_in">queue</span>[front++];  <span class="comment">// 出队</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;data == x) &#123;</span><br><span class="line">            DeleteXTree(p);  <span class="comment">// 删除以p为根的子树</span></span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 由于已经删除，当前循环跳过</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;lchild) &#123;</span><br><span class="line">            <span class="built_in">queue</span>[rear++] = p-&gt;lchild;  <span class="comment">// 左子树入队</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (p-&gt;rchild) &#123;</span><br><span class="line">            <span class="built_in">queue</span>[rear++] = p-&gt;rchild;  <span class="comment">// 右子树入队</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">free</span>(<span class="built_in">queue</span>);  <span class="comment">// 释放队列内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="解释：-7"><a href="#解释：-7" class="headerlink" title="解释："></a>解释：</h3><ol>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li><code>BiTNode</code> 结构体表示二叉树的结点，包含结点的数据和指向左右孩子的指针。</li>
</ul>
</li>
<li><p><strong>函数说明</strong>：</p>
<ul>
<li><code>DeleteXTree(BiTree &amp;bt)</code>：递归删除以 $ bt $ 为根的子树。<ul>
<li>先删除左子树，再删除右子树，最后释放当前结点的内存，并将指针置为 <code>NULL</code>。</li>
</ul>
</li>
<li><code>Search(BiTree bt, int x)</code>：层次遍历二叉树，查找值为 $ x $ 的结点，并删除以其为根的子树。<ul>
<li>使用队列实现层次遍历，找到每个结点的父结点，并在找到匹配值时调用 <code>DeleteXTree</code>。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>复杂度</strong>：</p>
<ul>
<li>时间复杂度为 $ O(n) $，每个结点最多被访问一次。</li>
<li>空间复杂度为 $ O(w) $，其中 $ w $ 是树的最大宽度，主要用于队列存储。</li>
</ul>
</li>
</ol>
<h2 id="12：在二叉树中查找值为-x-的结点，编写算法（用-C-语言）打印值为-x-的结点的所有祖先，假设值为-x-的结点不多于一个。"><a href="#12：在二叉树中查找值为-x-的结点，编写算法（用-C-语言）打印值为-x-的结点的所有祖先，假设值为-x-的结点不多于一个。" class="headerlink" title="12：在二叉树中查找值为 $ x $ 的结点，编写算法（用 C 语言）打印值为 $ x $ 的结点的所有祖先，假设值为 $ x $ 的结点不多于一个。"></a><strong>12</strong>：在二叉树中查找值为 $ x $ 的结点，编写算法（用 C 语言）打印值为 $ x $ 的结点的所有祖先，假设值为 $ x $ 的结点不多于一个。</h2><p><strong>12.【解答】</strong></p>
<h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>采用非递归的后序遍历，通过使用一个栈来模拟递归过程。当找到值为 $ x $ 的结点时，栈中的所有元素都为该结点的祖先。通过逆序遍历栈来打印这些祖先结点的值。</p>
<h3 id="主要步骤-1"><a href="#主要步骤-1" class="headerlink" title="主要步骤"></a>主要步骤</h3><ol>
<li>定义一个栈结构，用于存储遍历的结点和访问标记。</li>
<li>使用循环和条件判断进行非递归后序遍历。</li>
<li>当找到值为 $ x $ 的结点时，打印栈中的所有结点。</li>
</ol>
<h3 id="算法实现-2"><a href="#算法实现-2" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 结点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span>  <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span>  <span class="comment">// 右孩子</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    BiTree t;  <span class="comment">// 指向二叉树结点的指针</span></span><br><span class="line">    <span class="type">int</span> tag;   <span class="comment">// 标记，0表示左子女被访问，1表示右子女被访问</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找值为x的结点，并打印其所有祖先</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Search</span><span class="params">(BiTree bt, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">    Stack *s = (Stack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Stack) * <span class="number">100</span>); <span class="comment">// 栈容量足够大</span></span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;  <span class="comment">// 栈顶指针</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (bt != <span class="literal">NULL</span> || top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历左分支</span></span><br><span class="line">        <span class="keyword">while</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s[++top].t = bt;  <span class="comment">// 结点入栈</span></span><br><span class="line">            s[top].tag = <span class="number">0</span>;   <span class="comment">// 标记为访问左子树</span></span><br><span class="line">            bt = bt-&gt;lchild;  <span class="comment">// 沿左分支向下</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 访问栈顶结点</span></span><br><span class="line">        <span class="keyword">if</span> (top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            bt = s[top].t;  <span class="comment">// 取出栈顶结点</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查当前结点的值是否为x</span></span><br><span class="line">            <span class="keyword">if</span> (bt-&gt;data == x) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;所查结点的所有祖先结点的值为:\n&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; top; i++) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, s[i].t-&gt;data); <span class="comment">// 打印祖先结点的值</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">free</span>(s);  <span class="comment">// 释放栈内存</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">0</span>);  <span class="comment">// 找到后退出</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理右子树</span></span><br><span class="line">            <span class="keyword">if</span> (s[top].tag == <span class="number">0</span>) &#123;</span><br><span class="line">                s[top].tag = <span class="number">1</span>;  <span class="comment">// 将当前结点标记为已访问左子树</span></span><br><span class="line">                bt = bt-&gt;rchild;  <span class="comment">// 访问右子树</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                top--;  <span class="comment">// 左右子树都已访问，出栈</span></span><br><span class="line">                bt = <span class="literal">NULL</span>;  <span class="comment">// 继续处理下一个结点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;未找到值为 %d 的结点。\n&quot;</span>, x); <span class="comment">// 未找到值为x的结点</span></span><br><span class="line">    <span class="built_in">free</span>(s);  <span class="comment">// 释放栈内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li><code>BiTNode</code> 结构体表示二叉树的结点，包含结点的数据和指向左右孩子的指针。</li>
<li><code>Stack</code> 结构体用于存储栈中的结点和访问状态。</li>
</ul>
</li>
<li><p><strong>函数说明</strong>：</p>
<ul>
<li><code>Search(BiTree bt, int x)</code>：在二叉树中查找值为 $ x $ 的结点，并打印其所有祖先。<ul>
<li>使用一个栈来模拟后序遍历。通过 <code>tag</code> 标记判断当前结点是否已经访问过左子树。</li>
<li>当找到值为 $ x $ 的结点时，打印栈中所有结点的值。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>复杂度</strong>：</p>
<ul>
<li>时间复杂度为 $ O(n) $，其中 $ n $ 是树中结点的数量。</li>
<li>空间复杂度为 $ O(h) $，其中 $ h $ 是树的高度（栈的最大深度）。</li>
</ul>
</li>
</ol>
<h2 id="13：设一棵二叉树的结点结构为-LLINK-INFO-RLINK-，ROOT-为指向该二叉树根结点的指针，p-和-q-分别为指向该二叉树中任意两个结点的指针，试编写算法-ANCESTOR-ROOT-P-Q-R-，找到-P-和-Q-的最近公共祖先结点-R。"><a href="#13：设一棵二叉树的结点结构为-LLINK-INFO-RLINK-，ROOT-为指向该二叉树根结点的指针，p-和-q-分别为指向该二叉树中任意两个结点的指针，试编写算法-ANCESTOR-ROOT-P-Q-R-，找到-P-和-Q-的最近公共祖先结点-R。" class="headerlink" title="13：设一棵二叉树的结点结构为 (LLINK, INFO, RLINK)，ROOT 为指向该二叉树根结点的指针，p 和 q 分别为指向该二叉树中任意两个结点的指针，试编写算法 ANCESTOR(ROOT, P, Q, R)，找到 P 和 Q 的最近公共祖先结点 R。"></a><strong>13</strong>：设一棵二叉树的结点结构为 <code>(LLINK, INFO, RLINK)</code>，<code>ROOT</code> 为指向该二叉树根结点的指针，<code>p</code> 和 <code>q</code> 分别为指向该二叉树中任意两个结点的指针，试编写算法 <code>ANCESTOR(ROOT, P, Q, R)</code>，找到 <code>P</code> 和 <code>Q</code> 的最近公共祖先结点 <code>R</code>。</h2><p><strong>解答</strong>：</p>
<h3 id="算法思想-1"><a href="#算法思想-1" class="headerlink" title="算法思想"></a>算法思想</h3><p>使用非递归的后序遍历，利用栈来保存二叉树的结点。当遍历到某个结点时，栈中的所有元素均为该结点的祖先。在找到结点 <code>P</code> 后，将栈中的内容复制到一个辅助栈中。继续遍历到结点 <code>Q</code> 时，从栈顶开始逐个与辅助栈的元素进行匹配，首次匹配的元素就是 <code>P</code> 和 <code>Q</code> 的最近公共祖先。</p>
<h3 id="算法实现-3"><a href="#算法实现-3" class="headerlink" title="算法实现"></a>算法实现</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树结点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;  <span class="comment">// 结点数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>;</span>  <span class="comment">// 左孩子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">rchild</span>;</span>  <span class="comment">// 右孩子</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 栈结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    BiTree t;  <span class="comment">// 指向二叉树结点的指针</span></span><br><span class="line">    <span class="type">int</span> tag;   <span class="comment">// 标记，0表示左子女已被访问，1表示右子女已被访问</span></span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找p和q的最近公共祖先</span></span><br><span class="line">BiTree <span class="title function_">Ancestor</span><span class="params">(BiTree ROOT, BiTNode *p, BiTNode *q)</span> &#123;</span><br><span class="line">    Stack s[<span class="number">100</span>], s1[<span class="number">100</span>]; <span class="comment">// 栈，容量足够大</span></span><br><span class="line">    <span class="type">int</span> top = <span class="number">-1</span>;          <span class="comment">// 栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1 = <span class="number">-1</span>;         <span class="comment">// 辅助栈的栈顶指针</span></span><br><span class="line">    BiTree bt = ROOT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历二叉树</span></span><br><span class="line">    <span class="keyword">while</span> (bt != <span class="literal">NULL</span> || top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (bt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s[++top].t = bt; <span class="comment">// 结点入栈</span></span><br><span class="line">            s[top].tag = <span class="number">0</span>;  <span class="comment">// 标记为访问左子树</span></span><br><span class="line">            bt = bt-&gt;lchild; <span class="comment">// 沿左分支向下</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理栈顶结点</span></span><br><span class="line">        <span class="keyword">if</span> (top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            bt = s[top].t; <span class="comment">// 取出栈顶结点</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 假定p在q的左侧，遇到p时，栈中元素均为p的祖先</span></span><br><span class="line">            <span class="keyword">if</span> (s[top].t == p) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= top; i++) &#123;</span><br><span class="line">                    s1[++top1] = s[i]; <span class="comment">// 将栈s的元素转入辅助栈s1保存</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 找到q结点</span></span><br><span class="line">                <span class="keyword">while</span> (top &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s[top].t == q) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> i = top; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 遍历栈s</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> j = top1; j &gt;= <span class="number">0</span>; j--) &#123; <span class="comment">// 遍历辅助栈s1</span></span><br><span class="line">                                <span class="keyword">if</span> (s1[j].t == s[i].t) &#123;</span><br><span class="line">                                    <span class="keyword">return</span> s[i].t; <span class="comment">// p和q的最近公共祖先已找到</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    top--; <span class="comment">// 退栈</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 处理右子树</span></span><br><span class="line">                <span class="keyword">if</span> (s[top].tag == <span class="number">0</span>) &#123;</span><br><span class="line">                    s[top].tag = <span class="number">1</span>; <span class="comment">// 标记为右子树已被访问</span></span><br><span class="line">                    bt = s[top].t-&gt;rchild; <span class="comment">// 访问右子树</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    top--; <span class="comment">// 退栈</span></span><br><span class="line">                    bt = <span class="literal">NULL</span>; <span class="comment">// 继续处理下一个结点</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// p和q无公共祖先</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><ol>
<li><p><strong>数据结构</strong>：</p>
<ul>
<li><code>BiTNode</code> 结构体表示二叉树的结点，包含结点的数据和指向左右孩子的指针。</li>
<li><code>Stack</code> 结构体用于存储栈中的结点和访问状态。</li>
</ul>
</li>
<li><p><strong>函数说明</strong>：</p>
<ul>
<li><code>Ancestor(BiTree ROOT, BiTNode *p, BiTNode *q)</code>：在二叉树中查找 <code>p</code> 和 <code>q</code> 的最近公共祖先。<ul>
<li>使用一个栈来模拟后序遍历。通过 <code>tag</code> 标记判断当前结点是否已经访问过左子树。</li>
<li>当找到结点 <code>P</code> 时，复制栈内容到辅助栈 <code>s1</code>。继续遍历到结点 <code>Q</code>，进行匹配。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>复杂度</strong>：</p>
<ul>
<li>时间复杂度为 $ O(n) $，其中 $ n $ 是树中结点的数量。</li>
<li>空间复杂度为 $ O(h) $，其中 $ h $ 是树的高度（栈的最大深度）。</li>
</ul>
</li>
</ol>
<h2 id="14-要设计一个算法来求非空二叉树的宽度（即具有结点数最多的那一层的结点个数），我们可以采用层次遍历的方法。下面是算法的实现思路和详细步骤："><a href="#14-要设计一个算法来求非空二叉树的宽度（即具有结点数最多的那一层的结点个数），我们可以采用层次遍历的方法。下面是算法的实现思路和详细步骤：" class="headerlink" title="14.要设计一个算法来求非空二叉树的宽度（即具有结点数最多的那一层的结点个数），我们可以采用层次遍历的方法。下面是算法的实现思路和详细步骤："></a><strong>14</strong>.要设计一个算法来求非空二叉树的宽度（即具有结点数最多的那一层的结点个数），我们可以采用层次遍历的方法。下面是算法的实现思路和详细步骤：</h2><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ol>
<li><p><strong>层次遍历</strong>：使用队列进行层次遍历。每次出队一个节点时，检查其左右子节点，并将它们入队。同时记录每个节点的层次。</p>
</li>
<li><p><strong>层次统计</strong>：使用一个数组或变量来统计每一层的节点数，遍历结束后，找到节点数最多的层。</p>
</li>
</ol>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>我们需要一个队列来存储节点及其层次信息。队列可以用数组实现，包含以下两个属性：</p>
<ul>
<li><code>data</code>: 存储队列中的节点指针。</li>
<li><code>level</code>: 存储对应节点的层次。</li>
</ul>
<h3 id="算法实现-4"><a href="#算法实现-4" class="headerlink" title="算法实现"></a>算法实现</h3><p>下面是求非空二叉树宽度的算法实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100 <span class="comment">// 定义队列的最大容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="type">int</span> data; <span class="comment">// 这里假设节点包含一个整数数据</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    BiTree data[MaxSize]; <span class="comment">// 保存队列中的节点指针</span></span><br><span class="line">    <span class="type">int</span> front, rear; <span class="comment">// 队列的头和尾</span></span><br><span class="line">    <span class="type">int</span> level[MaxSize]; <span class="comment">// 保存 data 中相同下标节点的层次</span></span><br><span class="line">&#125; Qu;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化队列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitQueue</span><span class="params">(Qu *q)</span> &#123;</span><br><span class="line">    q-&gt;front = q-&gt;rear = <span class="number">-1</span>; <span class="comment">// 队列为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 入队</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Enqueue</span><span class="params">(Qu *q, BiTree node, <span class="type">int</span> lvl)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;rear &lt; MaxSize - <span class="number">1</span>) &#123; <span class="comment">// 确保队列未满</span></span><br><span class="line">        q-&gt;rear++;</span><br><span class="line">        q-&gt;data[q-&gt;rear] = node; <span class="comment">// 入队节点</span></span><br><span class="line">        q-&gt;level[q-&gt;rear] = lvl; <span class="comment">// 入队节点的层次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 出队</span></span><br><span class="line">BiTree <span class="title function_">Dequeue</span><span class="params">(Qu *q, <span class="type">int</span> *lvl)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (q-&gt;front &lt; q-&gt;rear) &#123; <span class="comment">// 队列非空</span></span><br><span class="line">        q-&gt;front++;</span><br><span class="line">        *lvl = q-&gt;level[q-&gt;front];</span><br><span class="line">        <span class="keyword">return</span> q-&gt;data[q-&gt;front]; <span class="comment">// 返回出队的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">// 队列空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算二叉树宽度</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BTwidth</span><span class="params">(BiTree b)</span> &#123;</span><br><span class="line">    Qu <span class="built_in">queue</span>;</span><br><span class="line">    InitQueue(&amp;<span class="built_in">queue</span>);</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>; <span class="comment">// 存储最大宽度</span></span><br><span class="line">    <span class="type">int</span> levelCount[MaxSize] = &#123;<span class="number">0</span>&#125;; <span class="comment">// 统计各层的节点数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Enqueue(&amp;<span class="built_in">queue</span>, b, <span class="number">1</span>); <span class="comment">// 根节点入队，层次为1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">queue</span>.front &lt; <span class="built_in">queue</span>.rear) &#123; <span class="comment">// 遍历队列</span></span><br><span class="line">        <span class="type">int</span> currentLevel = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>; <span class="comment">// 当前层节点计数</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">queue</span>.front &lt; <span class="built_in">queue</span>.rear) &#123; <span class="comment">// 统计当前层节点数</span></span><br><span class="line">            BiTree p = Dequeue(&amp;<span class="built_in">queue</span>, &amp;currentLevel); <span class="comment">// 出队</span></span><br><span class="line">            <span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                n++; <span class="comment">// 当前层节点数加一</span></span><br><span class="line">                <span class="keyword">if</span> (p-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    Enqueue(&amp;<span class="built_in">queue</span>, p-&gt;lchild, currentLevel + <span class="number">1</span>); <span class="comment">// 左孩子入队</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;rchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    Enqueue(&amp;<span class="built_in">queue</span>, p-&gt;rchild, currentLevel + <span class="number">1</span>); <span class="comment">// 右孩子入队</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">queue</span>.front &lt; <span class="built_in">queue</span>.rear &amp;&amp; <span class="built_in">queue</span>.level[<span class="built_in">queue</span>.front + <span class="number">1</span>] != currentLevel) &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 当前层遍历完成</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新最大宽度</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt; max) &#123;</span><br><span class="line">            max = n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> max; <span class="comment">// 返回二叉树的宽度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>队列结构</strong>：<code>Qu</code>结构体用于实现队列，包含节点指针数组<code>data</code>和层次数组<code>level</code>。</p>
</li>
<li><p><strong>初始化和基本操作</strong>：实现了入队（<code>Enqueue</code>）和出队（<code>Dequeue</code>）操作。</p>
</li>
<li><p><strong>计算宽度</strong>：<code>BTwidth</code>函数实现层次遍历，统计每层的节点数量并更新最大宽度。</p>
</li>
<li><p><strong>示例主函数</strong>：示例中构建了一棵二叉树并调用<code>BTwidth</code>函数来输出其宽度。</p>
</li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>队列的实现采用非环形方式以避免出队后节点信息丢失。</li>
<li>程序应确保在使用后释放分配的内存以避免内存泄漏。</li>
</ul>
<h2 id="15-要设计一个算法，将满二叉树的先序遍历序列转换为后序遍历序列，我们可以利用满二叉树的特点进行递归转换。下面是详细的算法说明和实现。"><a href="#15-要设计一个算法，将满二叉树的先序遍历序列转换为后序遍历序列，我们可以利用满二叉树的特点进行递归转换。下面是详细的算法说明和实现。" class="headerlink" title="15.要设计一个算法，将满二叉树的先序遍历序列转换为后序遍历序列，我们可以利用满二叉树的特点进行递归转换。下面是详细的算法说明和实现。"></a>15.要设计一个算法，将满二叉树的先序遍历序列转换为后序遍历序列，我们可以利用满二叉树的特点进行递归转换。下面是详细的算法说明和实现。</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>在满二叉树中：</p>
<ul>
<li>每个节点都有两个子节点（左子树和右子树）。</li>
<li>左子树和右子树的节点数相等。</li>
</ul>
<p>给定满二叉树的先序序列 $ \text{pre} $，我们需要生成其后序序列 $ \text{post} $。</p>
<h3 id="递归算法"><a href="#递归算法" class="headerlink" title="递归算法"></a>递归算法</h3><ol>
<li><p><strong>递归模型</strong>：利用递归函数 <code>PreToPost(pre, l1, h1, post, l2, h2)</code> 来实现转换。</p>
<ul>
<li>$ l1 $ 和 $ h1 $ 是先序序列的索引范围，表示当前处理的子树在先序序列中的位置。</li>
<li>$ l2 $ 和 $ h2 $ 是后序序列的索引范围，表示当前处理的子树在后序序列中的位置。</li>
<li>先序序列的第一个元素 $ \text{pre}[l1] $ 是当前子树的根节点，应该放在后序序列的最后。</li>
</ul>
</li>
<li><p><strong>递归终止条件</strong>：如果 $ h1 &lt; l1 $，表示当前子树没有节点，直接返回。</p>
</li>
<li><p><strong>计算子树的大小</strong>：</p>
<ul>
<li>满二叉树的节点数是 $ 2^k - 1 $，其中 $ k $ 是树的深度。</li>
<li>通过 $ \text{half} = \frac{h1 - l1}{2} $ 计算左子树和右子树的大小。</li>
</ul>
</li>
<li><p><strong>递归调用</strong>：</p>
<ul>
<li>将左子树的先序序列转换为后序序列。</li>
<li>将右子树的先序序列转换为后序序列。</li>
<li>将根节点放入后序序列的最后。</li>
</ul>
</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是完整的 C 语言代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> ElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将先序序列转换为后序序列</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreToPost</span><span class="params">(ElemType pre[], <span class="type">int</span> l1, <span class="type">int</span> h1, ElemType post[], <span class="type">int</span> l2, <span class="type">int</span> h2)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (h1 &lt; l1) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 递归终止条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将先序序列的第一个元素放入后序序列的最后</span></span><br><span class="line">    post[h2] = pre[l1];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算左子树的大小</span></span><br><span class="line">    <span class="type">int</span> half = (h1 - l1) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换左子树</span></span><br><span class="line">    PreToPost(pre, l1 + <span class="number">1</span>, l1 + half, post, l2, l2 + half - <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 转换右子树</span></span><br><span class="line">    PreToPost(pre, l1 + half + <span class="number">1</span>, h1, post, l2 + half, h2 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>数据定义</strong>：</p>
<ul>
<li><code>ElemType</code> 是节点类型，这里定义为字符。</li>
<li><code>MaxSize</code> 是存储后序序列的最大大小。</li>
</ul>
</li>
<li><p><strong>递归函数 <code>PreToPost</code></strong>：</p>
<ul>
<li><strong>输入参数</strong>：<code>pre[]</code> 是先序序列，<code>post[]</code> 是后序序列，<code>l1, h1</code> 和 <code>l2, h2</code> 分别表示先序序列和后序序列的索引范围。</li>
<li>通过递归将先序序列的左子树和右子树转换为后序序列，最后将根节点放入后序序列的最后。</li>
</ul>
</li>
<li><p><strong>主函数 <code>main</code></strong>：</p>
<ul>
<li>初始化先序序列并调用 <code>PreToPost</code> 函数。</li>
<li>输出转换后的后序序列。</li>
</ul>
</li>
</ol>
<h3 id="示例运行结果"><a href="#示例运行结果" class="headerlink" title="示例运行结果"></a>示例运行结果</h3><p>对于先序序列 <code>&quot;ABCDEFG&quot;</code>，运行结果将是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">后序序列: CDBFGEA</span><br></pre></td></tr></table></figure></p>
<h2 id="16-我们需要将二叉树的所有叶节点按从左到右的顺序连接成一个单链表。二叉树采用链表存储方式，叶节点的右指针域用于存放链表指针，链表的头指针为-head。"><a href="#16-我们需要将二叉树的所有叶节点按从左到右的顺序连接成一个单链表。二叉树采用链表存储方式，叶节点的右指针域用于存放链表指针，链表的头指针为-head。" class="headerlink" title="16.我们需要将二叉树的所有叶节点按从左到右的顺序连接成一个单链表。二叉树采用链表存储方式，叶节点的右指针域用于存放链表指针，链表的头指针为 head。"></a>16.我们需要将二叉树的所有叶节点按从左到右的顺序连接成一个单链表。二叉树采用链表存储方式，叶节点的右指针域用于存放链表指针，链表的头指针为 <code>head</code>。</h2><h3 id="算法思想-2"><a href="#算法思想-2" class="headerlink" title="算法思想"></a>算法思想</h3><ol>
<li><p><strong>中序遍历</strong>：我们选择中序遍历来访问二叉树的叶节点。中序遍历会首先遍历左子树，然后访问当前节点，最后遍历右子树。</p>
</li>
<li><p><strong>前驱指针</strong>：使用一个前驱节点指针 <code>pre</code> 来指向当前正在处理的叶节点。初始时，<code>pre</code> 为空，表示尚未连接任何叶节点。</p>
</li>
<li><p><strong>连接叶节点</strong>：</p>
<ul>
<li>当遍历到一个叶节点时，判断 <code>pre</code> 是否为空：<ul>
<li>如果为空，表示这是第一个叶节点，将 <code>head</code> 指向这个节点。</li>
<li>如果不为空，将 <code>pre</code> 的右指针指向当前叶节点。</li>
</ul>
</li>
<li>更新 <code>pre</code> 为当前叶节点。</li>
</ul>
</li>
<li><p><strong>结束处理</strong>：最后一个叶节点的右指针指向 <code>NULL</code>，表示链表的结束。</p>
</li>
</ol>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是 C 语言的完整实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span>* <span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTreeNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkedListNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LinkedListNode</span>* <span class="title">rchild</span>;</span> <span class="comment">// 用于连接叶节点的右指针</span></span><br><span class="line">&#125; LinkedListNode, *LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">LinkedList head = <span class="literal">NULL</span>;  <span class="comment">// 链表头指针</span></span><br><span class="line">LinkedList pre = <span class="literal">NULL</span>;   <span class="comment">// 前驱指针</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BiTree bt)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (bt) &#123;</span><br><span class="line">        <span class="comment">// 遍历左子树</span></span><br><span class="line">        InOrder(bt-&gt;lchild);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (bt-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; bt-&gt;rchild == <span class="literal">NULL</span>) &#123; <span class="comment">// 叶节点</span></span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                head = (LinkedList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedListNode));</span><br><span class="line">                head-&gt;data = bt-&gt;data; <span class="comment">// 赋值叶节点数据</span></span><br><span class="line">                head-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">                pre = head; <span class="comment">// 更新前驱指针</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pre-&gt;rchild = (LinkedList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkedListNode));</span><br><span class="line">                pre-&gt;rchild-&gt;data = bt-&gt;data; <span class="comment">// 赋值叶节点数据</span></span><br><span class="line">                pre-&gt;rchild-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">                pre = pre-&gt;rchild; <span class="comment">// 更新前驱指针</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历右子树</span></span><br><span class="line">        InOrder(bt-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="代码解释-2"><a href="#代码解释-2" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>数据结构定义</strong>：</p>
<ul>
<li><code>BiTreeNode</code> 表示二叉树节点，包含数据和左右子节点指针。</li>
<li><code>LinkedListNode</code> 表示链表节点，包含数据和右指针（用于连接）。</li>
</ul>
</li>
<li><p><strong>全局变量</strong>：</p>
<ul>
<li><code>head</code> 是链表头指针。</li>
<li><code>pre</code> 是前驱指针。</li>
</ul>
</li>
<li><p><strong>中序遍历函数 <code>InOrder</code></strong>：</p>
<ul>
<li>遍历二叉树，处理叶节点并将其添加到链表中。</li>
<li>对于每个叶节点，更新 <code>head</code> 和 <code>pre</code> 指针以构建链表。</li>
</ul>
</li>
<li><p><strong>主函数 <code>main</code></strong>：</p>
<ul>
<li>创建一个示例二叉树。</li>
<li>调用 <code>InOrder</code> 函数生成叶节点链表。</li>
<li>输出链表的内容。</li>
</ul>
</li>
</ol>
<h3 id="示例运行结果-1"><a href="#示例运行结果-1" class="headerlink" title="示例运行结果"></a>示例运行结果</h3><p>对于构建的示例二叉树，输出的叶节点链表将是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">叶节点链表: D E F G </span><br></pre></td></tr></table></figure></p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n)，其中 n 是二叉树的节点数，因为每个节点被访问一次。</li>
<li><strong>空间复杂度</strong>：O(n)，用于存储链表和递归调用栈的空间。</li>
</ul>
<h2 id="17-设计一个算法判断两棵二叉树是否相似。"><a href="#17-设计一个算法判断两棵二叉树是否相似。" class="headerlink" title="17.设计一个算法判断两棵二叉树是否相似。"></a>17.设计一个算法判断两棵二叉树是否相似。</h2><p>相似的定义如下：</p>
<ul>
<li>两棵二叉树 $T_1$ 和 $T_2$ 都为空的二叉树，或都只有一个根节点；</li>
<li>$T_1$ 的左子树与 $T_2$ 的左子树相似，且 $T_1$ 的右子树与 $T_2$ 的右子树相似。</li>
</ul>
<h3 id="算法思想-3"><a href="#算法思想-3" class="headerlink" title="算法思想"></a>算法思想</h3><p>我们可以使用递归的方式来判断两棵二叉树是否相似。具体步骤如下：</p>
<ol>
<li><p><strong>基准情况</strong>：</p>
<ul>
<li>如果两棵树都为空，返回相似（返回1）。</li>
<li>如果其中一棵树为空而另一棵树不为空，返回不相似（返回0）。</li>
</ul>
</li>
<li><p><strong>递归比较</strong>：</p>
<ul>
<li>如果两棵树都不为空，递归判断它们的左子树和右子树是否相似：<ul>
<li>调用 <code>similar(T1-&gt;lchild, T2-&gt;lchild)</code> 检查左子树。</li>
<li>调用 <code>similar(T1-&gt;rchild, T2-&gt;rchild)</code> 检查右子树。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>返回结果</strong>：</p>
<ul>
<li>返回左子树和右子树的相似性结果的逻辑与（AND）值。</li>
</ul>
</li>
</ol>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是 C 语言的完整实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span>* <span class="title">lchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span>* <span class="title">rchild</span>;</span></span><br><span class="line">&#125; BiTreeNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两棵二叉树是否相似的函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">similar</span><span class="params">(BiTree T1, BiTree T2)</span> &#123;</span><br><span class="line">    <span class="comment">// 两树皆空</span></span><br><span class="line">    <span class="keyword">if</span> (T1 == <span class="literal">NULL</span> &amp;&amp; T2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// 相似</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 只有一棵树为空</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (T1 == <span class="literal">NULL</span> || T2 == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 不相似</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 递归判断左子树和右子树</span></span><br><span class="line">        <span class="type">int</span> leftS = similar(T1-&gt;lchild, T2-&gt;lchild);</span><br><span class="line">        <span class="type">int</span> rightS = similar(T1-&gt;rchild, T2-&gt;rchild);</span><br><span class="line">        <span class="keyword">return</span> leftS &amp;&amp; rightS; <span class="comment">// 返回相似性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="代码解释-3"><a href="#代码解释-3" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>数据结构定义</strong>：</p>
<ul>
<li><code>BiTreeNode</code> 表示二叉树节点，包含数据和左右子节点指针。</li>
</ul>
</li>
<li><p><strong>相似性判断函数 <code>similar</code></strong>：</p>
<ul>
<li>首先判断两棵树是否都为空。</li>
<li>然后判断其中一棵树是否为空。</li>
<li>递归调用检查左子树和右子树的相似性，最终返回它们的逻辑与值。</li>
</ul>
</li>
<li><p><strong>主函数 <code>main</code></strong>：</p>
<ul>
<li>创建两棵示例二叉树 <code>tree1</code> 和 <code>tree2</code>。</li>
<li>调用 <code>similar</code> 函数判断它们是否相似，并输出结果。</li>
</ul>
</li>
</ol>
<h3 id="示例运行结果-2"><a href="#示例运行结果-2" class="headerlink" title="示例运行结果"></a>示例运行结果</h3><p>对于上面创建的示例二叉树，输出将是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两棵二叉树相似</span><br></pre></td></tr></table></figure></p>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(n)，其中 n 是较小树的节点数，因为每个节点最多被访问一次。</li>
<li><strong>空间复杂度</strong>：O(h)，其中 h 是树的高度，主要用于递归调用的栈空间。</li>
</ul>
<h2 id="18-在中序线索二叉树中，设计一个算法查找指定结点在后序遍历中的前驱结点。后序遍历的前驱结点是指在后序序列中紧接在该结点之前的结点。"><a href="#18-在中序线索二叉树中，设计一个算法查找指定结点在后序遍历中的前驱结点。后序遍历的前驱结点是指在后序序列中紧接在该结点之前的结点。" class="headerlink" title="18.在中序线索二叉树中，设计一个算法查找指定结点在后序遍历中的前驱结点。后序遍历的前驱结点是指在后序序列中紧接在该结点之前的结点。"></a>18.在中序线索二叉树中，设计一个算法查找指定结点在后序遍历中的前驱结点。后序遍历的前驱结点是指在后序序列中紧接在该结点之前的结点。</h2><h3 id="算法思想-4"><a href="#算法思想-4" class="headerlink" title="算法思想"></a>算法思想</h3><ol>
<li><p><strong>判断右子女</strong>：</p>
<ul>
<li>如果结点 $ p $ 有右子女（即 $ p $ 的右线索为 0），则 $ p $ 的右子女是其后序前驱。</li>
</ul>
</li>
<li><p><strong>判断左子女</strong>：</p>
<ul>
<li>如果结点 $ p $ 只有左子女（即 $ p $ 的右线索为 1，且左线索为 0），则 $ p $ 的左子女是其后序前驱。</li>
</ul>
</li>
<li><p><strong>无子女情况</strong>：</p>
<ul>
<li>如果结点 $ p $ 既没有左子女也没有右子女，则需要向上查找。我们沿着左线索查找 $ p $ 的祖先，直到找到一个祖先有左子女的结点，该左子女即为 $ p $ 的后序前驱。</li>
<li>特殊情况：如果 $ p $ 是中序遍历的第一个结点，则 $ p $ 在中序和后序遍历下均无前驱。</li>
</ul>
</li>
</ol>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><p>以下是 C 语言的完整实现代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrTreeNode</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrTreeNode</span>* <span class="title">lchild</span>;</span> <span class="comment">// 左子女指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrTreeNode</span>* <span class="title">rchild</span>;</span> <span class="comment">// 右子女指针</span></span><br><span class="line">    <span class="type">int</span> ltag; <span class="comment">// 左线索标志，0表示有左子女，1表示左线索</span></span><br><span class="line">    <span class="type">int</span> rtag; <span class="comment">// 右线索标志，0表示有右子女，1表示右线索</span></span><br><span class="line">&#125; BiThrTreeNode, *BiThrTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查找后序前驱结点的函数</span></span><br><span class="line">BiThrTree <span class="title function_">InPostPre</span><span class="params">(BiThrTree tBiThrTree p)</span> &#123;</span><br><span class="line">    BiThrTree q = <span class="literal">NULL</span>; <span class="comment">// 初始化前驱结点指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若结点p有右子女，则右子女是其后序前驱</span></span><br><span class="line">    <span class="keyword">if</span> (p-&gt;rtag == <span class="number">0</span>) &#123;</span><br><span class="line">        q = p-&gt;rchild; <span class="comment">// 找到右子女</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 若结点p没有右子女，但有左子女，则左子女是其后序前驱</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>) &#123;</span><br><span class="line">        q = p-&gt;lchild; <span class="comment">// 找到左子女</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 若结点p无左子女和右子女</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;lchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// p是中序序列第一结点，无后序前驱</span></span><br><span class="line">        q = <span class="literal">NULL</span>; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 顺左线索向上找p的祖先，若存在，再找祖先的左子女</span></span><br><span class="line">        <span class="keyword">while</span> (p-&gt;ltag == <span class="number">1</span> &amp;&amp; p-&gt;lchild != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            p = p-&gt;lchild; <span class="comment">// 沿左线索向上查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 若找到的祖先有左子女，则该左子女是p的后序前驱</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;ltag == <span class="number">0</span>) &#123;</span><br><span class="line">            q = p-&gt;lchild; <span class="comment">// 找到祖先的左子女</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 仅有单支树(p是叶子)，已到根结点，p无后序前驱</span></span><br><span class="line">            q = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q; <span class="comment">// 返回后序前驱结点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="代码解释-4"><a href="#代码解释-4" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>数据结构定义</strong>：</p>
<ul>
<li><code>BiThrTreeNode</code> 表示中序线索二叉树的节点，包含数据和左右子节点指针，以及左右线索标志。</li>
</ul>
</li>
<li><p><strong>查找后序前驱的函数 <code>InPostPre</code></strong>：</p>
<ul>
<li>首先判断结点 $ p $ 是否有右子女。</li>
<li>如果没有右子女，接着判断是否有左子女。</li>
<li>如果都没有，判断 $ p $ 是否是中序序列的第一个结点。</li>
<li>若以上条件都不满足，向上查找祖先的左子女。</li>
</ul>
</li>
<li><p><strong>主函数 <code>main</code></strong>：</p>
<ul>
<li>构造一棵简单的中序线索二叉树。</li>
<li>调用 <code>InPostPre</code> 函数查找结点 $ C $ 的后序前驱，并输出结果。</li>
</ul>
</li>
</ol>
<h3 id="示例运行结果-3"><a href="#示例运行结果-3" class="headerlink" title="示例运行结果"></a>示例运行结果</h3><p>对于上面构造的示例树，输出将是：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">结点C的后序前驱是：A</span><br></pre></td></tr></table></figure></p>
<h3 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul>
<li><strong>时间复杂度</strong>：O(h)，其中 h 是树的高度，主要取决于沿着线索查找的路径长度。</li>
<li><strong>空间复杂度</strong>：O(1)，不使用额外的存储空间。</li>
</ul>
<h2 id="19-2014统考真题：二叉树的带权路径长度-WPL-是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树-T，采用二叉链表存储，结点结构如下："><a href="#19-2014统考真题：二叉树的带权路径长度-WPL-是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树-T，采用二叉链表存储，结点结构如下：" class="headerlink" title="19.2014统考真题：二叉树的带权路径长度 (WPL) 是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树 T，采用二叉链表存储，结点结构如下："></a>19.2014统考真题：二叉树的带权路径长度 (WPL) 是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树 T，采用二叉链表存储，结点结构如下：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span>  <span class="comment">// 指向左子树</span></span><br><span class="line">    <span class="type">int</span> weight;         <span class="comment">// 叶结点的权值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span> <span class="comment">// 指向右子树</span></span><br><span class="line">&#125; BiTree;</span><br></pre></td></tr></table></figure>
<p>设 <code>root</code> 为指向 T 的根结点的指针，请设计求 T 的 WPL 的算法，要求：</p>
<ol>
<li>给出算法的基本设计思想。</li>
<li>使用 C 或 C++ 语言，给出二叉树结点的数据类型定义。</li>
<li>根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释。</li>
</ol>
<h4 id="1-算法的基本设计思想"><a href="#1-算法的基本设计思想" class="headerlink" title="1) 算法的基本设计思想"></a>1) 算法的基本设计思想</h4><p>二叉树的带权路径长度 (WPL) 是所有叶结点的带权路径长度之和。带权路径长度是指每个叶结点的权值乘以其到根结点的路径长度。</p>
<p>为了求得 WPL，可以采用递归遍历的方法，遍历整棵树并对每个叶结点进行处理。具体步骤如下：</p>
<ul>
<li>定义一个递归函数，接收当前节点和当前深度作为参数。</li>
<li>如果当前节点是叶结点，则将其权值乘以当前深度，并累加到 WPL 中。</li>
<li>如果当前节点不是叶结点，则递归遍历其左子树和右子树，深度加一。</li>
</ul>
<h4 id="1-基于先序遍历的算法"><a href="#1-基于先序遍历的算法" class="headerlink" title="1. 基于先序遍历的算法"></a>1. 基于先序遍历的算法</h4><p>以下是基于先序遍历的 WPL 计算算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树节点的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span>* <span class="title">left</span>;</span>   <span class="comment">// 指向左子树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span>* <span class="title">right</span>;</span>  <span class="comment">// 指向右子树</span></span><br><span class="line">    <span class="type">int</span> weight;                <span class="comment">// 叶结点的权值</span></span><br><span class="line">&#125; BiTreeNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算 WPL 的主函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">WPL</span><span class="params">(BiTree root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> wplPreOrder(root, <span class="number">0</span>); <span class="comment">// 从根节点开始遍历，深度初始化为 0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现先序遍历计算 WPL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">wplPreOrder</span><span class="params">(BiTree root, <span class="type">int</span> depth)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> wpl = <span class="number">0</span>; <span class="comment">// 静态变量存储 WPL</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="comment">// 如果当前结点为空，则返回</span></span><br><span class="line">        <span class="keyword">return</span> wpl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是叶节点，累加 WPL</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        wpl += depth * root-&gt;weight;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        wplPreOrder(root-&gt;left, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        wplPreOrder(root-&gt;right, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wpl; <span class="comment">// 返回 WPL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-基于层次遍历的算法"><a href="#2-基于层次遍历的算法" class="headerlink" title="2. 基于层次遍历的算法"></a>2. 基于层次遍历的算法</h4><p>以下是基于层次遍历的 WPL 计算算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100 <span class="comment">// 定义队列的最大容量</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树节点的定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span>* <span class="title">left</span>;</span>   <span class="comment">// 指向左子树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTreeNode</span>* <span class="title">right</span>;</span>  <span class="comment">// 指向右子树</span></span><br><span class="line">    <span class="type">int</span> weight;                <span class="comment">// 叶结点的权值</span></span><br><span class="line">&#125; BiTreeNode, *BiTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 层次遍历计算 WPL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">WPL_LevelOrder</span><span class="params">(BiTree root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 如果根节点为空，返回 0</span></span><br><span class="line"></span><br><span class="line">    BiTree q[MaxSize]; <span class="comment">// 队列数组</span></span><br><span class="line">    <span class="type">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>; <span class="comment">// 队列的头指针和尾指针</span></span><br><span class="line">    <span class="type">int</span> wpl = <span class="number">0</span>; <span class="comment">// 存储 WPL</span></span><br><span class="line">    <span class="type">int</span> depth = <span class="number">0</span>; <span class="comment">// 存储当前深度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将根节点入队</span></span><br><span class="line">    q[tail++] = root; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环遍历队列</span></span><br><span class="line">    <span class="keyword">while</span> (head &lt; tail) &#123;</span><br><span class="line">        <span class="type">int</span> levelSize = tail - head; <span class="comment">// 当前层的节点数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">            BiTree t = q[head++]; <span class="comment">// 取出队列头元素</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 如果是叶节点，统计 WPL</span></span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left == <span class="literal">NULL</span> &amp;&amp; t-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                wpl += depth * t-&gt;weight;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果左子树存在，将左子树入队</span></span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                q[tail++] = t-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果右子树存在，将右子树入队</span></span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                q[tail++] = t-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        depth++; <span class="comment">// 深度加 1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> wpl; <span class="comment">// 返回 WPL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="20-【2017统考真题】：请设计一个算法，将给定的表达式树（即二叉树）转换为等价的中缀表达式（通过括号反映操作符的计算次序）并输出。例如，当下列两表达式树作为算法的输入时，输出的等价中缀表达式分别为-a-b-c-d-和-a-b-c-d-。"><a href="#20-【2017统考真题】：请设计一个算法，将给定的表达式树（即二叉树）转换为等价的中缀表达式（通过括号反映操作符的计算次序）并输出。例如，当下列两表达式树作为算法的输入时，输出的等价中缀表达式分别为-a-b-c-d-和-a-b-c-d-。" class="headerlink" title="20.【2017统考真题】：请设计一个算法，将给定的表达式树（即二叉树）转换为等价的中缀表达式（通过括号反映操作符的计算次序）并输出。例如，当下列两表达式树作为算法的输入时，输出的等价中缀表达式分别为 $ (a+b)(c(-d)) $ 和 $ (a*b)+(-(c-d)) $。"></a>20.【2017统考真题】：请设计一个算法，将给定的表达式树（即二叉树）转换为等价的中缀表达式（通过括号反映操作符的计算次序）并输出。例如，当下列两表达式树作为算法的输入时，输出的等价中缀表达式分别为 $ (a+b)<em>(c</em>(-d)) $ 和 $ (a*b)+(-(c-d)) $。</h2><p>二叉树节点定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">10</span>]; <span class="comment">// 存储操作数或操作符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>, *<span class="title">right</span>;</span> <span class="comment">// 指向左右子树</span></span><br><span class="line">&#125; BTree;</span><br></pre></td></tr></table></figure>
<p>要求：</p>
<ol>
<li>给出算法的基本设计思想。</li>
<li>根据设计思想，采用 C 或 C++ 语言描述算法，关键之处给出注释。</li>
</ol>
<h3 id="一、算法的基本设计思想"><a href="#一、算法的基本设计思想" class="headerlink" title="一、算法的基本设计思想"></a>一、算法的基本设计思想</h3><p>要将表达式树转换为等价的中缀表达式，需要基于中序遍历的策略，并在适当的位置加上括号。基本步骤如下：</p>
<ol>
<li><p><strong>中序遍历</strong>：按照中序遍历的顺序访问树的结点，从而形成一个表达式的线性表示。</p>
</li>
<li><p><strong>括号处理</strong>：</p>
<ul>
<li>当遍历到一个分支结点（操作符）时，若其有子树，则在输出该操作符前后添加括号，以确保操作符的计算顺序符合优先级。</li>
<li>叶结点（操作数）直接输出，不需要添加括号。</li>
</ul>
</li>
<li><p><strong>控制深度</strong>：通过深度参数控制何时添加括号。根结点和叶结点不需要添加括号，而内部结点需要根据其子树的存在情况决定。</p>
</li>
</ol>
<h3 id="二、算法实现"><a href="#二、算法实现" class="headerlink" title="二、算法实现"></a>二、算法实现</h3><p>以下是使用 C 语言实现的算法，包含二叉树结点的定义和转换为中缀表达式的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> data[<span class="number">10</span>];             <span class="comment">// 存储操作数或操作符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">left</span>;</span>        <span class="comment">// 指向左子树</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">right</span>;</span>       <span class="comment">// 指向右子树</span></span><br><span class="line">&#125; BTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将表达式树转换为中缀表达式的主函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BTreeToE</span><span class="params">(BTree *root)</span> &#123;</span><br><span class="line">    BTreeToExp(root, <span class="number">1</span>); <span class="comment">// 根的高度为 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归实现中序遍历生成中缀表达式</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BTreeToExp</span><span class="params">(BTree *root, <span class="type">int</span> deep)</span> &#123;</span><br><span class="line">    <span class="comment">// 空结点返回</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是叶结点，直接输出操作数</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, root-&gt;data);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果有子表达式，则加左括号</span></span><br><span class="line">        <span class="keyword">if</span> (deep &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;(&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历左子树</span></span><br><span class="line">        BTreeToExp(root-&gt;left, deep + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出操作符</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, root-&gt;data);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 递归遍历右子树</span></span><br><span class="line">        BTreeToExp(root-&gt;right, deep + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有子表达式，则加右括号</span></span><br><span class="line">        <span class="keyword">if</span> (deep &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><ol>
<li><p><strong>结点定义</strong>：<code>BTree</code> 结构体包含操作数/操作符及其左右子树的指针。</p>
</li>
<li><p><strong>BTreeToE 函数</strong>：主函数，负责初始化调用中序遍历的递归函数 <code>BTreeToExp</code>。</p>
</li>
<li><p><strong>BTreeToExp 函数</strong>：</p>
<ul>
<li>递归遍历树的结点。</li>
<li>如果当前结点是叶结点（无子树），直接输出操作数。</li>
<li>如果是分支结点，则在遍历左子树前加左括号，在遍历右子树后加右括号，确保操作符的优先级被正确反映。</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.totorocatcat.top/">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/2024/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A8%8B%E5%BA%8F%E9%A2%98/">http://totorocatcat.top/2024/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A8%8B%E5%BA%8F%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8F%90%E9%AB%98/">提高</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/598fbde0bcb1378156ac7a1118bc74d1dbbc7803.jpg@1256w_1376h_!web-article-pic.avif" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%A0%91%E4%B8%8E%E6%A3%AE%E6%9E%97/" title="数据结构之树与森林"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/774e5b329acf13ade6eeac8c1af1103c395143382.jpg@1256w_1542h_!web-article-pic.avif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构之树与森林</div></div></a></div><div class="next-post pull-right"><a href="/2024/10/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%89%E6%8B%A9%E9%A2%98/" title="数据结构之二叉树的遍历和线索二叉树选择题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/7580ab121e73175551c16369691479a955200ed5.jpg@1256w_890h_!web-article-pic.avif" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">数据结构之二叉树的遍历和线索二叉树选择题</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/09/10/01%EF%BC%89/" title="CS61B 课程笔记（Lecture 01）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/v2-8ec31f81be5877162f6b605704025fce_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-10</div><div class="title">CS61B 课程笔记（Lecture 01）</div></div></a></div><div><a href="/2024/09/11/02%EF%BC%89/" title="CS61B 课程笔记（Lecture 02）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/v2-2ed7f4c9e1a7a699a3ef300a6f761abe_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-11</div><div class="title">CS61B 课程笔记（Lecture 02）</div></div></a></div><div><a href="/2024/09/12/03%EF%BC%89/" title="CS61B 课程笔记（Lecture 03）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/v2-2ed7f4c9e1a7a699a3ef300a6f761abe_720w.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-12</div><div class="title">CS61B 课程笔记（Lecture 03）</div></div></a></div><div><a href="/2024/09/13/04%EF%BC%89/" title="CS61B 课程笔记（Lecture 04）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/2749a496aabc7d650b2912e256582e390a0a636b.jpg@1256w_1246h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-13</div><div class="title">CS61B 课程笔记（Lecture 04）</div></div></a></div><div><a href="/2024/09/16/07%EF%BC%89/" title="CS61B 课程笔记（Lecture 07）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/ef0c9dc1434371965c925677e389b329298252208.png@1256w_1702h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-16</div><div class="title">CS61B 课程笔记（Lecture 07）</div></div></a></div><div><a href="/2024/09/14/05%EF%BC%89/" title="CS61B 课程笔记（Lecture 05）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4ccebbc43a0ca31a719afadee2f86b4902402baf.jpg@1256w_786h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-14</div><div class="title">CS61B 课程笔记（Lecture 05）</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description">热爱文学的SCUT软件学院学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">746</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E7%A8%8B%E5%BA%8F%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">数据结构之二叉树的遍历和线索二叉树程序题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#01-%E8%8B%A5%E6%9F%90%E9%9D%9E%E7%A9%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97%E5%92%8C%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%E6%AD%A3%E5%A5%BD%E7%9B%B8%E5%8F%8D%EF%BC%8C%E5%88%99%E8%AF%A5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BD%A2%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">01. 若某非空二叉树的先序序列和后序序列正好相反，则该二叉树的形态是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#02-%E8%8B%A5%E6%9F%90%E9%9D%9E%E7%A9%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E5%BA%8F%E5%88%97%E5%92%8C%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%E6%AD%A3%E5%A5%BD%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%88%99%E8%AF%A5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BD%A2%E6%80%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.2.</span> <span class="toc-text">02. 若某非空二叉树的先序序列和后序序列正好相同，则该二叉树的形态是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#03%EF%BC%9A%E7%BC%96%E5%86%99%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E3%80%82"><span class="toc-number">1.3.</span> <span class="toc-text">03：编写后序遍历二叉树的非递归算法。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#04%EF%BC%9A%E8%AF%95%E7%BB%99%E5%87%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E3%80%81%E4%BB%8E%E5%8F%B3%E5%88%B0%E5%B7%A6%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95%E3%80%82"><span class="toc-number">1.4.</span> <span class="toc-text">04：试给出二叉树的自下而上、从右到左的层次遍历算法。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">1.4.1.</span> <span class="toc-text">解释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%EF%BC%9A"><span class="toc-number">1.4.2.</span> <span class="toc-text">结果：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#05%EF%BC%9A%E5%81%87%E8%AE%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E9%87%87%E7%94%A8%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%EF%BC%8C%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E3%80%82"><span class="toc-number">1.5.</span> <span class="toc-text">05：假设二叉树采用二叉链表存储结构，设计一个非递归算法求二叉树的高度。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A-1"><span class="toc-number">1.5.1.</span> <span class="toc-text">解释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%EF%BC%9A-1"><span class="toc-number">1.5.2.</span> <span class="toc-text">结果：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#06%EF%BC%9A%E8%AE%BE%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%90%84%E7%BB%93%E7%82%B9%E7%9A%84%E5%80%BC%E4%BA%92%E4%B8%8D%E7%9B%B8%E5%90%8C%EF%BC%8C%E5%85%B6%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E5%92%8C%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E5%88%86%E5%88%AB%E5%AD%98%E4%BA%8E%E4%B8%A4%E4%B8%AA%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84-A-1-n-%E5%92%8C-B-1-n-%E4%B8%AD%EF%BC%8C%E8%AF%95%E7%BC%96%E5%86%99%E7%AE%97%E6%B3%95%E5%BB%BA%E7%AB%8B%E8%AF%A5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E3%80%82"><span class="toc-number">1.6.</span> <span class="toc-text">06：设一棵二叉树中各结点的值互不相同，其先序遍历序列和中序遍历序列分别存于两个一维数组 $A[1..n]$ 和 $B[1..n]$ 中，试编写算法建立该二叉树的二叉链表。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4%E8%AF%A6%E8%A7%A3%EF%BC%9A"><span class="toc-number">1.6.1.</span> <span class="toc-text">步骤详解：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.6.2.</span> <span class="toc-text">算法实现如下：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A-2"><span class="toc-number">1.6.3.</span> <span class="toc-text">解释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%EF%BC%9A-2"><span class="toc-number">1.6.4.</span> <span class="toc-text">结果：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#07%EF%BC%9A%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%8C%E5%88%A4%E6%96%AD%E5%85%B6%E6%98%AF%E5%90%A6%E4%B8%BA%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%82"><span class="toc-number">1.7.</span> <span class="toc-text">07：给定一个二叉树，判断其是否为完全二叉树。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%EF%BC%9A-1"><span class="toc-number">1.7.1.</span> <span class="toc-text">算法实现如下：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A-3"><span class="toc-number">1.7.2.</span> <span class="toc-text">解释：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#08%EF%BC%9A%E8%AE%A1%E7%AE%97%E4%B8%80%E6%A3%B5%E7%BB%99%E5%AE%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%8C%E5%88%86%E6%94%AF%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%E3%80%82"><span class="toc-number">1.8.</span> <span class="toc-text">08：计算一棵给定二叉树中的所有双分支结点个数。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-number">1.8.1.</span> <span class="toc-text">递归模型：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%EF%BC%9A-2"><span class="toc-number">1.8.2.</span> <span class="toc-text">算法实现如下：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A-4"><span class="toc-number">1.8.3.</span> <span class="toc-text">解释：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#09%EF%BC%9A%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%86%E6%A0%91B%EF%BC%88%E9%87%87%E7%94%A8%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89%E4%B8%AD%E6%89%80%E6%9C%89%E7%BB%93%E7%82%B9%E7%9A%84%E5%B7%A6%E3%80%81%E5%8F%B3%E5%AD%90%E6%A0%91%E8%BF%9B%E8%A1%8C%E4%BA%A4%E6%8D%A2%E3%80%82"><span class="toc-number">1.9.</span> <span class="toc-text">09：编写一个函数，将树B（采用链式结构存储的二叉树）中所有结点的左、右子树进行交换。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%E5%A6%82%E4%B8%8B%EF%BC%9A-3"><span class="toc-number">1.9.1.</span> <span class="toc-text">算法实现如下：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A-5"><span class="toc-number">1.9.2.</span> <span class="toc-text">解释：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%EF%BC%9A%E5%81%87%E8%AE%BE%E4%BA%8C%E5%8F%89%E6%A0%91%E9%87%87%E7%94%A8%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%EF%BC%8C%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%EF%BC%8C%E6%B1%82%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E4%B8%AD%E7%AC%AC-k-%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E5%80%BC%EF%BC%88-1-leq-k-leq-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%EF%BC%89%E3%80%82"><span class="toc-number">1.10.</span> <span class="toc-text">10：假设二叉树采用链式结构存储，设计一个算法，求先序遍历序列中第 $ k $ 个结点的值（$ 1 \leq k \leq $ 二叉树中结点个数）。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.10.1.</span> <span class="toc-text">递归模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.10.2.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A-6"><span class="toc-number">1.10.3.</span> <span class="toc-text">解释：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%EF%BC%9A%E5%B7%B2%E7%9F%A5%E4%BA%8C%E5%8F%89%E6%A0%91%E4%BB%A5%E9%93%BE%E5%BC%8F%E7%BB%93%E6%9E%84%E5%AD%98%E5%82%A8%EF%BC%8C%E7%BC%96%E5%86%99%E7%AE%97%E6%B3%95%E5%AE%8C%E6%88%90%EF%BC%9A%E5%AF%B9%E4%BA%8E%E6%A0%91%E4%B8%AD%E6%AF%8F%E4%B8%AA%E5%85%83%E7%B4%A0%E5%80%BC%E4%B8%BA-x-%E7%9A%84%E7%BB%93%E7%82%B9%EF%BC%8C%E5%88%A0%E5%8E%BB%E4%BB%A5-x-%E4%B8%BA%E6%A0%B9%E7%9A%84%E5%AD%90%E6%A0%91%EF%BC%8C%E5%B9%B6%E9%87%8A%E6%94%BE%E7%9B%B8%E5%BA%94%E7%9A%84%E7%A9%BA%E9%97%B4%E3%80%82"><span class="toc-number">1.11.</span> <span class="toc-text">11：已知二叉树以链式结构存储，编写算法完成：对于树中每个元素值为 $ x $ 的结点，删去以 $ x $ 为根的子树，并释放相应的空间。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4"><span class="toc-number">1.11.1.</span> <span class="toc-text">主要步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.11.2.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A-7"><span class="toc-number">1.11.3.</span> <span class="toc-text">解释：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%EF%BC%9A%E5%9C%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%80%BC%E4%B8%BA-x-%E7%9A%84%E7%BB%93%E7%82%B9%EF%BC%8C%E7%BC%96%E5%86%99%E7%AE%97%E6%B3%95%EF%BC%88%E7%94%A8-C-%E8%AF%AD%E8%A8%80%EF%BC%89%E6%89%93%E5%8D%B0%E5%80%BC%E4%B8%BA-x-%E7%9A%84%E7%BB%93%E7%82%B9%E7%9A%84%E6%89%80%E6%9C%89%E7%A5%96%E5%85%88%EF%BC%8C%E5%81%87%E8%AE%BE%E5%80%BC%E4%B8%BA-x-%E7%9A%84%E7%BB%93%E7%82%B9%E4%B8%8D%E5%A4%9A%E4%BA%8E%E4%B8%80%E4%B8%AA%E3%80%82"><span class="toc-number">1.12.</span> <span class="toc-text">12：在二叉树中查找值为 $ x $ 的结点，编写算法（用 C 语言）打印值为 $ x $ 的结点的所有祖先，假设值为 $ x $ 的结点不多于一个。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">1.12.1.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%AD%A5%E9%AA%A4-1"><span class="toc-number">1.12.2.</span> <span class="toc-text">主要步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.12.3.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">1.12.4.</span> <span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%EF%BC%9A%E8%AE%BE%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84%E4%B8%BA-LLINK-INFO-RLINK-%EF%BC%8CROOT-%E4%B8%BA%E6%8C%87%E5%90%91%E8%AF%A5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%A0%B9%E7%BB%93%E7%82%B9%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%8Cp-%E5%92%8C-q-%E5%88%86%E5%88%AB%E4%B8%BA%E6%8C%87%E5%90%91%E8%AF%A5%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E4%BB%BB%E6%84%8F%E4%B8%A4%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E6%8C%87%E9%92%88%EF%BC%8C%E8%AF%95%E7%BC%96%E5%86%99%E7%AE%97%E6%B3%95-ANCESTOR-ROOT-P-Q-R-%EF%BC%8C%E6%89%BE%E5%88%B0-P-%E5%92%8C-Q-%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88%E7%BB%93%E7%82%B9-R%E3%80%82"><span class="toc-number">1.13.</span> <span class="toc-text">13：设一棵二叉树的结点结构为 (LLINK, INFO, RLINK)，ROOT 为指向该二叉树根结点的指针，p 和 q 分别为指向该二叉树中任意两个结点的指针，试编写算法 ANCESTOR(ROOT, P, Q, R)，找到 P 和 Q 的最近公共祖先结点 R。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-1"><span class="toc-number">1.13.1.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">1.13.2.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="toc-number">1.13.3.</span> <span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E8%A6%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E6%9D%A5%E6%B1%82%E9%9D%9E%E7%A9%BA%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%BD%E5%BA%A6%EF%BC%88%E5%8D%B3%E5%85%B7%E6%9C%89%E7%BB%93%E7%82%B9%E6%95%B0%E6%9C%80%E5%A4%9A%E7%9A%84%E9%82%A3%E4%B8%80%E5%B1%82%E7%9A%84%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0%EF%BC%89%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E9%87%87%E7%94%A8%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%E4%B8%8B%E9%9D%A2%E6%98%AF%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%80%9D%E8%B7%AF%E5%92%8C%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">1.14.</span> <span class="toc-text">14.要设计一个算法来求非空二叉树的宽度（即具有结点数最多的那一层的结点个数），我们可以采用层次遍历的方法。下面是算法的实现思路和详细步骤：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF"><span class="toc-number">1.14.1.</span> <span class="toc-text">算法思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.14.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0-4"><span class="toc-number">1.14.3.</span> <span class="toc-text">算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">1.14.4.</span> <span class="toc-text">代码解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.14.5.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E8%A6%81%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%EF%BC%8C%E5%B0%86%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E5%88%A9%E7%94%A8%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%89%B9%E7%82%B9%E8%BF%9B%E8%A1%8C%E9%80%92%E5%BD%92%E8%BD%AC%E6%8D%A2%E3%80%82%E4%B8%8B%E9%9D%A2%E6%98%AF%E8%AF%A6%E7%BB%86%E7%9A%84%E7%AE%97%E6%B3%95%E8%AF%B4%E6%98%8E%E5%92%8C%E5%AE%9E%E7%8E%B0%E3%80%82"><span class="toc-number">1.15.</span> <span class="toc-text">15.要设计一个算法，将满二叉树的先序遍历序列转换为后序遍历序列，我们可以利用满二叉树的特点进行递归转换。下面是详细的算法说明和实现。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">1.15.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95"><span class="toc-number">1.15.2.</span> <span class="toc-text">递归算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.15.3.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-1"><span class="toc-number">1.15.4.</span> <span class="toc-text">代码解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">1.15.5.</span> <span class="toc-text">示例运行结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E5%B0%86%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E5%8F%B6%E8%8A%82%E7%82%B9%E6%8C%89%E4%BB%8E%E5%B7%A6%E5%88%B0%E5%8F%B3%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%BF%9E%E6%8E%A5%E6%88%90%E4%B8%80%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8%E3%80%82%E4%BA%8C%E5%8F%89%E6%A0%91%E9%87%87%E7%94%A8%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%8F%B6%E8%8A%82%E7%82%B9%E7%9A%84%E5%8F%B3%E6%8C%87%E9%92%88%E5%9F%9F%E7%94%A8%E4%BA%8E%E5%AD%98%E6%94%BE%E9%93%BE%E8%A1%A8%E6%8C%87%E9%92%88%EF%BC%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%B4%E6%8C%87%E9%92%88%E4%B8%BA-head%E3%80%82"><span class="toc-number">1.16.</span> <span class="toc-text">16.我们需要将二叉树的所有叶节点按从左到右的顺序连接成一个单链表。二叉树采用链表存储方式，叶节点的右指针域用于存放链表指针，链表的头指针为 head。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-2"><span class="toc-number">1.16.1.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-1"><span class="toc-number">1.16.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-2"><span class="toc-number">1.16.3.</span> <span class="toc-text">代码解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-1"><span class="toc-number">1.16.4.</span> <span class="toc-text">示例运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">1.16.5.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E5%88%A4%E6%96%AD%E4%B8%A4%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E7%9B%B8%E4%BC%BC%E3%80%82"><span class="toc-number">1.17.</span> <span class="toc-text">17.设计一个算法判断两棵二叉树是否相似。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-3"><span class="toc-number">1.17.1.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2"><span class="toc-number">1.17.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-3"><span class="toc-number">1.17.3.</span> <span class="toc-text">代码解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-2"><span class="toc-number">1.17.4.</span> <span class="toc-text">示例运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-1"><span class="toc-number">1.17.5.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%9C%A8%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%EF%BC%8C%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E6%9F%A5%E6%89%BE%E6%8C%87%E5%AE%9A%E7%BB%93%E7%82%B9%E5%9C%A8%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E4%B8%AD%E7%9A%84%E5%89%8D%E9%A9%B1%E7%BB%93%E7%82%B9%E3%80%82%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E5%89%8D%E9%A9%B1%E7%BB%93%E7%82%B9%E6%98%AF%E6%8C%87%E5%9C%A8%E5%90%8E%E5%BA%8F%E5%BA%8F%E5%88%97%E4%B8%AD%E7%B4%A7%E6%8E%A5%E5%9C%A8%E8%AF%A5%E7%BB%93%E7%82%B9%E4%B9%8B%E5%89%8D%E7%9A%84%E7%BB%93%E7%82%B9%E3%80%82"><span class="toc-number">1.18.</span> <span class="toc-text">18.在中序线索二叉树中，设计一个算法查找指定结点在后序遍历中的前驱结点。后序遍历的前驱结点是指在后序序列中紧接在该结点之前的结点。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-4"><span class="toc-number">1.18.1.</span> <span class="toc-text">算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3"><span class="toc-number">1.18.2.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-4"><span class="toc-number">1.18.3.</span> <span class="toc-text">代码解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C-3"><span class="toc-number">1.18.4.</span> <span class="toc-text">示例运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-number">1.18.5.</span> <span class="toc-text">复杂度分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-2014%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6-WPL-%E6%98%AF%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E6%89%80%E6%9C%89%E5%8F%B6%E7%BB%93%E7%82%B9%E7%9A%84%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%E4%B9%8B%E5%92%8C%E3%80%82%E7%BB%99%E5%AE%9A%E4%B8%80%E6%A3%B5%E4%BA%8C%E5%8F%89%E6%A0%91-T%EF%BC%8C%E9%87%87%E7%94%A8%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8%EF%BC%8C%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">1.19.</span> <span class="toc-text">19.2014统考真题：二叉树的带权路径长度 (WPL) 是二叉树中所有叶结点的带权路径长度之和。给定一棵二叉树 T，采用二叉链表存储，结点结构如下：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">1.19.0.1.</span> <span class="toc-text">1) 算法的基本设计思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%9F%BA%E4%BA%8E%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.19.0.2.</span> <span class="toc-text">1. 基于先序遍历的算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%9F%BA%E4%BA%8E%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.19.0.3.</span> <span class="toc-text">2. 基于层次遍历的算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E3%80%902017%E7%BB%9F%E8%80%83%E7%9C%9F%E9%A2%98%E3%80%91%EF%BC%9A%E8%AF%B7%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%EF%BC%8C%E5%B0%86%E7%BB%99%E5%AE%9A%E7%9A%84%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%EF%BC%88%E5%8D%B3%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%AD%89%E4%BB%B7%E7%9A%84%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88%E9%80%9A%E8%BF%87%E6%8B%AC%E5%8F%B7%E5%8F%8D%E6%98%A0%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%9A%84%E8%AE%A1%E7%AE%97%E6%AC%A1%E5%BA%8F%EF%BC%89%E5%B9%B6%E8%BE%93%E5%87%BA%E3%80%82%E4%BE%8B%E5%A6%82%EF%BC%8C%E5%BD%93%E4%B8%8B%E5%88%97%E4%B8%A4%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91%E4%BD%9C%E4%B8%BA%E7%AE%97%E6%B3%95%E7%9A%84%E8%BE%93%E5%85%A5%E6%97%B6%EF%BC%8C%E8%BE%93%E5%87%BA%E7%9A%84%E7%AD%89%E4%BB%B7%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%88%86%E5%88%AB%E4%B8%BA-a-b-c-d-%E5%92%8C-a-b-c-d-%E3%80%82"><span class="toc-number">1.20.</span> <span class="toc-text">20.【2017统考真题】：请设计一个算法，将给定的表达式树（即二叉树）转换为等价的中缀表达式（通过括号反映操作符的计算次序）并输出。例如，当下列两表达式树作为算法的输入时，输出的等价中缀表达式分别为 $ (a+b)(c(-d)) $ 和 $ (a*b)+(-(c-d)) $。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%AE%97%E6%B3%95%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">1.20.1.</span> <span class="toc-text">一、算法的基本设计思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.20.2.</span> <span class="toc-text">二、算法实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%AF%B4%E6%98%8E"><span class="toc-number">1.20.3.</span> <span class="toc-text">代码说明</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/02/%E7%A6%BB%E6%95%A3PPT%E5%90%88%E9%9B%86/" title="离散PPT问题合集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/db3de1085687df057372811df7dd9d6.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="离散PPT问题合集"/></a><div class="content"><a class="title" href="/2024/12/02/%E7%A6%BB%E6%95%A3PPT%E5%90%88%E9%9B%86/" title="离散PPT问题合集">离散PPT问题合集</a><time datetime="2024-12-02T13:08:12.000Z" title="发表于 2024-12-02 21:08:12">2024-12-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/24/chat5/" title="Chapter 5 Basic Processing Unit"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/7c19b45104600b55d7e0a93de1eaff2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 5 Basic Processing Unit"/></a><div class="content"><a class="title" href="/2024/11/24/chat5/" title="Chapter 5 Basic Processing Unit">Chapter 5 Basic Processing Unit</a><time datetime="2024-11-23T16:15:41.000Z" title="发表于 2024-11-24 00:15:41">2024-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/23/chat39/" title="Chapter 8 Cache(9)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4e0d02920af5e683a1aca9fd37a0596.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 8 Cache(9)"/></a><div class="content"><a class="title" href="/2024/11/23/chat39/" title="Chapter 8 Cache(9)">Chapter 8 Cache(9)</a><time datetime="2024-11-23T04:20:26.000Z" title="发表于 2024-11-23 12:20:26">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/23/chat38/" title="Chapter 8 Cache(8)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/7843e89e553c188c1b98b4e17ae922d.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 8 Cache(8)"/></a><div class="content"><a class="title" href="/2024/11/23/chat38/" title="Chapter 8 Cache(8)">Chapter 8 Cache(8)</a><time datetime="2024-11-23T04:20:09.000Z" title="发表于 2024-11-23 12:20:09">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/23/chat37/" title="Chapter 8 Cache(7)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/2ef847e0b7524acf0407d9664f8d873.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 8 Cache(7)"/></a><div class="content"><a class="title" href="/2024/11/23/chat37/" title="Chapter 8 Cache(7)">Chapter 8 Cache(7)</a><time datetime="2024-11-23T04:19:49.000Z" title="发表于 2024-11-23 12:19:49">2024-11-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HT1PalaKkPaG1UqAXBhJXIu8-gzGzoHsz',
      appKey: 'iT0TnVVAwf9zuZ7NqwclQItY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="1" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="只此无为身，且前行,忘记过去的人注定重蹈覆辙,我是我，我靠自己站立，我会做好自身,如果我睡大觉，谁给我摘月亮呢,假期和朋友，是人生中顶好的两样东西啊。,去爱，去失去，要不负相遇,没什么想不想通的，只是固执而已,我们深爱星辰，乃至不惧夜的黑,吃，喝，享受幸福，接受奇迹,浊水若长流，自清澄,雅俗共赏,总会有什么也不想的幸福时刻吧,时间顺流而下，生活逆流而上,悟已往之不谏，知来者之可追,希望你的小世界里,山花烂漫,茶酒俱全,安宁清淡,明朗欢愉" data-fontsize="20px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS70の旅/&quot;);" href="javascript:void(0);">CS70の旅</a><span class="categoryBar-list-count">25</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS61B/&quot;);" href="javascript:void(0);">CS61B</a><span class="categoryBar-list-count">76</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/期末の旅/&quot;);" href="javascript:void(0);">期末の旅</a><span class="categoryBar-list-count">61</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACMの旅/&quot;);" href="javascript:void(0);">ACMの旅</a><span class="categoryBar-list-count">68</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/区域赛の旅/&quot;);" href="javascript:void(0);">区域赛の旅</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数学建模/&quot;);" href="javascript:void(0);">数学建模</a><span class="categoryBar-list-count">31</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Codeforcesの旅/&quot;);" href="javascript:void(0);">Codeforcesの旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题计划/&quot;);" href="javascript:void(0);">刷题计划</a><span class="categoryBar-list-count">40</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/牛客の旅/&quot;);" href="javascript:void(0);">牛客の旅</a><span class="categoryBar-list-count">65</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/前端の旅/&quot;);" href="javascript:void(0);">前端の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构/&quot;);" href="javascript:void(0);">数据结构</a><span class="categoryBar-list-count">47</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_24.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Atcoderの旅/&quot;);" href="javascript:void(0);">Atcoderの旅</a><span class="categoryBar-list-count">53</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_25.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-の旅/&quot;);" href="javascript:void(0);">C++の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_26.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CSAPPの旅/&quot;);" href="javascript:void(0);">CSAPPの旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_27.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS知识/&quot;);" href="javascript:void(0);">CS知识</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_28.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程基础/&quot;);" href="javascript:void(0);">编程基础</a><span class="categoryBar-list-count">22</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_29.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/离散数学/&quot;);" href="javascript:void(0);">离散数学</a><span class="categoryBar-list-count">29</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_30.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JAVAの旅/&quot;);" href="javascript:void(0);">JAVAの旅</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_31.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MIT-6-031-Software-Construction/&quot;);" href="javascript:void(0);">MIT 6.031:Software Construction</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_32.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS-110L/&quot;);" href="javascript:void(0);">CS 110L</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_33.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/灵魂の旅/&quot;);" href="javascript:void(0);">灵魂の旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_34.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/个人安排/&quot;);" href="javascript:void(0);">个人安排</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_35.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂项/&quot;);" href="javascript:void(0);">杂项</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_36.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">30</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_37.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文学/&quot;);" href="javascript:void(0);">文学</a><span class="categoryBar-list-count">49</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_38.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/力扣の旅/&quot;);" href="javascript:void(0);">力扣の旅</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_39.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/千里十二行/&quot;);" href="javascript:void(0);">千里十二行</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/🗡指offer/&quot;);" href="javascript:void(0);">🗡指offer</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_41.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/少年游/&quot;);" href="javascript:void(0);">少年游</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_42.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法提高课/&quot;);" href="javascript:void(0);">算法提高课</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_43.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/汇编の旅/&quot;);" href="javascript:void(0);">汇编の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-实训/&quot;);" href="javascript:void(0);">C++实训</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4b31456c6f0f4489f99177f89e936de7286431045.png@1256w_708h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt="">诗录</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/51d37eba99d243607ddedfff6e91568f617436609.jpg@1256w_1884h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">TotoroのPlan</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.48/img_482_1920x1080_96_null_normal.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt="">Markdown格式</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>