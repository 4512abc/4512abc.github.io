<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>A Brief Summary for Exam(离散) | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="A Brief Summary for Exam 离散数学考试加油！！！  Propositions命题 (Propositions)    Definition (定义): A proposition is a declarative sentence that is either true or false.命题是一个陈述句，它的真假是确定的。   Truth value (真值): The">
<meta property="og:type" content="article">
<meta property="og:title" content="A Brief Summary for Exam(离散)">
<meta property="og:url" content="http://totorocatcat.top/2024/11/18/Exam/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="A Brief Summary for Exam 离散数学考试加油！！！  Propositions命题 (Propositions)    Definition (定义): A proposition is a declarative sentence that is either true or false.命题是一个陈述句，它的真假是确定的。   Truth value (真值): The">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/9f41e08726c9a62a829f2f2dd69942f.png">
<meta property="article:published_time" content="2024-11-18T08:30:09.000Z">
<meta property="article:modified_time" content="2024-11-18T08:38:18.704Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="兴趣&amp;提高">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/9f41e08726c9a62a829f2f2dd69942f.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/b5ca6e582a7a45e6fde46e616eeb68e.png"><link rel="canonical" href="http://totorocatcat.top/2024/11/18/Exam/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":765,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'A Brief Summary for Exam(离散)',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-11-18 16:38:18'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">802</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/9f41e08726c9a62a829f2f2dd69942f.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">A Brief Summary for Exam(离散)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-18T08:30:09.000Z" title="发表于 2024-11-18 16:30:09">2024-11-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-18T08:38:18.704Z" title="更新于 2024-11-18 16:38:18">2024-11-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/">离散数学</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>75分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="A Brief Summary for Exam(离散)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2024/11/18/Exam/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2024/11/18/Exam/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="A-Brief-Summary-for-Exam"><a href="#A-Brief-Summary-for-Exam" class="headerlink" title="A Brief Summary for Exam"></a><strong>A Brief Summary for Exam</strong></h1><blockquote>
<p>离散数学考试加油！！！</p>
</blockquote>
<h3 id="Propositions"><a href="#Propositions" class="headerlink" title="Propositions"></a><strong>Propositions</strong></h3><p><strong>命题 (Propositions)</strong>  </p>
<ul>
<li><strong>Definition (定义):</strong> A proposition is a declarative sentence that is either true or false.<br><strong>命题是一个陈述句，它的真假是确定的。</strong>  </li>
<li><strong>Truth value (真值):</strong> The truth value of a proposition is either <strong>true (T)</strong> or <strong>false (F)</strong>.<br><strong>命题的真值是“真”或“假”。</strong></li>
</ul>
<h3 id="Propositional-Symbols"><a href="#Propositional-Symbols" class="headerlink" title="Propositional Symbols"></a><strong>Propositional Symbols</strong></h3><p><strong>命题符号 (Propositional Symbols)</strong>  </p>
<ul>
<li><strong>Definition (定义):</strong> A propositional symbol represents a proposition. For example, $ p, q, r $ are commonly used symbols for propositions.<br><strong>命题符号代表一个命题。例如，$ p, q, r $ 是常用的命题符号。</strong></li>
</ul>
<h3 id="Operators"><a href="#Operators" class="headerlink" title="Operators"></a><strong>Operators</strong></h3><p><strong>运算符 (Operators)</strong>  </p>
<ul>
<li><strong>Negation ($\neg$)</strong>: The negation of a proposition $ p $ is $ \neg p $, meaning “not $ p $.” If $ p $ is true, $ \neg p $ is false, and vice versa.<br><strong>否定 ($\neg$)：命题 $ p $ 的否定是 $ \neg p $，表示“不是 $ p $”。如果 $ p $ 为真，$ \neg p $ 为假，反之亦然。</strong></li>
<li><strong>Conjunction ($\land$)</strong>: The conjunction of two propositions $ p $ and $ q $ is $ p \land q $, meaning “both $ p $ and $ q $.” It is true only when both $ p $ and $ q $ are true.<br><strong>合取 ($\land$)：命题 $ p $ 和 $ q $ 的合取是 $ p \land q $，表示“$ p $ 和 $ q $ 都为真”。当且仅当 $ p $ 和 $ q $ 都为真时，$ p \land q $ 才为真。</strong></li>
<li><strong>Disjunction ($\lor$)</strong>: The disjunction of $ p $ and $ q $ is $ p \lor q $, meaning “either $ p $ or $ q $.” It is false only when both $ p $ and $ q $ are false.<br><strong>析取 ($\lor$)：命题 $ p $ 和 $ q $ 的析取是 $ p \lor q $，表示“要么 $ p $，要么 $ q $”。当且仅当 $ p $ 和 $ q $ 都为假时，$ p \lor q $ 才为假。</strong></li>
<li><strong>Implication ($\rightarrow$)</strong>: The implication $ p \rightarrow q $ means “if $ p $, then $ q $.” It is false only when $ p $ is true and $ q $ is false.<br><strong>蕴含 ($\rightarrow$)：命题 $ p \rightarrow q $ 表示“如果 $ p $，那么 $ q $”。当且仅当 $ p $ 为真且 $ q $ 为假时，$ p \rightarrow q $ 才为假。</strong></li>
<li><strong>Biconditional ($\leftrightarrow$)</strong>: The biconditional $ p \leftrightarrow q $ means “$ p $ if and only if $ q $.” It is true when $ p $ and $ q $ have the same truth value.<br><strong>双条件 ($\leftrightarrow$)：命题 $ p \leftrightarrow q $ 表示“当且仅当 $ p $ 和 $ q $ 具有相同的真值时”。</strong></li>
</ul>
<h3 id="Truth-Tables"><a href="#Truth-Tables" class="headerlink" title="Truth Tables"></a><strong>Truth Tables</strong></h3><p><strong>真值表 (Truth Tables)</strong>  </p>
<ul>
<li><strong>Definition (定义):</strong> A truth table is a table used to show the truth values of a compound proposition based on the truth values of its components.<br><strong>真值表是用于显示复合命题的真值的表格，基于其组成部分的真值。</strong></li>
</ul>
<h3 id="Composite-Propositions"><a href="#Composite-Propositions" class="headerlink" title="Composite Propositions"></a><strong>Composite Propositions</strong></h3><p><strong>复合命题 (Composite Propositions)</strong>  </p>
<ul>
<li><strong>Definition (定义):</strong> A composite proposition is a proposition formed by combining two or more simpler propositions using logical operators.<br><strong>复合命题是通过逻辑运算符组合两个或更多简单命题形成的命题。</strong></li>
</ul>
<h3 id="Tautology-and-Contradiction"><a href="#Tautology-and-Contradiction" class="headerlink" title="Tautology and Contradiction"></a><strong>Tautology and Contradiction</strong></h3><p><strong>重言式与矛盾式 (Tautology and Contradiction)</strong>  </p>
<ul>
<li><strong>Tautology (重言式):</strong> A tautology is a proposition that is always true, no matter the truth values of the individual components.<br><strong>重言式是一个无论组成部分的真值如何，始终为真的命题。</strong></li>
<li><strong>Contradiction (矛盾式):</strong> A contradiction is a proposition that is always false.<br><strong>矛盾式是一个始终为假的命题。</strong></li>
</ul>
<h3 id="Equivalence-of-Propositional-Statements"><a href="#Equivalence-of-Propositional-Statements" class="headerlink" title="Equivalence of Propositional Statements"></a><strong>Equivalence of Propositional Statements</strong></h3><p><strong>命题的等价性 (Equivalence of Propositional Statements)</strong>  </p>
<ul>
<li><strong>Definition (定义):</strong> Two propositional statements are equivalent if they have the same truth value in all cases.<br><strong>两个命题等价，当且仅当它们在所有情况下具有相同的真值。</strong></li>
</ul>
<h3 id="Equivalence-Laws"><a href="#Equivalence-Laws" class="headerlink" title="Equivalence Laws"></a><strong>Equivalence Laws</strong></h3><p><strong>等价律 (Equivalence Laws)</strong>  </p>
<ul>
<li><strong>Definition (定义):</strong> Equivalence laws are a set of rules used to transform one proposition into an equivalent proposition. Examples include:<br><strong>等价律是用于将一个命题转化为等价命题的一组规则。例如：</strong><ul>
<li><strong>De Morgan’s Laws</strong>:  <ul>
<li>$ \neg (p \land q) \equiv \neg p \lor \neg q $  </li>
<li>$ \neg (p \lor q) \equiv \neg p \land \neg q $<br><strong>德摩根定律：</strong></li>
<li>$ \neg (p \land q) \equiv \neg p \lor \neg q $</li>
<li>$ \neg (p \lor q) \equiv \neg p \land \neg q $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Proving-Equivalence"><a href="#Proving-Equivalence" class="headerlink" title="Proving Equivalence"></a><strong>Proving Equivalence</strong></h3><p><strong>证明命题等价 (Proving Equivalence)</strong>  </p>
<ul>
<li><strong>By Truth Table (通过真值表):</strong> Construct the truth table for both propositions and compare the results. If their truth values match for every possible input, the propositions are equivalent.<br><strong>通过真值表：构造两个命题的真值表，并比较结果。如果它们对每种可能的输入的真值都匹配，那么这两个命题是等价的。</strong></li>
<li><strong>By Equivalence Laws (通过等价律)：</strong> Apply the equivalence laws to transform one proposition into another.<br><strong>通过等价律：应用等价律将一个命题转化为另一个命题。</strong></li>
</ul>
<h3 id="Predicates"><a href="#Predicates" class="headerlink" title="Predicates"></a><strong>Predicates</strong></h3><p><strong>谓词 (Predicates)</strong>  </p>
<ul>
<li><strong>Definition (定义):</strong> A predicate is a statement that contains one or more variables and becomes a proposition when the variables are replaced by specific values.<br><strong>谓词是一个包含一个或多个变量的陈述，当变量被特定值替代时，它变成一个命题。</strong><br>Example:  <ul>
<li>$ P(x) $: “x is a prime number.”<br><strong>例如：</strong><ul>
<li>$ P(x) $：“x 是一个质数。”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Universal-and-Existential-Quantifiers"><a href="#Universal-and-Existential-Quantifiers" class="headerlink" title="Universal and Existential Quantifiers"></a><strong>Universal and Existential Quantifiers</strong></h3><p><strong>全称量词与存在量词 (Universal and Existential Quantifiers)</strong>  </p>
<ul>
<li><p><strong>Universal Quantifier ($\forall$)</strong>: The universal quantifier is used to express that a predicate holds for all elements in a domain. It is read as “for all.”<br><strong>全称量词 ($\forall$)：用于表示一个谓词对某个领域中的所有元素都成立。读作“对于所有”。</strong><br>Example:  </p>
<ul>
<li>$ \forall x \, P(x) $: “For all $ x $, $ x $ is a prime number.”<br><strong>例如：</strong>  <ul>
<li>$ \forall x \, P(x) $：“对于所有 $ x $，$ x $ 是一个质数。”</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Existential Quantifier ($\exists$)</strong>: The existential quantifier is used to express that there exists at least one element in the domain for which the predicate holds. It is read as “there exists.”<br><strong>存在量词 ($\exists$)：用于表示在某个领域中存在至少一个元素使得谓词成立。读作“存在”。</strong><br>Example:  </p>
<ul>
<li>$ \exists x \, P(x) $: “There exists an $ x $ such that $ x $ is a prime number.”<br><strong>例如：</strong>  <ul>
<li>$ \exists x \, P(x) $： “存在一个 $ x $，使得 $ x $ 是一个质数。”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Duality-of-Universal-and-Existential-Quantifiers"><a href="#Duality-of-Universal-and-Existential-Quantifiers" class="headerlink" title="Duality of Universal and Existential Quantifiers"></a><strong>Duality of Universal and Existential Quantifiers</strong></h3><p><strong>全称量词与存在量词的对偶性 (Duality of Quantifiers)</strong>  </p>
<ul>
<li><p><strong>Duality:</strong> The universal quantifier and the existential quantifier are duals of each other. This means that:  </p>
<ul>
<li>The negation of a universal statement becomes an existential statement, and vice versa.  </li>
<li><strong>对偶性：</strong> 全称量词与存在量词是对偶的。这意味着：  <ul>
<li>全称命题的否定变成存在命题，反之亦然。</li>
</ul>
</li>
</ul>
<p>Example:  </p>
<ul>
<li>$ \neg \forall x \, P(x) \equiv \exists x \, \neg P(x) $<br><strong>例如：</strong>  <ul>
<li>$ \neg \forall x \, P(x) \equiv \exists x \, \neg P(x) $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Predicates-Becoming-Propositions"><a href="#Predicates-Becoming-Propositions" class="headerlink" title="Predicates Becoming Propositions"></a><strong>Predicates Becoming Propositions</strong></h3><p><strong>谓词变为命题 (When Predicates Become Propositions)</strong>  </p>
<ul>
<li>A predicate becomes a proposition when all of its variables are replaced by specific values.<br><strong>当谓词的所有变量都被特定值替代时，谓词变为命题。</strong><br>Example:  <ul>
<li>$ P(x) $: “x is an even number.”  </li>
<li>If $ x = 4 $, $ P(4) $ becomes the proposition “4 is an even number,” which is true.<br><strong>例如：</strong>  <ul>
<li>$ P(x) $：“x 是偶数。”</li>
<li>如果 $ x = 4 $，$ P(4) $ 变成命题“4 是偶数”，这是对的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Instantiation-and-Quantification-of-Variables"><a href="#Instantiation-and-Quantification-of-Variables" class="headerlink" title="Instantiation and Quantification of Variables"></a><strong>Instantiation and Quantification of Variables</strong></h3><p><strong>变量的实例化与量化 (Instantiation and Quantification of Variables)</strong>  </p>
<ul>
<li><p><strong>Instantiation (实例化):</strong> Replacing a variable in a predicate with a specific value, making it a proposition.<br><strong>实例化：将谓词中的变量替换为特定值，使其成为命题。</strong><br>Example:  </p>
<ul>
<li>$ \forall x \, P(x) $: “For all $ x $, $ P(x) $ is true.”  </li>
<li>If we instantiate $ x $ with $ 2 $, we get $ P(2) $: “2 is even.”<br><strong>例如：</strong>  <ul>
<li>$ \forall x \, P(x) $：“对于所有 $ x $，$ P(x) $ 都为真。”</li>
<li>如果我们实例化 $ x $ 为 $ 2 $，我们得到 $ P(2) $：“2 是偶数。”</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Quantification (量化):</strong> The process of applying a quantifier (either universal or existential) to a predicate.<br><strong>量化：对谓词应用量词（全称量词或存在量词）的过程。</strong></p>
</li>
</ul>
<h3 id="Nested-Quantifiers"><a href="#Nested-Quantifiers" class="headerlink" title="Nested Quantifiers"></a><strong>Nested Quantifiers</strong></h3><p><strong>嵌套量词 (Nested Quantifiers)</strong>  </p>
<ul>
<li><strong>Definition (定义):</strong> Nested quantifiers are quantifiers that appear within the scope of another quantifier. They can be used to express more complex logical relationships.<br><strong>嵌套量词是出现在另一个量词范围内的量词。它们可以用来表达更复杂的逻辑关系。</strong><br>Example:  <ul>
<li>$ \forall x \, \exists y \, P(x, y) $: “For all $ x $, there exists a $ y $ such that $ P(x, y) $ is true.”<br><strong>例如：</strong>  <ul>
<li>$ \forall x \, \exists y \, P(x, y) $： “对于所有 $ x $，存在一个 $ y $，使得 $ P(x, y) $ 为真。”</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Quantifiers-with-Negation"><a href="#Quantifiers-with-Negation" class="headerlink" title="Quantifiers with Negation"></a><strong>Quantifiers with Negation</strong></h3><p><strong>量词与否定 (Quantifiers with Negation)</strong>  </p>
<ul>
<li><p><strong>Universal Quantifier with Negation:</strong><br>$ \neg \forall x \, P(x) \equiv \exists x \, \neg P(x) $<br>The negation of a universal quantifier turns it into an existential quantifier.<br><strong>全称量词与否定：</strong><br>$ \neg \forall x \, P(x) \equiv \exists x \, \neg P(x) $<br>全称量词的否定变为存在量词。</p>
</li>
<li><p><strong>Existential Quantifier with Negation:</strong><br>$ \neg \exists x \, P(x) \equiv \forall x \, \neg P(x) $<br>The negation of an existential quantifier turns it into a universal quantifier.<br><strong>存在量词与否定：</strong><br>$ \neg \exists x \, P(x) \equiv \forall x \, \neg P(x) $<br>存在量词的否定变为全称量词。</p>
</li>
</ul>
<h3 id="Logical-Expressions-with-Predicates-Operators-and-Quantifiers"><a href="#Logical-Expressions-with-Predicates-Operators-and-Quantifiers" class="headerlink" title="Logical Expressions with Predicates, Operators, and Quantifiers"></a><strong>Logical Expressions with Predicates, Operators, and Quantifiers</strong></h3><p><strong>由谓词、运算符和量词构成的逻辑表达式 (Logical Expressions Formed by Predicates, Operators, and Quantifiers)</strong>  </p>
<ul>
<li>A logical expression can include predicates, operators (such as $ \neg, \land, \lor, \rightarrow $), and quantifiers (universal or existential). These expressions allow us to represent complex logical relationships between variables.<br><strong>逻辑表达式可以包含谓词、运算符（如 $ \neg, \land, \lor, \rightarrow $）和量词（全称量词或存在量词）。这些表达式使我们能够表示变量之间的复杂逻辑关系。</strong><br>Example:  <ul>
<li>$ \forall x \, \exists y \, (P(x, y) \land Q(x, y)) $: “For all $ x $, there exists a $ y $ such that both $ P(x, y) $ and $ Q(x, y) $ are true.”<br><strong>例如：</strong>  <ul>
<li>$ \forall x \, \exists y \, (P(x, y) \land Q(x, y)) $： “对于所有 $ x $，存在一个 $ y $，使得 $ P(x, y) $ 和 $ Q(x, y) $ 都为真。”</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Rules-of-Inference"><a href="#Rules-of-Inference" class="headerlink" title="Rules of Inference"></a><strong>Rules of Inference</strong></h3><p><strong>推理规则 (Rules of Inference)</strong>  </p>
<ul>
<li><strong>Definition (定义):</strong> Rules of inference are logical rules used to derive conclusions from premises. These rules are essential for constructing valid arguments and proofs.<br><strong>推理规则是用来从前提推导结论的逻辑规则。这些规则对于构建有效的论证和证明至关重要。</strong></li>
</ul>
<h4 id="Common-Rules-of-Inference"><a href="#Common-Rules-of-Inference" class="headerlink" title="Common Rules of Inference:"></a>Common Rules of Inference:</h4><ul>
<li><p><strong>Modus Ponens (MP) (肯定前件):</strong>  </p>
<ul>
<li>If $ P \rightarrow Q $ and $ P $, then $ Q $.<br><strong>如果 $ P \rightarrow Q $ 且 $ P $ 为真，则 $ Q $ 为真。</strong><br>Example:  <ul>
<li>$ P \rightarrow Q $, $ P $ ⟹ $ Q $<br><strong>例如：</strong>  <ul>
<li>$ P \rightarrow Q $，$ P $ ⟹ $ Q $</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Modus Tollens (MT) (否定后件):</strong>  </p>
<ul>
<li>If $ P \rightarrow Q $ and $ \neg Q $, then $ \neg P $.<br><strong>如果 $ P \rightarrow Q $ 且 $ \neg Q $，则 $ \neg P $。</strong><br>Example:  <ul>
<li>$ P \rightarrow Q $, $ \neg Q $ ⟹ $ \neg P $<br><strong>例如：</strong>  <ul>
<li>$ P \rightarrow Q $，$ \neg Q $ ⟹ $ \neg P $</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Resolution (消解法):</strong>  </p>
<ul>
<li>Resolving two clauses to derive a new clause.<br><strong>通过消解两个子句得到一个新子句。</strong><br>Example:  <ul>
<li>$ P \lor Q $, $ \neg P $ ⟹ $ Q $<br><strong>例如：</strong>  <ul>
<li>$ P \lor Q $，$ \neg P $ ⟹ $ Q $</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Simplification (简化法):</strong>  </p>
<ul>
<li>From $ P \land Q $, infer $ P $ (and also infer $ Q $ similarly).<br><strong>从 $ P \land Q $ 推导出 $ P $（同理也可以推导出 $ Q $）。</strong><br>Example:  <ul>
<li>$ P \land Q $ ⟹ $ P $<br><strong>例如：</strong>  <ul>
<li>$ P \land Q $ ⟹ $ P $</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Addition (加法法):</strong>  </p>
<ul>
<li>From $ P $, infer $ P \lor Q $.<br><strong>从 $ P $ 推导出 $ P \lor Q $。</strong><br>Example:  <ul>
<li>$ P $ ⟹ $ P \lor Q $<br><strong>例如：</strong>  <ul>
<li>$ P $ ⟹ $ P \lor Q $</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Universal-and-Existential-Instantiation-Generalization"><a href="#Universal-and-Existential-Instantiation-Generalization" class="headerlink" title="Universal and Existential Instantiation/Generalization"></a><strong>Universal and Existential Instantiation/Generalization</strong></h3><p><strong>全称量化与存在量化实例化/泛化 (Universal and Existential Instantiation/Generalization)</strong>  </p>
<ul>
<li><p><strong>Universal Instantiation (全称量化实例化):</strong><br>If $ \forall x \, P(x) $, then $ P(a) $ for any specific value $ a $.<br><strong>如果 $ \forall x \, P(x) $，则对于任何特定值 $ a $，$ P(a) $ 都为真。</strong><br>Example:  </p>
<ul>
<li>$ \forall x \, P(x) $ ⟹ $ P(a) $<br><strong>例如：</strong>  <ul>
<li>$ \forall x \, P(x) $ ⟹ $ P(a) $</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Existential Instantiation (存在量化实例化):</strong><br>If $ \exists x \, P(x) $, then we can introduce a specific instance $ c $ such that $ P(c) $ is true.<br><strong>如果 $ \exists x \, P(x) $，则我们可以引入一个特定实例 $ c $，使得 $ P(c) $ 为真。</strong><br>Example:  </p>
<ul>
<li>$ \exists x \, P(x) $ ⟹ $ P(c) $<br><strong>例如：</strong>  <ul>
<li>$ \exists x \, P(x) $ ⟹ $ P(c) $</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Universal Generalization (全称量化泛化):</strong><br>If $ P(a) $ holds for an arbitrary $ a $, then we can generalize to $ \forall x \, P(x) $.<br><strong>如果 $ P(a) $ 对任意的 $ a $ 都成立，则可以推广为 $ \forall x \, P(x) $。</strong><br>Example:  </p>
<ul>
<li>$ P(a) $ for arbitrary $ a $ ⟹ $ \forall x \, P(x) $<br><strong>例如：</strong>  <ul>
<li>对任意 $ a $，$ P(a) $ ⟹ $ \forall x \, P(x) $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Valid-Argument"><a href="#Valid-Argument" class="headerlink" title="Valid Argument"></a><strong>Valid Argument</strong></h3><p><strong>有效论证 (Valid Argument)</strong>  </p>
<ul>
<li><strong>Definition (定义):</strong> An argument is valid if and only if the conclusion logically follows from the premises. In a valid argument, it is impossible for the premises to be true and the conclusion false.<br><strong>有效论证是指仅当结论从前提中逻辑地推导出来时才成立。在有效论证中，前提为真而结论为假的情况是不可能发生的。</strong><br>Example:  <ul>
<li>Premises: $ P $, $ P \rightarrow Q $  </li>
<li>Conclusion: $ Q $<br><strong>例如：</strong>  <ul>
<li>前提：$ P $，$ P \rightarrow Q $  </li>
<li>结论：$ Q $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Construction-of-Valid-Argument-using-Rules-of-Inference"><a href="#Construction-of-Valid-Argument-using-Rules-of-Inference" class="headerlink" title="Construction of Valid Argument using Rules of Inference"></a><strong>Construction of Valid Argument using Rules of Inference</strong></h3><p><strong>使用推理规则构建有效论证 (Construction of Valid Argument Using Rules of Inference)</strong>  </p>
<ul>
<li>To construct a valid argument, each step must use one of the inference rules, and we should write down each rule used along with the statements involved.<br><strong>要构建有效的论证，每一步都必须使用推理规则，并且应该写出每个规则及其使用的陈述。</strong></li>
</ul>
<p>Example:  </p>
<ul>
<li><p>Premises:  </p>
<ol>
<li>$ P $  </li>
<li>$ P \rightarrow Q $  </li>
</ol>
</li>
<li><p>Inference:  </p>
<ol>
<li><p>$ Q $ (from 1 and 2 using Modus Ponens)<br><strong>例如：</strong>  </p>
<ul>
<li>前提：  <ol>
<li>$ P $  </li>
<li>$ P \rightarrow Q $  </li>
</ol>
</li>
<li>推理：  <ol>
<li>$ Q $（由 1 和 2 使用肯定前件推理得出）</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="Proof-Methods-证明方法"><a href="#Proof-Methods-证明方法" class="headerlink" title="Proof Methods (证明方法)"></a><strong>Proof Methods (证明方法)</strong></h3><p><strong>证明方法 (Proof Methods)</strong>  </p>
<h4 id="a-Direct-Proof-直接证明"><a href="#a-Direct-Proof-直接证明" class="headerlink" title="a. Direct Proof (直接证明)"></a>a. <strong>Direct Proof (直接证明)</strong></h4><ul>
<li><strong>Definition (定义):</strong> To prove $ P \rightarrow Q $, assume $ P $ is true and show that $ Q $ must follow logically.<br><strong>直接证明是证明 $ P \rightarrow Q $，假设 $ P $ 为真并证明 $ Q $ 必须跟随其后。</strong><br>Example:  <ul>
<li>To prove: $ P \rightarrow Q $  </li>
<li>Assume $ P $ is true.  </li>
<li>Derive $ Q $ logically.<br><strong>例如：</strong>  <ul>
<li>证明：$ P \rightarrow Q $  </li>
<li>假设 $ P $ 为真。  </li>
<li>逻辑地推导出 $ Q $。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="b-Indirect-Proof-间接证明"><a href="#b-Indirect-Proof-间接证明" class="headerlink" title="b. Indirect Proof (间接证明)"></a>b. <strong>Indirect Proof (间接证明)</strong></h4><ul>
<li><strong>Definition (定义):</strong> To prove $ P \rightarrow Q $, assume $ \neg Q $ is true and show that this leads to a contradiction, thereby proving $ P \rightarrow Q $.<br><strong>间接证明是证明 $ P \rightarrow Q $，假设 $ \neg Q $ 为真并证明这一假设会导致矛盾，从而证明 $ P \rightarrow Q $。</strong><br>Example:  <ul>
<li>Assume $ \neg Q $ is true.  </li>
<li>Derive a contradiction from this assumption.  </li>
<li>Conclude that $ Q $ must be true, so $ P \rightarrow Q $ holds.<br><strong>例如：</strong>  <ul>
<li>假设 $ \neg Q $ 为真。  </li>
<li>从这一假设中推导出矛盾。  </li>
<li>结论是 $ Q $ 必须为真，因此 $ P \rightarrow Q $ 成立。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="c-Proof-by-Contradiction-反证法"><a href="#c-Proof-by-Contradiction-反证法" class="headerlink" title="c. Proof by Contradiction (反证法)"></a>c. <strong>Proof by Contradiction (反证法)</strong></h4><ul>
<li><strong>Definition (定义):</strong> Assume $ \neg Q $ is true and derive a contradiction (i.e., derive both $ r $ and $ \neg r $ for some $ r $). This contradiction shows that $ Q $ must be true.<br>**反证法是假设 $ \neg Q $ 为真并推导出矛盾（即推导出某个 $ r $ 和 $ \</li>
</ul>
<p>neg r $）。这个矛盾表明 $ Q $ 必须为真。**<br>  Example:  </p>
<ul>
<li>Assume $ \neg Q $.  </li>
<li>Derive both $ r $ and $ \neg r $.  </li>
<li>Conclude $ Q $ is true.<br><strong>例如：</strong>  <ul>
<li>假设 $ \neg Q $。  </li>
<li>推导出 $ r $ 和 $ \neg r $。  </li>
<li>结论是 $ Q $ 为真。</li>
</ul>
</li>
</ul>
<h3 id="Basics-of-Set-Theory"><a href="#Basics-of-Set-Theory" class="headerlink" title="Basics of Set Theory"></a><strong>Basics of Set Theory</strong></h3><p><strong>集合理论基础 (Basics)</strong>  </p>
<ul>
<li><strong>Set (集合):</strong> A set is a collection of distinct elements or objects.<br><strong>集合是由不同元素或对象构成的集合。</strong><br>Example:  <ul>
<li>$ A = \{1, 2, 3\} $<br><strong>例如：</strong>  <ul>
<li>$ A = \{1, 2, 3\} $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Membership-Subsets-Cardinality-and-Set-Equality"><a href="#Membership-Subsets-Cardinality-and-Set-Equality" class="headerlink" title="Membership, Subsets, Cardinality, and Set Equality"></a><strong>Membership, Subsets, Cardinality, and Set Equality</strong></h3><p><strong>成员关系、子集、基数和集合的相等 (Membership, Subsets, Cardinality, Set Equality)</strong>  </p>
<ul>
<li><p><strong>Membership (成员关系):</strong> An element $ x $ is a member of a set $ A $ if $ x \in A $.<br><strong>如果元素 $ x $ 属于集合 $ A $，则记作 $ x \in A $。</strong><br>Example:  </p>
<ul>
<li>$ 1 \in A $<br><strong>例如：</strong>  <ul>
<li>$ 1 \in A $</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Subset (子集):</strong> A set $ A $ is a subset of $ B $ if every element of $ A $ is also an element of $ B $, denoted $ A \subseteq B $.<br><strong>如果集合 $ A $ 中的每个元素都是集合 $ B $ 的元素，则称 $ A $ 是 $ B $ 的子集，记作 $ A \subseteq B $。</strong><br>Example:  </p>
<ul>
<li>$ \{1, 2\} \subseteq \{1, 2, 3\} $<br><strong>例如：</strong>  <ul>
<li>$ \{1, 2\} \subseteq \{1, 2, 3\} $</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Cardinality (基数):</strong> The cardinality of a set $ A $, denoted $ |A| $, is the number of elements in $ A $.<br><strong>集合 $ A $ 的基数，记作 $ |A| $，表示集合 $ A $ 中元素的个数。</strong><br>Example:  </p>
<ul>
<li>$ |A| = 3 $ for $ A = \{1, 2, 3\} $<br><strong>例如：</strong>  <ul>
<li>对于 $ A = \{1, 2, 3\} $，$ |A| = 3 $</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Set Equality (集合的相等):</strong> Two sets $ A $ and $ B $ are equal if they have the same elements, denoted $ A = B $.<br><strong>两个集合 $ A $ 和 $ B $ 相等，当且仅当它们包含相同的元素，记作 $ A = B $。</strong><br>Example:  </p>
<ul>
<li>$ A = B $ if $ A = \{1, 2, 3\} $ and $ B = \{3, 2, 1\} $<br><strong>例如：</strong>  <ul>
<li>如果 $ A = \{1, 2, 3\} $ 和 $ B = \{3, 2, 1\} $，则 $ A = B $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Defining-Sets-Enumeration-and-Builder-Function"><a href="#Defining-Sets-Enumeration-and-Builder-Function" class="headerlink" title="Defining Sets: Enumeration and Builder Function"></a><strong>Defining Sets: Enumeration and Builder Function</strong></h3><p><strong>集合的定义：列举法和生成函数 (Defining Sets: Enumeration and Builder Function)</strong>  </p>
<ul>
<li><p><strong>Enumeration (列举法):</strong> A set can be defined by listing its elements.<br><strong>集合可以通过列举它的元素来定义。</strong><br>Example:  </p>
<ul>
<li>$ A = \{1, 2, 3\} $<br><strong>例如：</strong>  <ul>
<li>$ A = \{1, 2, 3\} $</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Builder Function (生成函数):</strong> A set can also be defined by a rule or condition that its elements satisfy.<br><strong>集合也可以通过其元素满足的规则或条件来定义。</strong><br>Example:  </p>
<ul>
<li>$ B = \{x \mid x \text{ is a prime number less than 10}\} = \{2, 3, 5, 7\} $<br><strong>例如：</strong>  <ul>
<li>$ B = \{x \mid x \text{ 是小于 10 的质数}\} = \{2, 3, 5, 7\} $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Cartesian-Product"><a href="#Cartesian-Product" class="headerlink" title="Cartesian Product"></a><strong>Cartesian Product</strong></h3><p><strong>笛卡尔积 (Cartesian Product)</strong>  </p>
<ul>
<li><strong>Definition (定义):</strong> The Cartesian product of two sets $ A $ and $ B $, denoted $ A \times B $, is the set of all ordered pairs $ (a, b) $ where $ a \in A $ and $ b \in B $.<br><strong>两个集合 $ A $ 和 $ B $ 的笛卡尔积，记作 $ A \times B $，是所有有序对 $ (a, b) $ 的集合，其中 $ a \in A $ 且 $ b \in B $。</strong><br>Example:  <ul>
<li>If $ A = \{1, 2\} $ and $ B = \{a, b\} $, then $ A \times B = \{(1, a), (1, b), (2, a), (2, b)\} $<br><strong>例如：</strong>  <ul>
<li>如果 $ A = \{1, 2\} $ 和 $ B = \{a, b\} $，则 $ A \times B = \{(1, a), (1, b), (2, a), (2, b)\} $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Power-Set"><a href="#Power-Set" class="headerlink" title="Power Set"></a><strong>Power Set</strong></h3><p><strong>幂集 (Power Set)</strong>  </p>
<ul>
<li><strong>Definition (定义):</strong> The power set of a set $ A $, denoted $ \mathcal{P}(A) $, is the set of all subsets of $ A $, including the empty set and $ A $ itself.<br><strong>集合 $ A $ 的幂集，记作 $ \mathcal{P}(A) $，是所有 $ A $ 的子集的集合，包括空集和 $ A $ 本身。</strong><br>Example:  <ul>
<li>For $ A = \{1, 2\} $, the power set is $ \mathcal{P}(A) = \{\emptyset, \{1\}, \{2\}, \{1, 2\}\} $<br><strong>例如：</strong>  <ul>
<li>对于 $ A = \{1, 2\} $，幂集是 $ \mathcal{P}(A) = \{\emptyset, \{1\}, \{2\}, \{1, 2\}\} $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Set-Operations"><a href="#Set-Operations" class="headerlink" title="Set Operations"></a><strong>Set Operations</strong></h3><p><strong>集合运算 (Set Operations)</strong>  </p>
<h4 id="a-Union-并集"><a href="#a-Union-并集" class="headerlink" title="a. Union (并集)"></a>a. <strong>Union (并集)</strong></h4><ul>
<li><strong>Definition (定义):</strong> The union of two sets $ A $ and $ B $, denoted $ A \cup B $, is the set of all elements that are in $ A $ or in $ B $ (or in both).<br><strong>两个集合 $ A $ 和 $ B $ 的并集，记作 $ A \cup B $，是所有属于 $ A $ 或 $ B $（或两者）的元素的集合。</strong><br>Example:  <ul>
<li>If $ A = \{1, 2\} $ and $ B = \{2, 3\} $, then $ A \cup B = \{1, 2, 3\} $<br><strong>例如：</strong>  <ul>
<li>如果 $ A = \{1, 2\} $ 和 $ B = \{2, 3\} $，则 $ A \cup B = \{1, 2, 3\} $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="b-Intersection-交集"><a href="#b-Intersection-交集" class="headerlink" title="b. Intersection (交集)"></a>b. <strong>Intersection (交集)</strong></h4><ul>
<li><strong>Definition (定义):</strong> The intersection of two sets $ A $ and $ B $, denoted $ A \cap B $, is the set of all elements that are in both $ A $ and $ B $.<br><strong>两个集合 $ A $ 和 $ B $ 的交集，记作 $ A \cap B $，是所有既属于 $ A $ 又属于 $ B $ 的元素的集合。</strong><br>Example:  <ul>
<li>If $ A = \{1, 2\} $ and $ B = \{2, 3\} $, then $ A \cap B = \{2\} $<br><strong>例如：</strong>  <ul>
<li>如果 $ A = \{1, 2\} $ 和 $ B = \{2, 3\} $，则 $ A \cap B = \{2\} $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="c-Difference-差集"><a href="#c-Difference-差集" class="headerlink" title="c. Difference (差集)"></a>c. <strong>Difference (差集)</strong></h4><ul>
<li><strong>Definition (定义):</strong> The difference of two sets $ A $ and $ B $, denoted $ A - B $, is the set of all elements in $ A $ but not in $ B $.<br>**两个集合 $ A $ 和 $ B $ 的差集，记</li>
</ul>
<p>作 $ A - B $，是所有属于 $ A $ 但不属于 $ B $ 的元素的集合。**<br>  Example:  </p>
<ul>
<li>If $ A = \{1, 2\} $ and $ B = \{2, 3\} $, then $ A - B = \{1\} $<br><strong>例如：</strong>  <ul>
<li>如果 $ A = \{1, 2\} $ 和 $ B = \{2, 3\} $，则 $ A - B = \{1\} $</li>
</ul>
</li>
</ul>
<h4 id="d-Complement-补集"><a href="#d-Complement-补集" class="headerlink" title="d. Complement (补集)"></a>d. <strong>Complement (补集)</strong></h4><ul>
<li><strong>Definition (定义):</strong> The complement of a set $ A $ in a universal set $ U $, denoted $ A’ $, is the set of all elements in $ U $ that are not in $ A $.<br><strong>集合 $ A $ 在全集 $ U $ 中的补集，记作 $ A’ $，是全集中不属于 $ A $ 的所有元素的集合。</strong><br>Example:  <ul>
<li>If $ U = \{1, 2, 3\} $ and $ A = \{1\} $, then $ A’ = \{2, 3\} $<br><strong>例如：</strong>  <ul>
<li>如果 $ U = \{1, 2, 3\} $ 和 $ A = \{1\} $，则 $ A’ = \{2, 3\} $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Set-Identity-Laws"><a href="#Set-Identity-Laws" class="headerlink" title="Set Identity Laws"></a><strong>Set Identity Laws</strong></h3><p><strong>集合恒等律 (Set Identity Laws)</strong>  </p>
<ul>
<li><p><strong>Identity Laws (恒等律):</strong>  </p>
<ul>
<li>$ A \cup \emptyset = A $  </li>
<li>$ A \cap U = A $<br><strong>恒等律：</strong>  <ul>
<li>$ A \cup \emptyset = A $  </li>
<li>$ A \cap U = A $  </li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Complement Laws (补集律):</strong>  </p>
<ul>
<li>$ A \cup A’ = U $  </li>
<li>$ A \cap A’ = \emptyset $<br><strong>补集律：</strong>  <ul>
<li>$ A \cup A’ = U $  </li>
<li>$ A \cap A’ = \emptyset $</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Proving-Set-Equality"><a href="#Proving-Set-Equality" class="headerlink" title="Proving Set Equality"></a><strong>Proving Set Equality</strong></h3><p><strong>证明集合相等 (Proving Set Equality)</strong>  </p>
<ul>
<li><strong>By Identity Laws (通过恒等律证明):</strong> Use the identity laws to show that two sets are equal.<br><strong>通过恒等律：</strong> 使用恒等律证明两个集合相等。  </li>
<li><strong>By Membership Table (通过成员表证明):</strong> List the elements of both sets and check if they match.<br><strong>通过成员表：</strong> 列出两个集合的元素并检查它们是否匹配。  </li>
</ul>
<p>Example:  </p>
<ul>
<li>Prove $ A = B $ by showing that each element of $ A $ is in $ B $ and vice versa.<br><strong>例如：</strong>  <ul>
<li>通过证明 $ A $ 的每个元素都在 $ B $ 中，反之亦然，来证明 $ A = B $。</li>
</ul>
</li>
</ul>
<h3 id="Basics-of-Functions-函数基础"><a href="#Basics-of-Functions-函数基础" class="headerlink" title="Basics of Functions (函数基础)"></a><strong>Basics of Functions (函数基础)</strong></h3><p>A <strong>function</strong> is a relation between a set of inputs (domain) and a set of possible outputs (co-domain) such that each input is related to exactly one output.</p>
<p><strong>函数</strong>是输入集合（定义域）和可能输出集合（值域）之间的关系，其中每个输入值都对应一个唯一的输出值。</p>
<h4 id="What-is-a-Function-什么是函数"><a href="#What-is-a-Function-什么是函数" class="headerlink" title="What is a Function? (什么是函数?)"></a><strong>What is a Function? (什么是函数?)</strong></h4><ul>
<li>A function $ f $ from set $ A $ to set $ B $ is denoted as $ f: A \to B $, meaning that for every element $ x \in A $, there exists exactly one element $ y \in B $ such that $ f(x) = y $.<br><strong>从集合 $ A $ 到集合 $ B $ 的函数记作 $ f: A \to B $，意味着对于每个元素 $ x \in A $，存在唯一的元素 $ y \in B $，使得 $ f(x) = y $。</strong></li>
</ul>
<h4 id="What-is-Not-a-Function-什么不是函数"><a href="#What-is-Not-a-Function-什么不是函数" class="headerlink" title="What is Not a Function? (什么不是函数?)"></a><strong>What is Not a Function? (什么不是函数?)</strong></h4><ul>
<li>A relation where an input has multiple outputs is not a function.<br><strong>一个输入对应多个输出的关系不是函数。</strong><br>Example:  <ul>
<li>$ \{(1, 2), (1, 3)\} $ is not a function because the input $ 1 $ is related to both $ 2 $ and $ 3 $.<br><strong>例如：</strong>  <ul>
<li>$ \{(1, 2), (1, 3)\} $ 不是一个函数，因为输入 $ 1 $ 关联了 $ 2 $ 和 $ 3 $。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Domain-Co-domain-Range-Image-and-Pre-image-定义域、值域、陪域、像集和原像集"><a href="#Domain-Co-domain-Range-Image-and-Pre-image-定义域、值域、陪域、像集和原像集" class="headerlink" title="Domain, Co-domain, Range, Image, and Pre-image (定义域、值域、陪域、像集和原像集)"></a><strong>Domain, Co-domain, Range, Image, and Pre-image (定义域、值域、陪域、像集和原像集)</strong></h3><ul>
<li><p><strong>Domain (定义域):</strong> The set of all possible inputs for the function.<br><strong>定义域：</strong> 函数所有可能输入的集合。<br>Example:  </p>
<ul>
<li>For $ f(x) = x^2 $, the domain could be all real numbers $ \mathbb{R} $.<br><strong>例如：</strong>  <ul>
<li>对于 $ f(x) = x^2 $，定义域可以是所有实数 $ \mathbb{R} $。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Co-domain (陪域):</strong> The set of all possible outputs the function could have, not necessarily the actual outputs.<br><strong>陪域：</strong> 函数可能具有的所有输出集合，但不一定是实际输出。<br>Example:  </p>
<ul>
<li>For $ f(x) = x^2 $ with domain $ \mathbb{R} $, the co-domain is $ \mathbb{R} $.<br><strong>例如：</strong>  <ul>
<li>对于 $ f(x) = x^2 $ 和定义域 $ \mathbb{R} $，陪域是 $ \mathbb{R} $。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Range (值域):</strong> The set of actual outputs that the function produces.<br><strong>值域：</strong> 函数实际产生的输出集合。<br>Example:  </p>
<ul>
<li>For $ f(x) = x^2 $, the range is $ [0, \infty) $ if $ x \in \mathbb{R} $.<br><strong>例如：</strong>  <ul>
<li>对于 $ f(x) = x^2 $，当 $ x \in \mathbb{R} $ 时，值域是 $ [0, \infty) $。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Image (像集):</strong> The actual outputs (same as range) for a specific input.<br><strong>像集：</strong> 对于特定输入的实际输出（与值域相同）。<br>Example:  </p>
<ul>
<li>If $ f(x) = x^2 $ and $ x = 2 $, then the image of $ 2 $ is $ 4 $.<br><strong>例如：</strong>  <ul>
<li>如果 $ f(x) = x^2 $ 且 $ x = 2 $，则 $ 2 $ 的像是 $ 4 $。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Pre-image (原像集):</strong> The set of all elements that map to a given element in the range (or co-domain).<br><strong>原像集：</strong> 所有映射到给定值域（或陪域）中的元素的集合。<br>Example:  </p>
<ul>
<li>For $ f(x) = x^2 $, the pre-image of $ 4 $ is $ \{ -2, 2 \} $.<br><strong>例如：</strong>  <ul>
<li>对于 $ f(x) = x^2 $，$ 4 $ 的原像集是 $ \{ -2, 2 \} $。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Types-of-Functions-函数类型"><a href="#Types-of-Functions-函数类型" class="headerlink" title="Types of Functions (函数类型)"></a><strong>Types of Functions (函数类型)</strong></h3><ul>
<li><p><strong>Injective (One-to-One) Function (单射函数)</strong><br>A function $ f: A \to B $ is injective (one-to-one) if different inputs map to different outputs. In other words, if $ f(a_1) = f(a_2) $, then $ a_1 = a_2 $.<br><strong>函数 $ f: A \to B $ 是单射（一对一）函数，当且仅当不同的输入映射到不同的输出。换句话说，如果 $ f(a_1) = f(a_2) $，则 $ a_1 = a_2 $。</strong><br>Example:  </p>
<ul>
<li>$ f(x) = 2x $ is injective.<br><strong>例如：</strong>  <ul>
<li>$ f(x) = 2x $ 是单射。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Surjective (Onto) Function (满射函数)</strong><br>A function $ f: A \to B $ is surjective (onto) if every element in the co-domain has at least one element in the domain that maps to it.<br><strong>函数 $ f: A \to B $ 是满射（到射）函数，当且仅当值域中的每个元素至少有一个域中的元素映射到它。</strong><br>Example:  </p>
<ul>
<li>$ f(x) = x^2 $ with $ A = \mathbb{R} $ and co-domain $ B = [0, \infty) $ is surjective.<br><strong>例如：</strong>  <ul>
<li>$ f(x) = x^2 $，定义域 $ A = \mathbb{R} $，值域 $ B = [0, \infty) $，是满射。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Bijective (One-to-One Correspondence) Function (双射函数)</strong><br>A function $ f: A \to B $ is bijective if it is both injective and surjective, meaning every element in $ A $ corresponds to exactly one element in $ B $, and every element in $ B $ has a corresponding element in $ A $.<br><strong>函数 $ f: A \to B $ 是双射函数，当且仅当它既是单射又是满射，意味着 $ A $ 中的每个元素对应于 $ B $ 中的一个元素，且 $ B $ 中的每个元素都有一个对应的 $ A $ 中的元素。</strong><br>Example:  </p>
<ul>
<li>$ f(x) = 2x + 1 $ is bijective.<br><strong>例如：</strong>  <ul>
<li>$ f(x) = 2x + 1 $ 是双射。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Inverse-Function-反函数"><a href="#Inverse-Function-反函数" class="headerlink" title="Inverse Function (反函数)"></a><strong>Inverse Function (反函数)</strong></h3><ul>
<li>A function $ f: A \to B $ has an inverse $ f^{-1}: B \to A $ if and only if $ f $ is bijective. The inverse function reverses the mapping: if $ f(a) = b $, then $ f^{-1}(b) = a $.<br><strong>当且仅当函数 $ f: A \to B $ 是双射函数时，它才有反函数 $ f^{-1}: B \to A $。反函数反转映射：如果 $ f(a) = b $，则 $ f^{-1}(b) = a $。</strong><br>Example:  <ul>
<li>If $ f(x) = 2x + 1 $, then $ f^{-1}(x) = \frac{x - 1}{2} $.<br><strong>例如：</strong>  <ul>
<li>如果 $ f(x) = 2x + 1 $，则 $ f^{-1}(x) = \frac{x - 1}{2} $。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Composition-of-Functions-函数的复合"><a href="#Composition-of-Functions-函数的复合" class="headerlink" title="Composition of Functions (函数的复合)"></a><strong>Composition of Functions (函数的复合)</strong></h3><ul>
<li><p>The composition of two functions $ f: A \to B $ and $ g: B \to C $ is a new function $ g \circ f: A \to C $ defined as $ (g \circ f)(a) = g(f(a)) $.<br><strong>两个函数 $ f: A \to B $ 和 $ g: B \to C $ 的复合是一个新的函数 $ g \circ f: A \to C $，定义为 $ (g \circ f)(a) = g(f(a)) $。</strong><br>Example:  </p>
<ul>
<li>If $ f(x) = x + 1 $ and $ g(x) =</li>
</ul>
<p>2x $, then $ (g \circ f)(x) = g(f(x)) = 2(x + 1) = 2x + 2 $.<br>  <strong>例如：</strong>  </p>
<ul>
<li>如果 $ f(x) = x + 1 $ 且 $ g(x) = 2x $，则 $ (g \circ f)(x) = g(f(x)) = 2(x + 1) = 2x + 2 $。</li>
</ul>
</li>
</ul>
<h3 id="Definitions-of-Relations-关系的定义"><a href="#Definitions-of-Relations-关系的定义" class="headerlink" title="Definitions of Relations (关系的定义)"></a><strong>Definitions of Relations (关系的定义)</strong></h3><ul>
<li><p><strong>(Binary) Relation from A to B (从 A 到 B 的二元关系)</strong><br>A binary relation $ R $ from set $ A $ to set $ B $ is a subset of the Cartesian product $ A \times B $, which consists of ordered pairs $ (a, b) $ where $ a \in A $ and $ b \in B $.<br><strong>从集合 $ A $ 到集合 $ B $ 的二元关系 $ R $ 是笛卡尔积 $ A \times B $ 的一个子集，它由有序对 $ (a, b) $ 组成，其中 $ a \in A $，$ b \in B $。</strong><br>Example:  </p>
<ul>
<li>If $ A = \{1, 2\} $ and $ B = \{a, b\} $, then $ R = \{(1, a), (2, b)\} $ is a relation from $ A $ to $ B $.<br><strong>例如：</strong>  <ul>
<li>如果 $ A = \{1, 2\} $ 和 $ B = \{a, b\} $，则 $ R = \{(1, a), (2, b)\} $ 是从 $ A $ 到 $ B $ 的关系。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Relation on A (集合 A 上的关系)</strong><br>A relation $ R $ on set $ A $ is a subset of $ A \times A $, consisting of ordered pairs $ (a, b) $ where $ a, b \in A $.<br><strong>集合 $ A $ 上的关系 $ R $ 是笛卡尔积 $ A \times A $ 的一个子集，它由有序对 $ (a, b) $ 组成，其中 $ a, b \in A $。</strong><br>Example:  </p>
<ul>
<li>If $ A = \{1, 2, 3\} $, then $ R = \{(1, 1), (2, 3)\} $ is a relation on $ A $.<br><strong>例如：</strong>  <ul>
<li>如果 $ A = \{1, 2, 3\} $，则 $ R = \{(1, 1), (2, 3)\} $ 是集合 $ A $ 上的关系。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>n-ary Relation (n元关系)</strong><br>An $ n $-ary relation $ R $ is a subset of $ A_1 \times A_2 \times \dots \times A_n $, consisting of ordered $ n $-tuples $ (a_1, a_2, \dots, a_n) $ where $ a_i \in A_i $ for $ i = 1, 2, \dots, n $.<br><strong>n元关系 $ R $ 是 $ A_1 \times A_2 \times \dots \times A_n $ 的一个子集，它由有序的 $ n $-元组 $ (a_1, a_2, \dots, a_n) $ 组成，其中 $ a_i \in A_i $，$ i = 1, 2, \dots, n $。</strong><br>Example:  </p>
<ul>
<li>If $ A_1 = \{1, 2\} $, $ A_2 = \{a, b\} $, then a 2-ary relation could be $ R = \{(1, a), (2, b)\} $.<br><strong>例如：</strong>  <ul>
<li>如果 $ A_1 = \{1, 2\} $，$ A_2 = \{a, b\} $，则 2 元关系可能是 $ R = \{(1, a), (2, b)\} $。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Functions as Special Cases of Relations (函数是关系的特例)</strong><br>A function is a special case of a binary relation where each element in the domain is related to exactly one element in the co-domain. In contrast, a general binary relation may relate one element to multiple elements.<br><strong>函数是二元关系的特例，其中定义域中的每个元素都与陪域中的一个元素关联。相比之下，一般的二元关系可能将一个元素与多个元素关联。</strong><br>Example:  </p>
<ul>
<li>$ f(x) = x + 1 $ is a function (each $ x $ is related to exactly one $ y $), but $ R = \{(1, 2), (1, 3)\} $ is not a function, as 1 is related to both 2 and 3.<br><strong>例如：</strong>  <ul>
<li>$ f(x) = x + 1 $ 是一个函数（每个 $ x $ 只与一个 $ y $ 关联），但 $ R = \{(1, 2), (1, 3)\} $ 不是函数，因为 $ 1 $ 同时与 $ 2 $ 和 $ 3 $ 关联。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-Properties-of-Relations-关系的性质"><a href="#2-Properties-of-Relations-关系的性质" class="headerlink" title="2. Properties of Relations (关系的性质)"></a>2. <strong>Properties of Relations (关系的性质)</strong></h3><p>Relations can have various properties, which can be identified based on their structure.</p>
<p><strong>关系可以具有多种性质，可以通过它们的结构来识别。</strong></p>
<h4 id="Reflexive-Irreflexive-自反-非自反"><a href="#Reflexive-Irreflexive-自反-非自反" class="headerlink" title="Reflexive / Irreflexive (自反 / 非自反)"></a><strong>Reflexive / Irreflexive (自反 / 非自反)</strong></h4><ul>
<li><p>A relation $ R $ on set $ A $ is <strong>reflexive</strong> if for every element $ a \in A $, $ (a, a) \in R $.<br><strong>集合 $ A $ 上的关系 $ R $ 是自反的，当且仅当对于每个 $ a \in A $，都有 $ (a, a) \in R $。</strong><br>Example:  </p>
<ul>
<li>$ R = \{(1, 1), (2, 2), (3, 3)\} $ is reflexive on $ A = \{1, 2, 3\} $.<br><strong>例如：</strong>  <ul>
<li>$ R = \{(1, 1), (2, 2), (3, 3)\} $ 在集合 $ A = \{1, 2, 3\} $ 上是自反的。</li>
</ul>
</li>
</ul>
</li>
<li><p>A relation $ R $ is <strong>irreflexive</strong> if for no element $ a \in A $, $ (a, a) \in R $.<br><strong>如果对于集合 $ A $ 中的任何元素 $ a $，都没有 $ (a, a) \in R $，则关系 $ R $ 是非自反的。</strong><br>Example:  </p>
<ul>
<li>$ R = \{(1, 2), (2, 3)\} $ is irreflexive on $ A = \{1, 2, 3\} $.<br><strong>例如：</strong>  <ul>
<li>$ R = \{(1, 2), (2, 3)\} $ 在集合 $ A = \{1, 2, 3\} $ 上是非自反的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="Symmetric-Asymmetric-Antisymmetric-对称-非对称-反对称"><a href="#Symmetric-Asymmetric-Antisymmetric-对称-非对称-反对称" class="headerlink" title="Symmetric / Asymmetric / Antisymmetric (对称 / 非对称 / 反对称)"></a><strong>Symmetric / Asymmetric / Antisymmetric (对称 / 非对称 / 反对称)</strong></h4><ul>
<li><p>A relation $ R $ is <strong>symmetric</strong> if for every pair $ (a, b) \in R $, $ (b, a) \in R $.<br><strong>关系 $ R $ 是对称的，当且仅当对于每个 $ (a, b) \in R $，都有 $ (b, a) \in R $。</strong><br>Example:  </p>
<ul>
<li>$ R = \{(1, 2), (2, 1)\} $ is symmetric.<br><strong>例如：</strong>  <ul>
<li>$ R = \{(1, 2), (2, 1)\} $ 是对称的。</li>
</ul>
</li>
</ul>
</li>
<li><p>A relation $ R $ is <strong>asymmetric</strong> if for no pair $ (a, b) \in R $, $ (b, a) \in R $.<br><strong>关系 $ R $ 是非对称的，当且仅当对于任何 $ (a, b) \in R $，都没有 $ (b, a) \in R $。</strong><br>Example:  </p>
<ul>
<li>$ R = \{(1, 2), (2, 3)\} $ is asymmetric.<br><strong>例如：</strong>  <ul>
<li>$ R = \{(1, 2), (2, 3)\} $ 是非对称的。</li>
</ul>
</li>
</ul>
</li>
<li><p>A relation $ R $ is <strong>antisymmetric</strong> if for all pairs $ (a, b) $ and $ (b, a) \in R $, $ a = b $.<br><strong>关系 $ R $ 是反对称的，当且仅当对于所有的对 $ (a, b) $ 和 $ (b, a) \in R $，都有 $ a = b $。</strong><br>Example:  </p>
<ul>
<li>$ R = \{(1, 2), (2, 1), (3, 3)\} $ is not antisymmetric.<br><strong>例如：</strong></li>
</ul>
</li>
</ul>
<pre><code>- $ R = \&#123;(1, 2), (2, 1), (3, 3)\&#125; $ 不是反对称的。
</code></pre><h4 id="Transitive-传递性"><a href="#Transitive-传递性" class="headerlink" title="Transitive (传递性)"></a><strong>Transitive (传递性)</strong></h4><p>A relation $ R $ is <strong>transitive</strong> if whenever $ (a, b) \in R $ and $ (b, c) \in R $, it follows that $ (a, c) \in R $.<br><strong>关系 $ R $ 是传递的，当且仅当对于所有的 $ (a, b) \in R $ 和 $ (b, c) \in R $，都有 $ (a, c) \in R $。</strong><br>Example:  </p>
<ul>
<li>$ R = \{(1, 2), (2, 3), (1, 3)\} $ is transitive.<br><strong>例如：</strong>  <ul>
<li>$ R = \{(1, 2), (2, 3), (1, 3)\} $ 是传递的。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="Combining-Relations-关系的组合"><a href="#Combining-Relations-关系的组合" class="headerlink" title="Combining Relations (关系的组合)"></a><strong>Combining Relations (关系的组合)</strong></h3><ul>
<li><p><strong>Union of Relations (关系的并集)</strong><br>$ R_1 \cup R_2 = \{(a, b) \mid (a, b) \in R_1 \text{ or } (a, b) \in R_2 \} $.<br><strong>并集 $ R_1 \cup R_2 = \{(a, b) \mid (a, b) \in R_1 \text{ 或 } (a, b) \in R_2 \} $。</strong></p>
</li>
<li><p><strong>Intersection of Relations (关系的交集)</strong><br>$ R_1 \cap R_2 = \{(a, b) \mid (a, b) \in R_1 \text{ and } (a, b) \in R_2 \} $.<br><strong>交集 $ R_1 \cap R_2 = \{(a, b) \mid (a, b) \in R_1 \text{ 且 } (a, b) \in R_2 \} $。</strong></p>
</li>
<li><p><strong>Difference of Relations (关系的差集)</strong><br>$ R_1 - R_2 = \{(a, b) \mid (a, b) \in R_1 \text{ and } (a, b) \notin R_2 \} $.<br><strong>差集 $ R_1 - R_2 = \{(a, b) \mid (a, b) \in R_1 \text{ 且 } (a, b) \notin R_2 \} $。</strong></p>
</li>
<li><p><strong>Composition of Relations (关系的复合)</strong><br>The composition of $ R_1 $ and $ R_2 $, denoted $ R_1 \circ R_2 $, consists of all pairs $ (a, c) $ such that there exists a $ b $ where $ (a, b) \in R_1 $ and $ (b, c) \in R_2 $.<br><strong>关系 $ R_1 $ 和 $ R_2 $ 的复合，记作 $ R_1 \circ R_2 $，由所有的有序对 $ (a, c) $ 组成，其中存在一个 $ b $，使得 $ (a, b) \in R_1 $ 且 $ (b, c) \in R_2 $。</strong></p>
</li>
</ul>
<hr>
<h3 id="Representing-Relations-R-from-A-to-B-关系的表示：-R-从-A-到-B"><a href="#Representing-Relations-R-from-A-to-B-关系的表示：-R-从-A-到-B" class="headerlink" title="Representing Relations: $ R $ from $ A $ to $ B $ (关系的表示：$ R $ 从 $ A $ 到 $ B $)"></a>Representing Relations: $ R $ from $ A $ to $ B $ (关系的表示：$ R $ 从 $ A $ 到 $ B $)</h3><h4 id="1-Set-of-Ordered-Pairs-有序对集合"><a href="#1-Set-of-Ordered-Pairs-有序对集合" class="headerlink" title="1. Set of Ordered Pairs (有序对集合)"></a>1. <strong>Set of Ordered Pairs (有序对集合)</strong></h4><p>A relation $ R $ from $ A $ to $ B $ is represented as a set of ordered pairs:<br>$ R = \{ (a, b) \mid aRb \text{ for } (a, b) \in A \times B \} $<br><strong>关系 $ R $ 从集合 $ A $ 到集合 $ B $ 被表示为有序对集合：</strong><br>$ R = \{ (a, b) \mid aRb \text{ 对于 } (a, b) \in A \times B \} $</p>
<ul>
<li><strong>Example (例子):</strong><br>If $ A = \{1, 2\} $ and $ B = \{x, y\} $, and the relation is $ R = \{(1, x), (2, y)\} $, then the relation is the set of ordered pairs $ \{(1, x), (2, y)\} $.<br><strong>例如：</strong><br>如果 $ A = \{1, 2\} $ 和 $ B = \{x, y\} $，并且关系是 $ R = \{(1, x), (2, y)\} $，那么该关系就是有序对集合 $ \{(1, x), (2, y)\} $。</li>
</ul>
<hr>
<h4 id="2-0-–-1-Matrix-0-1-矩阵"><a href="#2-0-–-1-Matrix-0-1-矩阵" class="headerlink" title="2. 0 – 1 Matrix (0-1 矩阵)"></a>2. <strong>0 – 1 Matrix (0-1 矩阵)</strong></h4><p>A relation $ R $ from $ A $ to $ B $ can be represented by a $ |A| \times |B| $ matrix, where each element $ m_{ij} $ is 1 if the pair $ (a_i, b_j) $ belongs to the relation, and 0 otherwise.<br><strong>关系 $ R $ 从 $ A $ 到 $ B $ 可以通过一个 $ |A| \times |B| $ 矩阵表示，其中每个元素 $ m_{ij} $ 为 1，如果有序对 $ (a_i, b_j) $ 属于该关系，否则为 0。</strong></p>
<ul>
<li><strong>Example (例子):</strong><br>If $ A = \{1, 2\} $ and $ B = \{x, y\} $, and $ R = \{(1, x), (2, y)\} $, the matrix would look like this:<br>$<br>\begin{matrix}<br>  m_{11} = 1 &amp; m_{12} = 0 \\<br>  m_{21} = 0 &amp; m_{22} = 1<br>\end{matrix}<br>$<br><strong>例如：</strong><br>如果 $ A = \{1, 2\} $ 和 $ B = \{x, y\} $，并且关系是 $ R = \{(1, x), (2, y)\} $，那么矩阵表示为：<br>$<br>\begin{matrix}<br>  m_{11} = 1 &amp; m_{12} = 0 \\<br>  m_{21} = 0 &amp; m_{22} = 1<br>\end{matrix}<br>$</li>
</ul>
<hr>
<h4 id="3-Directed-Graph-有向图"><a href="#3-Directed-Graph-有向图" class="headerlink" title="3. Directed Graph (有向图)"></a>3. <strong>Directed Graph (有向图)</strong></h4><p>A relation $ R $ from $ A $ to $ B $ can also be represented as a directed graph $ (V, E) $, where $ V = A \cup B $ (or $ V = A $ if the relation is on $ A $) and the edges $ E $ represent the ordered pairs in the relation.<br><strong>关系 $ R $ 从 $ A $ 到 $ B $ 还可以表示为一个有向图 $ (V, E) $，其中 $ V = A \cup B $（如果关系定义在 $ A $ 上，则 $ V = A $），边 $ E $ 表示关系中的有序对。</strong></p>
<ul>
<li><strong>Example (例子):</strong><br>If $ A = \{1, 2\} $ and $ B = \{x, y\} $, and $ R = \{(1, x), (2, y)\} $, the directed graph would have two vertices (1, 2, x, y) and directed edges from 1 to x, and 2 to y.<br><strong>例如：</strong><br>如果 $ A = \{1, 2\} $ 和 $ B = \{x, y\} $，并且关系是 $ R = \{(1, x), (2, y)\} $，则有向图将包含两个顶点（1，2，x，y）和从 1 到 x，以及从 2 到 y 的有向边。</li>
</ul>
<hr>
<h3 id="Converting-Between-Representations-三种表示之间的转换"><a href="#Converting-Between-Representations-三种表示之间的转换" class="headerlink" title="Converting Between Representations (三种表示之间的转换)"></a>Converting Between Representations (三种表示之间的转换)</h3><ol>
<li><p><strong>From Set of Ordered Pairs to 0-1 Matrix (从有序对集合到 0-1 矩阵)</strong><br>For each pair $ (a_i, b_j) \in R $, set $ m_{ij} = 1 $, otherwise $ m_{ij} = 0 $.<br><strong>对于关系中的每一对 $ (a_i, b_j) \in R $，设置 $ m_{ij} = 1 $，否则 $ m_{ij} = 0 $。</strong></p>
</li>
<li><p><strong>From Set of Ordered Pairs to Directed Graph (从有序对集合到有向图)</strong><br>Create a vertex for each element in $ A $ and $ B $, then draw a directed edge from $ a_i $ to $ b_j $ for each $ (a_i, b_j) \in R $.<br><strong>为 $ A $ 和 $ B $ 中的每个元素创建一个顶点，然后为每个 $ (a_i, b_j) \in R $ 从 $ a_i $ 到 $ b_j $ 画一个有向边。</strong></p>
</li>
<li><p><strong>From 0-1 Matrix to Set of Ordered Pairs (从 0-1 矩阵到有序对集合)</strong><br>For each $ m_{ij} = 1 $, include $ (a_i, b_j) $ in the set of ordered pairs.<br><strong>对于每个 $ m_{ij} = 1 $，将 $ (a_i, b_j) $ 包含在有序对集合中。</strong></p>
</li>
<li><p><strong>From Directed Graph to Set of Ordered Pairs (从有向图到有序对集合)</strong><br>For each directed edge from vertex $ a_i $ to vertex $ b_j $, include $ (a_i, b_j) $ in the set of ordered pairs.<br><strong>对于从顶点 $ a_i $ 到顶点 $ b_j $ 的每条有向边，将 $ (a_i, b_j) $ 包含在有序对集合中。</strong></p>
</li>
</ol>
<hr>
<h3 id="Closure-of-Relations-关系的闭包"><a href="#Closure-of-Relations-关系的闭包" class="headerlink" title="Closure of Relations (关系的闭包)"></a>Closure of Relations (关系的闭包)</h3><h4 id="Definition-定义"><a href="#Definition-定义" class="headerlink" title="Definition (定义):"></a>Definition (定义):</h4><p>The closure of a relation $ R $ is obtained by adding the minimum number of ordered pairs to $ R $ to ensure that the relation has a certain property $ P $.<br><strong>关系 $ R $ 的闭包是通过向 $ R $ 添加最少的有序对，使得该关系具有某个属性 $ P $ 而得到的。</strong></p>
<ul>
<li><p><strong>$ R’ \supseteq R $</strong>: The closure $ R’ $ contains $ R $, meaning it includes all the original pairs of the relation.<br><strong>$ R’ \supseteq R $</strong>：闭包 $ R’ $ 包含 $ R $，即它包括关系中的所有原始有序对。</p>
</li>
<li><p><strong>Property $ P $</strong>: The relation $ R’ $ has the property $ P $, which could be reflexivity, symmetry, transitivity, or any other desired property.<br><strong>属性 $ P $</strong>：关系 $ R’ $ 具有属性 $ P $，该属性可以是自反性、对称性、传递性或任何其他期望的属性。</p>
</li>
<li><p>If $ R’’ \supseteq R $ and $ R’’ $ has property $ P $, then $ R’’ \supseteq R’ $, meaning that $ R’ $ is the <strong>smallest</strong> relation with property $ P $ that contains $ R $.<br><strong>如果 $ R’’ \supseteq R $ 且 $ R’’ $ 具有属性 $ P $，则 $ R’’ \supseteq R’ $，这意味着 $ R’ $ 是包含 $ R $ 的具有属性 $ P $ 的最小关系。</strong></p>
</li>
</ul>
<p>Hence, $ R’ $ is called the <strong>$ P $-closure</strong> of $ R $.<br><strong>因此，$ R’ $ 被称为 $ R $ 的 $ P $-闭包。</strong></p>
<hr>
<h4 id="Types-of-Closures-闭包的类型"><a href="#Types-of-Closures-闭包的类型" class="headerlink" title="Types of Closures (闭包的类型)"></a>Types of Closures (闭包的类型)</h4><ol>
<li><p><strong>Reflexive Closure (自反闭包)</strong><br>The <strong>reflexive closure</strong> $ r(R) $ of a relation $ R $ is the smallest reflexive relation that contains $ R $. It is obtained by adding the minimal number of pairs $ (a, a) $ for all $ a \in A $ (the domain of the relation) that are not already in $ R $.<br><strong>自反闭包 $ r(R) $ 是包含关系 $ R $ 的最小自反关系。通过添加所有 $ a \in A $（关系的定义域）中尚未包含在 $ R $ 中的最小数量的对 $ (a, a) $ 来得到它。</strong></p>
<ul>
<li><p><strong>Formally (形式化定义):</strong><br>$<br>r(R) = R \cup \Delta<br>$<br>where $ \Delta $ is the diagonal set $ \{(a, a) \mid a \in A\} $.<br><strong>其中 $ \Delta $ 是对角线集合 $ \{(a, a) \mid a \in A\} $。</strong></p>
</li>
<li><p><strong>Example (例子):</strong><br>If $ R = \{(1, 2), (2, 3)\} $ and $ A = \{1, 2, 3\} $, then the reflexive closure $ r(R) $ would be $ \{(1, 2), (2, 3), (1, 1), (2, 2), (3, 3)\} $.</p>
</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li><p><strong>Symmetric Closure (对称闭包)</strong><br>The <strong>symmetric closure</strong> $ s(R) $ of a relation $ R $ is the smallest symmetric relation that contains $ R $. It is obtained by adding the pairs $ (b, a) $ whenever $ (a, b) \in R $ and $ (b, a) \notin R $.<br><strong>对称闭包 $ s(R) $ 是包含关系 $ R $ 的最小对称关系。通过每当 $ (a, b) \in R $ 且 $ (b, a) \notin R $ 时，添加对 $ (b, a) $ 来得到它。</strong></p>
<ul>
<li><p><strong>Formally (形式化定义):</strong><br>$<br>s(R) = R \cup R^{-1}<br>$<br>where $ R^{-1} $ is the inverse of $ R $, i.e., the set $ \{(b, a) \mid (a, b) \in R\} $.<br><strong>其中 $ R^{-1} $ 是 $ R $ 的逆，即集合 $ \{(b, a) \mid (a, b) \in R\} $。</strong></p>
</li>
<li><p><strong>Example (例子):</strong><br>If $ R = \{(1, 2), (2, 3)\} $, then the symmetric closure $ s(R) $ would be $ \{(1, 2), (2, 3), (2, 1), (3, 2)\} $.</p>
</li>
</ul>
</li>
</ol>
<hr>
<ol>
<li><p><strong>Transitive Closure (传递闭包)</strong><br>The <strong>transitive closure</strong> $ t(R) $ of a relation $ R $ is the smallest transitive relation that contains $ R $. It is obtained by adding the pairs $ (a, c) $ whenever there exists a sequence of pairs $ (a, b) $ and $ (b, c) $ in $ R $, such that $ (a, c) $ is not already in $ R $.<br><strong>传递闭包 $ t(R) $ 是包含关系 $ R $ 的最小传递关系。通过每当 $ R $ 中存在一对序列 $ (a, b) $ 和 $ (b, c) $，且 $ (a, c) $ 尚未包含在 $ R $ 中时，添加对 $ (a, c) $ 来得到它。</strong></p>
<ul>
<li><p><strong>Formally (形式化定义):</strong><br>The transitive closure can be described as:<br>$<br>t(R) = R \cup \{(a, c) \mid \exists b \text{ such that } (a, b) \in R \text{ and } (b, c) \in R\}<br>$<br><strong>传递闭包可以描述为：</strong><br>$<br>t(R) = R \cup \{(a, c) \mid \exists b \text{ 使得 } (a, b) \in R \text{ 且 } (b, c) \in R\}<br>$  </p>
</li>
<li><p><strong>Example (例子):</strong><br>If $ R = \{(1, 2), (2, 3)\} $, then the transitive closure $ t(R) $ would be $ \{(1, 2), (2, 3), (1, 3)\} $.</p>
</li>
</ul>
</li>
</ol>
<ul>
<li><strong>Reflexive Closure (自反闭包):</strong> Adds missing pairs $ (a, a) $ for all $ a \in A $.  </li>
<li><strong>Symmetric Closure (对称闭包):</strong> Adds the inverse of each pair $ (a, b) $, i.e., $ (b, a) $, if not already present.  </li>
<li><strong>Transitive Closure (传递闭包):</strong> Adds pairs $ (a, c) $ if there is a sequence of pairs $ (a, b) $ and $ (b, c) $ in $ R $.  </li>
</ul>
<h3 id="Equivalence-Relations-等价关系"><a href="#Equivalence-Relations-等价关系" class="headerlink" title="Equivalence Relations (等价关系)"></a>Equivalence Relations (等价关系)</h3><h4 id="Definition-定义-1"><a href="#Definition-定义-1" class="headerlink" title="Definition (定义):"></a>Definition (定义):</h4><p>An <strong>equivalence relation</strong> on a set $ A $ is a relation $ R $ that satisfies the following three properties:</p>
<p><strong>等价关系</strong>是集合 $ A $ 上的一种关系 $ R $，它满足以下三种性质：</p>
<ol>
<li><p><strong>Reflexive (自反性)</strong>: For all $ a \in A $, $ aRa $.<br><strong>自反性</strong>：对于所有 $ a \in A $，都有 $ aRa $。</p>
</li>
<li><p><strong>Symmetric (对称性)</strong>: For all $ a, b \in A $, if $ aRb $, then $ bRa $.<br><strong>对称性</strong>：对于所有 $ a, b \in A $，如果 $ aRb $，则 $ bRa $。</p>
</li>
<li><p><strong>Transitive (传递性)</strong>: For all $ a, b, c \in A $, if $ aRb $ and $ bRc $, then $ aRc $.<br><strong>传递性</strong>：对于所有 $ a, b, c \in A $，如果 $ aRb $ 且 $ bRc $，则 $ aRc $。</p>
</li>
</ol>
<hr>
<h4 id="Equivalence-Class-等价类"><a href="#Equivalence-Class-等价类" class="headerlink" title="Equivalence Class (等价类)"></a>Equivalence Class (等价类)</h4><ul>
<li><p>An <strong>equivalence class</strong> of an element $ a \in A $ with respect to the equivalence relation $ R $ is the set of all elements $ b \in A $ that are related to $ a $ by $ R $.<br><strong>等价类</strong>是相对于等价关系 $ R $ 来说，包含所有与元素 $ a \in A $ 通过关系 $ R $ 相关的元素 $ b \in A $ 的集合。</p>
</li>
<li><p>The equivalence class of $ a $ is denoted by $ [a]_R $, and it is defined as:<br><strong>元素 $ a $ 的等价类记作 $ [a]_R $，定义为：</strong><br>$<br>[a]_R = \{ b \in A \mid bRa \}<br>$<br><strong>for all $ b \in A $, if $ bRa $, then $ b \in [a]_R $.</strong><br><strong>对于所有 $ b \in A $，如果 $ bRa $，则 $ b \in [a]_R $。</strong></p>
</li>
<li><p>If $ aRb $, then the equivalence classes $ [a]_R $ and $ [b]_R $ are equal:<br><strong>如果 $ aRb $，则等价类 $ [a]_R $ 和 $ [b]_R $ 是相等的：</strong><br>$<br>[a]_R = [b]_R<br>$<br><strong>and the intersection of the two equivalence classes is non-empty</strong>:<br><strong>且这两个等价类的交集非空：</strong><br>$<br>[a]_R \cap [b]_R \neq \emptyset<br>$</p>
</li>
<li><p>If $ a $ is not related to $ b $ (i.e., $ a \not\sim b $), then their equivalence classes are disjoint:<br><strong>如果 $ a $ 不与 $ b $ 相关（即 $ a \not\sim b $），则它们的等价类是不相交的：</strong><br>$<br>[a]_R \neq [b]_R \quad \text{and} \quad [a]_R \cap [b]_R = \emptyset<br>$</p>
</li>
</ul>
<hr>
<h4 id="Partition-of-a-Set-集合的划分"><a href="#Partition-of-a-Set-集合的划分" class="headerlink" title="Partition of a Set (集合的划分)"></a>Partition of a Set (集合的划分)</h4><p>A set $ A $ is partitioned into equivalence classes by an equivalence relation $ R $ if the following conditions hold:</p>
<p><strong>集合 $ A $ 被等价关系 $ R $ 划分为等价类，当且仅当满足以下条件：</strong></p>
<ol>
<li><p><strong>Non-emptiness (非空性)</strong>: Each equivalence class $ A_i $ is non-empty, i.e., $ A_i \neq \emptyset $ for all $ i \in I $, where $ I $ is the index set.<br><strong>每个等价类 $ A_i $ 是非空的，即对于所有 $ i \in I $，有 $ A_i \neq \emptyset $，其中 $ I $ 是索引集。</strong></p>
</li>
<li><p><strong>Disjointness (互不相交性)</strong>: If $ i \neq j $, then the equivalence classes $ A_i $ and $ A_j $ are disjoint, i.e., $ A_i \cap A_j = \emptyset $.<br><strong>如果 $ i \neq j $，则等价类 $ A_i $ 和 $ A_j $ 互不相交，即 $ A_i \cap A_j = \emptyset $。</strong></p>
</li>
<li><p><strong>Union (并集性)</strong>: The union of all equivalence classes is equal to the set $ A $, i.e.,<br>$<br>\bigcup_{i \in I} A_i = A<br>$<br><strong>所有等价类的并集等于集合 $ A $，即：</strong><br>$<br>\bigcup_{i \in I} A_i = A<br>$</p>
</li>
</ol>
<p>Thus, equivalence classes of a relation $ R $ on a set $ A $ partition the set $ A $ into disjoint subsets.<br><strong>因此，关系 $ R $ 在集合 $ A $ 上的等价类将集合 $ A $ 划分为互不相交的子集。</strong></p>
<ul>
<li><p>An equivalence relation is <strong>reflexive</strong>, <strong>symmetric</strong>, and <strong>transitive</strong>.<br>等价关系是<strong>自反的</strong>、<strong>对称的</strong>和<strong>传递的</strong>。</p>
</li>
<li><p><strong>Equivalence class</strong> $ [a]_R $ is the set of elements related to $ a $ under $ R $.<br><strong>等价类</strong> $ [a]_R $ 是与 $ a $ 在关系 $ R $ 下相关的所有元素的集合。</p>
</li>
<li><p>If $ aRb $, then $ [a]_R = [b]_R $, and the intersection of their equivalence classes is non-empty.<br>如果 $ aRb $，则 $ [a]_R = [b]_R $，且它们的等价类的交集非空。</p>
</li>
<li><p>A set $ A $ is partitioned into equivalence classes by $ R $ if:</p>
<ol>
<li>Each equivalence class is non-empty.  </li>
<li>Equivalence classes are disjoint.  </li>
<li>The union of equivalence classes is $ A $.  </li>
</ol>
<p><strong>集合 $ A $ 被关系 $ R $ 划分为等价类，当且仅当：</strong>  </p>
<ol>
<li>每个等价类是非空的。  </li>
<li>等价类互不相交。  </li>
<li>等价类的并集是 $ A $。</li>
</ol>
</li>
</ul>
<h3 id="Partial-Orderings-偏序关系"><a href="#Partial-Orderings-偏序关系" class="headerlink" title="Partial Orderings (偏序关系)"></a>Partial Orderings (偏序关系)</h3><h4 id="Definition-定义-2"><a href="#Definition-定义-2" class="headerlink" title="Definition (定义):"></a>Definition (定义):</h4><p>A <strong>partial ordering</strong> on a set $ A $ is a binary relation $ \leq $ that satisfies the following three properties:</p>
<p><strong>偏序关系</strong>是集合 $ A $ 上的二元关系 $ \leq $，它满足以下三个性质：</p>
<ol>
<li><p><strong>Reflexive (自反性)</strong>: For all $ a \in A $, $ a \leq a $.<br><strong>自反性</strong>：对于所有 $ a \in A $，都有 $ a \leq a $。</p>
</li>
<li><p><strong>Antisymmetric (反对称性)</strong>: For all $ a, b \in A $, if $ a \leq b $ and $ b \leq a $, then $ a = b $.<br><strong>反对称性</strong>：对于所有 $ a, b \in A $，如果 $ a \leq b $ 且 $ b \leq a $，则 $ a = b $。</p>
</li>
<li><p><strong>Transitive (传递性)</strong>: For all $ a, b, c \in A $, if $ a \leq b $ and $ b \leq c $, then $ a \leq c $.<br><strong>传递性</strong>：对于所有 $ a, b, c \in A $，如果 $ a \leq b $ 且 $ b \leq c $，则 $ a \leq c $。</p>
</li>
</ol>
<hr>
<h4 id="Comparable-and-Incomparable-可比与不可比"><a href="#Comparable-and-Incomparable-可比与不可比" class="headerlink" title="Comparable and Incomparable (可比与不可比)"></a>Comparable and Incomparable (可比与不可比)</h4><ul>
<li><p><strong>Comparable (可比)</strong>: Two elements $ a $ and $ b $ in $ A $ are said to be <strong>comparable</strong> if either $ a \leq b $ or $ b \leq a $.<br><strong>可比</strong>：集合 $ A $ 中的两个元素 $ a $ 和 $ b $，如果满足 $ a \leq b $ 或 $ b \leq a $，则称它们为可比元素。</p>
</li>
<li><p><strong>Incomparable (不可比)</strong>: Two elements $ a $ and $ b $ in $ A $ are said to be <strong>incomparable</strong> if neither $ a \leq b $ nor $ b \leq a $.<br><strong>不可比</strong>：集合 $ A $ 中的两个元素 $ a $ 和 $ b $，如果既不满足 $ a \leq b $，也不满足 $ b \leq a $，则称它们为不可比元素。</p>
</li>
</ul>
<hr>
<h4 id="Types-of-Orderings-序关系的类型"><a href="#Types-of-Orderings-序关系的类型" class="headerlink" title="Types of Orderings (序关系的类型)"></a>Types of Orderings (序关系的类型)</h4><ul>
<li><p><strong>Totally Ordered (全序)</strong>: A set $ A $ is <strong>totally ordered</strong> under a relation $ \leq $ if every pair of elements in $ A $ is comparable. That is, for all $ a, b \in A $, either $ a \leq b $ or $ b \leq a $.<br><strong>全序</strong>：如果集合 $ A $ 中的每一对元素都可比，则称集合 $ A $ 在关系 $ \leq $ 下为全序。即，对于所有 $ a, b \in A $，要么 $ a \leq b $，要么 $ b \leq a $。</p>
</li>
<li><p><strong>Well-Ordered (良序)</strong>: A set $ A $ is <strong>well-ordered</strong> if it is totally ordered and every non-empty subset of $ A $ has a least element.<br><strong>良序</strong>：如果集合 $ A $ 是全序的，且 $ A $ 的每个非空子集都有最小元素，则称集合 $ A $ 为良序。</p>
</li>
<li><p><strong>Lexicographic Order (字典序)</strong>: A set $ A $ of tuples is <strong>lexicographically ordered</strong> if the first components of the tuples are ordered first, then the second components, and so on.<br><strong>字典序</strong>：如果集合 $ A $ 是元组的集合，并且按元组的第一个分量排序，然后是第二个分量，以此类推，则称集合 $ A $ 为字典序。</p>
</li>
</ul>
<hr>
<h4 id="Hasse-Diagrams-哈斯图"><a href="#Hasse-Diagrams-哈斯图" class="headerlink" title="Hasse Diagrams (哈斯图)"></a>Hasse Diagrams (哈斯图)</h4><p>A <strong>Hasse diagram</strong> is a graphical representation of a partial order. It is drawn by:</p>
<ul>
<li>Vertices representing the elements of the set.</li>
<li>Edges representing the relations between elements, where an edge from $ a $ to $ b $ indicates that $ a \leq b $ and there is no element $ c $ such that $ a \leq c \leq b $.<br><strong>哈斯图</strong>是偏序关系的图形表示。它由以下部分组成：<ul>
<li>顶点代表集合中的元素。</li>
<li>边表示元素之间的关系，边从 $ a $ 到 $ b $ 表示 $ a \leq b $，且不存在元素 $ c $ 使得 $ a \leq c \leq b $。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Maximal-and-Minimal-Elements-最大元素和最小元素"><a href="#Maximal-and-Minimal-Elements-最大元素和最小元素" class="headerlink" title="Maximal and Minimal Elements (最大元素和最小元素)"></a>Maximal and Minimal Elements (最大元素和最小元素)</h4><ul>
<li><p><strong>Maximal Element (最大元素)</strong>: An element $ m \in A $ is <strong>maximal</strong> if there is no element $ x \in A $ such that $ m &lt; x $ (i.e., $ m \leq x $ and $ m \neq x $).<br><strong>最大元素</strong>：元素 $ m \in A $ 被称为最大元素，如果没有元素 $ x \in A $ 满足 $ m &lt; x $（即 $ m \leq x $ 且 $ m \neq x $）。</p>
</li>
<li><p><strong>Minimal Element (最小元素)</strong>: An element $ m \in A $ is <strong>minimal</strong> if there is no element $ x \in A $ such that $ x &lt; m $ (i.e., $ x \leq m $ and $ x \neq m $).<br><strong>最小元素</strong>：元素 $ m \in A $ 被称为最小元素，如果没有元素 $ x \in A $ 满足 $ x &lt; m $（即 $ x \leq m $ 且 $ x \neq m $）。</p>
</li>
</ul>
<hr>
<h4 id="Greatest-and-Least-Elements-最大元素与最小元素"><a href="#Greatest-and-Least-Elements-最大元素与最小元素" class="headerlink" title="Greatest and Least Elements (最大元素与最小元素)"></a>Greatest and Least Elements (最大元素与最小元素)</h4><ul>
<li><p><strong>Greatest Element (最大元素)</strong>: An element $ g \in A $ is the <strong>greatest element</strong> if for all $ x \in A $, $ x \leq g $.<br><strong>最大元素</strong>：元素 $ g \in A $ 被称为最大元素，如果对于所有 $ x \in A $，都有 $ x \leq g $。</p>
</li>
<li><p><strong>Least Element (最小元素)</strong>: An element $ l \in A $ is the <strong>least element</strong> if for all $ x \in A $, $ l \leq x $.<br><strong>最小元素</strong>：元素 $ l \in A $ 被称为最小元素，如果对于所有 $ x \in A $，都有 $ l \leq x $。</p>
</li>
</ul>
<hr>
<h4 id="Upper-Bound-and-Lower-Bound-上界与下界"><a href="#Upper-Bound-and-Lower-Bound-上界与下界" class="headerlink" title="Upper Bound and Lower Bound (上界与下界)"></a>Upper Bound and Lower Bound (上界与下界)</h4><ul>
<li><p><strong>Upper Bound (上界)</strong>: An element $ u \in A $ is an <strong>upper bound</strong> of a subset $ B \subseteq A $ if for all $ b \in B $, $ b \leq u $.<br><strong>上界</strong>：元素 $ u \in A $ 是子集 $ B \subseteq A $ 的上界，如果对于所有 $ b \in B $，都有 $ b \leq u $。</p>
</li>
<li><p><strong>Lower Bound (下界)</strong>: An element $ l \in A $ is a <strong>lower bound</strong> of a subset $ B \subseteq A $ if for all $ b \in B $, $ l \leq b $.<br><strong>下界</strong>：元素 $ l \in A $ 是子集 $ B \subseteq A $ 的下界，如果对于所有 $ b \in B $，都有 $ l \leq b $。</p>
</li>
<li><p><strong>Least Upper Bound (lub, 最小上界)</strong>: The <strong>least upper bound</strong> (lub) of a subset $ B \subseteq A $ is the smallest element $ u \in A $ that is an upper bound of $ B $.<br><strong>最小上界</strong>：子集 $ B \subseteq A $ 的最小上界（lub）是集合 $ A $ 中的最小的上界元素 $ u $。</p>
</li>
<li><p><strong>Greatest Lower Bound (glb, 最大下界)</strong>: The <strong>greatest lower bound</strong> (glb) of a subset $ B \subseteq A $ is the largest element $ l \in A $ that is a lower bound of $ B $.<br><strong>最大下界</strong>：子集 $ B \subseteq A $ 的最大下界（glb）是集合 $ A $ 中最大的下界元素 $ l $。</p>
</li>
<li><p><strong>Partial ordering</strong> is a binary relation that is reflexive, antisymmetric, and transitive.<br><strong>偏序关系</strong>是一个自反的、反对称的和传递的二元关系。</p>
</li>
<li><p><strong>Comparable</strong> elements are those that are related by the ordering, while <strong>incomparable</strong> elements are those that are not.<br><strong>可比元素</strong>是指通过偏序关系相关的元素，<strong>不可比元素</strong>则是指没有相关性的元素。</p>
</li>
<li><p>**Tot</p>
</li>
</ul>
<p>ally ordered<strong> sets have a total relation between all elements, while </strong>well-ordered<strong> sets additionally have a least element in every non-empty subset.  
  </strong>全序集合<strong>中所有元素都有一个完整的偏序关系，</strong>良序集合**则是每个非空子集都有最小元素。</p>
<ul>
<li><p><strong>Hasse diagrams</strong> visually represent partial orders, with vertices for elements and edges showing the relations.<br><strong>哈斯图</strong>通过顶点和边来可视化偏序关系。</p>
</li>
<li><p><strong>Maximal</strong>, <strong>minimal</strong>, <strong>greatest</strong>, and <strong>least</strong> elements help to describe the structure of ordered sets, and <strong>upper</strong> and <strong>lower bounds</strong> provide limits on subsets.<br><strong>最大</strong>、<strong>最小</strong>、<strong>最大元素</strong>和<strong>最小元素</strong>描述了有序集合的结构，而<strong>上界</strong>和<strong>下界</strong>则提供了子集的极限。</p>
</li>
</ul>
<h3 id="Graphs-图论-–-Sections-8-1-–-8-8"><a href="#Graphs-图论-–-Sections-8-1-–-8-8" class="headerlink" title="Graphs (图论) – Sections 8.1 – 8.8"></a>Graphs (图论) – Sections 8.1 – 8.8</h3><h4 id="Definitions-定义"><a href="#Definitions-定义" class="headerlink" title="Definitions (定义)"></a>Definitions (定义)</h4><ul>
<li><p><strong>Graph (图)</strong>: A graph $ G $ consists of a set of vertices $ V $ and a set of edges $ E $ where each edge is a pair of vertices.<br><strong>图</strong>：图 $ G $ 由一组顶点 $ V $ 和一组边 $ E $ 组成，每条边是两个顶点的有序或无序对。</p>
</li>
<li><p><strong>Vertex (顶点)</strong>: A point in a graph, denoted by $ v $.<br><strong>顶点</strong>：图中的一个点，通常用 $ v $ 表示。</p>
</li>
<li><p><strong>Edge (边)</strong>: A connection between two vertices, denoted by $ (u, v) $ for undirected graphs or $ (u \to v) $ for directed graphs.<br><strong>边</strong>：两个顶点之间的连接，对于无向图用 $ (u, v) $ 表示，指向图用 $ (u \to v) $ 表示。</p>
</li>
</ul>
<hr>
<h4 id="Simple-Undirected-and-Directed-Graphs-简单图、无向图和有向图"><a href="#Simple-Undirected-and-Directed-Graphs-简单图、无向图和有向图" class="headerlink" title="Simple, Undirected, and Directed Graphs (简单图、无向图和有向图)"></a>Simple, Undirected, and Directed Graphs (简单图、无向图和有向图)</h4><ul>
<li><p><strong>Simple Graph (简单图)</strong>: A graph without loops or multiple edges between any pair of vertices.<br><strong>简单图</strong>：没有环路或任意两顶点之间没有多重边的图。</p>
</li>
<li><p><strong>Undirected Graph (无向图)</strong>: A graph where edges have no direction. An edge between vertices $ u $ and $ v $ is denoted $ (u, v) $.<br><strong>无向图</strong>：边没有方向。两个顶点 $ u $ 和 $ v $ 之间的边用 $ (u, v) $ 表示。</p>
</li>
<li><p><strong>Directed Graph (有向图)</strong>: A graph where edges have direction. An edge between vertices $ u $ and $ v $ is denoted $ (u \to v) $.<br><strong>有向图</strong>：边有方向。两个顶点 $ u $ 和 $ v $ 之间的边用 $ (u \to v) $ 表示。</p>
</li>
</ul>
<hr>
<h4 id="Degree-of-Vertex-顶点的度"><a href="#Degree-of-Vertex-顶点的度" class="headerlink" title="Degree of Vertex (顶点的度)"></a>Degree of Vertex (顶点的度)</h4><ul>
<li><p><strong>Degree (度)</strong>: The degree of a vertex is the number of edges incident to it.<br><strong>度</strong>：顶点的度是与它相连的边的数量。</p>
</li>
<li><p><strong>Indegree (入度)</strong>: In a directed graph, the indegree of a vertex $ v $ is the number of edges directed toward $ v $.<br><strong>入度</strong>：在有向图中，顶点 $ v $ 的入度是指向 $ v $ 的边的数量。</p>
</li>
<li><p><strong>Outdegree (出度)</strong>: In a directed graph, the outdegree of a vertex $ v $ is the number of edges directed away from $ v $.<br><strong>出度</strong>：在有向图中，顶点 $ v $ 的出度是从 $ v $ 指向其他顶点的边的数量。</p>
</li>
</ul>
<hr>
<h4 id="Special-Graphs-特殊图"><a href="#Special-Graphs-特殊图" class="headerlink" title="Special Graphs (特殊图)"></a>Special Graphs (特殊图)</h4><ul>
<li><p><strong>Complete Graph (完全图)</strong>: A graph in which every pair of distinct vertices is connected by a unique edge.<br><strong>完全图</strong>：每一对不同的顶点都有一条独特的边相连的图。</p>
</li>
<li><p><strong>Bipartite Graph (二分图)</strong>: A graph whose vertices can be divided into two disjoint sets such that every edge connects a vertex in one set to a vertex in the other set.<br><strong>二分图</strong>：图的顶点可以分为两个不相交的集合，并且每一条边都连接一个集合中的顶点和另一个集合中的顶点。</p>
</li>
<li><p><strong>Complete Bipartite Graph (完全二分图)</strong>: A bipartite graph in which every vertex in one set is connected to every vertex in the other set.<br><strong>完全二分图</strong>：每个集合中的每个顶点都与另一个集合中的每个顶点相连接的二分图。</p>
</li>
<li><p><strong>N-Cube (n-立方体)</strong>: A graph representing the vertices and edges of an $ n $-dimensional cube. The vertices represent all binary sequences of length $ n $, and an edge exists between two vertices if their sequences differ in exactly one position.<br><strong>n-立方体</strong>：表示 $ n $-维立方体的顶点和边的图。顶点表示长度为 $ n $ 的所有二进制序列，如果两个序列在一个位置上有所不同，则它们之间有一条边。</p>
</li>
</ul>
<hr>
<h4 id="Subgraph-子图"><a href="#Subgraph-子图" class="headerlink" title="Subgraph (子图)"></a>Subgraph (子图)</h4><ul>
<li><strong>Subgraph (子图)</strong>: A subgraph of a graph $ G $ is a graph formed by a subset of the vertices and edges of $ G $.<br><strong>子图</strong>：图 $ G $ 的子图是由 $ G $ 的顶点和边的子集组成的图。</li>
</ul>
<hr>
<h4 id="Adjacency-邻接"><a href="#Adjacency-邻接" class="headerlink" title="Adjacency (邻接)"></a>Adjacency (邻接)</h4><ul>
<li><strong>Adjacency (邻接)</strong>: Two vertices $ u $ and $ v $ are adjacent if there is an edge between them. In undirected graphs, this means $ (u, v) $ is an edge, and in directed graphs, it means $ (u \to v) $.<br><strong>邻接</strong>：如果两个顶点 $ u $ 和 $ v $ 之间有一条边，则称它们为邻接。在无向图中，这意味着存在边 $ (u, v) $，在有向图中，这意味着存在边 $ (u \to v) $。</li>
</ul>
<hr>
<h4 id="Degree-Sum-Formulas-度数和公式"><a href="#Degree-Sum-Formulas-度数和公式" class="headerlink" title="Degree Sum Formulas (度数和公式)"></a>Degree Sum Formulas (度数和公式)</h4><ul>
<li><p><strong>For Undirected Graphs (无向图)</strong>: The sum of the degrees of all vertices in an undirected graph is twice the number of edges.<br><strong>无向图</strong>：无向图中所有顶点的度数之和等于边数的两倍，公式为：<br>$<br>\sum_{v \in V} \text{deg}(v) = 2|E|<br>$</p>
</li>
<li><p><strong>For Directed Graphs (有向图)</strong>: The sum of the indegrees is equal to the sum of the outdegrees, and both are equal to the total number of edges.<br><strong>有向图</strong>：有向图中所有顶点的入度之和等于所有顶点的出度之和，两者都等于边的数量，公式为：<br>$<br>\sum_{v \in V} \text{deg}^-(v) = \sum_{v \in V} \text{deg}^+(v) = |E|<br>$</p>
</li>
</ul>
<hr>
<h3 id="Summary-总结"><a href="#Summary-总结" class="headerlink" title="Summary (总结)"></a>Summary (总结)</h3><ul>
<li><p><strong>Simple Graphs</strong> do not contain loops or multiple edges between any two vertices.<br><strong>简单图</strong>：不包含环路或任意两顶点之间的多重边。</p>
</li>
<li><p><strong>Undirected Graphs</strong> have edges that do not have direction, while <strong>Directed Graphs</strong> have edges with direction.<br><strong>无向图</strong>：边没有方向，而<strong>有向图</strong>：边有方向。</p>
</li>
<li><p><strong>Degree</strong> describes the number of edges connected to a vertex.<br><strong>度</strong>描述了与顶点连接的边的数量。</p>
</li>
<li><p><strong>Special Graphs</strong> include complete graphs, bipartite graphs, complete bipartite graphs, and n-cubes.<br><strong>特殊图</strong>包括完全图、二分图、完全二分图和 n-立方体。</p>
</li>
<li><p><strong>Subgraphs</strong> are formed by taking a subset of the vertices and edges from the original graph.<br><strong>子图</strong>是通过取原图的顶点和边的子集来形成的。</p>
</li>
<li><p><strong>Adjacency</strong> refers to the relationship between two vertices that are connected by an edge.<br><strong>邻接</strong>是指通过边连接的两个顶点之间的关系。</p>
</li>
<li><p><strong>Degree Sum Formulas</strong> give relationships between the number of vertices, edges, and degrees in a graph.<br><strong>度数和公式</strong>给出了图中顶点、边和度数之间的关系。</p>
</li>
</ul>
<h3 id="Euler-and-Hamilton-Path-欧拉路径与哈密顿路径"><a href="#Euler-and-Hamilton-Path-欧拉路径与哈密顿路径" class="headerlink" title="Euler and Hamilton Path (欧拉路径与哈密顿路径)"></a>Euler and Hamilton Path (欧拉路径与哈密顿路径)</h3><h4 id="Definitions-定义-1"><a href="#Definitions-定义-1" class="headerlink" title="Definitions (定义)"></a>Definitions (定义)</h4><ul>
<li><p><strong>Euler Path (欧拉路径)</strong>: A path in a graph that visits every edge exactly once.<br><strong>欧拉路径</strong>：图中的一条路径，它恰好访问每一条边一次。</p>
</li>
<li><p><strong>Euler Circuit (欧拉回路)</strong>: An Euler path that starts and ends at the same vertex.<br><strong>欧拉回路</strong>：一条欧拉路径，它的起点和终点是同一个顶点。</p>
</li>
<li><p><strong>Hamiltonian Path (哈密顿路径)</strong>: A path in a graph that visits every vertex exactly once.<br><strong>哈密顿路径</strong>：图中的一条路径，它恰好访问每个顶点一次。</p>
</li>
<li><p><strong>Hamiltonian Circuit (哈密顿回路)</strong>: A Hamiltonian path that starts and ends at the same vertex.<br><strong>哈密顿回路</strong>：一条哈密顿路径，它的起点和终点是同一个顶点。</p>
</li>
</ul>
<hr>
<h4 id="Necessary-and-Sufficient-Conditions-for-Euler-Circuits-and-Paths-欧拉回路与路径的必要与充分条件"><a href="#Necessary-and-Sufficient-Conditions-for-Euler-Circuits-and-Paths-欧拉回路与路径的必要与充分条件" class="headerlink" title="Necessary and Sufficient Conditions for Euler Circuits and Paths (欧拉回路与路径的必要与充分条件)"></a>Necessary and Sufficient Conditions for Euler Circuits and Paths (欧拉回路与路径的必要与充分条件)</h4><ul>
<li><p><strong>Euler Path (欧拉路径) Conditions</strong>: </p>
<ul>
<li><strong>Necessary condition</strong>: The graph must be connected, except possibly for isolated vertices.</li>
<li><strong>Sufficient condition</strong>: A graph has an Euler path if it has exactly two vertices with odd degrees (or zero odd degree vertices for an Euler circuit).<br><strong>欧拉路径条件</strong>：</li>
<li><strong>必要条件</strong>：图必须是连通的，可能有孤立的顶点。</li>
<li><strong>充分条件</strong>：图有欧拉路径当且仅当它恰好有两个顶点的度数是奇数（或者对于欧拉回路，所有顶点的度数都是偶数）。</li>
</ul>
</li>
<li><p><strong>Euler Circuit (欧拉回路) Conditions</strong>:</p>
<ul>
<li><strong>Necessary and sufficient condition</strong>: A connected graph has an Euler circuit if and only if every vertex has an even degree.<br><strong>欧拉回路条件</strong>：</li>
<li><strong>必要且充分条件</strong>：一个连通图当且仅当它的每个顶点的度数都是偶数时，才有欧拉回路。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Sufficient-Conditions-for-Hamilton-Circuits-哈密顿回路的充分条件"><a href="#Sufficient-Conditions-for-Hamilton-Circuits-哈密顿回路的充分条件" class="headerlink" title="Sufficient Conditions for Hamilton Circuits (哈密顿回路的充分条件)"></a>Sufficient Conditions for Hamilton Circuits (哈密顿回路的充分条件)</h4><ul>
<li><p><strong>Sufficient Condition</strong>: A graph will have a Hamiltonian circuit if it is <strong>complete</strong> (i.e., there is an edge between every pair of vertices).<br><strong>哈密顿回路的充分条件</strong>：如果一个图是<strong>完全图</strong>（即每对顶点之间都有边），则它必定有哈密顿回路。</p>
</li>
<li><p><strong>Dirac’s Theorem</strong>: A graph with $ n \geq 3 $ vertices will have a Hamiltonian circuit if every vertex has a degree of at least $ \frac{n}{2} $.<br><strong>Dirac 定理</strong>：对于一个有 $ n \geq 3 $ 个顶点的图，如果每个顶点的度数至少为 $ \frac{n}{2} $，则它必定有哈密顿回路。</p>
</li>
</ul>
<hr>
<h4 id="Shortest-Path-Problems-最短路径问题"><a href="#Shortest-Path-Problems-最短路径问题" class="headerlink" title="Shortest Path Problems (最短路径问题)"></a>Shortest Path Problems (最短路径问题)</h4><ul>
<li><p><strong>Weighted Graph (加权图)</strong>: A graph in which each edge has a weight or cost associated with it, typically representing distance, time, or some other metric.<br><strong>加权图</strong>：图中每条边都与一个权重或成本相关，通常代表距离、时间或其他度量。</p>
</li>
<li><p><strong>Shortest Path Problem (最短路径问题)</strong>: The problem of finding the path between two vertices that minimizes the total edge weight.<br><strong>最短路径问题</strong>：寻找两顶点之间的路径，使得路径上所有边的权重和最小。</p>
</li>
</ul>
<hr>
<h4 id="Dijkstra’s-Algorithm-Dijkstra-算法"><a href="#Dijkstra’s-Algorithm-Dijkstra-算法" class="headerlink" title="Dijkstra’s Algorithm (Dijkstra 算法)"></a>Dijkstra’s Algorithm (Dijkstra 算法)</h4><ul>
<li><p><strong>Dijkstra’s Algorithm</strong>: An algorithm for finding the shortest paths from a source vertex to all other vertices in a graph with non-negative edge weights.<br><strong>Dijkstra 算法</strong>：一种用于在带有非负边权的图中找到从源顶点到所有其他顶点的最短路径的算法。</p>
<p><strong>Steps</strong>:</p>
<ol>
<li>Initialize distances: set the distance to the source vertex as 0 and to all other vertices as infinity.</li>
<li>Select the vertex with the smallest tentative distance and update the distances to its adjacent vertices.</li>
<li>Repeat until all vertices have been processed.<br><strong>步骤</strong>：</li>
<li>初始化距离：将源顶点的距离设置为 0，所有其他顶点的距离设置为无穷大。</li>
<li>选择具有最小临时距离的顶点，并更新其邻接顶点的距离。</li>
<li>重复直到所有顶点都被处理。</li>
</ol>
</li>
</ul>
<hr>
<h4 id="The-Traveling-Salesman-Problem-旅行商问题"><a href="#The-Traveling-Salesman-Problem-旅行商问题" class="headerlink" title="The Traveling Salesman Problem (旅行商问题)"></a>The Traveling Salesman Problem (旅行商问题)</h4><ul>
<li><p><strong>Traveling Salesman Problem (TSP)</strong>: The problem of finding the shortest possible route that visits each city exactly once and returns to the origin city.<br><strong>旅行商问题</strong>：寻找一条最短的路线，要求每个城市恰好访问一次，并返回到起点城市。</p>
</li>
<li><p><strong>Approximation Algorithm (近似算法)</strong>: Due to the NP-hard nature of the TSP, finding an exact solution is computationally expensive, so approximation algorithms (such as the greedy algorithm) are used to find a near-optimal solution.<br><strong>近似算法</strong>：由于 TSP 是 NP 难题，精确解法计算量很大，因此使用近似算法（如贪心算法）来寻找近似最优解。</p>
</li>
<li><p><strong>Euler Paths and Circuits (欧拉路径与回路)</strong>:</p>
<ul>
<li>Euler path: Visits every edge exactly once.</li>
<li>Euler circuit: A Euler path that starts and ends at the same vertex.</li>
<li>Necessary and sufficient conditions for Euler paths and circuits are based on vertex degree.</li>
</ul>
</li>
<li><p><strong>Hamiltonian Paths and Circuits (哈密顿路径与回路)</strong>:</p>
<ul>
<li>Hamiltonian path: Visits every vertex exactly once.</li>
<li>Hamiltonian circuit: A Hamiltonian path that starts and ends at the same vertex.</li>
<li>Sufficient conditions for Hamiltonian circuits include complete graphs and Dirac’s theorem.</li>
</ul>
</li>
<li><p><strong>Shortest Path Problem (最短路径问题)</strong>:</p>
<ul>
<li>Involves finding the minimum weight path between vertices in a weighted graph.</li>
<li>Dijkstra’s algorithm is a well-known method for solving this problem in graphs with non-negative weights.</li>
</ul>
</li>
<li><p><strong>Traveling Salesman Problem (旅行商问题)</strong>:</p>
<ul>
<li>A classic optimization problem to find the shortest route that visits all cities exactly once and returns to the origin.</li>
<li>Approximation algorithms are often used due to the NP-hard nature of the problem.</li>
</ul>
</li>
</ul>
<h3 id="Planar-Graphs-平面图"><a href="#Planar-Graphs-平面图" class="headerlink" title="Planar Graphs (平面图)"></a>Planar Graphs (平面图)</h3><h4 id="Definitions-定义-2"><a href="#Definitions-定义-2" class="headerlink" title="Definitions (定义)"></a>Definitions (定义)</h4><ul>
<li><p><strong>Planar Graph (平面图)</strong>: A graph that can be embedded in the plane, meaning it can be drawn on a plane without any edges crossing.<br><strong>平面图</strong>：可以嵌入平面中的图，意味着它可以在平面上绘制而不产生任何边交叉。</p>
</li>
<li><p><strong>Planar Representation of a Graph (图的平面表示)</strong>: A drawing of a planar graph in the plane such that no edges cross each other.<br><strong>图的平面表示</strong>：平面图的绘制方式，使得图中的边不交叉。</p>
</li>
</ul>
<hr>
<h4 id="Euler’s-Formula-欧拉公式"><a href="#Euler’s-Formula-欧拉公式" class="headerlink" title="Euler’s Formula (欧拉公式)"></a>Euler’s Formula (欧拉公式)</h4><ul>
<li><p><strong>Euler’s Formula for Planar Graphs</strong>: For a connected planar graph with $v$ vertices, $e$ edges, and $r$ regions (including the outer region), the formula is:<br><strong>欧拉公式</strong>：对于一个连通平面图，它有 $v$ 个顶点，$e$ 条边，和 $r$ 个区域（包括外部区域），公式为：</p>
<p>$<br>r = e - v + 2<br>$</p>
<ul>
<li><strong>$v$</strong>: Number of vertices.</li>
<li><strong>$e$</strong>: Number of edges.</li>
<li><strong>$r$</strong>: Number of regions (including the outer region).</li>
</ul>
</li>
</ul>
<hr>
<h4 id="Corollaries-推论"><a href="#Corollaries-推论" class="headerlink" title="Corollaries (推论)"></a>Corollaries (推论)</h4><ol>
<li><p><strong>Corollary 1</strong> (推论 1): For any connected planar graph, the following inequality holds:</p>
<p>$<br>e \leq 3v - 6<br>$</p>
<p>This is a consequence of Euler’s formula for planar graphs with $v \geq 3$ vertices.<br><strong>推论 1</strong>：对于任何连通的平面图，以下不等式成立：</p>
<p>$<br>e \leq 3v - 6<br>$</p>
<p>这是欧拉公式的一个推论，适用于顶点数 $v \geq 3$ 的平面图。</p>
</li>
<li><p><strong>Corollary 2</strong> (推论 2): In a planar graph, each region is bounded by at least 3 edges (i.e., no region can be bounded by fewer than 3 edges).<br><strong>推论 2</strong>：在平面图中，每个区域至少由三条边界定（即，任何区域的边数不能少于三条）。</p>
</li>
</ol>
<hr>
<h4 id="Kuratowski’s-Theorem-Kuratowski-定理"><a href="#Kuratowski’s-Theorem-Kuratowski-定理" class="headerlink" title="Kuratowski’s Theorem (Kuratowski 定理)"></a>Kuratowski’s Theorem (Kuratowski 定理)</h4><ul>
<li><strong>Kuratowski’s Theorem</strong>: A graph is planar if and only if it does not contain a subgraph that is a subdivision of either $K_5$ (the complete graph on 5 vertices) or $K_{3,3}$ (the complete bipartite graph on two sets of 3 vertices).<br><strong>Kuratowski 定理</strong>：一个图是平面图当且仅当它不包含 $K_5$（5个顶点的完全图）或 $K_{3,3}$（两个3顶点集合的完全二分图）的子图。</li>
</ul>
<hr>
<h4 id="Necessary-and-Sufficient-Conditions-for-Planarity-平面图的必要与充分条件"><a href="#Necessary-and-Sufficient-Conditions-for-Planarity-平面图的必要与充分条件" class="headerlink" title="Necessary and Sufficient Conditions for Planarity (平面图的必要与充分条件)"></a>Necessary and Sufficient Conditions for Planarity (平面图的必要与充分条件)</h4><ul>
<li><strong>Necessary and Sufficient Conditions for Planarity</strong>: A graph is planar if and only if it does not contain a subgraph homeomorphic to $K_5$ or $K_{3,3}$, as per Kuratowski’s theorem.<br><strong>平面图的必要与充分条件</strong>：一个图是平面图当且仅当它不包含同胚于 $K_5$ 或 $K_{3,3}$ 的子图，依据Kuratowski 定理。</li>
</ul>
<hr>
<h3 id="Graph-Coloring-图着色"><a href="#Graph-Coloring-图着色" class="headerlink" title="Graph Coloring (图着色)"></a>Graph Coloring (图着色)</h3><h4 id="Chromatic-Number-色数"><a href="#Chromatic-Number-色数" class="headerlink" title="Chromatic Number (色数)"></a>Chromatic Number (色数)</h4><ul>
<li><p><strong>Chromatic Number (色数)</strong>: The minimum number of colors required to color the vertices of a graph such that no two adjacent vertices share the same color.<br><strong>色数</strong>：将图的顶点着色所需的最小颜色数，使得任何两个相邻的顶点颜色不同。</p>
</li>
<li><p><strong>Notation</strong>: The chromatic number of a graph $G$ is denoted by $\chi(G)$.<br><strong>记法</strong>：图 $G$ 的色数记作 $\chi(G)$。</p>
</li>
</ul>
<hr>
<h4 id="The-Four-Color-Theorem-四色定理"><a href="#The-Four-Color-Theorem-四色定理" class="headerlink" title="The Four Color Theorem (四色定理)"></a>The Four Color Theorem (四色定理)</h4><ul>
<li><p><strong>Four Color Theorem (四色定理)</strong>: Any planar graph can be colored with no more than four colors, such that no two adjacent regions (or vertices) share the same color.<br><strong>四色定理</strong>：任何平面图都可以用至多四种颜色着色，使得没有两个相邻的区域（或顶点）颜色相同。</p>
</li>
<li><p><strong>Implication</strong>: This theorem implies that it is possible to color any map using no more than four colors, ensuring that adjacent regions (countries or states, for example) are colored differently.<br><strong>含义</strong>：这个定理意味着，可以用最多四种颜色着色任何地图，确保相邻的区域（例如国家或州）颜色不同。</p>
</li>
<li><p><strong>Planar Graph (平面图)</strong>: A graph that can be drawn in the plane without edges crossing.</p>
</li>
<li><strong>Euler’s Formula (欧拉公式)</strong>: $r = e - v + 2$, which relates vertices, edges, and regions in a planar graph.</li>
<li><strong>Kuratowski’s Theorem (Kuratowski 定理)</strong>: A graph is planar if and only if it does not contain a subgraph homeomorphic to $K_5$ or $K_{3,3}$.</li>
<li><strong>Graph Coloring (图着色)</strong>: The process of assigning colors to vertices or edges of a graph such that adjacent elements have different colors.</li>
<li><strong>Chromatic Number (色数)</strong>: The minimum number of colors needed for graph coloring.</li>
<li><strong>Four Color Theorem (四色定理)</strong>: States that any planar graph can be colored using no more than four colors.</li>
</ul>
<h3 id="Trees-树-Sections-9-1-to-9-6"><a href="#Trees-树-Sections-9-1-to-9-6" class="headerlink" title="Trees (树) - Sections 9.1 to 9.6"></a>Trees (树) - Sections 9.1 to 9.6</h3><h4 id="Definitions-定义-3"><a href="#Definitions-定义-3" class="headerlink" title="Definitions (定义)"></a>Definitions (定义)</h4><ul>
<li><p><strong>Tree (树)</strong>: A connected, acyclic graph, meaning there are no cycles and any two vertices are connected by exactly one path.<br><strong>树</strong>：一个连通的无环图，意味着没有环路，任何两个顶点之间有且只有一条路径。</p>
</li>
<li><p><strong>Forest (森林)</strong>: A collection of disjoint trees, or equivalently, a graph with no cycles.<br><strong>森林</strong>：多个不相交的树的集合，或者等价地，指的是没有环的图。</p>
</li>
<li><p><strong>Subtree (子树)</strong>: A tree formed by a node (vertex) and all its descendants.<br><strong>子树</strong>：由一个节点及其所有后代节点形成的树。</p>
</li>
</ul>
<hr>
<h4 id="Rooted-Tree-有根树"><a href="#Rooted-Tree-有根树" class="headerlink" title="Rooted Tree (有根树)"></a>Rooted Tree (有根树)</h4><ul>
<li><p><strong>Rooted Tree (有根树)</strong>: A tree in which one vertex is designated as the root, and the rest of the tree is structured hierarchically in terms of parent-child relationships.<br><strong>有根树</strong>：一棵树，其中一个顶点被指定为根，其余的树是根据父子关系按层级结构排列的。</p>
</li>
<li><p><strong>Parent (父节点)</strong>: A node that has one or more child nodes.<br><strong>父节点</strong>：一个节点有一个或多个子节点。</p>
</li>
<li><p><strong>Child (子节点)</strong>: A node that is a descendant of another node (its parent).<br><strong>子节点</strong>：一个节点是另一个节点（它的父节点）的后代。</p>
</li>
<li><p><strong>Sibling (兄弟节点)</strong>: Nodes that share the same parent.<br><strong>兄弟节点</strong>：共享相同父节点的节点。</p>
</li>
<li><p><strong>Ancestor (祖先节点)</strong>: A node that is on the path from a node to the root.<br><strong>祖先节点</strong>：在一个节点到根节点的路径上的节点。</p>
</li>
<li><p><strong>Descendant (后代节点)</strong>: A node that is on the path from the root to a given node.<br><strong>后代节点</strong>：在从根节点到给定节点的路径上的节点。</p>
</li>
<li><p><strong>Internal Vertex (内部节点)</strong>: A node that has at least one child.<br><strong>内部节点</strong>：有至少一个子节点的节点。</p>
</li>
<li><p><strong>Leaf (叶子节点)</strong>: A node that has no children.<br><strong>叶子节点</strong>：没有子节点的节点。</p>
</li>
<li><p><strong>Level of a Vertex (节点的层次)</strong>: The distance of a node from the root, measured in edges.<br><strong>节点的层次</strong>：一个节点到根节点的距离，用边的数量来度量。</p>
</li>
<li><p><strong>Height of a Tree (树的高度)</strong>: The maximum level of any vertex in the tree.<br><strong>树的高度</strong>：树中任何节点的最大层次。</p>
</li>
</ul>
<hr>
<h4 id="m-ary-Tree-m叉树"><a href="#m-ary-Tree-m叉树" class="headerlink" title="m-ary Tree (m叉树)"></a>m-ary Tree (m叉树)</h4><ul>
<li><p><strong>m-ary Tree (m叉树)</strong>: A tree where each internal vertex has at most $m$ children.<br><strong>m叉树</strong>：每个内部节点最多有$m$个子节点的树。</p>
</li>
<li><p><strong>Full m-ary Tree (完全 m叉树)</strong>: A tree in which every internal vertex has exactly $m$ children.<br><strong>完全 m叉树</strong>：每个内部节点恰好有$m$个子节点的树。</p>
</li>
<li><p><strong>Binary Tree (二叉树)</strong>: A special case of an m-ary tree where each node has at most two children (left and right).<br><strong>二叉树</strong>：一种特殊的m叉树，其中每个节点最多有两个子节点（左子节点和右子节点）。</p>
</li>
</ul>
<hr>
<h4 id="Special-Types-of-Trees-特殊树"><a href="#Special-Types-of-Trees-特殊树" class="headerlink" title="Special Types of Trees (特殊树)"></a>Special Types of Trees (特殊树)</h4><ul>
<li><p><strong>Ordered Tree (有序树)</strong>: A tree where the children of each node are ordered.<br><strong>有序树</strong>：每个节点的子节点有顺序的树。</p>
</li>
<li><p><strong>Balanced Tree (平衡树)</strong>: A tree in which the height of the left and right subtrees of every node differ by at most one.<br><strong>平衡树</strong>：每个节点的左右子树的高度差不超过1的树。</p>
</li>
<li><p><strong>Binary Search Tree (二叉搜索树)</strong>: A binary tree in which for each node, the left subtree contains only nodes with values less than the node’s value, and the right subtree contains only nodes with values greater than the node’s value.<br><strong>二叉搜索树</strong>：一种二叉树，其中对于每个节点，左子树只包含小于该节点值的节点，右子树只包含大于该节点值的节点。</p>
</li>
<li><p><strong>Decision Tree (决策树)</strong>: A tree used for decision-making, where nodes represent decisions or tests, and branches represent the outcomes of those decisions.<br><strong>决策树</strong>：用于决策的树，其中节点表示决策或测试，分支表示这些决策的结果。</p>
</li>
<li><p><strong>Prefix Code Tree (前缀编码树)</strong>: A tree where the leaves represent the symbols in a prefix code, and the path to each leaf corresponds to the code for that symbol.<br><strong>前缀编码树</strong>：一种树，其中叶子节点表示前缀编码中的符号，通向每个叶子的路径对应于该符号的编码。</p>
</li>
</ul>
<hr>
<h4 id="Tree-Traversal-树的遍历"><a href="#Tree-Traversal-树的遍历" class="headerlink" title="Tree Traversal (树的遍历)"></a>Tree Traversal (树的遍历)</h4><ul>
<li><p><strong>Preorder Traversal (前序遍历)</strong>: Visit the root first, then recursively visit the left subtree and right subtree.<br><strong>前序遍历</strong>：先访问根节点，再递归访问左子树和右子树。</p>
</li>
<li><p><strong>Prefix (or Polish) Notation (前缀（波兰）表示法)</strong>: A way of writing expressions where operators precede their operands.<br><strong>前缀（波兰）表示法</strong>：一种写表达式的方法，其中运算符在操作数之前。</p>
</li>
<li><p><strong>Inorder Traversal (中序遍历)</strong>: Recursively visit the left subtree, visit the root, and then recursively visit the right subtree.<br><strong>中序遍历</strong>：递归访问左子树，访问根节点，再递归访问右子树。</p>
</li>
<li><p><strong>Infix Notation (中缀表示法)</strong>: A way of writing expressions where operators are between their operands.<br><strong>中缀表示法</strong>：一种写表达式的方法，其中运算符位于操作数之间。</p>
</li>
<li><p><strong>Postorder Traversal (后序遍历)</strong>: Recursively visit the left subtree, then the right subtree, and finally visit the root.<br><strong>后序遍历</strong>：递归访问左子树，然后是右子树，最后访问根节点。</p>
</li>
<li><p><strong>Postfix (or Reverse Polish) Notation (后缀（逆波兰）表示法)</strong>: A way of writing expressions where operators follow their operands.<br><strong>后缀（逆波兰）表示法</strong>：一种写表达式的方法，其中运算符在操作数之后。</p>
</li>
</ul>
<hr>
<h4 id="Spanning-Tree-生成树"><a href="#Spanning-Tree-生成树" class="headerlink" title="Spanning Tree (生成树)"></a>Spanning Tree (生成树)</h4><ul>
<li><p><strong>Spanning Tree (生成树)</strong>: A tree that contains all the vertices of the graph and is a subgraph of the original graph.<br><strong>生成树</strong>：包含图中所有顶点的树，是原图的一个子图。</p>
</li>
<li><p><strong>Minimum Spanning Tree (最小生成树)</strong>: A spanning tree of a graph such that the sum of the edge weights is minimized.<br><strong>最小生成树</strong>：一棵生成树，使得所有边的权重之和最小化。</p>
</li>
<li><p><strong>Greedy Algorithm (贪心算法)</strong>: An algorithmic approach that makes locally optimal choices at each step with the hope of finding the global optimum.<br><strong>贪心算法</strong>：一种算法方法，在每一步做出局部最优选择，希望能找到全局最优解。</p>
</li>
</ul>
<h3 id="Types-of-Questions-问题类型"><a href="#Types-of-Questions-问题类型" class="headerlink" title="Types of Questions (问题类型)"></a>Types of Questions (问题类型)</h3><h4 id="Conceptual-Questions-概念性问题"><a href="#Conceptual-Questions-概念性问题" class="headerlink" title="Conceptual Questions (概念性问题)"></a>Conceptual Questions (概念性问题)</h4><ul>
<li><strong>Definitions of terms (术语定义)</strong>: These questions focus on understanding and recalling the definitions of key terms and concepts discussed in the lectures.<br><strong>术语定义</strong>：这些问题侧重于理解和回忆讲座中讨论的关键术语和概念的定义。</li>
</ul>
<hr>
<h4 id="True-False-Questions-判断题"><a href="#True-False-Questions-判断题" class="headerlink" title="True/False Questions (判断题)"></a>True/False Questions (判断题)</h4><ul>
<li><strong>True/False (判断正误)</strong>: These questions ask whether a statement is true or false, often testing your understanding of specific properties, theorems, or facts.<br><strong>判断正误</strong>：这些问题要求判断一个陈述是对还是错，通常测试你对特定性质、定理或事实的理解。</li>
</ul>
<hr>
<h4 id="Multiple-Choice-Questions-选择题"><a href="#Multiple-Choice-Questions-选择题" class="headerlink" title="Multiple Choice Questions (选择题)"></a>Multiple Choice Questions (选择题)</h4><ul>
<li><strong>Multiple Choice (多项选择)</strong>: Questions with several possible answers, where you are required to select the most appropriate one. These questions test both your recall and application of knowledge.<br><strong>多项选择</strong>：有多个可能答案的问题，要求你选择最合适的答案。这些问题测试你的知识回忆和应用能力。</li>
</ul>
<hr>
<h4 id="Simple-Questions-简单问题"><a href="#Simple-Questions-简单问题" class="headerlink" title="Simple Questions (简单问题)"></a>Simple Questions (简单问题)</h4><ul>
<li><strong>Simple Questions (简单问题)</strong>: These questions involve basic understanding and recall of fundamental concepts or facts, usually requiring a straightforward answer.<br><strong>简单问题</strong>：这些问题涉及对基本概念或事实的基础理解和回忆，通常需要一个直接的答案。</li>
</ul>
<hr>
<h4 id="Problem-Solving-解题"><a href="#Problem-Solving-解题" class="headerlink" title="Problem Solving (解题)"></a>Problem Solving (解题)</h4><ul>
<li><p><strong>Work with Small Concrete Example Problems (通过具体例子解题)</strong>: These questions ask you to solve problems using small, specific examples to demonstrate your problem-solving skills.<br><strong>通过具体例子解题</strong>：这些问题要求你使用具体的小例子来解决问题，展示你的解题能力。</p>
</li>
<li><p><strong>Use Your Knowledge in a Comprehensive Way for Problem-Solving (综合运用知识解题)</strong>: These questions involve applying a broad range of knowledge to tackle more complex problems or situations.<br><strong>综合运用知识解题</strong>：这些问题要求你综合运用广泛的知识来解决更复杂的问题或情境。</p>
</li>
</ul>
<hr>
<h4 id="Proofs-证明"><a href="#Proofs-证明" class="headerlink" title="Proofs (证明)"></a>Proofs (证明)</h4><ul>
<li><p><strong>Simple Theorems or Propositions (简单定理或命题)</strong>: Questions that require proving basic mathematical theorems or propositions, often using direct reasoning or other methods.<br><strong>简单定理或命题</strong>：需要证明基本数学定理或命题的问题，通常使用直接推理或其他方法。</p>
</li>
<li><p><strong>Possible Proof Methods (可能的证明方法)</strong>: Different methods of proving statements, including:</p>
<ul>
<li><strong>Induction (数学归纳法)</strong>: A method used to prove statements about natural numbers by proving a base case and then showing that if the statement holds for one case, it holds for the next.<br><strong>数学归纳法</strong>：通过证明基本情况，并展示如果命题对于某一情况成立，则对下一情况也成立，来证明关于自然数的命题。</li>
<li><strong>Direct Proof (直接证明)</strong>: A straightforward approach where the truth of a statement is established by logical deduction from known facts.<br><strong>直接证明</strong>：一种通过已知事实的逻辑推理来建立命题真理的直接方法。</li>
<li><strong>Proof by Contradiction (反证法)</strong>: A method where you assume the opposite of the statement and show that this leads to a contradiction, thereby proving the original statement.<br><strong>反证法</strong>：假设命题的反面并证明这一假设导致矛盾，从而证明原命题的方法。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="General-Exam-Guidelines-考试指南"><a href="#General-Exam-Guidelines-考试指南" class="headerlink" title="General Exam Guidelines (考试指南)"></a>General Exam Guidelines (考试指南)</h4><ul>
<li><strong>No questions will be outside of lecture notes (所有问题都在讲座笔记范围内)</strong>: All questions on the exam will be based on the material covered in class and found in your lecture notes. It is important to focus your studies on these materials.<br><strong>所有问题都在讲座笔记范围内</strong>：考试中的所有问题都基于课堂上讲授的内容，并出现在讲座笔记中。因此，集中学习这些材料非常重要。</li>
</ul>
<h3 id="中英对照"><a href="#中英对照" class="headerlink" title="中英对照"></a>中英对照</h3><p>connective 连接词</p>
<p>contrapositive 倒置蕴含</p>
<p>biconditional双条件</p>
<p>bitwise operations按位运算</p>
<p>universe of discourse论域</p>
<p>formula公式</p>
<p>normal form范式</p>
<p>literal文字</p>
<p>range值域</p>
<p>axiom公理</p>
<p>fallacy谬误</p>
<p>conjecture猜想</p>
<p>modus ponens假言推理</p>
<p>law of detachment分离规则</p>
<p>modus tollens拒取式</p>
<p>hypothetical syllogism假言三段论</p>
<p>disjunctive syllogism析取三段论</p>
<p>universal instantiation全称量词例示</p>
<p>​    generalization生成</p>
<p>proof by contradiction归谬证明</p>
<p>counterexample反例</p>
<p>cardinality基数</p>
<p>intersection交集</p>
<p>difference差集</p>
<p>symmetric difference对称差</p>
<p>range值域</p>
<p>recursion递归</p>
<p>diagonal realtion对角线关系</p>
<p>transpose转置矩阵</p>
<p>primary key主键</p>
<p>composite key复合键</p>
<p>projection投影</p>
<p>congruence同余</p>
<p>modulo模</p>
<p>partition划分</p>
<p>quotient set商集</p>
<p>lexicographic order字典序</p>
<p>lattice格</p>
<p>compatible相容的</p>
<p>topological拓扑排序</p>
<p>pseudograph伪图</p>
<p>adjacent相邻</p>
<p>incident关联</p>
<p>pendant悬挂点</p>
<p>regular graph正则图</p>
<p>matrix矩阵</p>
<p>entry项</p>
<p>isomorphic同构</p>
<p>homeomorphic同胚的</p>
<p>sibling兄弟</p>
<p>descendant后代</p>
<p>stack栈</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.totorocatcat.top/">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/2024/11/18/Exam/">http://totorocatcat.top/2024/11/18/Exam/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%85%B4%E8%B6%A3-%E6%8F%90%E9%AB%98/">兴趣&amp;提高</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/9f41e08726c9a62a829f2f2dd69942f.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/18/%E5%8D%8E%E5%8D%97%E7%90%86%E5%B7%A5%E5%A4%A7%E5%AD%A6%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95%E3%80%8A%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E3%80%8B%E8%AF%95%E5%8D%B7A/" title="华南理工大学期末考试《离散数学》试卷A"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/dd932631b1216a892618e8ec72e91df.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">华南理工大学期末考试《离散数学》试卷A</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/18/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%A4%8D%E4%B9%A0ing%EF%BC%882%EF%BC%89/" title="离散数学复习ing（2）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/db7baa72bb74cf1f1d05e0f6e4c9513.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">离散数学复习ing（2）</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/10/06/01A/" title="CS 70 Disc 01A"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/9fba9ad72112622428f85d33a564be7d617436609.jpg@1256w_818h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-06</div><div class="title">CS 70 Disc 01A</div></div></a></div><div><a href="/2024/03/21/2019%E5%B9%B4%E5%8D%8E%E5%B7%A5%E5%90%8C%E6%AD%A5%E8%B5%9B/" title="2019年华工同步赛"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.22/img_223_650x521_99.9997940063477_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-21</div><div class="title">2019年华工同步赛</div></div></a></div><div><a href="/2024/02/21/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/" title="AC自动机"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.86/img_860_2039x1147_350_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-02-21</div><div class="title">AC自动机</div></div></a></div><div><a href="/2024/03/23/ACM%E6%A8%A1%E6%9D%BF/" title="ACM模板"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.86/img_860_2039x1147_350_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-23</div><div class="title">ACM模板</div></div></a></div><div><a href="/2024/03/12/CF933/" title="Codeforces Round 933 (Div. 3)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.69/img_692_1370x2047_96_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-12</div><div class="title">Codeforces Round 933 (Div. 3)</div></div></a></div><div><a href="/2024/10/06/CS70Cisc0B/" title="CS70 Disc  0B"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/b0e81b0a2d1999fcfd1dc4a87af1f66b617436609.jpg@1256w_1256h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-06</div><div class="title">CS70 Disc  0B</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description">热爱文学的SCUT软件学院学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">802</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#A-Brief-Summary-for-Exam"><span class="toc-text">A Brief Summary for Exam</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Propositions"><span class="toc-text">Propositions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Propositional-Symbols"><span class="toc-text">Propositional Symbols</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Operators"><span class="toc-text">Operators</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Truth-Tables"><span class="toc-text">Truth Tables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Composite-Propositions"><span class="toc-text">Composite Propositions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tautology-and-Contradiction"><span class="toc-text">Tautology and Contradiction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Equivalence-of-Propositional-Statements"><span class="toc-text">Equivalence of Propositional Statements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Equivalence-Laws"><span class="toc-text">Equivalence Laws</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proving-Equivalence"><span class="toc-text">Proving Equivalence</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Predicates"><span class="toc-text">Predicates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Universal-and-Existential-Quantifiers"><span class="toc-text">Universal and Existential Quantifiers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Duality-of-Universal-and-Existential-Quantifiers"><span class="toc-text">Duality of Universal and Existential Quantifiers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Predicates-Becoming-Propositions"><span class="toc-text">Predicates Becoming Propositions</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Instantiation-and-Quantification-of-Variables"><span class="toc-text">Instantiation and Quantification of Variables</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Nested-Quantifiers"><span class="toc-text">Nested Quantifiers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Quantifiers-with-Negation"><span class="toc-text">Quantifiers with Negation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Logical-Expressions-with-Predicates-Operators-and-Quantifiers"><span class="toc-text">Logical Expressions with Predicates, Operators, and Quantifiers</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Rules-of-Inference"><span class="toc-text">Rules of Inference</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Common-Rules-of-Inference"><span class="toc-text">Common Rules of Inference:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Universal-and-Existential-Instantiation-Generalization"><span class="toc-text">Universal and Existential Instantiation&#x2F;Generalization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Valid-Argument"><span class="toc-text">Valid Argument</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Construction-of-Valid-Argument-using-Rules-of-Inference"><span class="toc-text">Construction of Valid Argument using Rules of Inference</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proof-Methods-%E8%AF%81%E6%98%8E%E6%96%B9%E6%B3%95"><span class="toc-text">Proof Methods (证明方法)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-Direct-Proof-%E7%9B%B4%E6%8E%A5%E8%AF%81%E6%98%8E"><span class="toc-text">a. Direct Proof (直接证明)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-Indirect-Proof-%E9%97%B4%E6%8E%A5%E8%AF%81%E6%98%8E"><span class="toc-text">b. Indirect Proof (间接证明)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-Proof-by-Contradiction-%E5%8F%8D%E8%AF%81%E6%B3%95"><span class="toc-text">c. Proof by Contradiction (反证法)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Basics-of-Set-Theory"><span class="toc-text">Basics of Set Theory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Membership-Subsets-Cardinality-and-Set-Equality"><span class="toc-text">Membership, Subsets, Cardinality, and Set Equality</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Defining-Sets-Enumeration-and-Builder-Function"><span class="toc-text">Defining Sets: Enumeration and Builder Function</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cartesian-Product"><span class="toc-text">Cartesian Product</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Power-Set"><span class="toc-text">Power Set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-Operations"><span class="toc-text">Set Operations</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#a-Union-%E5%B9%B6%E9%9B%86"><span class="toc-text">a. Union (并集)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-Intersection-%E4%BA%A4%E9%9B%86"><span class="toc-text">b. Intersection (交集)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-Difference-%E5%B7%AE%E9%9B%86"><span class="toc-text">c. Difference (差集)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#d-Complement-%E8%A1%A5%E9%9B%86"><span class="toc-text">d. Complement (补集)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-Identity-Laws"><span class="toc-text">Set Identity Laws</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Proving-Set-Equality"><span class="toc-text">Proving Set Equality</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Basics-of-Functions-%E5%87%BD%E6%95%B0%E5%9F%BA%E7%A1%80"><span class="toc-text">Basics of Functions (函数基础)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#What-is-a-Function-%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-text">What is a Function? (什么是函数?)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#What-is-Not-a-Function-%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-text">What is Not a Function? (什么不是函数?)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Domain-Co-domain-Range-Image-and-Pre-image-%E5%AE%9A%E4%B9%89%E5%9F%9F%E3%80%81%E5%80%BC%E5%9F%9F%E3%80%81%E9%99%AA%E5%9F%9F%E3%80%81%E5%83%8F%E9%9B%86%E5%92%8C%E5%8E%9F%E5%83%8F%E9%9B%86"><span class="toc-text">Domain, Co-domain, Range, Image, and Pre-image (定义域、值域、陪域、像集和原像集)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Types-of-Functions-%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-text">Types of Functions (函数类型)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Inverse-Function-%E5%8F%8D%E5%87%BD%E6%95%B0"><span class="toc-text">Inverse Function (反函数)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Composition-of-Functions-%E5%87%BD%E6%95%B0%E7%9A%84%E5%A4%8D%E5%90%88"><span class="toc-text">Composition of Functions (函数的复合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Definitions-of-Relations-%E5%85%B3%E7%B3%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">Definitions of Relations (关系的定义)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Properties-of-Relations-%E5%85%B3%E7%B3%BB%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-text">2. Properties of Relations (关系的性质)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Reflexive-Irreflexive-%E8%87%AA%E5%8F%8D-%E9%9D%9E%E8%87%AA%E5%8F%8D"><span class="toc-text">Reflexive &#x2F; Irreflexive (自反 &#x2F; 非自反)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Symmetric-Asymmetric-Antisymmetric-%E5%AF%B9%E7%A7%B0-%E9%9D%9E%E5%AF%B9%E7%A7%B0-%E5%8F%8D%E5%AF%B9%E7%A7%B0"><span class="toc-text">Symmetric &#x2F; Asymmetric &#x2F; Antisymmetric (对称 &#x2F; 非对称 &#x2F; 反对称)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Transitive-%E4%BC%A0%E9%80%92%E6%80%A7"><span class="toc-text">Transitive (传递性)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Combining-Relations-%E5%85%B3%E7%B3%BB%E7%9A%84%E7%BB%84%E5%90%88"><span class="toc-text">Combining Relations (关系的组合)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Representing-Relations-R-from-A-to-B-%E5%85%B3%E7%B3%BB%E7%9A%84%E8%A1%A8%E7%A4%BA%EF%BC%9A-R-%E4%BB%8E-A-%E5%88%B0-B"><span class="toc-text">Representing Relations: $ R $ from $ A $ to $ B $ (关系的表示：$ R $ 从 $ A $ 到 $ B $)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Set-of-Ordered-Pairs-%E6%9C%89%E5%BA%8F%E5%AF%B9%E9%9B%86%E5%90%88"><span class="toc-text">1. Set of Ordered Pairs (有序对集合)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-0-%E2%80%93-1-Matrix-0-1-%E7%9F%A9%E9%98%B5"><span class="toc-text">2. 0 – 1 Matrix (0-1 矩阵)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Directed-Graph-%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-text">3. Directed Graph (有向图)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Converting-Between-Representations-%E4%B8%89%E7%A7%8D%E8%A1%A8%E7%A4%BA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-text">Converting Between Representations (三种表示之间的转换)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Closure-of-Relations-%E5%85%B3%E7%B3%BB%E7%9A%84%E9%97%AD%E5%8C%85"><span class="toc-text">Closure of Relations (关系的闭包)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Definition-%E5%AE%9A%E4%B9%89"><span class="toc-text">Definition (定义):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Types-of-Closures-%E9%97%AD%E5%8C%85%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">Types of Closures (闭包的类型)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Equivalence-Relations-%E7%AD%89%E4%BB%B7%E5%85%B3%E7%B3%BB"><span class="toc-text">Equivalence Relations (等价关系)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Definition-%E5%AE%9A%E4%B9%89-1"><span class="toc-text">Definition (定义):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Equivalence-Class-%E7%AD%89%E4%BB%B7%E7%B1%BB"><span class="toc-text">Equivalence Class (等价类)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Partition-of-a-Set-%E9%9B%86%E5%90%88%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-text">Partition of a Set (集合的划分)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Partial-Orderings-%E5%81%8F%E5%BA%8F%E5%85%B3%E7%B3%BB"><span class="toc-text">Partial Orderings (偏序关系)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Definition-%E5%AE%9A%E4%B9%89-2"><span class="toc-text">Definition (定义):</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Comparable-and-Incomparable-%E5%8F%AF%E6%AF%94%E4%B8%8E%E4%B8%8D%E5%8F%AF%E6%AF%94"><span class="toc-text">Comparable and Incomparable (可比与不可比)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Types-of-Orderings-%E5%BA%8F%E5%85%B3%E7%B3%BB%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">Types of Orderings (序关系的类型)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Hasse-Diagrams-%E5%93%88%E6%96%AF%E5%9B%BE"><span class="toc-text">Hasse Diagrams (哈斯图)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Maximal-and-Minimal-Elements-%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E5%92%8C%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="toc-text">Maximal and Minimal Elements (最大元素和最小元素)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Greatest-and-Least-Elements-%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0%E4%B8%8E%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="toc-text">Greatest and Least Elements (最大元素与最小元素)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Upper-Bound-and-Lower-Bound-%E4%B8%8A%E7%95%8C%E4%B8%8E%E4%B8%8B%E7%95%8C"><span class="toc-text">Upper Bound and Lower Bound (上界与下界)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graphs-%E5%9B%BE%E8%AE%BA-%E2%80%93-Sections-8-1-%E2%80%93-8-8"><span class="toc-text">Graphs (图论) – Sections 8.1 – 8.8</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Definitions-%E5%AE%9A%E4%B9%89"><span class="toc-text">Definitions (定义)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Simple-Undirected-and-Directed-Graphs-%E7%AE%80%E5%8D%95%E5%9B%BE%E3%80%81%E6%97%A0%E5%90%91%E5%9B%BE%E5%92%8C%E6%9C%89%E5%90%91%E5%9B%BE"><span class="toc-text">Simple, Undirected, and Directed Graphs (简单图、无向图和有向图)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Degree-of-Vertex-%E9%A1%B6%E7%82%B9%E7%9A%84%E5%BA%A6"><span class="toc-text">Degree of Vertex (顶点的度)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Special-Graphs-%E7%89%B9%E6%AE%8A%E5%9B%BE"><span class="toc-text">Special Graphs (特殊图)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Subgraph-%E5%AD%90%E5%9B%BE"><span class="toc-text">Subgraph (子图)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Adjacency-%E9%82%BB%E6%8E%A5"><span class="toc-text">Adjacency (邻接)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Degree-Sum-Formulas-%E5%BA%A6%E6%95%B0%E5%92%8C%E5%85%AC%E5%BC%8F"><span class="toc-text">Degree Sum Formulas (度数和公式)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Summary-%E6%80%BB%E7%BB%93"><span class="toc-text">Summary (总结)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Euler-and-Hamilton-Path-%E6%AC%A7%E6%8B%89%E8%B7%AF%E5%BE%84%E4%B8%8E%E5%93%88%E5%AF%86%E9%A1%BF%E8%B7%AF%E5%BE%84"><span class="toc-text">Euler and Hamilton Path (欧拉路径与哈密顿路径)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Definitions-%E5%AE%9A%E4%B9%89-1"><span class="toc-text">Definitions (定义)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Necessary-and-Sufficient-Conditions-for-Euler-Circuits-and-Paths-%E6%AC%A7%E6%8B%89%E5%9B%9E%E8%B7%AF%E4%B8%8E%E8%B7%AF%E5%BE%84%E7%9A%84%E5%BF%85%E8%A6%81%E4%B8%8E%E5%85%85%E5%88%86%E6%9D%A1%E4%BB%B6"><span class="toc-text">Necessary and Sufficient Conditions for Euler Circuits and Paths (欧拉回路与路径的必要与充分条件)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Sufficient-Conditions-for-Hamilton-Circuits-%E5%93%88%E5%AF%86%E9%A1%BF%E5%9B%9E%E8%B7%AF%E7%9A%84%E5%85%85%E5%88%86%E6%9D%A1%E4%BB%B6"><span class="toc-text">Sufficient Conditions for Hamilton Circuits (哈密顿回路的充分条件)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Shortest-Path-Problems-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98"><span class="toc-text">Shortest Path Problems (最短路径问题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra%E2%80%99s-Algorithm-Dijkstra-%E7%AE%97%E6%B3%95"><span class="toc-text">Dijkstra’s Algorithm (Dijkstra 算法)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Traveling-Salesman-Problem-%E6%97%85%E8%A1%8C%E5%95%86%E9%97%AE%E9%A2%98"><span class="toc-text">The Traveling Salesman Problem (旅行商问题)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Planar-Graphs-%E5%B9%B3%E9%9D%A2%E5%9B%BE"><span class="toc-text">Planar Graphs (平面图)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Definitions-%E5%AE%9A%E4%B9%89-2"><span class="toc-text">Definitions (定义)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Euler%E2%80%99s-Formula-%E6%AC%A7%E6%8B%89%E5%85%AC%E5%BC%8F"><span class="toc-text">Euler’s Formula (欧拉公式)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Corollaries-%E6%8E%A8%E8%AE%BA"><span class="toc-text">Corollaries (推论)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kuratowski%E2%80%99s-Theorem-Kuratowski-%E5%AE%9A%E7%90%86"><span class="toc-text">Kuratowski’s Theorem (Kuratowski 定理)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Necessary-and-Sufficient-Conditions-for-Planarity-%E5%B9%B3%E9%9D%A2%E5%9B%BE%E7%9A%84%E5%BF%85%E8%A6%81%E4%B8%8E%E5%85%85%E5%88%86%E6%9D%A1%E4%BB%B6"><span class="toc-text">Necessary and Sufficient Conditions for Planarity (平面图的必要与充分条件)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graph-Coloring-%E5%9B%BE%E7%9D%80%E8%89%B2"><span class="toc-text">Graph Coloring (图着色)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Chromatic-Number-%E8%89%B2%E6%95%B0"><span class="toc-text">Chromatic Number (色数)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-Four-Color-Theorem-%E5%9B%9B%E8%89%B2%E5%AE%9A%E7%90%86"><span class="toc-text">The Four Color Theorem (四色定理)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Trees-%E6%A0%91-Sections-9-1-to-9-6"><span class="toc-text">Trees (树) - Sections 9.1 to 9.6</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Definitions-%E5%AE%9A%E4%B9%89-3"><span class="toc-text">Definitions (定义)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rooted-Tree-%E6%9C%89%E6%A0%B9%E6%A0%91"><span class="toc-text">Rooted Tree (有根树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#m-ary-Tree-m%E5%8F%89%E6%A0%91"><span class="toc-text">m-ary Tree (m叉树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Special-Types-of-Trees-%E7%89%B9%E6%AE%8A%E6%A0%91"><span class="toc-text">Special Types of Trees (特殊树)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Tree-Traversal-%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">Tree Traversal (树的遍历)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spanning-Tree-%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">Spanning Tree (生成树)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Types-of-Questions-%E9%97%AE%E9%A2%98%E7%B1%BB%E5%9E%8B"><span class="toc-text">Types of Questions (问题类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Conceptual-Questions-%E6%A6%82%E5%BF%B5%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-text">Conceptual Questions (概念性问题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#True-False-Questions-%E5%88%A4%E6%96%AD%E9%A2%98"><span class="toc-text">True&#x2F;False Questions (判断题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multiple-Choice-Questions-%E9%80%89%E6%8B%A9%E9%A2%98"><span class="toc-text">Multiple Choice Questions (选择题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Simple-Questions-%E7%AE%80%E5%8D%95%E9%97%AE%E9%A2%98"><span class="toc-text">Simple Questions (简单问题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Problem-Solving-%E8%A7%A3%E9%A2%98"><span class="toc-text">Problem Solving (解题)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proofs-%E8%AF%81%E6%98%8E"><span class="toc-text">Proofs (证明)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#General-Exam-Guidelines-%E8%80%83%E8%AF%95%E6%8C%87%E5%8D%97"><span class="toc-text">General Exam Guidelines (考试指南)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E8%8B%B1%E5%AF%B9%E7%85%A7"><span class="toc-text">中英对照</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%887%EF%BC%89/" title="计组习题的那些事（7）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/omoide004.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计组习题的那些事（7）"/></a><div class="content"><a class="title" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%887%EF%BC%89/" title="计组习题的那些事（7）">计组习题的那些事（7）</a><time datetime="2024-12-07T15:50:36.000Z" title="发表于 2024-12-07 23:50:36">2024-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%886%EF%BC%89/" title="计组习题的那些事（6）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/porco026.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计组习题的那些事（6）"/></a><div class="content"><a class="title" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%886%EF%BC%89/" title="计组习题的那些事（6）">计组习题的那些事（6）</a><time datetime="2024-12-07T15:06:12.000Z" title="发表于 2024-12-07 23:06:12">2024-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%885%EF%BC%89/" title="计组习题的那些事（5）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/porco026.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计组习题的那些事（5）"/></a><div class="content"><a class="title" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%885%EF%BC%89/" title="计组习题的那些事（5）">计组习题的那些事（5）</a><time datetime="2024-12-07T09:25:25.000Z" title="发表于 2024-12-07 17:25:25">2024-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%884%EF%BC%89/" title="计组习题的那些事（4）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/howl032.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计组习题的那些事（4）"/></a><div class="content"><a class="title" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%884%EF%BC%89/" title="计组习题的那些事（4）">计组习题的那些事（4）</a><time datetime="2024-12-07T07:53:21.000Z" title="发表于 2024-12-07 15:53:21">2024-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%883%EF%BC%89/" title="计组习题的那些事（3）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/howl005.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计组习题的那些事（3）"/></a><div class="content"><a class="title" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%883%EF%BC%89/" title="计组习题的那些事（3）">计组习题的那些事（3）</a><time datetime="2024-12-07T05:13:23.000Z" title="发表于 2024-12-07 13:13:23">2024-12-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HT1PalaKkPaG1UqAXBhJXIu8-gzGzoHsz',
      appKey: 'iT0TnVVAwf9zuZ7NqwclQItY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="1" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS70の旅/&quot;);" href="javascript:void(0);">CS70の旅</a><span class="categoryBar-list-count">25</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS61B/&quot;);" href="javascript:void(0);">CS61B</a><span class="categoryBar-list-count">76</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/期末の旅/&quot;);" href="javascript:void(0);">期末の旅</a><span class="categoryBar-list-count">99</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/区域赛の旅/&quot;);" href="javascript:void(0);">区域赛の旅</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACMの旅/&quot;);" href="javascript:void(0);">ACMの旅</a><span class="categoryBar-list-count">68</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数学建模/&quot;);" href="javascript:void(0);">数学建模</a><span class="categoryBar-list-count">31</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Codeforcesの旅/&quot;);" href="javascript:void(0);">Codeforcesの旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题计划/&quot;);" href="javascript:void(0);">刷题计划</a><span class="categoryBar-list-count">40</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/牛客の旅/&quot;);" href="javascript:void(0);">牛客の旅</a><span class="categoryBar-list-count">65</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/前端の旅/&quot;);" href="javascript:void(0);">前端の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构/&quot;);" href="javascript:void(0);">数据结构</a><span class="categoryBar-list-count">47</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_24.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Atcoderの旅/&quot;);" href="javascript:void(0);">Atcoderの旅</a><span class="categoryBar-list-count">53</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_25.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-の旅/&quot;);" href="javascript:void(0);">C++の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_26.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CSAPPの旅/&quot;);" href="javascript:void(0);">CSAPPの旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_27.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS知识/&quot;);" href="javascript:void(0);">CS知识</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_28.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程基础/&quot;);" href="javascript:void(0);">编程基础</a><span class="categoryBar-list-count">22</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_29.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/离散数学/&quot;);" href="javascript:void(0);">离散数学</a><span class="categoryBar-list-count">29</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_30.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JAVAの旅/&quot;);" href="javascript:void(0);">JAVAの旅</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_31.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MIT-6-031-Software-Construction/&quot;);" href="javascript:void(0);">MIT 6.031:Software Construction</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_32.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS-110L/&quot;);" href="javascript:void(0);">CS 110L</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_33.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/灵魂の旅/&quot;);" href="javascript:void(0);">灵魂の旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_34.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/个人安排/&quot;);" href="javascript:void(0);">个人安排</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_35.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂项/&quot;);" href="javascript:void(0);">杂项</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_36.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">48</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_37.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文学/&quot;);" href="javascript:void(0);">文学</a><span class="categoryBar-list-count">49</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_38.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/力扣の旅/&quot;);" href="javascript:void(0);">力扣の旅</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_39.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/千里十二行/&quot;);" href="javascript:void(0);">千里十二行</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/🗡指offer/&quot;);" href="javascript:void(0);">🗡指offer</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_41.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/少年游/&quot;);" href="javascript:void(0);">少年游</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_42.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法提高课/&quot;);" href="javascript:void(0);">算法提高课</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_43.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/汇编の旅/&quot;);" href="javascript:void(0);">汇编の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-实训/&quot;);" href="javascript:void(0);">C++实训</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4b31456c6f0f4489f99177f89e936de7286431045.png@1256w_708h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt="">诗录</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/51d37eba99d243607ddedfff6e91568f617436609.jpg@1256w_1884h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">TotoroのPlan</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.48/img_482_1920x1080_96_null_normal.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt="">Markdown格式</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>