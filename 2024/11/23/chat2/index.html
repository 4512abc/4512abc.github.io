<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Chapter 2 Instruction Set Architecture | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Chapter 2 Instruction Set Architecture 这一章会比较容易接受，先解决比较容易接受的，最后回头去看第八章，第八章比起第九章还会简单一些，最难的已经解决了，其他的不过是时间问题罢了，不要打一百次战斗都胜利，要一次战斗保证以后不用再战斗了。  Contents    英文内容 中文翻译     2.1 Instruction and Instruction Sequ">
<meta property="og:type" content="article">
<meta property="og:title" content="Chapter 2 Instruction Set Architecture">
<meta property="og:url" content="http://totorocatcat.top/2024/11/23/chat2/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="Chapter 2 Instruction Set Architecture 这一章会比较容易接受，先解决比较容易接受的，最后回头去看第八章，第八章比起第九章还会简单一些，最难的已经解决了，其他的不过是时间问题罢了，不要打一百次战斗都胜利，要一次战斗保证以后不用再战斗了。  Contents    英文内容 中文翻译     2.1 Instruction and Instruction Sequ">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/8170c4048482fe21b05d8442e9af6b4.png">
<meta property="article:published_time" content="2024-11-22T16:36:18.000Z">
<meta property="article:modified_time" content="2024-11-22T16:38:33.394Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/8170c4048482fe21b05d8442e9af6b4.png"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/b5ca6e582a7a45e6fde46e616eeb68e.png"><link rel="canonical" href="http://totorocatcat.top/2024/11/23/chat2/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":765,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Chapter 2 Instruction Set Architecture',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-11-23 00:38:33'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">802</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/8170c4048482fe21b05d8442e9af6b4.png')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Chapter 2 Instruction Set Architecture</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-11-22T16:36:18.000Z" title="发表于 2024-11-23 00:36:18">2024-11-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-11-22T16:38:33.394Z" title="更新于 2024-11-23 00:38:33">2024-11-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/">计算机组成原理</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">11.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>35分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Chapter 2 Instruction Set Architecture"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2024/11/23/chat2/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2024/11/23/chat2/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Chapter-2-Instruction-Set-Architecture"><a href="#Chapter-2-Instruction-Set-Architecture" class="headerlink" title="Chapter 2 Instruction Set Architecture"></a>Chapter 2 Instruction Set Architecture</h1><blockquote>
<p>这一章会比较容易接受，先解决比较容易接受的，最后回头去看第八章，第八章比起第九章还会简单一些，最难的已经解决了，其他的不过是时间问题罢了，不要打一百次战斗都胜利，要一次战斗保证以后不用再战斗了。</p>
</blockquote>
<h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><div class="table-container">
<table>
<thead>
<tr>
<th>英文内容</th>
<th>中文翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>2.1 Instruction and Instruction Sequencing</strong></td>
<td><strong>2.1 指令与指令序列</strong></td>
</tr>
<tr>
<td><strong>2.2 Instruction Formats</strong></td>
<td><strong>2.2 指令格式</strong></td>
</tr>
<tr>
<td><strong>2.3 Addressing Modes</strong></td>
<td><strong>2.3 寻址方式</strong></td>
</tr>
<tr>
<td><strong>2.4 Stacks</strong></td>
<td><strong>2.4 栈</strong></td>
</tr>
<tr>
<td><strong>2.5 Subroutines</strong></td>
<td><strong>2.5 子程序</strong></td>
</tr>
<tr>
<td><strong>2.6 CISC Instruction Sets</strong></td>
<td><strong>2.6 CISC 指令集</strong></td>
</tr>
<tr>
<td><strong>2.7 RISC and CISC Styles</strong></td>
<td><strong>2.7 RISC 和 CISC 风格</strong></td>
</tr>
</tbody>
</table>
</div>
<h1 id="2-1-Instruction-and-Instruction-Sequencing"><a href="#2-1-Instruction-and-Instruction-Sequencing" class="headerlink" title="2.1 Instruction and Instruction Sequencing"></a>2.1 Instruction and Instruction Sequencing</h1><div class="table-container">
<table>
<thead>
<tr>
<th>英文内容</th>
<th>中文翻译</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Register Transfer Notation</strong></td>
<td><strong>寄存器传送符号</strong></td>
</tr>
<tr>
<td><strong>Assembly Language Notation</strong></td>
<td><strong>汇编语言符号</strong></td>
</tr>
<tr>
<td><strong>RISC and CISC Instruction Sets</strong></td>
<td><strong>RISC 和 CISC 指令集</strong></td>
</tr>
<tr>
<td><strong>Introduction to RISC Instruction Sets</strong></td>
<td><strong>RISC 指令集简介</strong></td>
</tr>
<tr>
<td><strong>Instruction Execution and Straight Line Sequencing</strong></td>
<td><strong>指令执行与直线顺序</strong></td>
</tr>
<tr>
<td><strong>Branching</strong></td>
<td><strong>分支</strong></td>
</tr>
</tbody>
</table>
</div>
<h2 id="指令与指令序列"><a href="#指令与指令序列" class="headerlink" title="指令与指令序列"></a>指令与指令序列</h2><p><strong>四种类型的指令</strong>：</p>
<ol>
<li><strong>内存与处理器寄存器之间的数据传送</strong>。</li>
<li><strong>对数据进行的算术和逻辑操作</strong>。</li>
<li><strong>程序顺序和控制</strong>。</li>
<li><strong>输入/输出传输</strong>。</li>
</ol>
<h2 id="寄存器传送符号（Register-Transfer-Notation）"><a href="#寄存器传送符号（Register-Transfer-Notation）" class="headerlink" title="寄存器传送符号（Register Transfer Notation）"></a>寄存器传送符号（Register Transfer Notation）</h2><ul>
<li><strong>寄存器传送符号</strong>用于描述硬件级别的数据传送和操作。</li>
<li><strong>处理器寄存器</strong>：如 R0、R5。</li>
<li><strong>I/O 寄存器</strong>：如 DATAIN、OUTSTATUS。</li>
<li><strong>内存位置</strong>：如 LOC、PLACE、A、VAR2。</li>
<li><strong>符号表示</strong>：<ul>
<li>用 <code>[...]</code> 表示某个位置的内容。</li>
<li>用 <code>&lt;-</code> 表示数据传送到目标位置。</li>
</ul>
</li>
</ul>
<h2 id="寄存器传送符号示例"><a href="#寄存器传送符号示例" class="headerlink" title="寄存器传送符号示例"></a>寄存器传送符号示例</h2><ul>
<li><p><strong>示例 1</strong>：<code>R2 &lt;- [LOC]</code></p>
<ul>
<li><strong>解释</strong>：将内存中的 LOC 的内容传送到寄存器 R2。</li>
<li>右边的表达式始终表示一个值，左边的表达式始终表示一个位置。</li>
</ul>
</li>
<li><p><strong>示例 2</strong>：<code>R4 &lt;- [R2] + [R3]</code></p>
<ul>
<li><strong>解释</strong>：将寄存器 R2 和 R3 的内容相加，并将结果存储在寄存器 R4 中。</li>
</ul>
</li>
</ul>
<h2 id="汇编语言符号（Assembly-Language-Notation）"><a href="#汇编语言符号（Assembly-Language-Notation）" class="headerlink" title="汇编语言符号（Assembly Language Notation）"></a>汇编语言符号（Assembly Language Notation）</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. <strong>概述</strong></h3><ul>
<li><strong>RTN（寄存器传送符号）</strong>：显示数据传输和算术运算。</li>
<li>但是 <strong>RTN 不适合表示完整的机器指令和程序</strong>。</li>
<li>为此目的，需要一种专用的符号表示法——<strong>汇编语言</strong>。</li>
</ul>
<hr>
<h3 id="2-汇编语言示例"><a href="#2-汇编语言示例" class="headerlink" title="2. 汇编语言示例"></a>2. <strong>汇编语言示例</strong></h3><ul>
<li>对于之前用 RTN 表示的两个示例：<ul>
<li><strong>RTN 表示</strong>：<ol>
<li><code>R2 &lt;- [LOC]</code>  </li>
<li><code>R4 &lt;- [R2] + [R3]</code></li>
</ol>
</li>
<li><strong>汇编语言表示</strong>：<ol>
<li><code>Load R2, LOC</code>（加载内存 LOC 的内容到寄存器 R2）</li>
<li><code>Add R4, R2, R3</code>（将寄存器 R2 和 R3 的值相加，结果存储在寄存器 R4）</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-汇编指令的基本组成"><a href="#3-汇编指令的基本组成" class="headerlink" title="3. 汇编指令的基本组成"></a>3. <strong>汇编指令的基本组成</strong></h3><ul>
<li><strong>一条指令</strong>包括：<ol>
<li><strong>指定的操作</strong>（Desired Operation）。</li>
<li><strong>涉及的操作数</strong>（Operands）。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-操作符表示法"><a href="#4-操作符表示法" class="headerlink" title="4. 操作符表示法"></a>4. <strong>操作符表示法</strong></h3><ul>
<li><strong>本章使用示例</strong>：<ul>
<li>英文单词表示操作符，如 <code>Load</code>、<code>Store</code>、<code>Add</code> 等。</li>
</ul>
</li>
<li><strong>商用处理器的表示</strong>：<ul>
<li>使用助记符（Mnemonics），通常是操作的缩写，例如：<ul>
<li><code>LD</code> 表示 Load。</li>
<li><code>ST</code> 表示 Store。</li>
<li><code>ADD</code> 表示 Add。</li>
</ul>
</li>
<li><strong>注意</strong>：不同处理器的助记符可能有所不同。</li>
</ul>
</li>
</ul>
<h2 id="RISC-和-CISC-指令集"><a href="#RISC-和-CISC-指令集" class="headerlink" title="RISC 和 CISC 指令集"></a>RISC 和 CISC 指令集</h2><h3 id="1-指令集的本质"><a href="#1-指令集的本质" class="headerlink" title="1. 指令集的本质"></a>1. <strong>指令集的本质</strong></h3><ul>
<li><strong>指令的性质</strong>是区分计算机架构的关键因素。</li>
<li><strong>现代计算机的两种基本指令集设计方法</strong>：<ol>
<li><strong>精简指令集计算机</strong>（RISC, Reduced Instruction Set Computers）。</li>
<li><strong>复杂指令集计算机</strong>（CISC, Complex Instruction Set Computers）。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-RISC-指令集（精简指令集计算机）"><a href="#2-RISC-指令集（精简指令集计算机）" class="headerlink" title="2. RISC 指令集（精简指令集计算机）"></a>2. <strong>RISC 指令集</strong>（精简指令集计算机）</h3><ul>
<li><strong>特点</strong>：<ol>
<li><strong>指令简短</strong>：每条指令通常为一个字（one word）。</li>
<li><strong>操作数要求</strong>：算术操作数必须在寄存器中，不能直接从内存中获取。</li>
<li><strong>指令集较小</strong>：通常只有 <strong>32 条左右</strong> 的指令。</li>
<li><strong>指令简单</strong>：每条指令通常在 <strong>一个时钟周期</strong> 内完成。</li>
<li><strong>高效的流水线</strong>：由于指令的固定长度和简单性，能更有效地使用流水线技术。</li>
</ol>
</li>
<li><strong>示例</strong>：<ul>
<li>ARM 架构是一种典型的 RISC 架构。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-CISC-指令集（复杂指令集计算机）"><a href="#3-CISC-指令集（复杂指令集计算机）" class="headerlink" title="3. CISC 指令集（复杂指令集计算机）"></a>3. <strong>CISC 指令集</strong>（复杂指令集计算机）</h3><ul>
<li><strong>特点</strong>：<ol>
<li><strong>指令复杂</strong>：支持多字指令（multi-word instructions）。</li>
<li><strong>操作数灵活</strong>：允许操作数直接从内存中获取或存储。</li>
<li><strong>指令数量多</strong>：通常包含 <strong>几百条指令</strong>。</li>
<li><strong>执行周期长</strong>：一条指令可能需要 <strong>多个时钟周期</strong> 才能完成。</li>
</ol>
</li>
<li><strong>示例</strong>：<ul>
<li>X86 架构是一种典型的 CISC 架构。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="表格总结"><a href="#表格总结" class="headerlink" title="表格总结"></a>表格总结</h3><blockquote>
<p>这里的长度和操作数的获取需要注意一下，其他随便看一下就好了。</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>RISC</strong></th>
<th><strong>CISC</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>指令长度</strong></td>
<td>固定长度（通常 1 个字）</td>
<td>可变长度（多字指令）</td>
</tr>
<tr>
<td><strong>操作数获取</strong></td>
<td>必须从寄存器中获取</td>
<td>可直接从内存中获取或存储</td>
</tr>
<tr>
<td><strong>指令数量</strong></td>
<td>少量（约 32 条）</td>
<td>大量（几百条指令）</td>
</tr>
<tr>
<td><strong>指令复杂度</strong></td>
<td>简单，每条指令一个时钟周期完成</td>
<td>复杂，可能需要多个时钟周期完成</td>
</tr>
<tr>
<td><strong>流水线效率</strong></td>
<td>高效，易于实现流水线</td>
<td>流水线实现难度较高</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td>ARM 架构</td>
<td>X86 架构</td>
</tr>
</tbody>
</table>
</div>
<p>RISC 强调简单和高效，适合现代处理器的流水线设计；而 CISC 提供灵活性，适合复杂操作和早期的编程需求。</p>
<h2 id="RISC-指令集（RISC-Instruction-Sets）"><a href="#RISC-指令集（RISC-Instruction-Sets）" class="headerlink" title="RISC 指令集（RISC Instruction Sets）"></a>RISC 指令集（RISC Instruction Sets）</h2><h3 id="1-RISC-指令集的两个关键特性"><a href="#1-RISC-指令集的两个关键特性" class="headerlink" title="1. RISC 指令集的两个关键特性"></a>1. <strong>RISC 指令集的两个关键特性</strong></h3><ol>
<li><strong>固定长度指令</strong>：每条指令占用一个字（single word）。  </li>
<li><strong>加载/存储架构（Load/Store Architecture）</strong>：<ul>
<li><strong>访问内存操作数</strong>：只能通过 <strong>Load</strong> 和 <strong>Store</strong> 指令进行。  </li>
<li><strong>算术/逻辑运算的操作数</strong>：必须在寄存器中，或者有一个操作数可以在指令字中显式提供。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="2-初始状态与数据传输"><a href="#2-初始状态与数据传输" class="headerlink" title="2. 初始状态与数据传输"></a>2. <strong>初始状态与数据传输</strong></h3><ul>
<li><p><strong>初始存储</strong>：所有指令和数据最初都存储在内存中。  </p>
</li>
<li><p><strong>寄存器操作数需求</strong>：由于 RISC 指令需要寄存器操作数，因此在算术运算前必须完成数据传输。  </p>
</li>
<li><p><strong>加载指令（Load）</strong>：用于从内存将数据传输到寄存器，格式为：  </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Load processor_register, mem_location</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>寻址方式</strong>：指定内存位置的寻址模式将在后续部分讨论。</p>
</li>
</ul>
<hr>
<h3 id="3-高级语言语句示例：C-A-B"><a href="#3-高级语言语句示例：C-A-B" class="headerlink" title="3. 高级语言语句示例：C = A + B"></a>3. <strong>高级语言语句示例：C = A + B</strong></h3><ul>
<li><p><strong>A、B、C</strong> 对应于内存位置。</p>
</li>
<li><p><strong>RTN 表达式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C &lt;- [A] + [B]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>执行步骤</strong>：</p>
<ol>
<li>获取内存位置 A 和 B 的内容。  </li>
<li>计算和。  </li>
<li>将结果存储到内存位置 C。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="4-实现任务的简单-RISC-指令序列"><a href="#4-实现任务的简单-RISC-指令序列" class="headerlink" title="4. 实现任务的简单 RISC 指令序列"></a>4. <strong>实现任务的简单 RISC 指令序列</strong></h3><ol>
<li><code>Load R2, A</code>：将内存位置 A 的内容加载到寄存器 R2 中。  </li>
<li><code>Load R3, B</code>：将内存位置 B 的内容加载到寄存器 R3 中。  </li>
<li><code>Add R4, R2, R3</code>：将寄存器 R2 和 R3 的内容相加，结果存储在寄存器 R4 中。  </li>
<li><code>Store R4, C</code>：将寄存器 R4 的内容存储到内存位置 C 中。</li>
</ol>
<hr>
<h3 id="5-指令说明"><a href="#5-指令说明" class="headerlink" title="5. 指令说明"></a>5. <strong>指令说明</strong></h3><ul>
<li><strong>Load 指令</strong>：将数据从内存加载到寄存器中。  </li>
<li><strong>Store 指令</strong>：将数据从寄存器存储到内存中。  </li>
<li><strong>注意</strong>：  <ul>
<li><strong>Load 指令</strong>的源是内存，目标是寄存器。  </li>
<li><strong>Store 指令</strong>的源是寄存器，目标是内存。</li>
<li>源和目标的顺序在两种指令中是相反的。</li>
</ul>
</li>
</ul>
<h2 id="分支（Branching）"><a href="#分支（Branching）" class="headerlink" title="分支（Branching）"></a>分支（Branching）</h2><h3 id="1-示例任务：累加-n-个数"><a href="#1-示例任务：累加-n-个数" class="headerlink" title="1. 示例任务：累加 n 个数"></a>1. <strong>示例任务：累加 n 个数</strong></h3><ul>
<li>将一组包含 <strong>n</strong> 个数字的列表进行求和。</li>
<li><strong>实现方法</strong>：<ol>
<li>使用单独的 <strong>Load</strong> 指令加载每个数。</li>
<li>使用 <strong>Add</strong> 指令将数字依次累加到寄存器中。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="2-程序循环（Program-Loop）"><a href="#2-程序循环（Program-Loop）" class="headerlink" title="2. 程序循环（Program Loop）"></a>2. <strong>程序循环（Program Loop）</strong></h3><ul>
<li>对于累加 n 个数的操作，可以通过 <strong>循环（Loop）</strong> 来实现：<ul>
<li>每次迭代加载一个数。</li>
<li>累加后更新结果。</li>
<li>条件满足时退出循环。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-分支指令（Branch-Instructions）"><a href="#3-分支指令（Branch-Instructions）" class="headerlink" title="3. 分支指令（Branch Instructions）"></a>3. <strong>分支指令（Branch Instructions）</strong></h3><ul>
<li><strong>功能</strong>：分支指令通过加载新地址到程序计数器（PC）来实现跳转。</li>
<li><strong>分支目标（Branch Target）</strong>：<ul>
<li>分支跳转后程序执行的新地址。</li>
</ul>
</li>
<li><strong>条件分支（Conditional Branch）</strong>：<ul>
<li>分支跳转的执行依赖于某些条件是否满足。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-条件分支示例"><a href="#4-条件分支示例" class="headerlink" title="4. 条件分支示例"></a>4. <strong>条件分支示例</strong></h3><ul>
<li><p><strong>功能描述</strong>：比较两个寄存器的内容并基于条件跳转。</p>
</li>
<li><p><strong>RTN 表示</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Branch_if [R4] &gt; [R5] Loop</span><br></pre></td></tr></table></figure>
<ul>
<li>如果寄存器 R4 的内容大于 R5，则跳转到 <code>Loop</code> 位置。</li>
<li>否则，继续顺序执行。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241122230756998.png" alt="image-20241122230756998"></p>
<hr>
<h3 id="5-条件码（Condition-Codes）"><a href="#5-条件码（Condition-Codes）" class="headerlink" title="5. 条件码（Condition Codes）"></a>5. <strong>条件码（Condition Codes）</strong></h3><ul>
<li><strong>用途</strong>：条件码用于标识最近一次指令执行的结果（如比较运算的结果）。  </li>
<li><strong>典型条件</strong>：<ol>
<li><strong>零标志（Zero Flag, ZF）</strong>：结果是否为零。</li>
<li><strong>负标志（Negative Flag, NF）</strong>：结果是否为负数。</li>
<li><strong>溢出标志（Overflow Flag, OF）</strong>：是否发生溢出。</li>
<li><strong>进位标志（Carry Flag, CF）</strong>：是否发生进位或借位。</li>
</ol>
</li>
</ul>
<h1 id="2-2-指令格式（Instruction-Formats）"><a href="#2-2-指令格式（Instruction-Formats）" class="headerlink" title="2.2 指令格式（Instruction Formats）"></a>2.2 指令格式（Instruction Formats）</h1><h3 id="1-什么是机器指令（Machine-Instruction）？"><a href="#1-什么是机器指令（Machine-Instruction）？" class="headerlink" title="1. 什么是机器指令（Machine Instruction）？"></a>1. <strong>什么是机器指令（Machine Instruction）？</strong></h3><ul>
<li><strong>定义</strong>：<br>机器指令是通过处理器电路执行特定任务的行为描述。  </li>
<li><strong>特点</strong>：  <ul>
<li>指令直接指定了处理器必须完成的操作。  </li>
<li>通常以汇编语言代码表示。  </li>
</ul>
</li>
</ul>
<h3 id="2-什么是指令集（Instruction-Set）？"><a href="#2-什么是指令集（Instruction-Set）？" class="headerlink" title="2. 什么是指令集（Instruction Set）？"></a>2. <strong>什么是指令集（Instruction Set）？</strong></h3><ul>
<li><strong>定义</strong>：<br>指令集是处理器可以执行的所有不同机器指令的集合。  </li>
<li><strong>作用</strong>：  <ul>
<li>定义了处理器的功能范围和执行能力。  </li>
<li>不同的处理器拥有不同的指令集，例如 RISC 指令集和 CISC 指令集。</li>
</ul>
</li>
</ul>
<h2 id="机器指令的组成要素（Elements-of-a-Machine-Instruction）"><a href="#机器指令的组成要素（Elements-of-a-Machine-Instruction）" class="headerlink" title="机器指令的组成要素（Elements of a Machine Instruction）"></a>机器指令的组成要素（Elements of a Machine Instruction）</h2><h3 id="1-操作码（Opcode）"><a href="#1-操作码（Opcode）" class="headerlink" title="1. 操作码（Opcode）"></a>1. <strong>操作码（Opcode）</strong></h3><ul>
<li><strong>定义</strong>：<br>操作码用于指定指令要执行的操作，例如加法（ADD）、输入/输出（I/O）等。  </li>
<li><strong>表示方式</strong>：<br>操作码通常以二进制代码表示。</li>
</ul>
<hr>
<h3 id="2-源操作数引用（Source-Operand-Reference）"><a href="#2-源操作数引用（Source-Operand-Reference）" class="headerlink" title="2. 源操作数引用（Source Operand Reference）"></a>2. <strong>源操作数引用（Source Operand Reference）</strong></h3><ul>
<li><strong>作用</strong>：<br>指定指令所需的操作数来源。  </li>
<li><strong>操作数的位置</strong>：<ol>
<li><strong>主存储器或虚拟存储器</strong>：从内存中加载操作数。  </li>
<li><strong>处理器寄存器</strong>：直接从寄存器中获取操作数。  </li>
<li><strong>I/O 设备</strong>：操作数来自输入/输出设备。</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-结果操作数引用（Result-Operand-Reference）"><a href="#3-结果操作数引用（Result-Operand-Reference）" class="headerlink" title="3. 结果操作数引用（Result Operand Reference）"></a>3. <strong>结果操作数引用（Result Operand Reference）</strong></h3><ul>
<li><strong>作用</strong>：<br>指定操作结果存储的位置。  </li>
<li><strong>可能的位置</strong>：<ul>
<li>主存储器或虚拟存储器。</li>
<li>处理器寄存器。</li>
<li>I/O 设备。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-下一条指令引用（Next-Instruction-Reference）"><a href="#4-下一条指令引用（Next-Instruction-Reference）" class="headerlink" title="4. 下一条指令引用（Next Instruction Reference）"></a>4. <strong>下一条指令引用（Next Instruction Reference）</strong></h3><ul>
<li><strong>作用</strong>：<br>指定下一条要执行的指令的位置。  </li>
<li><strong>特点</strong>：  <ul>
<li><strong>隐式引用</strong>：在大多数情况下，下一条指令不需要在当前指令中显式指定。  </li>
<li><strong>顺序执行</strong>：通常情况下，下一条指令是程序中逻辑上紧随当前指令的一条（按线性或顺序方式执行）。  </li>
</ul>
</li>
</ul>
<h2 id="指令表示（Instruction-Representation）"><a href="#指令表示（Instruction-Representation）" class="headerlink" title="指令表示（Instruction Representation）"></a>指令表示（Instruction Representation）</h2><h3 id="1-指令的表示方式"><a href="#1-指令的表示方式" class="headerlink" title="1. 指令的表示方式"></a>1. <strong>指令的表示方式</strong></h3><ul>
<li><strong>在计算机中</strong>：<br>每条指令由一系列二进制位（binary bits）表示。  </li>
<li><strong>指令的划分</strong>：<br>指令通常分为两个字段：  <ol>
<li><strong>操作码字段（Operation Code Field, Opcode）</strong>：<ul>
<li>指定要执行的操作，例如加法、存储等。</li>
</ul>
</li>
<li><strong>地址字段（Address Field）</strong>：<ul>
<li>指定操作数或结果的位置。</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h2 id="指令设计准则（Instruction-Design-Criteria）"><a href="#指令设计准则（Instruction-Design-Criteria）" class="headerlink" title="指令设计准则（Instruction Design Criteria）"></a>指令设计准则（Instruction Design Criteria）</h2><h3 id="1-指令长度"><a href="#1-指令长度" class="headerlink" title="1. 指令长度"></a>1. <strong>指令长度</strong></h3><ul>
<li><strong>短指令优于长指令</strong>：  <ul>
<li>短指令能够节省存储空间并提高处理速度。  </li>
<li>然而，指令长度必须足够表达操作码和地址信息。</li>
</ul>
</li>
</ul>
<h3 id="2-操作表达能力"><a href="#2-操作表达能力" class="headerlink" title="2. 操作表达能力"></a>2. <strong>操作表达能力</strong></h3><ul>
<li>指令格式需要提供足够的空间来表示所有期望执行的操作。</li>
</ul>
<h3 id="3-地址字段的位数"><a href="#3-地址字段的位数" class="headerlink" title="3. 地址字段的位数"></a>3. <strong>地址字段的位数</strong></h3><ul>
<li>地址字段的位数直接影响：  <ul>
<li>可访问的内存范围（地址范围）。  </li>
<li>对处理器架构的复杂性要求。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="示例：指令格式"><a href="#示例：指令格式" class="headerlink" title="示例：指令格式"></a>示例：指令格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Opcode   Address</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Opcode（操作码）</strong>：指令的功能部分，例如 ADD、LOAD 等。  </li>
<li><strong>Address（地址）</strong>：存储操作数或结果的位置的指针。</li>
</ul>
<hr>
<h3 id="指令地址字段格式（Instruction-Address-Field-Formats）"><a href="#指令地址字段格式（Instruction-Address-Field-Formats）" class="headerlink" title="指令地址字段格式（Instruction Address Field Formats）"></a>指令地址字段格式（Instruction Address Field Formats）</h3><h4 id="1-零地址指令（Zero-address-Instruction）"><a href="#1-零地址指令（Zero-address-Instruction）" class="headerlink" title="1. 零地址指令（Zero-address Instruction）"></a>1. <strong>零地址指令（Zero-address Instruction）</strong></h4><ul>
<li><p><strong>特点</strong>：  </p>
<ul>
<li>指令中不需要显式地址字段。  </li>
<li>通常用于 <strong>栈结构</strong>，操作数隐式存储在栈顶。  </li>
</ul>
</li>
<li><p><strong>操作形式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Opcode</span><br></pre></td></tr></table></figure>
<ul>
<li>例如，栈中顶层两个操作数进行操作，结果放回栈顶。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="2-单地址指令（One-address-Instruction）"><a href="#2-单地址指令（One-address-Instruction）" class="headerlink" title="2. 单地址指令（One-address Instruction）"></a>2. <strong>单地址指令（One-address Instruction）</strong></h4><ul>
<li><p><strong>特点</strong>：  </p>
<ul>
<li>指令中包含一个显式地址字段。  </li>
<li>通常假设另一个操作数存储在处理器的累加器（Accumulator, AC）中。  </li>
</ul>
</li>
<li><p><strong>操作形式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OP [A] → A</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>[A]</strong>：操作数存储位置。  </li>
<li><strong>A</strong>：运算结果存储的位置。  </li>
<li><strong>累加器</strong>：隐式作为另一个操作数和存储结果的位置。</li>
</ul>
</li>
<li><p><strong>格式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Opcode A</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="3-双地址指令（Two-address-Instruction）"><a href="#3-双地址指令（Two-address-Instruction）" class="headerlink" title="3. 双地址指令（Two-address Instruction）"></a>3. <strong>双地址指令（Two-address Instruction）</strong></h4><ul>
<li><p><strong>特点</strong>：  </p>
<ul>
<li>指令中包含两个显式地址字段。  </li>
<li>一个地址用于来源操作数，另一个地址用于目标操作数。  </li>
</ul>
</li>
<li><p><strong>操作形式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A1] OP [A2] → A1</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>A1</strong>：目标操作数的地址，也是结果的存储位置。  </li>
<li><strong>A2</strong>：来源操作数的地址。</li>
</ul>
</li>
<li><p><strong>格式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Opcode A1 A2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="4-三地址指令（Three-address-Instruction）"><a href="#4-三地址指令（Three-address-Instruction）" class="headerlink" title="4. 三地址指令（Three-address Instruction）"></a>4. <strong>三地址指令（Three-address Instruction）</strong></h4><ul>
<li><p><strong>特点</strong>：  </p>
<ul>
<li>指令中包含三个显式地址字段。  </li>
<li>可直接指定两个来源操作数和一个结果存储位置。  </li>
</ul>
</li>
<li><p><strong>操作形式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[A2] OP [A3] → A1</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>A1</strong>：结果存储位置。  </li>
<li><strong>A2</strong>、<strong>A3</strong>：来源操作数的地址。  </li>
</ul>
</li>
<li><p><strong>格式</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Opcode A1 A2 A3</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="精华"><a href="#精华" class="headerlink" title="精华"></a>精华</h3><p>指令地址字段的设计直接影响处理器的复杂性和性能：</p>
<ul>
<li><strong>零地址指令</strong> 简单，常用于栈操作。</li>
<li><strong>单地址指令</strong> 通过累加器简化设计。</li>
<li><strong>双地址指令</strong> 和 <strong>三地址指令</strong> 提供更灵活的操作，适合复杂运算，但指令长度更长。</li>
</ul>
<h2 id="指令长度（Instruction-Length）"><a href="#指令长度（Instruction-Length）" class="headerlink" title="指令长度（Instruction Length）"></a>指令长度（Instruction Length）</h2><h3 id="1-指令长度的类型"><a href="#1-指令长度的类型" class="headerlink" title="1. 指令长度的类型"></a>1. <strong>指令长度的类型</strong></h3><ul>
<li><strong>固定长度指令（Fixed Length）</strong>：  <ul>
<li>所有指令长度相同。</li>
<li><strong>优点</strong>：简化指令解码，提高处理器的执行效率。  </li>
<li><strong>缺点</strong>：可能会浪费存储空间，尤其是简单指令的编码。  </li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241122231244351.png" alt="image-20241122231244351"></p>
<ul>
<li><strong>可变长度指令（Variable Length）</strong>：  <ul>
<li>不同指令的长度可以不同。  </li>
<li><strong>优点</strong>：灵活性更高，复杂指令可以使用更多位，简单指令可以使用较短编码。  </li>
<li><strong>缺点</strong>：增加了解码的复杂性，可能降低执行速度。</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241122231235904.png" alt="image-20241122231235904"></p>
<hr>
<h3 id="2-缩短指令长度的方法"><a href="#2-缩短指令长度的方法" class="headerlink" title="2. 缩短指令长度的方法"></a>2. <strong>缩短指令长度的方法</strong></h3><ol>
<li><p><strong>重复使用操作数（Operand Reuse）</strong>：</p>
<ul>
<li><strong>说明</strong>：<br>如果一个操作数需要被多次使用，可以将其先加载到寄存器中。  </li>
<li><strong>注意</strong>：  <ul>
<li>仅当操作数多次使用时，这种方式才有意义。  </li>
<li>如果操作数只使用一次，将其放入寄存器反而会增加额外开销。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>隐式指定操作数（Implicit Operand Specification）</strong>：</p>
<ul>
<li><strong>说明</strong>：<br>隐式地指定某些常用操作数或操作方式，而不是显式地在指令中提供地址。  </li>
<li><strong>示例</strong>：  <ul>
<li>累加器（Accumulator, AC）作为默认的目标或来源操作数。  </li>
<li>栈操作中，栈顶元素作为隐式操作数。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h3 id="精华-1"><a href="#精华-1" class="headerlink" title="精华"></a>精华</h3><p>指令长度的设计需要在<strong>执行效率</strong>和<strong>存储空间</strong>之间找到平衡：</p>
<ul>
<li><strong>固定长度指令</strong> 更适合简化解码和流水线处理。</li>
<li><strong>可变长度指令</strong> 在存储和复杂指令表示方面更灵活。<br>通过重复使用操作数和隐式指定操作数，可以有效缩短指令长度，同时减少存储和传输成本。</li>
</ul>
<h2 id="操作码格式（Opcode-Format）"><a href="#操作码格式（Opcode-Format）" class="headerlink" title="操作码格式（Opcode Format）"></a>操作码格式（Opcode Format）</h2><h3 id="1-固定长度操作码（Fixed-Length-Opcode）"><a href="#1-固定长度操作码（Fixed-Length-Opcode）" class="headerlink" title="1. 固定长度操作码（Fixed Length Opcode）"></a>1. <strong>固定长度操作码（Fixed Length Opcode）</strong></h3><ul>
<li><strong>特点</strong>：  <ul>
<li>操作码长度固定，但指令的总长度是可变的。</li>
<li>设定操作码为 <strong>k 位</strong>，操作数地址为 <strong>n 位</strong>。  </li>
<li>这种格式允许：<ul>
<li><strong>$2^k$</strong> 种不同的操作（可支持不同的操作指令）。  </li>
<li><strong>$2^n$</strong> 个可寻址的内存单元（指定操作数的地址）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-可变长度操作码（Variable-Length-Opcode）"><a href="#2-可变长度操作码（Variable-Length-Opcode）" class="headerlink" title="2. 可变长度操作码（Variable Length Opcode）"></a>2. <strong>可变长度操作码（Variable Length Opcode）</strong></h3><ul>
<li><p><strong>特点</strong>：  </p>
<ul>
<li>操作码的长度是可变的，通常指令的长度是固定的，操作码和操作数地址的长度相互制约。</li>
<li><strong>举例</strong>：  <ul>
<li>如果指令长度为 <strong>16 位</strong>，操作数地址为 <strong>4 位</strong>，设计者的需求如下：<ul>
<li>需要支持 <strong>15 条三地址指令</strong>  </li>
<li>需要支持 <strong>14 条二地址指令</strong>  </li>
<li>需要支持 <strong>31 条一地址指令</strong>  </li>
<li>需要支持 <strong>16 条零地址指令</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241122232602167.png" alt="image-20241122232602167"></p>
</li>
</ul>
<hr>
<h3 id="3-设计示例："><a href="#3-设计示例：" class="headerlink" title="3. 设计示例："></a>3. <strong>设计示例：</strong></h3><ul>
<li><strong>16 位指令长度，4 位操作数地址</strong>：<ul>
<li>设计可能为 <strong>4 位操作码</strong>，每条指令有 <strong>三个地址</strong>，可以设计 <strong>15 条三地址指令</strong>。<ul>
<li>4 位操作码可以表示 <strong>16 种操作</strong>，可以涵盖大部分基本操作。</li>
</ul>
</li>
<li>如果需要更多的操作指令，则可以扩展操作码的长度。例如，将操作码扩展到 <strong>8 位</strong>，然后可以设计 <strong>14 条二地址指令</strong>，并支持更多种类的操作。</li>
</ul>
</li>
<li><strong>具体设计</strong>：<ol>
<li><strong>三地址指令</strong>：  <ul>
<li><strong>4 位操作码</strong>，允许 <strong>15 条三地址指令</strong>，即操作码范围为 <code>0000</code> 到 <code>1110</code>（15 种操作）。</li>
</ul>
</li>
<li><strong>二地址指令</strong>：  <ul>
<li><strong>8 位操作码</strong>，允许 <strong>14 条二地址指令</strong>，即操作码范围为 <code>1111 0000</code> 到 <code>1111 1101</code>（15 到 32 的操作）。</li>
</ul>
</li>
<li><strong>一地址指令</strong>：  <ul>
<li><strong>12 位操作码</strong>，允许 <strong>31 条一地址指令</strong>，即操作码范围为 <code>1111 1111 0 0000</code> 到 <code>1111 1111 1110</code>。</li>
</ul>
</li>
<li><strong>零地址指令</strong>：  <ul>
<li><strong>16 位操作码</strong>，可以设计 <strong>16 条零地址指令</strong>，即操作码范围为 <code>1111 1111 1111 0000</code> 到 <code>1111 1111 1111 1111</code>。</li>
</ul>
</li>
</ol>
</li>
</ul>
<h1 id="2-3-寻址方式-Addressing-Modes"><a href="#2-3-寻址方式-Addressing-Modes" class="headerlink" title="2.3 寻址方式 (Addressing Modes)"></a>2.3 寻址方式 (Addressing Modes)</h1><p><strong>寻址方式</strong>是指在指令中指定操作数位置的不同方法，决定了如何解释指令中的地址字段。</p>
<h3 id="1-什么是寻址方式？"><a href="#1-什么是寻址方式？" class="headerlink" title="1. 什么是寻址方式？"></a>1. <strong>什么是寻址方式？</strong></h3><ul>
<li><strong>寻址方式</strong>指的是在指令中，操作数的位置是如何被指定的。换句话说，就是在机器指令中，地址字段是如何被解释的。通过寻址方式，计算机能够知道在哪里查找操作数（例如，寄存器、内存、I/O 设备等）。</li>
</ul>
<h3 id="2-为什么需要寻址方式？"><a href="#2-为什么需要寻址方式？" class="headerlink" title="2. 为什么需要寻址方式？"></a>2. <strong>为什么需要寻址方式？</strong></h3><ul>
<li>计算机指令可能包含直接的数据（例如立即数），也可能包含指向数据的地址。不同的寻址方式使得指令能够灵活地访问数据，提升程序的效率和表达能力。通过采用不同的寻址方式，可以在内存、寄存器、甚至外部设备之间高效地进行操作。</li>
</ul>
<h3 id="3-常见的寻址方式种类："><a href="#3-常见的寻址方式种类：" class="headerlink" title="3. 常见的寻址方式种类："></a>3. <strong>常见的寻址方式种类：</strong></h3><ul>
<li><p><strong>立即寻址（Immediate Addressing）</strong><br>操作数直接在指令中给出，不需要进一步访问内存或寄存器。例如，在指令中直接指定一个常数。</p>
</li>
<li><p><strong>寄存器寻址（Register Addressing）</strong><br>操作数位于处理器的寄存器中，指令通过指定寄存器编号来访问数据。</p>
</li>
<li><p><strong>直接寻址（Direct Addressing）</strong><br>指令中的地址字段直接指向内存中的某个位置，操作数存储在该内存地址中。</p>
</li>
<li><p><strong>间接寻址（Indirect Addressing）</strong><br>指令中的地址字段提供的是内存地址的地址（即间接地址），首先需要访问该内存地址，获取指向实际操作数的地址。</p>
</li>
<li><p><strong>变址寻址（Indexed Addressing）</strong><br>基地址加上偏移量，用于计算操作数的实际位置。适用于数组等结构的存取。</p>
</li>
<li><p><strong>相对寻址（Relative Addressing）</strong><br>基地址是程序计数器（PC）的值，通常用于实现跳转指令。</p>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241122233742440.png" alt="image-20241122233742440"></p>
<h2 id="立即寻址（Immediate-Mode）"><a href="#立即寻址（Immediate-Mode）" class="headerlink" title="立即寻址（Immediate Mode）"></a>立即寻址（Immediate Mode）</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. <strong>定义</strong></h3><ul>
<li><strong>立即寻址</strong>模式下，操作数直接在指令中给出，而不是存储在内存或寄存器中。</li>
</ul>
<h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. <strong>示例</strong></h3><ul>
<li>示例：<code>Add R4, R6, #200</code><br>该指令的含义是将常数 <code>200</code> 加到寄存器 <code>R6</code> 的内容中，结果存储到寄存器 <code>R4</code>。</li>
</ul>
<h3 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3. 使用场景"></a>3. <strong>使用场景</strong></h3><ul>
<li><strong>定义和使用常量</strong>：立即寻址常用于在程序中定义常数。</li>
<li><strong>设置变量的初始值</strong>：可以直接在指令中设置变量的初始值。</li>
</ul>
<h3 id="4-优点"><a href="#4-优点" class="headerlink" title="4. 优点"></a>4. <strong>优点</strong></h3><ul>
<li><strong>不需要额外的内存引用</strong>：操作数直接包含在指令中，除了获取指令本身之外，不需要其他的内存访问。</li>
</ul>
<h3 id="5-缺点"><a href="#5-缺点" class="headerlink" title="5. 缺点"></a>5. <strong>缺点</strong></h3><ul>
<li><strong>只能使用常数</strong>：立即寻址只能提供常数作为操作数，无法使用变量或内存中的值。</li>
<li><strong>操作数大小有限制</strong>：由于操作数被嵌入指令中，操作数的大小受到指令中地址字段的限制。如果常数太大，可能无法容纳在指令内。</li>
</ul>
<h2 id="绝对寻址（Absolute-Mode-Direct-Mode）"><a href="#绝对寻址（Absolute-Mode-Direct-Mode）" class="headerlink" title="绝对寻址（Absolute Mode / Direct Mode）"></a>绝对寻址（Absolute Mode / Direct Mode）</h2><h3 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1. 定义"></a>1. <strong>定义</strong></h3><ul>
<li><strong>绝对寻址</strong>模式下，操作数存储在内存中的某个位置，而该位置的地址会在指令中明确给出。</li>
</ul>
<h3 id="2-示例-1"><a href="#2-示例-1" class="headerlink" title="2. 示例"></a>2. <strong>示例</strong></h3><ul>
<li><p>示例：<code>Load R2, NUM1</code><br>该指令表示将存储在内存位置 <code>NUM1</code> 中的值加载到寄存器 <code>R2</code>。</p>
</li>
<li><p><strong>EA = A</strong>  </p>
<ul>
<li><strong>EA</strong>（有效地址）：指向包含引用操作数的内存位置的实际地址。</li>
<li><strong>A</strong>：指令中的地址字段内容，指示内存位置的地址。</li>
</ul>
</li>
</ul>
<h3 id="3-使用场景-1"><a href="#3-使用场景-1" class="headerlink" title="3. 使用场景"></a>3. <strong>使用场景</strong></h3><ul>
<li><strong>访问全局变量</strong>：当全局变量的地址在编译时已知，可以使用绝对寻址直接访问这些变量。</li>
</ul>
<h3 id="4-优点-1"><a href="#4-优点-1" class="headerlink" title="4. 优点"></a>4. <strong>优点</strong></h3><ul>
<li><strong>单次内存引用</strong>：操作数直接由指令中的地址字段指定，只需要一次内存引用，不需要额外的计算。</li>
</ul>
<h3 id="5-缺点-1"><a href="#5-缺点-1" class="headerlink" title="5. 缺点"></a>5. <strong>缺点</strong></h3><ul>
<li><strong>固定内存地址</strong>：指令总是访问相同的内存位置，无法动态变化。  </li>
<li><strong>有限的地址空间</strong>：由于地址字段的大小限制，绝对寻址只能提供一个有限的地址空间。如果程序需要更多的地址，可能无法满足需求。</li>
</ul>
<h2 id="间接寻址模式（Indirect-Mode）"><a href="#间接寻址模式（Indirect-Mode）" class="headerlink" title="间接寻址模式（Indirect Mode）"></a><strong>间接寻址模式（Indirect Mode）</strong></h2><p>间接寻址模式允许通过内存位置间接访问操作数，这种寻址方式通常出现在 <strong>CISC</strong> 风格的处理器中。具体来说，操作数的有效地址（EA）是存储在一个内存位置中的地址，而该内存位置的地址本身由指令提供。</p>
<h3 id="EA-A"><a href="#EA-A" class="headerlink" title="EA = [A]"></a><strong>EA = [A]</strong></h3><ul>
<li><strong>EA</strong>（有效地址）：表示操作数的实际内存地址，它是通过指令提供的内存位置 <code>A</code> 中存储的内容获取的。</li>
<li><strong>A</strong>：指令中的地址字段，指向存储有效地址的内存位置。</li>
<li><code>EA = [A]</code> 表示指令中的地址字段 <strong>A</strong> 指向一个内存位置，该位置存储的是操作数的有效地址。</li>
</ul>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a><strong>示例：</strong></h3><p>假设有指令 <code>Add (A), R0</code>，意味着：</p>
<ul>
<li><code>A</code> 指向一个内存位置，该内存位置存储着另一个内存地址，这个地址就是实际的操作数所在位置。</li>
<li>执行时，指令首先访问内存位置 <code>A</code>，获取该位置中存储的地址（假设为 <code>B</code>），然后从地址 <code>B</code> 处获取操作数，将其加到寄存器 <code>R0</code> 中。</li>
</ul>
<h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a><strong>优缺点：</strong></h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a><strong>优点：</strong></h4><ul>
<li><strong>广泛的地址空间</strong>：如果内存字长为 <code>N</code> 位，则地址空间可达到 <strong>2^N</strong>，使得可以访问更大范围的内存。</li>
</ul>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a><strong>缺点：</strong></h4><ul>
<li><strong>两次内存引用</strong>：指令执行需要两次内存引用：<ol>
<li>第一次访问获取有效地址 <code>EA</code>（即获取指令中的地址 <code>A</code> 所存储的内容）。</li>
<li>第二次访问使用获取的地址 <code>EA</code> 获取操作数的实际值。</li>
</ol>
</li>
</ul>
<h3 id="多级间接寻址（Multilevel-Indirect-Addressing）"><a href="#多级间接寻址（Multilevel-Indirect-Addressing）" class="headerlink" title="多级间接寻址（Multilevel Indirect Addressing）"></a><strong>多级间接寻址（Multilevel Indirect Addressing）</strong></h3><ul>
<li><strong>EA = […[A]…]</strong>：表示多级间接寻址，首先从内存位置 <code>A</code> 获取地址，再通过该地址获取下一级地址，依此类推。</li>
<li>在这种模式中，指令可能包含一个“间接标志”（<strong>I bit</strong>），用于指示是否需要进行多级间接寻址：<ul>
<li><strong>I bit = 0</strong>：表示指令中的地址字段 <strong>A</strong> 直接包含有效地址。</li>
<li><strong>I bit = 1</strong>：表示需要进一步间接寻址，即通过 <code>A</code> 获取另一个地址，直到找到实际的操作数。</li>
</ul>
</li>
</ul>
<h3 id="精华："><a href="#精华：" class="headerlink" title="精华："></a><strong>精华：</strong></h3><ul>
<li><strong>间接寻址模式</strong> 提供了较大的地址空间，但由于需要多次内存访问来获取操作数，因此会增加指令执行的时间。</li>
</ul>
<h2 id="寄存器寻址模式（Register-Mode）"><a href="#寄存器寻址模式（Register-Mode）" class="headerlink" title="寄存器寻址模式（Register Mode）"></a><strong>寄存器寻址模式（Register Mode）</strong></h2><p>寄存器寻址模式是指操作数存储在处理器的寄存器中，而指令中包含寄存器的地址。</p>
<h3 id="EA-Ri"><a href="#EA-Ri" class="headerlink" title="EA = Ri"></a><strong>EA = Ri</strong></h3><ul>
<li><strong>EA</strong>（有效地址）：等于寄存器 <code>Ri</code> 的内容。</li>
<li><strong>Ri</strong>：指令中地址字段的内容，指向一个寄存器，指示该寄存器存储了操作数。</li>
</ul>
<h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a><strong>示例：</strong></h3><p>假设有指令 <code>Add R4, R2, R3</code>，表示：</p>
<ul>
<li>这条指令将寄存器 <code>R2</code> 和寄存器 <code>R3</code> 的内容相加，并将结果存储到寄存器 <code>R4</code> 中。</li>
<li>这里，寄存器 <code>R2</code> 和 <code>R3</code> 的内容作为操作数，<code>R4</code> 是结果寄存器。</li>
</ul>
<h3 id="优缺点：-1"><a href="#优缺点：-1" class="headerlink" title="优缺点："></a><strong>优缺点：</strong></h3><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a><strong>优点：</strong></h4><ul>
<li><strong>小地址字段</strong>：指令中的地址字段非常小，只需要指定寄存器号，不需要复杂的内存地址。</li>
<li><strong>无需内存访问</strong>：操作数直接存在寄存器中，执行指令时无需访问内存，因此执行速度更快。</li>
</ul>
<h4 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a><strong>缺点：</strong></h4><ul>
<li><strong>有限的地址空间</strong>：由于操作数只能存储在寄存器中，寄存器数量有限，因此这种方式的可寻址范围很小，只能访问处理器内部的寄存器。</li>
</ul>
<h2 id="寄存器间接寻址模式（Register-Indirect-Mode）"><a href="#寄存器间接寻址模式（Register-Indirect-Mode）" class="headerlink" title="寄存器间接寻址模式（Register Indirect Mode）"></a><strong>寄存器间接寻址模式（Register Indirect Mode）</strong></h2><p>在寄存器间接寻址模式中，操作数的有效地址是由寄存器中的内容指定的，而寄存器的地址是在指令中给出的。</p>
<h3 id="EA-Ri-1"><a href="#EA-Ri-1" class="headerlink" title="EA = [Ri]"></a><strong>EA = [Ri]</strong></h3><ul>
<li><strong>EA</strong>（有效地址）：表示由寄存器 <code>Ri</code> 中的内容提供的内存地址，指向存储操作数的内存位置。</li>
<li><strong>Ri</strong>：指令中的地址字段，指向一个寄存器，寄存器的内容指示实际存储操作数的内存地址。</li>
</ul>
<h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a><strong>示例：</strong></h3><p>假设有指令 <code>Load R2, (R5)</code>，表示：</p>
<ul>
<li>这条指令首先从寄存器 <code>R5</code> 中获取一个地址（即 <code>R5</code> 的内容），然后使用这个地址从内存中加载数据到寄存器 <code>R2</code> 中。</li>
<li>这里，寄存器 <code>R5</code> 存储了目标操作数的内存地址，指令将数据从该内存地址加载到 <code>R2</code>。</li>
</ul>
<h3 id="优缺点：-2"><a href="#优缺点：-2" class="headerlink" title="优缺点："></a><strong>优缺点：</strong></h3><h4 id="优点：-2"><a href="#优点：-2" class="headerlink" title="优点："></a><strong>优点：</strong></h4><ul>
<li><strong>灵活性更强</strong>：可以通过寄存器间接寻址来访问大量的内存地址，增加了寻址的灵活性和可扩展性。</li>
<li><strong>节省空间</strong>：可以通过寄存器来存储内存地址，避免在指令中直接使用较长的内存地址。</li>
</ul>
<h4 id="缺点：-2"><a href="#缺点：-2" class="headerlink" title="缺点："></a><strong>缺点：</strong></h4><ul>
<li><strong>需要额外的内存访问</strong>：需要访问寄存器以获取有效地址，然后访问内存。这意味着执行指令时需要两个内存访问操作，可能会影响执行速度。</li>
</ul>
<h3 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a><strong>示例：</strong></h3><p>使用寄存器间接寻址模式访问 <code>n</code> 个数字列表。假设寄存器中存储了列表的起始地址，通过该寄存器可以间接访问列表中的元素。具体来说，指令会先从寄存器中读取一个地址，然后使用该地址来访问内存中的数据。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123000650736.png" alt="image-20241123000650736"></p>
<h3 id="图-2-8：-使用间接寻址访问列表中的元素"><a href="#图-2-8：-使用间接寻址访问列表中的元素" class="headerlink" title="图 2.8： 使用间接寻址访问列表中的元素"></a><strong>图 2.8：</strong> 使用间接寻址访问列表中的元素</h3><p>在程序设计中，可以通过寄存器间接寻址来高效地操作数组或列表。例如，寄存器中存储了数组的起始地址，而指令通过间接寻址方式访问数组中的不同元素，减少了对内存地址的直接操作。</p>
<h3 id="优点：-3"><a href="#优点：-3" class="headerlink" title="优点："></a><strong>优点：</strong></h3><ol>
<li><strong>减少指令中的内存地址引用：</strong> 通过寄存器间接寻址，可以避免在每条指令中都直接写入完整的内存地址。指令中只需包含寄存器的地址，而寄存器的内容则指向所需的内存位置。</li>
<li><strong>减少内存访问次数：</strong> 寄存器间接寻址模式通过寄存器存储内存地址，减少了直接从内存中提取长地址的开销，从而提高了程序的执行效率，尤其在多次访问连续内存地址时，能显著降低内存访问的延迟。</li>
</ol>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><p>寄存器间接寻址模式通过在寄存器中存储内存地址来访问内存，减少了对内存地址的显式引用，并能减少内存访问次数，提高了程序的效率。</p>
<h2 id="索引寻址模式（Indexed-Mode）"><a href="#索引寻址模式（Indexed-Mode）" class="headerlink" title="索引寻址模式（Indexed Mode）"></a><strong>索引寻址模式（Indexed Mode）</strong></h2><h3 id="基本概念："><a href="#基本概念：" class="headerlink" title="基本概念："></a><strong>基本概念：</strong></h3><p>在索引寻址模式中，操作数的有效地址是通过将寄存器（索引寄存器）中的值与指令中给定的常数值（偏移量）相加生成的。</p>
<ul>
<li><strong>有效地址（EA）</strong> = <strong>X</strong> + <strong>[Ri]</strong><br>其中：<ul>
<li><strong>X</strong> 是指令中的常数值（偏移量），</li>
<li><strong>[Ri]</strong> 是寄存器中的值，即索引寄存器的内容。</li>
</ul>
</li>
</ul>
<p>需要注意的是，在生成有效地址的过程中，索引寄存器的内容不会改变。</p>
<h3 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a><strong>示例：</strong></h3><ul>
<li><strong>X(Ri)</strong>：指令中包含常数偏移量 <strong>X</strong> 和一个寄存器 <strong>Ri</strong>，操作数的有效地址是通过将 <strong>X</strong> 和 <strong>Ri</strong> 的内容相加得到的。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123001427160.png" alt="image-20241123001427160"></p>
<h3 id="索引寻址模式的两种使用方式："><a href="#索引寻址模式的两种使用方式：" class="headerlink" title="索引寻址模式的两种使用方式："></a><strong>索引寻址模式的两种使用方式：</strong></h3><ol>
<li><p><strong>偏移量作为常数给出：</strong><br>在这种方式下，偏移量 <strong>X</strong> 是指令中直接给出的常数。例如：<br><code>Load R2, 100(R1)</code>，表示将寄存器 <strong>R1</strong> 中的值加上 100，得到操作数的有效地址，然后从该地址加载数据到寄存器 <strong>R2</strong>。</p>
</li>
<li><p><strong>偏移量存储在索引寄存器中：</strong><br>这种方式要求指令中有一个足够大的偏移量字段来存储地址。此时，索引寄存器的内容加上该偏移量字段值，形成操作数的有效地址。</p>
</li>
</ol>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a><strong>使用场景：</strong></h3><p>索引寻址模式常用于访问数据结构中相对于某个基准位置的操作数。比如，访问数组中的元素时，数组元素的存储地址是相对于数组基地址的一个偏移量。</p>
<h4 id="示例：-5"><a href="#示例：-5" class="headerlink" title="示例："></a><strong>示例：</strong></h4><ul>
<li><strong>N 行 4 列的数组</strong>，如果内存是字节可寻址且字长为 32 位，那么可以通过索引寻址方式高效地访问数组中的各个元素。</li>
</ul>
<h3 id="索引寻址模式的变种："><a href="#索引寻址模式的变种：" class="headerlink" title="索引寻址模式的变种："></a><strong>索引寻址模式的变种：</strong></h3><ol>
<li><p><strong>基址加索引（Base with Index）：</strong>  </p>
<ul>
<li><strong>(Ri, Rj)</strong>：使用两个寄存器，一个寄存器 <strong>Ri</strong> 作为索引寄存器，另一个寄存器 <strong>Rj</strong> 作为基址寄存器。</li>
<li><strong>有效地址（EA）</strong> = <strong>[Ri]</strong> + <strong>[Rj]</strong></li>
</ul>
</li>
<li><p><strong>基址加索引加偏移量（Base with Index and Offset）：</strong>  </p>
<ul>
<li><strong>X(Ri, Rj)</strong>：使用一个偏移量 <strong>X</strong> 和两个寄存器 <strong>Ri</strong> 和 <strong>Rj</strong>。  </li>
<li><strong>有效地址（EA）</strong> = <strong>[Ri]</strong> + <strong>[Rj]</strong> + <strong>X</strong></li>
</ul>
</li>
</ol>
<p>这种寻址方式可以非常灵活地访问多维数据结构（如矩阵、表格等）。</p>
<h3 id="精华：-1"><a href="#精华：-1" class="headerlink" title="精华："></a><strong>精华：</strong></h3><p>索引寻址模式通过将寄存器内容与指令中的偏移量相加，生成操作数的有效地址。它非常适合用于处理复杂的数据结构（如数组和表格），提高了对数据的访问效率。</p>
<h2 id="栈（Stacks）"><a href="#栈（Stacks）" class="headerlink" title="栈（Stacks）"></a><strong>栈（Stacks）</strong></h2><p>栈是一种数据元素的列表，通常是按字（word）存储的，具有以下访问限制：元素只能在列表的一端添加或移除。栈通常被称为“后进先出栈（LIFO）”或“压入栈（Pushdown Stack）”。</p>
<h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a><strong>操作：</strong></h3><ol>
<li><strong>Push（压栈）：</strong> 将一个新元素放入栈顶。</li>
<li><strong>Pop（弹栈）：</strong> 从栈顶移除一个元素。</li>
</ol>
<h3 id="栈的实现："><a href="#栈的实现：" class="headerlink" title="栈的实现："></a><strong>栈的实现：</strong></h3><ul>
<li>在现代计算机中，栈通常通过主存的一部分来实现。</li>
<li>程序员可以在内存中创建一个栈。</li>
<li>计算机系统中通常还有一个专用的处理器栈。</li>
</ul>
<h3 id="处理器栈（Processor-Stack）"><a href="#处理器栈（Processor-Stack）" class="headerlink" title="处理器栈（Processor Stack）"></a><strong>处理器栈（Processor Stack）</strong></h3><ul>
<li>处理器有一个<strong>栈指针（SP）</strong>寄存器，指向栈顶。</li>
<li>假设内存是字节可寻址，字长为 32 位。</li>
</ul>
<h3 id="Push-操作："><a href="#Push-操作：" class="headerlink" title="Push 操作："></a><strong>Push 操作：</strong></h3><ul>
<li><strong>Push</strong> 操作通常需要两个指令：<ol>
<li><strong>Subtract SP, SP, #4</strong>：将栈指针 SP 减少 4，准备为新的数据元素腾出空间。</li>
<li><strong>Store Rj, (SP)</strong>：将寄存器 Rj 的内容存储到栈顶（即栈指针所指的位置）。</li>
</ol>
</li>
</ul>
<h3 id="Pop-操作："><a href="#Pop-操作：" class="headerlink" title="Pop 操作："></a><strong>Pop 操作：</strong></h3><ul>
<li><strong>Pop</strong> 操作也通常需要两个指令：<ol>
<li><strong>Load Rj, (SP)</strong>：从栈顶（栈指针所指的位置）加载数据到寄存器 Rj。</li>
<li><strong>Add SP, SP, #4</strong>：将栈指针 SP 增加 4，移除栈顶元素的空间。</li>
</ol>
</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20241123003545737.png" alt="image-20241123003545737"></p>
<h2 id="子程序（Subroutines）"><a href="#子程序（Subroutines）" class="headerlink" title="子程序（Subroutines）"></a><strong>子程序（Subroutines）</strong></h2><p>在程序中，一个特定的任务可能会多次执行，并且使用不同的数据。例如：数学函数、列表排序等。为了避免在程序中多次重复相同的代码，我们可以将该任务实现为一个子程序。通过调用子程序来执行任务，而不是在程序的每个部分都复制整个子程序代码。</p>
<h3 id="子程序调用："><a href="#子程序调用：" class="headerlink" title="子程序调用："></a><strong>子程序调用：</strong></h3><ul>
<li>子程序调用使用的是特殊类型的分支指令，称为<strong>Call 指令</strong>。</li>
</ul>
<h3 id="子程序连接（Subroutine-Linkage）"><a href="#子程序连接（Subroutine-Linkage）" class="headerlink" title="子程序连接（Subroutine Linkage）"></a><strong>子程序连接（Subroutine Linkage）</strong></h3><p>子程序可以从不同的地方被调用。如何确保子程序返回到正确的位置，这是子程序连接的问题。</p>
<ul>
<li><strong>Call 指令</strong>执行时，会将程序计数器（PC）更新为指向 Call 指令之后的那一条指令。</li>
<li><strong>保存返回地址</strong>：这个地址需要被保存，以便 Return 指令使用。</li>
<li>最简单的方法是将返回地址存储在<strong>链接寄存器（Link Register）</strong>中。</li>
<li><strong>Call 指令</strong>的执行过程：<ol>
<li>将更新后的 PC 内容存储到链接寄存器。</li>
<li>分支跳转到子程序的目标位置。</li>
</ol>
</li>
</ul>
<h3 id="返回（Return）"><a href="#返回（Return）" class="headerlink" title="返回（Return）"></a><strong>返回（Return）</strong></h3><ul>
<li>返回时，<strong>Return 指令</strong>通过跳转到链接寄存器中保存的地址来完成。</li>
</ul>
<h3 id="子程序嵌套（Subroutine-Nesting）与处理器栈（Processor-Stack）"><a href="#子程序嵌套（Subroutine-Nesting）与处理器栈（Processor-Stack）" class="headerlink" title="子程序嵌套（Subroutine Nesting）与处理器栈（Processor Stack）"></a><strong>子程序嵌套（Subroutine Nesting）与处理器栈（Processor Stack）</strong></h3><p>允许一个子程序调用另一个子程序，这就形成了子程序嵌套。子程序的链接寄存器内容在第二次子程序调用时会被覆盖。</p>
<ul>
<li><strong>解决办法：</strong> 第一个子程序在第二个子程序调用之前，应该将链接寄存器的内容保存到处理器栈中。</li>
<li><strong>恢复链接寄存器：</strong> 在第二个子程序返回后，第一个子程序可以从栈中恢复链接寄存器的内容。</li>
</ul>
<h3 id="子程序嵌套的深度"><a href="#子程序嵌套的深度" class="headerlink" title="子程序嵌套的深度"></a><strong>子程序嵌套的深度</strong></h3><p>子程序嵌套可以达到任意深度，返回地址会按照“后进先出（LIFO）”的顺序进行生成和使用。这意味着与子程序调用相关的返回地址应该被推送到处理器栈上。</p>
<h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ul>
<li>子程序是程序中为执行某个特定任务而编写的一组指令，避免了重复代码。</li>
<li>子程序调用通过 Call 指令实现，返回通过链接寄存器和 Return 指令完成。</li>
<li>在子程序嵌套的情况下，返回地址被保存到处理器栈中，以支持多层嵌套的子程序调用。</li>
</ul>
<h2 id="CISC-指令集（CISC-Instruction-Sets）"><a href="#CISC-指令集（CISC-Instruction-Sets）" class="headerlink" title="CISC 指令集（CISC Instruction Sets）"></a><strong>CISC 指令集（CISC Instruction Sets）</strong></h2><p>CISC（复杂指令集计算机）指令集与加载/存储架构（load/store architecture）不同，后者要求算术和逻辑操作只能在处理器寄存器中的操作数上执行。</p>
<h3 id="CISC-指令集特点："><a href="#CISC-指令集特点：" class="headerlink" title="CISC 指令集特点："></a><strong>CISC 指令集特点：</strong></h3><ol>
<li><p><strong>不局限于加载/存储架构</strong>：<br>CISC 指令集可以直接在内存操作数上执行操作，而不需要首先将其加载到寄存器中。</p>
</li>
<li><p><strong>指令长度</strong>：<br>CISC 指令不一定都适应于单一的字长（单个机器字）。某些指令可能只占一个字，但也有可能跨越多个字节。</p>
</li>
<li><p><strong>大多数算术和逻辑指令使用两地址格式</strong>：  </p>
<ul>
<li>格式：<strong>操作数 目标, 源</strong>。</li>
<li>示例：<code>Add B, A</code><br>这会执行操作 <code>B ← [A] + [B]</code>，即对内存操作数执行加法。</li>
</ul>
</li>
<li><p><strong>移动指令（Move）</strong>：<br>移动指令具有加载和存储指令的功能。  </p>
<ul>
<li>格式：<strong>Move 目标, 源</strong>。  </li>
<li>示例：<code>Move C, A</code>，将 A 的内容移到 C 中。</li>
</ul>
</li>
<li><p><strong>在某些 CISC 处理器中</strong>，其中一个操作数可以是内存中的内容，另一个操作数必须是寄存器。  </p>
<ul>
<li>示例：  <ul>
<li><code>Move Ri, A</code>：将内存 A 中的内容移动到寄存器 Ri。  </li>
<li><code>Add Ri, B</code>：将寄存器 Ri 和内存 B 中的内容相加。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>指令示例</strong>：  </p>
<ul>
<li><code>Move C, Ri</code>：将寄存器 Ri 的内容移动到 C 中。</li>
<li><code>Add C, A</code>：将内存 A 中的内容加到 C 中。</li>
</ul>
</li>
</ol>
<h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a><strong>总结：</strong></h3><ul>
<li>CISC 指令集支持更加复杂的操作，允许在内存和寄存器之间直接操作，指令长度灵活，且通常支持两地址操作模式。</li>
<li>CISC 处理器可以通过多种方式直接对内存操作数进行算术或逻辑运算，而不必先将其加载到寄存器中。</li>
</ul>
<h2 id="自动增量和自动减量模式（Autoincrement-and-Autodecrement-Mode）"><a href="#自动增量和自动减量模式（Autoincrement-and-Autodecrement-Mode）" class="headerlink" title="自动增量和自动减量模式（Autoincrement and Autodecrement Mode）"></a><strong>自动增量和自动减量模式（Autoincrement and Autodecrement Mode）</strong></h2><h3 id="自动增量模式（Autoincrement-Mode）"><a href="#自动增量模式（Autoincrement-Mode）" class="headerlink" title="自动增量模式（Autoincrement Mode）"></a><strong>自动增量模式（Autoincrement Mode）</strong></h3><ul>
<li><strong>定义</strong>：操作数的有效地址是指令中指定的寄存器内容。访问操作数后，该寄存器的内容会自动增加，指向列表中的下一个项目。</li>
<li><strong>公式</strong>：<br><strong>EA = [Ri]，Ri 自动递增</strong></li>
<li><strong>用途</strong>：<br>这种模式非常适用于循环体内调整指针。例如：<ul>
<li><code>Add SUM, (Ri+)</code>：先取出 Ri 指向的值进行加法操作，然后 Ri 增加，指向下一个操作数。</li>
<li><code>MoveByte (Rj+), Rk</code>：将 Ri 指向的字节内容移到 Rk 中，同时 Ri 自动递增。</li>
<li><strong>增量量</strong>：对于字（words），递增为 4；对于字节（bytes），递增为 1。</li>
</ul>
</li>
</ul>
<h3 id="自动减量模式（Autodecrement-Mode）"><a href="#自动减量模式（Autodecrement-Mode）" class="headerlink" title="自动减量模式（Autodecrement Mode）"></a><strong>自动减量模式（Autodecrement Mode）</strong></h3><ul>
<li><strong>定义</strong>：指令中指定的寄存器内容首先自动递减，然后该寄存器的值用于作为操作数的有效地址。</li>
<li><strong>公式</strong>：<br><strong>EA = [Ri-]，Ri 自动递减</strong></li>
<li><strong>用途</strong>：<br>自动递增和自动递减模式通常用于堆栈操作。例如：<ul>
<li><code>Move --(SP), NEWITEM</code>：将 <code>NEWITEM</code> 存储到栈顶，栈指针 SP 先递减后存储。</li>
<li><code>Move ITEM, (SP)+</code>：从栈顶取出 ITEM，然后栈指针 SP 增加，指向下一个项目。</li>
</ul>
</li>
</ul>
<h3 id="精华：-2"><a href="#精华：-2" class="headerlink" title="精华："></a><strong>精华</strong>：</h3><ul>
<li>自动增量模式和自动减量模式用于简化指针操作，特别是在数据结构如栈或数组的遍历过程中，能够自动调整指针的位置，减少显式的地址修改。</li>
</ul>
<h2 id="相对寻址模式（Relative-Mode）"><a href="#相对寻址模式（Relative-Mode）" class="headerlink" title="相对寻址模式（Relative Mode）"></a><strong>相对寻址模式（Relative Mode）</strong></h2><ul>
<li><p><strong>定义</strong>：<br>在相对寻址模式下，操作数的有效地址是通过使用程序计数器（PC）代替通用寄存器 Ri，再加上一个偏移量来确定的。</p>
</li>
<li><p><strong>公式</strong>：<br><strong>EA = [PC] + X</strong><br>其中，X 是一个带符号的数字。</p>
</li>
<li><p><strong>用途</strong>：</p>
<ul>
<li>访问数据操作数。</li>
<li>在分支指令中指定目标地址。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<ul>
<li><strong>分支操作</strong>：<code>Branch &gt; 0 Loop</code><br>在这种情况下，分支目标地址可以通过从当前程序计数器值开始的偏移量来计算。</li>
</ul>
</li>
</ul>
<h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a><strong>总结</strong>：</h3><p>相对寻址模式常用于跳转指令中，通过程序计数器加上一个偏移量来计算目标地址，简化了控制流的计算和管理。</p>
<h2 id="条件码（Condition-Codes）"><a href="#条件码（Condition-Codes）" class="headerlink" title="条件码（Condition Codes）"></a><strong>条件码（Condition Codes）</strong></h2><ul>
<li><p><strong>定义</strong>：<br>处理器可以维持关于运算结果的信息，以影响随后的条件分支操作。</p>
</li>
<li><p><strong>来源</strong>：<br>条件码根据算术运算、比较操作或数据搬移操作的结果来设置。</p>
</li>
<li><p><strong>条件码标志</strong>：<br>这些标志通常保存在状态寄存器中，主要包括：</p>
<ul>
<li><strong>N (负数标志)</strong>：若结果为负，则设置为1，否则为0。</li>
<li><strong>Z (零标志)</strong>：若结果为零，则设置为1，否则为0。</li>
<li><strong>V (溢出标志)</strong>：若发生溢出，则设置为1，否则为0。</li>
<li><strong>C (进位标志)</strong>：若发生进位，则设置为1，否则为0。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="使用条件码的分支"><a href="#使用条件码的分支" class="headerlink" title="使用条件码的分支"></a><strong>使用条件码的分支</strong></h3><ul>
<li><p><strong>CISC分支</strong>：<br>CISC风格的处理器会根据条件码标志来执行分支。通过判断条件码，程序可以执行不同的控制流操作。</p>
</li>
<li><p><strong>示例</strong>：<br>假设进行寄存器递减操作，若结果不为零，则清除N和Z标志。  </p>
<ul>
<li>例如：检查条件<code>N + Z = 0</code>，可以用分支指令 <code>Branch &gt; 0 LOOP</code> 来实现。</li>
</ul>
</li>
<li><p><strong>其他条件</strong>：  </p>
<ul>
<li>比较条件：<code>&lt;</code>, <code>=</code>, <code>≠</code>, <code>≤</code>, <code>≥</code>等。</li>
<li>分支指令：  <ul>
<li><code>Branch_if_overflow</code>：如果发生溢出，则跳转。</li>
<li><code>Branch_if_carry</code>：如果发生进位，则跳转。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="Quiz"><a href="#Quiz" class="headerlink" title="Quiz"></a>Quiz</h2><h3 id="题目1-在哪种寻址模式下，操作数实际上是直接包含在指令中的？"><a href="#题目1-在哪种寻址模式下，操作数实际上是直接包含在指令中的？" class="headerlink" title="题目1: 在哪种寻址模式下，操作数实际上是直接包含在指令中的？"></a><strong>题目1</strong>: 在哪种寻址模式下，操作数实际上是直接包含在指令中的？</h3><ul>
<li><strong>A</strong>: 立即寻址模式 (Immediate mode)</li>
<li><strong>B</strong>: 直接寻址模式 (Direct mode)</li>
<li><strong>C</strong>: 寄存器寻址模式 (Register mode)</li>
<li><strong>D</strong>: 索引寻址模式 (Index mode)</li>
</ul>
<h3 id="答案-A-立即寻址模式-Immediate-mode"><a href="#答案-A-立即寻址模式-Immediate-mode" class="headerlink" title="答案: A. 立即寻址模式 (Immediate mode)"></a><strong>答案</strong>: <strong>A. 立即寻址模式 (Immediate mode)</strong></h3><h3 id="解释"><a href="#解释" class="headerlink" title="解释:"></a><strong>解释</strong>:</h3><ul>
<li><strong>立即寻址模式</strong>：操作数直接包含在指令中，指令本身提供了操作数的值。</li>
<li>例如：<code>Add R4, R6, #200</code> 中的 <code>#200</code> 就是操作数，直接在指令中给出。</li>
</ul>
<h3 id="题目2-在以下寻址模式中，哪个不属于RISC风格的计算机？"><a href="#题目2-在以下寻址模式中，哪个不属于RISC风格的计算机？" class="headerlink" title="题目2: 在以下寻址模式中，哪个不属于RISC风格的计算机？"></a><strong>题目2</strong>: 在以下寻址模式中，哪个不属于RISC风格的计算机？</h3><ul>
<li><strong>A</strong>: 绝对寻址模式 (Absolute mode)</li>
<li><strong>B</strong>: 寄存器间接寻址模式 (Register indirect mode)</li>
<li><strong>C</strong>: 索引寻址模式 (Index mode)</li>
<li><strong>D</strong>: 间接寻址模式 (Indirect mode)</li>
</ul>
<h3 id="答案-D-间接寻址模式-Indirect-mode"><a href="#答案-D-间接寻址模式-Indirect-mode" class="headerlink" title="答案: D. 间接寻址模式 (Indirect mode)"></a><strong>答案</strong>: <strong>D. 间接寻址模式 (Indirect mode)</strong></h3><h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释:"></a><strong>解释</strong>:</h3><ul>
<li><strong>RISC（精简指令集计算机）</strong> 风格的计算机通常依赖于简单和快速的寻址模式，通常采用 <strong>寄存器寻址</strong> 或 <strong>立即寻址</strong>，而 <strong>间接寻址模式</strong> 在 RISC 计算机中较少使用。</li>
<li><strong>间接寻址模式</strong> 需要通过内存来获取操作数的地址，这会增加额外的内存访问次数，降低效率，因此不常出现在 RISC 设计中。</li>
</ul>
<h3 id="题目3-条件标志-Z-被设置为-1-以指示："><a href="#题目3-条件标志-Z-被设置为-1-以指示：" class="headerlink" title="题目3: 条件标志 Z 被设置为 1 以指示："></a><strong>题目</strong>3: 条件标志 Z 被设置为 1 以指示：</h3><ul>
<li><strong>A</strong>: 操作导致错误 (The operation has resulted in an error)</li>
<li><strong>B</strong>: 操作需要中断调用 (The operation requires an interrupt call)</li>
<li><strong>C</strong>: 结果为零 (The result is zero)</li>
<li><strong>D</strong>: 没有空闲寄存器 (There is no empty register available)</li>
</ul>
<h3 id="答案-C-结果为零-The-result-is-zero"><a href="#答案-C-结果为零-The-result-is-zero" class="headerlink" title="答案: C. 结果为零 (The result is zero)"></a><strong>答案</strong>: <strong>C. 结果为零 (The result is zero)</strong></h3><h3 id="解释-2"><a href="#解释-2" class="headerlink" title="解释:"></a><strong>解释</strong>:</h3><ul>
<li><strong>Z (Zero flag)</strong> 是条件码标志之一，它用于指示最近的运算结果是否为零。当 <strong>Z</strong> 标志被设置为 1 时，表示最近的操作结果为零。</li>
</ul>
<h2 id="RISC-和-CISC-风格"><a href="#RISC-和-CISC-风格" class="headerlink" title="RISC 和 CISC 风格"></a><strong>RISC 和 CISC 风格</strong></h2><h3 id="RISC（精简指令集计算机）特点"><a href="#RISC（精简指令集计算机）特点" class="headerlink" title="RISC（精简指令集计算机）特点:"></a><strong>RISC（精简指令集计算机）特点</strong>:</h3><ul>
<li><strong>简单的寻址模式</strong>：RISC 使用更简单、较少的寻址模式。</li>
<li><strong>所有指令单词长度相同</strong>：RISC 中的每条指令都具有相同的长度，通常是一个字（word）。</li>
<li><strong>较少的指令</strong>：指令集相对较小，通常只包含常见的操作。</li>
<li><strong>算术/逻辑操作仅在寄存器上执行</strong>：数据处理通常只发生在寄存器中，内存操作则通过加载和存储指令来进行。</li>
<li><strong>加载/存储架构用于数据传输</strong>：RISC 体系结构使用加载（load）和存储（store）指令来处理内存和寄存器之间的数据交换。</li>
<li><strong>程序执行的指令数量较多</strong>：虽然每条指令较简单，但需要更多的指令来完成任务。</li>
</ul>
<h3 id="RISC-的优点"><a href="#RISC-的优点" class="headerlink" title="RISC 的优点:"></a><strong>RISC 的优点</strong>:</h3><ul>
<li>简单的指令集使得设计更简单的硬件成为可能，有助于通过流水线技术（pipelining）提高执行速度。</li>
</ul>
<h3 id="CISC（复杂指令集计算机）特点"><a href="#CISC（复杂指令集计算机）特点" class="headerlink" title="CISC（复杂指令集计算机）特点:"></a><strong>CISC（复杂指令集计算机）特点</strong>:</h3><ul>
<li><strong>更复杂的寻址模式</strong>：CISC 支持更多种类的寻址模式，允许更灵活的操作。</li>
<li><strong>指令长度可变</strong>：CISC 中的指令可能跨越多个字节，有时会有变长的指令格式。</li>
<li><strong>更多的指令</strong>：指令集较大，包含更多样化的指令。</li>
<li><strong>算术/逻辑操作可在内存上执行</strong>：支持直接对内存中的数据进行算术和逻辑操作。</li>
<li><strong>内存到内存的数据传输</strong>：CISC 支持内存与内存之间的直接数据传输。</li>
<li><strong>每个程序执行的指令较少</strong>：由于指令更复杂，CISC 系统通常需要较少的指令来完成同样的任务。</li>
</ul>
<h3 id="CISC-的优点"><a href="#CISC-的优点" class="headerlink" title="CISC 的优点:"></a><strong>CISC 的优点</strong>:</h3><ul>
<li>尽管硬件设计较为复杂，但在某些应用中仍可以设计出高效的处理器。</li>
</ul>
<h3 id="问题：以下哪项不是-RISC-风格的特点？"><a href="#问题：以下哪项不是-RISC-风格的特点？" class="headerlink" title="问题：以下哪项不是 RISC 风格的特点？"></a><strong>问题：以下哪项不是 RISC 风格的特点？</strong></h3><ul>
<li><strong>A</strong>: 简单的寻址模式  </li>
<li><strong>B</strong>: 所有指令都适合在一个单词中  </li>
<li><strong>C</strong>: 指令集中的指令较少  </li>
<li><strong>D</strong>: 算术和逻辑操作可以在内存操作数以及处理器寄存器中的操作数上执行  </li>
</ul>
<h4 id="答案解析："><a href="#答案解析：" class="headerlink" title="答案解析："></a><strong>答案解析</strong>：</h4><ul>
<li><strong>A</strong>、<strong>B</strong> 和 <strong>C</strong> 都是 RISC 风格的特点。</li>
<li><strong>D</strong> 是 CISC 风格的特点，因为 RISC 风格通常只允许在寄存器内进行算术和逻辑操作，而不支持在内存操作数上执行这些操作。所以 <strong>D</strong> 不是 RISC 风格的特点。</li>
</ul>
<h4 id="正确答案：D"><a href="#正确答案：D" class="headerlink" title="正确答案：D"></a><strong>正确答案</strong>：D</h4><h2 id="SUmmary"><a href="#SUmmary" class="headerlink" title="SUmmary"></a>SUmmary</h2><ol>
<li><strong>指令与指令顺序 (Instruction and Instruction Sequencing)</strong><ul>
<li>研究指令的执行顺序和程序流控制，如何按照一定顺序执行指令，以及如何使用分支控制程序的跳转。</li>
</ul>
</li>
<li><strong>汇编语言符号 (Assembly Language Notation)</strong><ul>
<li>汇编语言中用于表示指令、操作数和操作码的符号。</li>
</ul>
</li>
<li><strong>RISC 指令集 (RISC Instruction Sets)</strong><ul>
<li>RISC 架构采用简化的指令集，指令通常固定长度，并且仅支持有限的寻址模式。</li>
</ul>
</li>
<li><strong>指令执行 (Instruction Execution)</strong><ul>
<li>包括直线顺序执行和分支执行，探讨程序控制流如何根据指令序列执行。</li>
</ul>
</li>
<li><strong>指令格式 (Instruction Formats)</strong><ul>
<li>指令的结构设计，如何将操作码、操作数等信息编码成机器指令。</li>
</ul>
</li>
<li><strong>指令表示 (Instruction Representation)</strong><ul>
<li>指令在机器中的表示方法，包括如何在计算机中存储和读取指令。</li>
</ul>
</li>
<li><strong>常见的指令地址字段格式 (Common Instruction Address Field Formats)</strong><ul>
<li>不同地址字段格式的指令，如零地址、单地址、双地址、三地址指令等，解释它们的区别和应用。</li>
</ul>
</li>
<li><strong>操作码格式 (Opcode Format - Expanding Opcode)</strong><ul>
<li>操作码的格式与扩展，解释如何根据需要扩展操作码的位数以支持更多的操作。</li>
</ul>
</li>
<li><strong>寻址模式 (Addressing Modes)</strong><ul>
<li>寻址模式定义了如何指定操作数的存储位置，常见模式包括立即寻址、直接寻址、寄存器寻址等。</li>
</ul>
</li>
<li><strong>典型的 RISC 寻址模式 (Typical RISC Addressing Modes)</strong><ul>
<li>RISC 系统常用的寻址模式，通常包括寄存器寻址、立即寻址、堆栈寻址等。</li>
</ul>
</li>
<li><strong>堆栈与子程序 (Stack and Subroutine)</strong><ul>
<li>堆栈的使用和管理，如何利用堆栈支持子程序调用与返回。</li>
</ul>
</li>
<li><strong>CISC 指令集 (CISC Instruction Sets)</strong><ul>
<li>CISC 架构拥有更复杂的指令集，支持多种复杂的寻址模式和内存到内存的操作。</li>
</ul>
</li>
<li><strong>自动增量、自动减量和相对寻址 (Autoincrement, Autodecrement, and Relative Mode)</strong><ul>
<li>自增、自减寻址模式和相对寻址模式的定义及应用。</li>
</ul>
</li>
<li><strong>条件码 (Condition Codes)</strong><ul>
<li>用于记录算术运算结果的状态，如负数、零、溢出、进位等条件码，以用于后续的分支控制。</li>
</ul>
</li>
<li><strong>RISC 与 CISC 风格 (RISC vs. CISC Styles)</strong><ul>
<li>对比 RISC 与 CISC 架构的特点，RISC 强调简单的指令和更高效的执行，而 CISC 强调复杂的指令集和内存操作的直接支持。</li>
</ul>
</li>
</ol>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.totorocatcat.top/">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/2024/11/23/chat2/">http://totorocatcat.top/2024/11/23/chat2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/8170c4048482fe21b05d8442e9af6b4.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/11/23/chatt6/" title="Chapter 6 Pipelining（1）"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/1743acaf35ff0aa5396b22190f1c7f6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Chapter 6 Pipelining（1）</div></div></a></div><div class="next-post pull-right"><a href="/2024/11/22/%E4%B8%80%E4%BA%9B%E5%91%BD%E4%BB%A4%E5%92%8CButterfly%E9%85%8D%E7%BD%AE%E8%BF%BD%E7%95%AA%E6%8F%92%E4%BB%B6/" title="一些命令和Butterfly配置追番插件"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/1bede9afe93424afea2378f37985fd4.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">一些命令和Butterfly配置追番插件</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/10/04/2009%E5%B9%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%9F%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86/" title="2009年计算机统考-数据结构部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/e345af5b515d2f76bb44fdaa6eff3db4d6f598d3.jpg@1256w_908h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-04</div><div class="title">2009年计算机统考-数据结构部分</div></div></a></div><div><a href="/2024/10/05/2011%E5%B9%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%9F%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86/" title="2011年计算机统考-数据结构部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/e345af5b515d2f76bb44fdaa6eff3db4d6f598d3.jpg@1256w_908h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="title">2011年计算机统考-数据结构部分</div></div></a></div><div><a href="/2024/10/05/2012%E5%B9%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%9F%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%83%A8%E5%88%86/" title="2012年计算机统考-数据结构部分"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/e345af5b515d2f76bb44fdaa6eff3db4d6f598d3.jpg@1256w_908h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-05</div><div class="title">2012年计算机统考-数据结构部分</div></div></a></div><div><a href="/2024/10/04/2010%E5%B9%B4%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%9F%E8%80%83-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="2010年计算机统考-数据结构"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/e345af5b515d2f76bb44fdaa6eff3db4d6f598d3.jpg@1256w_908h_!web-article-pic.avif" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-10-04</div><div class="title">2010年计算机统考-数据结构</div></div></a></div><div><a href="/2024/05/16/2022%E5%B9%B4C-%E8%AF%95%E5%8D%B7%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2/" title="2022年C++试卷软件学院"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_80.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-16</div><div class="title">2022年C++试卷软件学院</div></div></a></div><div><a href="/2024/05/16/2022C-%E8%AF%95%E5%8D%B7/" title="2022C++试卷"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_80.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-16</div><div class="title">2022C++试卷</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description">热爱文学的SCUT软件学院学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">802</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Chapter-2-Instruction-Set-Architecture"><span class="toc-text">Chapter 2 Instruction Set Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Contents"><span class="toc-text">Contents</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-1-Instruction-and-Instruction-Sequencing"><span class="toc-text">2.1 Instruction and Instruction Sequencing</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E4%B8%8E%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97"><span class="toc-text">指令与指令序列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E9%80%81%E7%AC%A6%E5%8F%B7%EF%BC%88Register-Transfer-Notation%EF%BC%89"><span class="toc-text">寄存器传送符号（Register Transfer Notation）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%BC%A0%E9%80%81%E7%AC%A6%E5%8F%B7%E7%A4%BA%E4%BE%8B"><span class="toc-text">寄存器传送符号示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%AC%A6%E5%8F%B7%EF%BC%88Assembly-Language-Notation%EF%BC%89"><span class="toc-text">汇编语言符号（Assembly Language Notation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A4%BA%E4%BE%8B"><span class="toc-text">2. 汇编语言示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-text">3. 汇编指令的基本组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">4. 操作符表示法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RISC-%E5%92%8C-CISC-%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-text">RISC 和 CISC 指令集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">1. 指令集的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-RISC-%E6%8C%87%E4%BB%A4%E9%9B%86%EF%BC%88%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%89"><span class="toc-text">2. RISC 指令集（精简指令集计算机）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-CISC-%E6%8C%87%E4%BB%A4%E9%9B%86%EF%BC%88%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%89"><span class="toc-text">3. CISC 指令集（复杂指令集计算机）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E6%A0%BC%E6%80%BB%E7%BB%93"><span class="toc-text">表格总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RISC-%E6%8C%87%E4%BB%A4%E9%9B%86%EF%BC%88RISC-Instruction-Sets%EF%BC%89"><span class="toc-text">RISC 指令集（RISC Instruction Sets）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-RISC-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="toc-text">1. RISC 指令集的两个关键特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E7%8A%B6%E6%80%81%E4%B8%8E%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93"><span class="toc-text">2. 初始状态与数据传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E8%AF%AD%E5%8F%A5%E7%A4%BA%E4%BE%8B%EF%BC%9AC-A-B"><span class="toc-text">3. 高级语言语句示例：C &#x3D; A + B</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%AE%80%E5%8D%95-RISC-%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97"><span class="toc-text">4. 实现任务的简单 RISC 指令序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8C%87%E4%BB%A4%E8%AF%B4%E6%98%8E"><span class="toc-text">5. 指令说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%94%AF%EF%BC%88Branching%EF%BC%89"><span class="toc-text">分支（Branching）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%A4%BA%E4%BE%8B%E4%BB%BB%E5%8A%A1%EF%BC%9A%E7%B4%AF%E5%8A%A0-n-%E4%B8%AA%E6%95%B0"><span class="toc-text">1. 示例任务：累加 n 个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A8%8B%E5%BA%8F%E5%BE%AA%E7%8E%AF%EF%BC%88Program-Loop%EF%BC%89"><span class="toc-text">2. 程序循环（Program Loop）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%86%E6%94%AF%E6%8C%87%E4%BB%A4%EF%BC%88Branch-Instructions%EF%BC%89"><span class="toc-text">3. 分支指令（Branch Instructions）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%9D%A1%E4%BB%B6%E5%88%86%E6%94%AF%E7%A4%BA%E4%BE%8B"><span class="toc-text">4. 条件分支示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9D%A1%E4%BB%B6%E7%A0%81%EF%BC%88Condition-Codes%EF%BC%89"><span class="toc-text">5. 条件码（Condition Codes）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-2-%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F%EF%BC%88Instruction-Formats%EF%BC%89"><span class="toc-text">2.2 指令格式（Instruction Formats）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%EF%BC%88Machine-Instruction%EF%BC%89%EF%BC%9F"><span class="toc-text">1. 什么是机器指令（Machine Instruction）？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E6%8C%87%E4%BB%A4%E9%9B%86%EF%BC%88Instruction-Set%EF%BC%89%EF%BC%9F"><span class="toc-text">2. 什么是指令集（Instruction Set）？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E6%8C%87%E4%BB%A4%E7%9A%84%E7%BB%84%E6%88%90%E8%A6%81%E7%B4%A0%EF%BC%88Elements-of-a-Machine-Instruction%EF%BC%89"><span class="toc-text">机器指令的组成要素（Elements of a Machine Instruction）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C%E7%A0%81%EF%BC%88Opcode%EF%BC%89"><span class="toc-text">1. 操作码（Opcode）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%BA%90%E6%93%8D%E4%BD%9C%E6%95%B0%E5%BC%95%E7%94%A8%EF%BC%88Source-Operand-Reference%EF%BC%89"><span class="toc-text">2. 源操作数引用（Source Operand Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%93%E6%9E%9C%E6%93%8D%E4%BD%9C%E6%95%B0%E5%BC%95%E7%94%A8%EF%BC%88Result-Operand-Reference%EF%BC%89"><span class="toc-text">3. 结果操作数引用（Result Operand Reference）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%8B%E4%B8%80%E6%9D%A1%E6%8C%87%E4%BB%A4%E5%BC%95%E7%94%A8%EF%BC%88Next-Instruction-Reference%EF%BC%89"><span class="toc-text">4. 下一条指令引用（Next Instruction Reference）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%A1%A8%E7%A4%BA%EF%BC%88Instruction-Representation%EF%BC%89"><span class="toc-text">指令表示（Instruction Representation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%87%E4%BB%A4%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F"><span class="toc-text">1. 指令的表示方式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%AE%BE%E8%AE%A1%E5%87%86%E5%88%99%EF%BC%88Instruction-Design-Criteria%EF%BC%89"><span class="toc-text">指令设计准则（Instruction Design Criteria）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%87%E4%BB%A4%E9%95%BF%E5%BA%A6"><span class="toc-text">1. 指令长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E8%A1%A8%E8%BE%BE%E8%83%BD%E5%8A%9B"><span class="toc-text">2. 操作表达能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%9C%B0%E5%9D%80%E5%AD%97%E6%AE%B5%E7%9A%84%E4%BD%8D%E6%95%B0"><span class="toc-text">3. 地址字段的位数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E6%8C%87%E4%BB%A4%E6%A0%BC%E5%BC%8F"><span class="toc-text">示例：指令格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E5%9C%B0%E5%9D%80%E5%AD%97%E6%AE%B5%E6%A0%BC%E5%BC%8F%EF%BC%88Instruction-Address-Field-Formats%EF%BC%89"><span class="toc-text">指令地址字段格式（Instruction Address Field Formats）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9B%B6%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4%EF%BC%88Zero-address-Instruction%EF%BC%89"><span class="toc-text">1. 零地址指令（Zero-address Instruction）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8D%95%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4%EF%BC%88One-address-Instruction%EF%BC%89"><span class="toc-text">2. 单地址指令（One-address Instruction）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%8C%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4%EF%BC%88Two-address-Instruction%EF%BC%89"><span class="toc-text">3. 双地址指令（Two-address Instruction）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%89%E5%9C%B0%E5%9D%80%E6%8C%87%E4%BB%A4%EF%BC%88Three-address-Instruction%EF%BC%89"><span class="toc-text">4. 三地址指令（Three-address Instruction）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E"><span class="toc-text">精华</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%95%BF%E5%BA%A6%EF%BC%88Instruction-Length%EF%BC%89"><span class="toc-text">指令长度（Instruction Length）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8C%87%E4%BB%A4%E9%95%BF%E5%BA%A6%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 指令长度的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BC%A9%E7%9F%AD%E6%8C%87%E4%BB%A4%E9%95%BF%E5%BA%A6%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">2. 缩短指令长度的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E-1"><span class="toc-text">精华</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%A0%81%E6%A0%BC%E5%BC%8F%EF%BC%88Opcode-Format%EF%BC%89"><span class="toc-text">操作码格式（Opcode Format）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E6%93%8D%E4%BD%9C%E7%A0%81%EF%BC%88Fixed-Length-Opcode%EF%BC%89"><span class="toc-text">1. 固定长度操作码（Fixed Length Opcode）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%AF%E5%8F%98%E9%95%BF%E5%BA%A6%E6%93%8D%E4%BD%9C%E7%A0%81%EF%BC%88Variable-Length-Opcode%EF%BC%89"><span class="toc-text">2. 可变长度操作码（Variable Length Opcode）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%AE%BE%E8%AE%A1%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">3. 设计示例：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-3-%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F-Addressing-Modes"><span class="toc-text">2.3 寻址方式 (Addressing Modes)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">1. 什么是寻址方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-text">2. 为什么需要寻址方式？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%AF%BB%E5%9D%80%E6%96%B9%E5%BC%8F%E7%A7%8D%E7%B1%BB%EF%BC%9A"><span class="toc-text">3. 常见的寻址方式种类：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80%EF%BC%88Immediate-Mode%EF%BC%89"><span class="toc-text">立即寻址（Immediate Mode）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89"><span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A4%BA%E4%BE%8B"><span class="toc-text">2. 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">3. 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BC%98%E7%82%B9"><span class="toc-text">4. 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BC%BA%E7%82%B9"><span class="toc-text">5. 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E5%AF%BB%E5%9D%80%EF%BC%88Absolute-Mode-Direct-Mode%EF%BC%89"><span class="toc-text">绝对寻址（Absolute Mode &#x2F; Direct Mode）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%9A%E4%B9%89-1"><span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%A4%BA%E4%BE%8B-1"><span class="toc-text">2. 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-text">3. 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BC%98%E7%82%B9-1"><span class="toc-text">4. 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BC%BA%E7%82%B9-1"><span class="toc-text">5. 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F%EF%BC%88Indirect-Mode%EF%BC%89"><span class="toc-text">间接寻址模式（Indirect Mode）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EA-A"><span class="toc-text">EA &#x3D; [A]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">优缺点：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%EF%BC%88Multilevel-Indirect-Addressing%EF%BC%89"><span class="toc-text">多级间接寻址（Multilevel Indirect Addressing）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%EF%BC%9A"><span class="toc-text">精华：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F%EF%BC%88Register-Mode%EF%BC%89"><span class="toc-text">寄存器寻址模式（Register Mode）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EA-Ri"><span class="toc-text">EA &#x3D; Ri</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="toc-text">优缺点：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-1"><span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-1"><span class="toc-text">缺点：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F%EF%BC%88Register-Indirect-Mode%EF%BC%89"><span class="toc-text">寄存器间接寻址模式（Register Indirect Mode）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EA-Ri-1"><span class="toc-text">EA &#x3D; [Ri]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-2"><span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%EF%BC%9A-2"><span class="toc-text">优缺点：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-2"><span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9%EF%BC%9A-2"><span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-3"><span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE-2-8%EF%BC%9A-%E4%BD%BF%E7%94%A8%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E8%AE%BF%E9%97%AE%E5%88%97%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-text">图 2.8： 使用间接寻址访问列表中的元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A-3"><span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F%EF%BC%88Indexed-Mode%EF%BC%89"><span class="toc-text">索引寻址模式（Indexed Mode）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-text">基本概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-4"><span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-text">索引寻址模式的两种使用方式：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9A"><span class="toc-text">使用场景：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-5"><span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%98%E7%A7%8D%EF%BC%9A"><span class="toc-text">索引寻址模式的变种：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%EF%BC%9A-1"><span class="toc-text">精华：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%EF%BC%88Stacks%EF%BC%89"><span class="toc-text">栈（Stacks）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">操作：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"><span class="toc-text">栈的实现：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E6%A0%88%EF%BC%88Processor-Stack%EF%BC%89"><span class="toc-text">处理器栈（Processor Stack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Push-%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">Push 操作：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pop-%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-text">Pop 操作：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%EF%BC%88Subroutines%EF%BC%89"><span class="toc-text">子程序（Subroutines）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%EF%BC%9A"><span class="toc-text">子程序调用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%BF%9E%E6%8E%A5%EF%BC%88Subroutine-Linkage%EF%BC%89"><span class="toc-text">子程序连接（Subroutine Linkage）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%EF%BC%88Return%EF%BC%89"><span class="toc-text">返回（Return）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%B5%8C%E5%A5%97%EF%BC%88Subroutine-Nesting%EF%BC%89%E4%B8%8E%E5%A4%84%E7%90%86%E5%99%A8%E6%A0%88%EF%BC%88Processor-Stack%EF%BC%89"><span class="toc-text">子程序嵌套（Subroutine Nesting）与处理器栈（Processor Stack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E7%A8%8B%E5%BA%8F%E5%B5%8C%E5%A5%97%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-text">子程序嵌套的深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-1"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CISC-%E6%8C%87%E4%BB%A4%E9%9B%86%EF%BC%88CISC-Instruction-Sets%EF%BC%89"><span class="toc-text">CISC 指令集（CISC Instruction Sets）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CISC-%E6%8C%87%E4%BB%A4%E9%9B%86%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-text">CISC 指令集特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-2"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%A2%9E%E9%87%8F%E5%92%8C%E8%87%AA%E5%8A%A8%E5%87%8F%E9%87%8F%E6%A8%A1%E5%BC%8F%EF%BC%88Autoincrement-and-Autodecrement-Mode%EF%BC%89"><span class="toc-text">自动增量和自动减量模式（Autoincrement and Autodecrement Mode）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%A2%9E%E9%87%8F%E6%A8%A1%E5%BC%8F%EF%BC%88Autoincrement-Mode%EF%BC%89"><span class="toc-text">自动增量模式（Autoincrement Mode）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%87%8F%E9%87%8F%E6%A8%A1%E5%BC%8F%EF%BC%88Autodecrement-Mode%EF%BC%89"><span class="toc-text">自动减量模式（Autodecrement Mode）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%BE%E5%8D%8E%EF%BC%9A-2"><span class="toc-text">精华：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F%EF%BC%88Relative-Mode%EF%BC%89"><span class="toc-text">相对寻址模式（Relative Mode）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A-3"><span class="toc-text">总结：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%A0%81%EF%BC%88Condition-Codes%EF%BC%89"><span class="toc-text">条件码（Condition Codes）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E7%A0%81%E7%9A%84%E5%88%86%E6%94%AF"><span class="toc-text">使用条件码的分支</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Quiz"><span class="toc-text">Quiz</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE1-%E5%9C%A8%E5%93%AA%E7%A7%8D%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F%E4%B8%8B%EF%BC%8C%E6%93%8D%E4%BD%9C%E6%95%B0%E5%AE%9E%E9%99%85%E4%B8%8A%E6%98%AF%E7%9B%B4%E6%8E%A5%E5%8C%85%E5%90%AB%E5%9C%A8%E6%8C%87%E4%BB%A4%E4%B8%AD%E7%9A%84%EF%BC%9F"><span class="toc-text">题目1: 在哪种寻址模式下，操作数实际上是直接包含在指令中的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88-A-%E7%AB%8B%E5%8D%B3%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F-Immediate-mode"><span class="toc-text">答案: A. 立即寻址模式 (Immediate mode)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-text">解释:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE2-%E5%9C%A8%E4%BB%A5%E4%B8%8B%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F%E4%B8%AD%EF%BC%8C%E5%93%AA%E4%B8%AA%E4%B8%8D%E5%B1%9E%E4%BA%8ERISC%E9%A3%8E%E6%A0%BC%E7%9A%84%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%9F"><span class="toc-text">题目2: 在以下寻址模式中，哪个不属于RISC风格的计算机？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88-D-%E9%97%B4%E6%8E%A5%E5%AF%BB%E5%9D%80%E6%A8%A1%E5%BC%8F-Indirect-mode"><span class="toc-text">答案: D. 间接寻址模式 (Indirect mode)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="toc-text">解释:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE3-%E6%9D%A1%E4%BB%B6%E6%A0%87%E5%BF%97-Z-%E8%A2%AB%E8%AE%BE%E7%BD%AE%E4%B8%BA-1-%E4%BB%A5%E6%8C%87%E7%A4%BA%EF%BC%9A"><span class="toc-text">题目3: 条件标志 Z 被设置为 1 以指示：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%94%E6%A1%88-C-%E7%BB%93%E6%9E%9C%E4%B8%BA%E9%9B%B6-The-result-is-zero"><span class="toc-text">答案: C. 结果为零 (The result is zero)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-2"><span class="toc-text">解释:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RISC-%E5%92%8C-CISC-%E9%A3%8E%E6%A0%BC"><span class="toc-text">RISC 和 CISC 风格</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RISC%EF%BC%88%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%89%E7%89%B9%E7%82%B9"><span class="toc-text">RISC（精简指令集计算机）特点:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RISC-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">RISC 的优点:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CISC%EF%BC%88%E5%A4%8D%E6%9D%82%E6%8C%87%E4%BB%A4%E9%9B%86%E8%AE%A1%E7%AE%97%E6%9C%BA%EF%BC%89%E7%89%B9%E7%82%B9"><span class="toc-text">CISC（复杂指令集计算机）特点:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CISC-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-text">CISC 的优点:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BB%A5%E4%B8%8B%E5%93%AA%E9%A1%B9%E4%B8%8D%E6%98%AF-RISC-%E9%A3%8E%E6%A0%BC%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-text">问题：以下哪项不是 RISC 风格的特点？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%94%E6%A1%88%E8%A7%A3%E6%9E%90%EF%BC%9A"><span class="toc-text">答案解析：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%AD%94%E6%A1%88%EF%BC%9AD"><span class="toc-text">正确答案：D</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SUmmary"><span class="toc-text">SUmmary</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%887%EF%BC%89/" title="计组习题的那些事（7）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/omoide004.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计组习题的那些事（7）"/></a><div class="content"><a class="title" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%887%EF%BC%89/" title="计组习题的那些事（7）">计组习题的那些事（7）</a><time datetime="2024-12-07T15:50:36.000Z" title="发表于 2024-12-07 23:50:36">2024-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%886%EF%BC%89/" title="计组习题的那些事（6）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/porco026.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计组习题的那些事（6）"/></a><div class="content"><a class="title" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%886%EF%BC%89/" title="计组习题的那些事（6）">计组习题的那些事（6）</a><time datetime="2024-12-07T15:06:12.000Z" title="发表于 2024-12-07 23:06:12">2024-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%885%EF%BC%89/" title="计组习题的那些事（5）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/porco026.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计组习题的那些事（5）"/></a><div class="content"><a class="title" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%885%EF%BC%89/" title="计组习题的那些事（5）">计组习题的那些事（5）</a><time datetime="2024-12-07T09:25:25.000Z" title="发表于 2024-12-07 17:25:25">2024-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%884%EF%BC%89/" title="计组习题的那些事（4）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/howl032.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计组习题的那些事（4）"/></a><div class="content"><a class="title" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%884%EF%BC%89/" title="计组习题的那些事（4）">计组习题的那些事（4）</a><time datetime="2024-12-07T07:53:21.000Z" title="发表于 2024-12-07 15:53:21">2024-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%883%EF%BC%89/" title="计组习题的那些事（3）"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/howl005.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计组习题的那些事（3）"/></a><div class="content"><a class="title" href="/2024/12/07/%E8%AE%A1%E7%BB%84%E4%B9%A0%E9%A2%98%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%EF%BC%883%EF%BC%89/" title="计组习题的那些事（3）">计组习题的那些事（3）</a><time datetime="2024-12-07T05:13:23.000Z" title="发表于 2024-12-07 13:13:23">2024-12-07</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HT1PalaKkPaG1UqAXBhJXIu8-gzGzoHsz',
      appKey: 'iT0TnVVAwf9zuZ7NqwclQItY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="1" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="只此无为身，且前行,忘记过去的人注定重蹈覆辙,我是我，我靠自己站立，我会做好自身,如果我睡大觉，谁给我摘月亮呢,假期和朋友，是人生中顶好的两样东西啊。,去爱，去失去，要不负相遇,没什么想不想通的，只是固执而已,我们深爱星辰，乃至不惧夜的黑,吃，喝，享受幸福，接受奇迹,浊水若长流，自清澄,雅俗共赏,总会有什么也不想的幸福时刻吧,时间顺流而下，生活逆流而上,悟已往之不谏，知来者之可追,希望你的小世界里,山花烂漫,茶酒俱全,安宁清淡,明朗欢愉" data-fontsize="20px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS70の旅/&quot;);" href="javascript:void(0);">CS70の旅</a><span class="categoryBar-list-count">25</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS61B/&quot;);" href="javascript:void(0);">CS61B</a><span class="categoryBar-list-count">76</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/期末の旅/&quot;);" href="javascript:void(0);">期末の旅</a><span class="categoryBar-list-count">99</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACMの旅/&quot;);" href="javascript:void(0);">ACMの旅</a><span class="categoryBar-list-count">68</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/区域赛の旅/&quot;);" href="javascript:void(0);">区域赛の旅</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数学建模/&quot;);" href="javascript:void(0);">数学建模</a><span class="categoryBar-list-count">31</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Codeforcesの旅/&quot;);" href="javascript:void(0);">Codeforcesの旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题计划/&quot;);" href="javascript:void(0);">刷题计划</a><span class="categoryBar-list-count">40</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/牛客の旅/&quot;);" href="javascript:void(0);">牛客の旅</a><span class="categoryBar-list-count">65</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/前端の旅/&quot;);" href="javascript:void(0);">前端の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构/&quot;);" href="javascript:void(0);">数据结构</a><span class="categoryBar-list-count">47</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_24.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Atcoderの旅/&quot;);" href="javascript:void(0);">Atcoderの旅</a><span class="categoryBar-list-count">53</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_25.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-の旅/&quot;);" href="javascript:void(0);">C++の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_26.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CSAPPの旅/&quot;);" href="javascript:void(0);">CSAPPの旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_27.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS知识/&quot;);" href="javascript:void(0);">CS知识</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_28.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程基础/&quot;);" href="javascript:void(0);">编程基础</a><span class="categoryBar-list-count">22</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_29.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/离散数学/&quot;);" href="javascript:void(0);">离散数学</a><span class="categoryBar-list-count">29</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_30.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JAVAの旅/&quot;);" href="javascript:void(0);">JAVAの旅</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_31.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MIT-6-031-Software-Construction/&quot;);" href="javascript:void(0);">MIT 6.031:Software Construction</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_32.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS-110L/&quot;);" href="javascript:void(0);">CS 110L</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_33.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/个人安排/&quot;);" href="javascript:void(0);">个人安排</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_34.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/灵魂の旅/&quot;);" href="javascript:void(0);">灵魂の旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_35.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂项/&quot;);" href="javascript:void(0);">杂项</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_36.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">48</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_37.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文学/&quot;);" href="javascript:void(0);">文学</a><span class="categoryBar-list-count">49</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_38.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/力扣の旅/&quot;);" href="javascript:void(0);">力扣の旅</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_39.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/千里十二行/&quot;);" href="javascript:void(0);">千里十二行</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/🗡指offer/&quot;);" href="javascript:void(0);">🗡指offer</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_41.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/少年游/&quot;);" href="javascript:void(0);">少年游</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_42.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法提高课/&quot;);" href="javascript:void(0);">算法提高课</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_43.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/汇编の旅/&quot;);" href="javascript:void(0);">汇编の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-实训/&quot;);" href="javascript:void(0);">C++实训</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4b31456c6f0f4489f99177f89e936de7286431045.png@1256w_708h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt="">诗录</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/51d37eba99d243607ddedfff6e91568f617436609.jpg@1256w_1884h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">TotoroのPlan</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.48/img_482_1920x1080_96_null_normal.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt="">Markdown格式</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>