<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++八股 | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="https:&#x2F;&#x2F;github.com&#x2F;ZhanghHaoDev&#x2F;interview C++八股文由于要期末考试，还是看看八股文（） 第一章 C++基础篇1. C++ 中内存分配情况 在计算机程序的内存管理中，内存通常被划分为几个不同的区域，每个区域负责存储不同类型的数据。以下是各个内存区域的详细解释： 1. 栈（Stack） 管理方式：由编译器自动管理分配和回收。 存储内容：存储局部变量和函数参数">
<meta property="og:type" content="article">
<meta property="og:title" content="C++八股">
<meta property="og:url" content="http://totorocatcat.top/2024/06/01/C-%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="https:&#x2F;&#x2F;github.com&#x2F;ZhanghHaoDev&#x2F;interview C++八股文由于要期末考试，还是看看八股文（） 第一章 C++基础篇1. C++ 中内存分配情况 在计算机程序的内存管理中，内存通常被划分为几个不同的区域，每个区域负责存储不同类型的数据。以下是各个内存区域的详细解释： 1. 栈（Stack） 管理方式：由编译器自动管理分配和回收。 存储内容：存储局部变量和函数参数">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img.likepoems.com/resource/pc/b702fcf4480034312d58d6f56e30d7624.jpg">
<meta property="article:published_time" content="2024-06-01T13:57:43.000Z">
<meta property="article:modified_time" content="2024-06-07T12:02:21.541Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="有趣">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img.likepoems.com/resource/pc/b702fcf4480034312d58d6f56e30d7624.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/b5ca6e582a7a45e6fde46e616eeb68e.png"><link rel="canonical" href="http://totorocatcat.top/2024/06/01/C-%E5%85%AB%E8%82%A1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":765,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++八股',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-06-07 20:02:21'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">794</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://img.likepoems.com/resource/pc/b702fcf4480034312d58d6f56e30d7624.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++八股</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-01T13:57:43.000Z" title="发表于 2024-06-01 21:57:43">2024-06-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-07T12:02:21.541Z" title="更新于 2024-06-07 20:02:21">2024-06-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E3%81%AE%E6%97%85/">C++の旅</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">14.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++八股"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/2024/06/01/C-%E5%85%AB%E8%82%A1/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count" data-xid="/2024/06/01/C-%E5%85%AB%E8%82%A1/" itemprop="commentCount"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://github.com/ZhanghHaoDev/interview">https://github.com/ZhanghHaoDev/interview</a></p>
<h1 id="C-八股文"><a href="#C-八股文" class="headerlink" title="C++八股文"></a>C++八股文</h1><p>由于要期末考试，还是看看八股文（）</p>
<h2 id="第一章-C-基础篇"><a href="#第一章-C-基础篇" class="headerlink" title="第一章 C++基础篇"></a>第一章 C++基础篇</h2><h3 id="1-C-中内存分配情况"><a href="#1-C-中内存分配情况" class="headerlink" title="1. C++ 中内存分配情况"></a>1. C++ 中内存分配情况</h3><blockquote>
<p>在计算机程序的内存管理中，内存通常被划分为几个不同的区域，每个区域负责存储不同类型的数据。以下是各个内存区域的详细解释：</p>
<h3 id="1-栈（Stack）"><a href="#1-栈（Stack）" class="headerlink" title="1. 栈（Stack）"></a>1. 栈（Stack）</h3><ul>
<li><strong>管理方式</strong>：由编译器自动管理分配和回收。</li>
<li><strong>存储内容</strong>：存储局部变量和函数参数。</li>
<li><strong>特点</strong>：<ul>
<li>先进后出（LIFO）数据结构。</li>
<li>栈的空间相对较小，且大小在编译时确定。</li>
<li>存取速度快，因为是直接在内存中分配和释放的。</li>
<li>随着函数调用和返回自动分配和释放内存，不需要程序员手动管理。</li>
<li>栈溢出（Stack Overflow）：如果函数调用层次过深或者局部变量过大，会导致栈溢出。</li>
</ul>
</li>
</ul>
<h3 id="2-堆（Heap）"><a href="#2-堆（Heap）" class="headerlink" title="2. 堆（Heap）"></a>2. 堆（Heap）</h3><ul>
<li><strong>管理方式</strong>：由程序员手动管理分配和回收。<ul>
<li>分配：<code>new</code> 或 <code>malloc</code></li>
<li>回收：<code>delete</code> 或 <code>free</code></li>
</ul>
</li>
<li><strong>存储内容</strong>：动态分配的内存，例如动态数组、链表等。</li>
<li><strong>特点</strong>：<ul>
<li>空间相对较大，但管理复杂。</li>
<li>内存的分配和回收不定，因此可能会导致内存碎片化。</li>
<li>内存泄漏（Memory Leak）：如果程序员忘记释放分配的内存，会导致内存无法被再次使用。</li>
<li>分配和释放速度较慢，因为需要查找合适的内存块，并且可能涉及操作系统的系统调用。</li>
</ul>
</li>
</ul>
<h3 id="3-全局-静态存储区"><a href="#3-全局-静态存储区" class="headerlink" title="3. 全局/静态存储区"></a>3. 全局/静态存储区</h3><ul>
<li><strong>管理方式</strong>：由编译器在程序加载时分配，并在程序退出时释放。</li>
<li><strong>存储内容</strong>：存储全局变量和静态变量。<ul>
<li><strong>初始化区域</strong>：存储已初始化的全局变量和静态变量。</li>
<li><strong>未初始化区域（BSS段）</strong>：存储未初始化的全局变量和静态变量，在程序加载时被清零。</li>
</ul>
</li>
<li><strong>特点</strong>：<ul>
<li>变量的生命周期从程序开始到程序结束。</li>
<li>内存地址固定，存取速度快。</li>
<li>适合存储需要在整个程序运行过程中保持状态的变量。</li>
</ul>
</li>
</ul>
<h3 id="4-常量存储区"><a href="#4-常量存储区" class="headerlink" title="4. 常量存储区"></a>4. 常量存储区</h3><ul>
<li><strong>管理方式</strong>：由编译器在程序加载时分配，并在程序退出时释放。</li>
<li><strong>存储内容</strong>：存储常量，例如字符串常量、<code>const</code>修饰的变量等。</li>
<li><strong>特点</strong>：<ul>
<li>通常只读，试图修改这些区域的内容会导致运行时错误。</li>
<li>生命周期与程序相同。</li>
</ul>
</li>
</ul>
<h3 id="5-代码区"><a href="#5-代码区" class="headerlink" title="5. 代码区"></a>5. 代码区</h3><ul>
<li><strong>管理方式</strong>：由操作系统和编译器管理。</li>
<li><strong>存储内容</strong>：存储程序的二进制代码，即编译后的机器指令。</li>
<li><strong>特点</strong>：<ul>
<li>通常是只读的，防止程序修改自身的代码（自修改代码）。</li>
<li>存储的是程序的执行代码，从主函数开始到所有被调用的函数。</li>
</ul>
</li>
</ul>
<h3 id="图示"><a href="#图示" class="headerlink" title="图示"></a>图示</h3><p>为了更直观地理解内存布局，可以参照以下图示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+</span><br><span class="line">|    栈 （向下增长）    |</span><br><span class="line">|--------------------|</span><br><span class="line">|      空闲区         |</span><br><span class="line">|--------------------|</span><br><span class="line">|     堆 （向上增长）   |</span><br><span class="line">+--------------------+</span><br><span class="line">|     BSS段（未初始化） |</span><br><span class="line">|--------------------|</span><br><span class="line">|    数据段（已初始化） |</span><br><span class="line">|--------------------|</span><br><span class="line">|    代码段（只读）     |</span><br><span class="line">+--------------------+</span><br></pre></td></tr></table></figure>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global_var = <span class="number">10</span>; <span class="comment">// 全局变量，初始化区域</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> static_var; <span class="comment">// 静态变量，BSS段</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> local_var = <span class="number">20</span>; <span class="comment">// 局部变量，栈</span></span><br><span class="line">    <span class="type">int</span> *heap_var = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 动态分配内存，堆</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> const_var = <span class="number">30</span>; <span class="comment">// 常量，常量存储区</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Global variable: %d\n&quot;</span>, global_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Static variable: %d\n&quot;</span>, static_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Local variable: %d\n&quot;</span>, local_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap variable: %d\n&quot;</span>, *heap_var);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Constant variable: %d\n&quot;</span>, const_var);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(heap_var); <span class="comment">// 释放堆内存</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="2-堆和栈区别"><a href="#2-堆和栈区别" class="headerlink" title="2. 堆和栈区别"></a>2. 堆和栈区别</h3><p><strong>栈</strong></p>
<blockquote>
<p>由编译器进⾏管理，在需要时由编译器⾃动分配空间，在不需要时候⾃动回收空间，⼀般保存的是局部变量和函数参数等。<br>连续的内存空间，在函数调⽤的时候，⾸先⼊栈的主函数的下⼀条可执⾏指令的地址，然后是函数的各个参数。</p>
<p>⼤多数编译器中，参数是从右向左⼊栈（原因在于采⽤这种顺序，是为了让程序员在使⽤C/C++的“函数参数⻓度可变”这个特性时更⽅便。如果是从左向右压栈，第⼀个参数（即描述可变参数表各变量类型的那个参数）将被放在栈底，由于可变参的函数第⼀步就需要解析可变参数表的各参数类型，即第⼀步就需要得到上述参数，因此，将它放在栈底是很不⽅便的。）本次函数调⽤结束时，局部变量先出栈，然后是参数，最后是栈顶指针最开始存放的地址，程序由该点继续运⾏，不会产⽣碎⽚。<br>栈是⾼地址向低地址扩展，栈低⾼地址，空间较⼩。</p>
</blockquote>
<p><strong>堆</strong></p>
<blockquote>
<p>由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，如果不进⾏回收的话，会造成内存泄漏的问题。<br>不连续的空间，实际上系统中有⼀个空闲链表，当有程序申请的时候，系统遍历空闲链表找到第⼀个⼤于等于申请⼤⼩的空间分配给程序，⼀般在分配程序的时候，也会空间头部写⼊内存⼤⼩，⽅便 delete 回收空间⼤⼩。当然如果有剩余的，也会将剩余的插⼊到空闲链表中，这也是产⽣内存碎⽚的原因。<br>堆是低地址向⾼地址扩展，空间交⼤，较为灵活。</p>
</blockquote>
<h3 id="3-C-中如何申请和释放内存-C语言"><a href="#3-C-中如何申请和释放内存-C语言" class="headerlink" title="3. C++中如何申请和释放内存/C语言"></a>3. C++中如何申请和释放内存/C语言</h3><blockquote>
<p>C++中通过new来申请内存，通过delete来释放内存<br>C语言中是通过 malloc来申请内存，free来释放内存</p>
</blockquote>
<h3 id="4-new和malloc区别是什么？"><a href="#4-new和malloc区别是什么？" class="headerlink" title="4. new和malloc区别是什么？"></a>4. new和malloc区别是什么？</h3><blockquote>
<p>malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。<br>new 是c++中的操作符，malloc是c语言中的一个函数<br>new 不止是分配内存，而且会调用类的构造函数，同理delete会调用类的析构函数，而malloc则只分配内存，不会进行初始化类成员的工作，同样free 也不会调用析构函数<br>内存泄漏对于malloc或者new都可以检查出来的，区别在于new可以指明是那个文件的那一行，而malloc没有这些信息。<br>都可以⽤来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是库函数。</p>
<p>执⾏ new 实际上执⾏两个过程：<br>1.分配未初始化的内存空间（malloc）；<br>2.使⽤对象的构造函数对空间进⾏初始化；返回空间的⾸地址。如果在第⼀步分配空间中出现问题，则抛出 std::bad_alloc 异常，或被某个设定的异常处理函数捕获处理；如果在第⼆步构造对象时出现异常，则⾃动调⽤ delete 释放内存。</p>
<p>执⾏ delete 实际上也有两个过程：<br>1.使⽤析构函数对对象进⾏析构；2.回收内存空间（free）。</p>
<p>以上也可以看出 new 和 malloc 的区别，new 得到的是经过初始化的空间，⽽ malloc 得到的是未初始化的空间。所以 new 是 new ⼀个类型，⽽ malloc 则是malloc ⼀个字节⻓度的空间。delete 和 free 同理，delete 不仅释放空间还析构对象，delete ⼀个类型，free ⼀个字节⻓度的空间。</p>
<p>为什么有了 malloc／free 还需要 new／delete？因为对于⾮内部数据类型⽽⾔，光⽤ malloc／free ⽆法满⾜动态对象的要求。对象在创建的同时需要⾃动执⾏构造函数，对象在消亡以前要⾃动执⾏析构函数。由于 mallo／ free 是库函数⽽不是运算符，不在编译器控制权限之内，不能够把执⾏的构造函数和析构函数的任务强加于 malloc／free，所以有了 new／delete 操作符。</p>
</blockquote>
<h3 id="5-函数传递参数的⼏种⽅式"><a href="#5-函数传递参数的⼏种⽅式" class="headerlink" title="5. 函数传递参数的⼏种⽅式"></a>5. 函数传递参数的⼏种⽅式</h3><blockquote>
<p>值传递：形参是实参的拷⻉，函数内部对形参的操作并不会影响到外部的实参。<br>指针传递：也是值传递的⼀种⽅式，形参是指向实参地址的指针，当对形参的指向操作时，就相当于对实参本身进⾏操作。<br>引⽤传递：实际上就是把引⽤对象的地址放在了开辟的栈空间中，函数内部对形参的任何操作可以直接映射到外部的实参上⾯。</p>
</blockquote>
<h3 id="6-C-中的指针参数传递和引⽤参数传递"><a href="#6-C-中的指针参数传递和引⽤参数传递" class="headerlink" title="6. C++ 中的指针参数传递和引⽤参数传递"></a>6. C++ 中的指针参数传递和引⽤参数传递</h3><blockquote>
<p><strong>指针参数传递本质上是值传递</strong>，<br>它所传递的是⼀个地址值。值传递过程中，被调函数的形式参数作为被调函数的局部变量处理，会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从⽽形成了实参的⼀个副本（替身）。值传递的特点是，被调函数对形式参数的任何操作都是作为局部变量进⾏的，不会影响主调函数的实参变量的值（形参指针变了，实参指针不会变）。</p>
<p>引⽤参数传递过程中，被调函数的形式参数也作为局部变量在栈中开辟了内存空间，但是这时存放的是由主调函数放进来的实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。因此，被调函数对形参的任何操作都会影响主调函数中的实参变量。</p>
<p><strong>引⽤传递和指针传递是不同的</strong>，<br>虽然他们都是在被调函数栈空间上的⼀个局部变量，但是任何对于引⽤参数的处理都会通过⼀个间接寻址的⽅式操作到主调函数中的相关变量。⽽对于指针传递的参数，如果改变被调函数中的指针地址，它将应⽤不到主调函数的相关变量。如果想通过指针参数传递来改变主调函数中的相关变量（地址），那就得使⽤指向指针的指针或者指针引⽤。</p>
<p><strong>从编译的⻆度来讲</strong>，<br>程序在编译时分别将指针和引⽤添加到符号表上，符号表中记录的是变量名及变量所对应地 址。指针变量在符号表上对应的地址值为指针变量的地址值，⽽引⽤在符号表上对应的地址值为引⽤对象的地址值（与实参名字不同，地址相同）。符号表⽣成之后就不会再改，因此指针可以改变其指向的对象（指针变量中的值可以改），⽽引⽤对象则不能修改。</p>
</blockquote>
<h3 id="7-指针和引⽤的区别"><a href="#7-指针和引⽤的区别" class="headerlink" title="7. 指针和引⽤的区别"></a>7. 指针和引⽤的区别</h3><blockquote>
<p>指针和引⽤都是⼀种内存地址的概念，区别呢，指针是⼀个实体，引⽤只是⼀个别名。</p>
<p>指针它指向⼀块内存，指针的内容是所指向的内存的地址，在编译的时候，则是将“指针变量名-指针变量的地址”添加到符号表中，所以说，指针包含的内容是可以改变的，允许拷⻉和赋值，有 const 和⾮ const 区别，甚⾄可以为空，sizeof 指针得到的是指针类型的⼤⼩。</p>
<p>⽽对于引⽤来说，它只是⼀块内存的别名，在添加到符号表的时候，是将”引⽤变量名-引⽤对象的地址”添加到符号表中，符号表⼀经完成不能改变，所以引⽤必须⽽且只能在定义时被绑定到⼀块内存上，后续不能更改，也不能为空，也没有 const 和⾮ const 区别。</p>
<p>sizeof 引⽤得到代表对象的⼤⼩。⽽ sizeof 指针得到的是指针本身的⼤⼩。另外在参数传递中，指针需要被解引⽤后才可以对对象进⾏操作，⽽直接对引⽤进⾏的修改会直接作⽤到引⽤对象上。</p>
<p>作为参数时也不同，传指针的实质是传值，传递的值是指针的地址；传引⽤的实质是传地址，传递的是变量的地址。</p>
</blockquote>
<h3 id="8-简单说⼀下函数指针"><a href="#8-简单说⼀下函数指针" class="headerlink" title="8. 简单说⼀下函数指针"></a>8. 简单说⼀下函数指针</h3><p>从定义和⽤途两⽅⾯来说⼀下理解：<br><strong>⾸先是定义：</strong></p>
<blockquote>
<p>函数指针是指向函数的指针变量。函数指针本身⾸先是⼀个指针变量，该指针变量指向⼀个具体的函数。这正如⽤指针变量可指向整型变量、字符型、数组⼀样，这⾥是指向函数。<br>在编译时，每⼀个函数都有⼀个⼊⼝地址，该⼊⼝地址就是函数指针所指向的地址。有了指向函数的指针变量后，可⽤该指针变量调⽤函数，就如同⽤指针变量可引⽤其他类型变量⼀样，在这些概念上是⼤体⼀致的。</p>
</blockquote>
<p><strong>其次是⽤途：</strong></p>
<blockquote>
<p>调⽤函数和做函数的参数，⽐如回调函数。</p>
</blockquote>
<h3 id="9-野-wild-指针与悬空-dangling-指针有什么区别？如何避免？"><a href="#9-野-wild-指针与悬空-dangling-指针有什么区别？如何避免？" class="headerlink" title="9. 野(wild)指针与悬空(dangling)指针有什么区别？如何避免？"></a>9. 野(wild)指针与悬空(dangling)指针有什么区别？如何避免？</h3><blockquote>
<p>野指针(wild pointer)：就是没有被初始化过的指针。⽤ gcc -Wall 编译, 会出现useduninitialized 警告。</p>
<p>悬空指针：是指针最初指向的内存已经被释放了的⼀种指针。</p>
<p>⽆论是野指针还是悬空指针，都是指向⽆效内存区域(这⾥的⽆效指的是”不安全不可控”)的指针。 访问”不安全可控”(invalid)的内存区域将导致”Undefined Behavior”。</p>
<p>如何避免使⽤野指针？在平时的编码中，养成在定义指针后且在使⽤之前完成初始化的习惯或者使⽤智能指针。</p>
</blockquote>
<h3 id="10-说⼀下-const-修饰指针如何区分？"><a href="#10-说⼀下-const-修饰指针如何区分？" class="headerlink" title="10. 说⼀下 const 修饰指针如何区分？"></a>10. 说⼀下 const 修饰指针如何区分？</h3><p>下⾯都是合法的声明，但是含义⼤不同：</p>
<figure class="highlight plaintext"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const int * p1; //指向整形常量的指针，它指向的值不能修改</span><br><span class="line">int * const p2; //指向整形的常量指针 ，它不能在指向别的变量，但指向（变量）的值可以修改。</span><br><span class="line">const int *const p3; //指向整形常量的 常量指针 。它既不能再指向别的常量，指向的值也不能修改。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>理解这些声明的技巧在于，查看关键字const右边来确定什么被声明为常量，如果该关键字的右边是类型，则值是常量；如果关键字的右边是指针变量，则指针本身是常量。</p>
</blockquote>
<h3 id="11-C-中-const-和-static-关键字（定义，⽤途）"><a href="#11-C-中-const-和-static-关键字（定义，⽤途）" class="headerlink" title="11. C++ 中 const 和 static 关键字（定义，⽤途）"></a>11. C++ 中 const 和 static 关键字（定义，⽤途）</h3><p><strong>static关键字：含义及实现机制</strong></p>
<blockquote>
<p><strong>static</strong>  作⽤：控制变量的存储⽅式和可⻅性。</p>
<p><strong>作⽤⼀：修饰局部变量</strong>：⼀般情况下，对于局部变量在程序中是存放在栈区的，并且局部的⽣命周期在包含语句块执⾏结束时便结束了。但是如果⽤ static 关键字修饰的话，该变量便会存放在静态数据区，其⽣命周期会⼀直延续到整个程序执⾏结束。但是要注意的是，虽然⽤ static  对局部变量进⾏修饰之后，其⽣命周期以及存储空间发⽣了变化，但其作⽤域并没有改变，作⽤域还是限制在其语句块。</p>
<p><strong>作⽤⼆：修饰全部变量</strong>：对于⼀个全局变量，它既可以在本⽂件中被访问到，也可以在同⼀个⼯程中其它源⽂件被访问(添加 extern进⾏声明即可)。⽤ static 对全局变量进⾏修饰改变了其作⽤域范围，由原来的整个⼯程可⻅变成了本⽂件可⻅。</p>
<p><strong>作⽤三：修饰函数</strong>：⽤  static  修饰函数，情况和修饰全局变量类似，也是改变了函数的作⽤域。</p>
<p><strong>作⽤四：修饰类</strong>：如果 C++ 中对类中的某个函数⽤ static  修饰，则表示该函数属于⼀个类⽽不是属于此类的任何特定对象；如果对类中的某个变量进⾏ static 修饰，则表示该变量以及所有的对象所有，存储空间中只存在⼀个副本，可以通过；类和对象去调⽤。</p>
</blockquote>
<p><strong>const 关键字：含义及实现机制</strong></p>
<blockquote>
<p><strong>作用一：修饰基本类型数据类型</strong>：基本数据类型，修饰符 const 可以⽤在类型说明符前，也可以⽤在类型说明符后，其结果是⼀样的。在使⽤这些常量的时候，只要不改变这些常量的值即可。</p>
<p><strong>作用二：修饰指针变量和引⽤变量</strong>：如果 const 位于⼩星星的左侧，则 const 就是⽤来修饰指针所指向的变量，即指针指向为常量；如果 const 位于⼩星星的右侧，则 const 就是修饰指针本身，即指针本身是常量。</p>
<p><strong>作用三：应⽤到函数中</strong>：作为参数的 const 修饰符：调⽤函数的时候，⽤相应的变量初始化 const 常量，则在函数体中，按照 const 所修饰的部分进⾏常量化，保护了原对象的属性。 [注意]：参数 const 通常⽤于参数为指针或引⽤的情况; 作为函数返回值的 const 修饰符：声明了返回值后，const 按照”修饰原则”进⾏修饰，起到相应的保护作⽤。</p>
<p><strong>作用四：在类中的⽤法</strong>：const 成员变量，只在某个对象⽣命周期内是常量，⽽对于整个类⽽⾔是可以改变的。因为类可以创建多个对象，不同的对象其 const 数据成员值可以不同。所以不能在类的声明中初始化 const 数据成员，因为类的对象在没有创建时候，编译器不知道 const 数据成员的值是什么。const 数据成员的初始化只能在类的构造函数的初始化列表中进⾏。const 成员函数：const 成员函数的主要⽬的是防⽌成员函数修改对象的内容。要注意，const 关键字和 static 关键字对于成员函数来说是不能同时使⽤的，因为 static 关键字修饰静态成员函数不含有 this 指针，即不能实例化，const 成员函数⼜必须具体到某⼀个函数。</p>
<p><strong>作用五：</strong> 修饰类对象，定义常量对象，常量对象只能调⽤常量函数，别的成员函数都不能调⽤。</p>
<p><strong>补充</strong>：const 成员函数中如果实在想修改某个变量，可以使⽤ mutable 进⾏修饰。成员变量中如果想建⽴在整个类中都恒定的常量，应该⽤类中的枚举常量来实现或者 static const。</p>
</blockquote>
<h3 id="12-说⼀下-C-⾥是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#12-说⼀下-C-⾥是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="12. 说⼀下 C++ ⾥是怎么定义常量的？常量存放在内存的哪个位置？"></a>12. 说⼀下 C++ ⾥是怎么定义常量的？常量存放在内存的哪个位置？</h3><blockquote>
<p>对于局部常量，存放在栈区；<br>对于全局常量，编译期⼀般不分配内存，放在符号表中以提⾼访问效率；字⾯值常量，⽐如字符串，放在常量区。</p>
</blockquote>
<h3 id="13-宏定义-define-和常量-const-的区别"><a href="#13-宏定义-define-和常量-const-的区别" class="headerlink" title="13. 宏定义 #define 和常量 const 的区别"></a>13. 宏定义 #define 和常量 const 的区别</h3><p><strong>类型和安全检查不同</strong></p>
<blockquote>
<p>宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；<br>const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查</p>
</blockquote>
<p><strong>编译器处理不同</strong></p>
<blockquote>
<p>宏定义是一个”编译时”概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期；<br>const常量是一个”运行时”概念，在程序运行使用，类似于一个只读行数据</p>
</blockquote>
<p><strong>存储方式不同</strong></p>
<blockquote>
<p>宏定义是直接替换，不会分配内存，存储于程序的代码段中；<br>const常量需要进行内存分配，存储于程序的数据段中</p>
</blockquote>
<p><strong>定义域不同</strong></p>
<blockquote>
<p>宏定义是全局定义，可以在整个程序中使用；<br>const常量是局部定义，只能在定义的地方使用</p>
</blockquote>
<h3 id="14-C-和-C-区别-（函数-类-struct-class）"><a href="#14-C-和-C-区别-（函数-类-struct-class）" class="headerlink" title="14. C 和 C++ 区别 （函数/类/struct/class）"></a>14. C 和 C++ 区别 （函数/类/struct/class）</h3><p><strong>C++ 有新增的语法和关键字</strong></p>
<blockquote>
<p>语法的区别有头⽂件的不同和命名空间的不同，<br>C++ 允许我们⾃⼰定义⾃⼰的空间， C 中不可以。<br>关键字⽅⾯⽐如 C++ 与 C 动态管理内存的⽅式不同，C++ 中在 malloc 和 free 的基础上增加了 new和 delete，<br>⽽且 C++ 中在指针的基础上增加了引⽤的概念，<br>关键字例如 C++中还增加了 auto，explicit 体现显示和隐式转换上的概念要求，还有 dynamic_cast 增加类型安全⽅⾯的内容。</p>
</blockquote>
<p><strong>函数⽅⾯ C++ 中有重载和虚函数的概念</strong></p>
<blockquote>
<p>C++ ⽀持函数重载⽽C语言不⽀持，是因为 C++ 函数的名字修饰与 C 不同，C++函数名字的修饰会将参数加在后⾯，例如，int  func(int,double)经过名字修饰之后会变成_func_int_double，⽽ C 中则会变成 _func，所以 C++ 中会⽀持不同参数调⽤不同函数。</p>
</blockquote>
<p>C++ 还有虚函数概念，⽤以实现多态。</p>
<p><strong>类⽅⾯，C 的struct 和 C++ 的类也有很⼤不同</strong>：</p>
<blockquote>
<p>C++ 中的 struct 不仅可以有成员变量还可以成员函数，⽽且对于 struct 增加了权限访问的概念，struct 的默认成员访问权限和默认继承权限都是 public，<br>C++ 中除了 struct 还有 class 表示类，struct 和 class 还有⼀点不同在于 class 的默认成员访问权限和默认继承权限都是 private。</p>
</blockquote>
<p><strong>C++ 中增加了模板还重⽤代码，提供了更加强⼤的 STL 标准库。</strong><br><strong>C 的 struct 更适合看成是⼀个数据结构的实现体，⽽ C++ 的 class 更适合看成是⼀个对象的实现体。</strong></p>
<h3 id="15-C-和-Java-区别（语⾔特性，垃圾回收，应⽤场景等）"><a href="#15-C-和-Java-区别（语⾔特性，垃圾回收，应⽤场景等）" class="headerlink" title="15. C++ 和 Java 区别（语⾔特性，垃圾回收，应⽤场景等）"></a>15. C++ 和 Java 区别（语⾔特性，垃圾回收，应⽤场景等）</h3><blockquote>
<p>指针：Java 语⾔让程序员没法找到指针来直接访问内存，没有指针的概念，并有内存的⾃动管理功能，从⽽有效的防⽌了 C++ 语⾔中的指针操作失误的影响。但并⾮ Java 中没有指针，Java 虚拟机内部中还是⽤了指针，保证了 Java  程序的安全。</p>
<p>多重继承：C++ ⽀持多重继承但 Java 不⽀持，但⽀持⼀个类继承多个接⼝，实现 C++ 中多重继承的功能，⼜避免了 C++ 的多重继承带来的不便。</p>
<p>数据类型和类：Java 是完全⾯向对象的语⾔，所有的函数和变量必须是类的⼀部分。除了基本数据类型之外，其余的都作为类对象，对象将数据和⽅法结合起来，把它们封装在类中，这样每个对象都可以实现⾃⼰的特点和⾏为。 Java 中取消了 C++ 中的 struct 和  union 。</p>
<p>⾃动内存管理：Java 程序中所有对象都是⽤ new 操作符建⽴在内存堆栈上，Java ⾃动进⾏⽆⽤内存回收操作，不需要程序员进⾏⼿动删除。⽽ C++ 中必须由程序员释放内存资源，增加了程序设计者的负担。Java 中当⼀个对象不再被⽤到时， ⽆⽤内存回收器将给他们加上标签。Java ⾥⽆⽤内存回收程序是以线程⽅式在后台运⾏的，利⽤空闲时间⼯作来删除。</p>
<p>Java 不⽀持操作符重载。操作符重载被认为是 C++ 的突出特性。</p>
<p>Java 不⽀持预处理功能。C++ 在编译过程中都有⼀个预编译阶段，Java 没有预处理器，但它提供了 import 与 C++预处理器具有类似功能。</p>
<p>类型转换：C++ 中有数据类型隐含转换的机制，Java 中需要限时强制类型转换。</p>
<p>字符串：C++中字符串是以 Null 终⽌符代表字符串的结束，⽽ Java 的字符串 是⽤类对象（string 和stringBuffer）来实现的。</p>
<p>Java 中不提供 goto 语句，虽然指定 goto 作为关键字，但不⽀持它的使⽤，使程序简洁易读。</p>
<p>Java 的异常机制⽤于捕获例外事件，增强系统容错能⼒。</p>
</blockquote>
<h3 id="16-C-中重载和重写，重定义的区别"><a href="#16-C-中重载和重写，重定义的区别" class="headerlink" title="16. C++ 中重载和重写，重定义的区别"></a>16. C++ 中重载和重写，重定义的区别</h3><p><strong>重载</strong></p>
<blockquote>
<p>是指同⼀可访问区内被声明的⼏个具有不同参数列表的同名函数，依赖于 C++函数名字的修饰会将参数加在后⾯，可以是参数类型，个数，顺序的不同。根据参数列表决定调⽤哪个函数，重载不关⼼函数的返回类型。</p>
</blockquote>
<p><strong>重写</strong></p>
<blockquote>
<p>派⽣类中重新定义⽗类中除了函数体外完全相同的虚函数，注意被重写的函数不能是 static 的，<br>⼀定要是虚函数，且其他⼀定要完全相同。要注意，重写和被重写的函数是在不同的类当中的，重写函数的访问修饰符是可以不同的，尽管 virtual 中是 private 的，派⽣类中重写可以改为 public。</p>
</blockquote>
<p><strong>重定义（隐藏）</strong><br>派⽣类重新定义⽗类中相同名字的⾮ virtual 函数，参数列表和返回类型都可以不同，即⽗类中除了定义成 virtual 且完全相同的同名函数才不会被派⽣类中的同名函数所隐藏（重定义）。</p>
<p><strong>在c++中函数名称相同，参数列表相同，返回值不同，算重载吗？</strong></p>
<blockquote>
<p>重载最重要的是函数名称相同，函数的重载区分主要是靠参数列表来进行区分<br>返回值不同是不能重载的，因为当调用的时候无法区分调用的是哪个函数</p>
</blockquote>
<h3 id="17-介绍-C-所有的构造函数"><a href="#17-介绍-C-所有的构造函数" class="headerlink" title="17. 介绍 C++ 所有的构造函数"></a>17. 介绍 C++ 所有的构造函数</h3><p>构造函数的作⽤：初始化对象的数据成员。<br>类的对象被创建时，编译系统为对象分配内存空间，并⾃动调⽤构造函数，由构造函数完成成员的初始化⼯作。</p>
<p><strong>⽆参数构造函数</strong>：</p>
<blockquote>
<p>即默认构造函数，如果没有明确写出⽆参数构造函数，编译器会⾃动⽣成默认的⽆参数构造函数，函数为空，什么也不做，如果不想使⽤⾃动⽣成的⽆参构造函数，必需要⾃⼰显示写出⼀个⽆参构造函数。</p>
</blockquote>
<p><strong>⼀般构造函数</strong>：</p>
<blockquote>
<p>也称重载构造函数，⼀般构造函数可以有各种参数形式，⼀个类可以有多个⼀般构造函数，前提是参数的个数或者类型不同，创建对象时根据传⼊参数不同调⽤不同的构造函数。</p>
</blockquote>
<p><strong>拷⻉构造函数</strong>：</p>
<blockquote>
<p>拷⻉构造函数的函数参数为对象本身的引⽤，⽤于根据⼀个已存在的对象复制出⼀个新的该类的对象，⼀般在函数中会将已存在的对象的数据成员的值⼀⼀复制到新创建的对象中。如果没有显示的写拷⻉构造函 数，则系统会默认创建⼀个拷⻉构造函数，但当类中有指针成员时，最好不要使⽤编译器提供的默认的拷⻉构造函数，最好⾃⼰定义并且在函数中执⾏深拷⻉。</p>
</blockquote>
<p><strong>类型转换构造函数</strong>：</p>
<blockquote>
<p>根据⼀个指定类型的对象创建⼀个本类的对象，也可以算是⼀般构造函数的⼀种，这⾥提出来，是想说有的时候不允许默认转换的话，要记得将其声明为 explict 的，来阻⽌⼀些隐式转换的发⽣。</p>
</blockquote>
<p><strong>赋值运算符的重载</strong>：</p>
<blockquote>
<p>注意，这个类似拷⻉构造函数，将＝右边的本类对象的值复制给＝左边的对象，它不属于构造函数，＝左右两边的对象必需已经被创建。如果没有显示的写赋值运算符的重载，系统也会⽣成默认的赋值运算 符，做⼀些基本的拷⻉⼯作。<br>这⾥区分</p>
</blockquote>
<figure class="highlight plaintext"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A a1,A a2;a1 = a2;// 调用赋值运算符</span><br><span class="line">A a3 = a1;//调用拷贝构造函数，因为进行的是初始化工作，a3并未存在</span><br></pre></td></tr></table></figure>
<h3 id="18-C-的四种强制转换"><a href="#18-C-的四种强制转换" class="headerlink" title="18. C++ 的四种强制转换"></a>18. C++ 的四种强制转换</h3><p>C++ 的四种强制转换包括：static_cast, dynamic_cast, const_cast, reinterpret_cast</p>
<p><strong>static_cast：</strong></p>
<blockquote>
<p>明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换（派⽣类-&gt;基类）安全，下⾏转换（基类-&gt;派⽣类） 不安全，所以主要执⾏⾮多态的转换操作；</p>
</blockquote>
<p><strong>dynamic_cast：</strong></p>
<blockquote>
<p>专⻔⽤于派⽣类之间的转换，type-id 必须是类指针，类引⽤或 void*，对于下⾏转换是安全的，当类型不⼀致时，转换过来的是空指针，⽽static_cast，当类型不⼀致时，转换过来的事错误意义的指针，可能造成⾮法访问等问题。</p>
</blockquote>
<p><strong>const_cast：</strong></p>
<blockquote>
<p>专⻔⽤于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四个转换符中唯⼀⼀个可以操作常量的转换符。<br><strong>reinterpret_cast：</strong><br>不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏重新解释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤之间进⾏肆⽆忌惮的转换。</p>
</blockquote>
<h3 id="19-⾯向对象的三⼤特性"><a href="#19-⾯向对象的三⼤特性" class="headerlink" title="19. ⾯向对象的三⼤特性"></a>19. ⾯向对象的三⼤特性</h3><p>C++ ⾯向对象的三⼤特征是：封装、继承、多态。</p>
<p><strong>封装</strong></p>
<blockquote>
<p>就是把客观事物封装成抽象的类，并且类可以把⾃⼰的数据和⽅法只让信任的类或者对象操作，对不可信的进⾏信息隐藏。<br>⼀个类就是⼀个封装了数据以及操作这些数据的代码的逻辑实体。<br>在⼀个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种⽅式，对象对内部数据提供了不同级别的保护，以防⽌程序中⽆关的部分意外的改变或错误的使⽤了对象的私有部分。</p>
</blockquote>
<p><strong>继承</strong></p>
<blockquote>
<p>是指可以让某个类型的对象获得另⼀个类型的对象的属性的⽅法。它⽀持按级分类的概念。<br>继承是指这样⼀种能⼒：它可以使⽤现有类的所有功能，并在⽆需重新编写原来的类的情况下对这些功能进⾏扩展。通过继承创建的新类称为“⼦类”或者“派⽣类”，被继承的类称为“基类”、“⽗类”或“超类”。继承的过程，就是从⼀般到特殊的过程。要实现继承，可以通过“继承”和“组合”来实现。<br>继承概念的实现⽅式有两类：<br>实现继承：实现继承是指直接使⽤基类的属性和⽅法⽽⽆需额外编码的能⼒。<br>接⼝继承：接⼝继承是指仅使⽤属性和⽅法的名称、但是⼦类必需提供实现的能⼒。</p>
</blockquote>
<p><strong>多态</strong></p>
<blockquote>
<p>就是向不同的对象发送同⼀个消息，不同对象在接收时会产⽣不同的⾏为（即⽅法）。即⼀个接⼝，可以实现多种⽅法。<br>多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调⽤，在编译器编译期间就可以确定函数的调⽤地址，并产⽣代码，则是静态的，即地址早绑定。⽽如果函数调⽤的地址不能在编译器期间确定，需要在运⾏时才确定，这就属于晚绑定。</p>
</blockquote>
<h3 id="20-说一下c-中类权限的区别"><a href="#20-说一下c-中类权限的区别" class="headerlink" title="20. 说一下c++中类权限的区别"></a>20. 说一下c++中类权限的区别</h3><blockquote>
<p>public：公有类权限，可以被任何类或者函数访问。<br>protected：受保护类权限，可以被本类或子类访问。<br>private：私有类权限，只能被本类访问。</p>
</blockquote>
<h3 id="21-C-中另一文件可以调用其他文件中的函数"><a href="#21-C-中另一文件可以调用其他文件中的函数" class="headerlink" title="21. C++中另一文件可以调用其他文件中的函数"></a>21. C++中另一文件可以调用其他文件中的函数</h3><blockquote>
<p>可以使用#include &lt;&gt;来引入头文件，<br>并且可以使用using namespace std;来引入命名空间。</p>
</blockquote>
<h3 id="22-如何实现C-中的多态"><a href="#22-如何实现C-中的多态" class="headerlink" title="22. 如何实现C++中的多态"></a>22. 如何实现C++中的多态</h3><blockquote>
<p>可以使用virtual关键字来实现多态，<br>并且可以使用override关键字来实现重写。</p>
</blockquote>
<h3 id="23-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理"><a href="#23-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理" class="headerlink" title="23. 虚函数相关（虚函数表，虚函数指针），虚函数的实现原理"></a>23. 虚函数相关（虚函数表，虚函数指针），虚函数的实现原理</h3><blockquote>
<p>虚函数表：指向虚函数的指针数组，每个指针指向一个虚函数。<br>虚函数指针：指向虚函数的指针，指向虚函数表中的某个指针。<br>虚函数的实现原理：<br>当一个对象调用一个虚函数时，编译器会把虚函数的地址保存在虚函数指针中，然后调用虚函数指针。</p>
</blockquote>
<h3 id="24-virtual关键字"><a href="#24-virtual关键字" class="headerlink" title="24. virtual关键字"></a>24. virtual关键字</h3><blockquote>
<p>virtual关键字是用来实现多态的，它的作用是：在类中定义虚函数，在类的实现中调用虚函数，实现多态。</p>
</blockquote>
<h3 id="25-哪些函数不能是虚函数"><a href="#25-哪些函数不能是虚函数" class="headerlink" title="25. 哪些函数不能是虚函数"></a>25. 哪些函数不能是虚函数</h3><p>构造函数，构造函数初始化对象，派⽣类必须知道基类函数⼲了什么，才能进⾏构造；当有虚函数时，每⼀个类有<br>⼀个虚表，每⼀个对象有⼀个虚表指针，虚表指针在构造函数中初始化；<br>内联函数，内联函数表示在编译阶段进⾏函数体的替换操作，⽽虚函数意味着在运⾏期间进⾏类型确定，所以内联<br>函数不能是虚函数；<br>静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。<br>友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。<br>普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。</p>
<h3 id="25-简单说一下C-中程序从编写到运行的过程"><a href="#25-简单说一下C-中程序从编写到运行的过程" class="headerlink" title="25. 简单说一下C++中程序从编写到运行的过程"></a>25. 简单说一下C++中程序从编写到运行的过程</h3><blockquote>
<p>程序从编写到运行的过程：</p>
<ol>
<li>编译：编译器编译程序，生成二进制文件。</li>
<li>汇编：汇编器汇编程序，生成二进制文件。</li>
<li>链接：链接器链接程序，生成可执行文件。</li>
<li>运行：运行器运行程序，执行程序。</li>
</ol>
</blockquote>
<h3 id="26-简单说一下什么是编译器，都有哪些C-编译器，区别是什么？"><a href="#26-简单说一下什么是编译器，都有哪些C-编译器，区别是什么？" class="headerlink" title="26. 简单说一下什么是编译器，都有哪些C++编译器，区别是什么？"></a>26. 简单说一下什么是编译器，都有哪些C++编译器，区别是什么？</h3><p><strong>编译器</strong></p>
<blockquote>
<p>编译器是一个程序，它的作用是将源代码编译成二进制代码。</p>
</blockquote>
<p><strong>都有哪些编译器</strong></p>
<blockquote>
<ol>
<li>GCC</li>
<li>Visual Studio</li>
<li>Clang</li>
<li>LLVM</li>
</ol>
</blockquote>
<h3 id="27-析构函数⼀般写成虚函数的原因"><a href="#27-析构函数⼀般写成虚函数的原因" class="headerlink" title="27. 析构函数⼀般写成虚函数的原因"></a>27. 析构函数⼀般写成虚函数的原因</h3><blockquote>
<p>直观的讲：是为了降低内存泄漏的可能性。<br>举例来说就是，⼀个基类的指针指向⼀个派⽣类的对象，在使⽤完毕准备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指针类型就会认为当前对象的类型是基类，调⽤基类的析构函数  （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执⾏基类的析构，派⽣类的⾃身内容将⽆法被析构，造成内存泄漏。如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执⾏派⽣类的析构函数，再执⾏基类的析构函数，成功释放内存。</p>
</blockquote>
<h3 id="28-构造函数为什么⼀般不定义为虚函数"><a href="#28-构造函数为什么⼀般不定义为虚函数" class="headerlink" title="28. 构造函数为什么⼀般不定义为虚函数"></a>28. 构造函数为什么⼀般不定义为虚函数</h3><blockquote>
<p>虚函数调⽤只需要知道“部分的”信息，即只需要知道函数接⼝，⽽不需要知道对象的具体类型。但是，我们要创建⼀个对象的话，是需要知道对象的完整信息的。特别是，需要知道要创建对象的确切类型，因此，构造函数不应该被定义成虚函数；<br>⽽且从⽬前编译器实现虚函数进⾏多态的⽅式来看，虚函数的调⽤是通过实例化之后对象的虚函数表指针来找到虚函数的地址进⾏调⽤的，如果说构造函数是虚的，那么虚函数表指针则是不存在的，⽆法找到对应的虚函数表来调⽤虚函数，那么这个调⽤实际上也是违反了先实例化后调⽤的准则。</p>
</blockquote>
<h3 id="29-构造函数或析构函数中调⽤虚函数会怎样"><a href="#29-构造函数或析构函数中调⽤虚函数会怎样" class="headerlink" title="29. 构造函数或析构函数中调⽤虚函数会怎样"></a>29. 构造函数或析构函数中调⽤虚函数会怎样</h3><blockquote>
<p>实际上是不应该在构造函数或析构函数中调⽤虚函数的，因为这样的调⽤其实并不会带来所想要的效果。<br>举例来说就是，有⼀个动物的基类，基类中定义了⼀个动物本身⾏为的虚函数 action_type()，在基类的构造函数中调⽤了这个虚函数。</p>
</blockquote>
<h3 id="30-构造函数析构函数可否抛出异常"><a href="#30-构造函数析构函数可否抛出异常" class="headerlink" title="30. 构造函数析构函数可否抛出异常"></a>30. 构造函数析构函数可否抛出异常</h3><blockquote>
<p>C++ 只会析构已经完成的对象，对象只有在其构造函数执⾏完毕才算是完全构造妥当。在构造函数中发⽣异常，控制权转出构造函数之外。因此，在对象 b 的构造函数中发⽣异常，对象b的析构函数不会被调⽤。因此会造成内存泄漏。<br>如果异常从析构函数抛出，⽽且没有在当地进⾏捕捉，那个析构函数便是执⾏不全的。如果析构函数执⾏不全，就是没有完成他应该执⾏的每⼀件事情。</p>
</blockquote>
<h3 id="31-析构函数的作⽤，如何起作⽤？"><a href="#31-析构函数的作⽤，如何起作⽤？" class="headerlink" title="31. 析构函数的作⽤，如何起作⽤？"></a>31. 析构函数的作⽤，如何起作⽤？</h3><blockquote>
<p>构造函数只是起初始化值的作⽤，但实例化⼀个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数⾥⾯，这样就使其他的函数⾥⾯有值了。规则，只要你⼀实例化对象，系统⾃动回调⽤⼀个构造函数，就是你不写，编译器也⾃动调⽤⼀次。<br>析构函数与构造函数的作⽤相反，⽤于撤销对象的⼀些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前⾯加~。<br>析构函数没有参数，也没有返回值，⽽且不能重载，在⼀个类中只能有⼀个析构函数。  当撤销对象时，编译器也会⾃动调⽤析构函数。 每⼀个类必须有⼀个析构函数，⽤户可以⾃定义析构函数，也可以是编译器⾃动⽣成默认的析构函数。⼀般析构函数定义为类的公有成员。</p>
</blockquote>
<h3 id="32-构造函数的执⾏顺序？析构函数的执⾏顺序？"><a href="#32-构造函数的执⾏顺序？析构函数的执⾏顺序？" class="headerlink" title="32. 构造函数的执⾏顺序？析构函数的执⾏顺序？"></a>32. 构造函数的执⾏顺序？析构函数的执⾏顺序？</h3><p><strong>基类构造函数:</strong></p>
<blockquote>
<p>如果有多个基类，则构造函数的调⽤顺序是某类在类派⽣表中出现的顺序，⽽不是它们在成员初始化表中的顺序。</p>
</blockquote>
<p><strong>成员类对象构造函数:</strong></p>
<blockquote>
<p>如果有多个成员类对象则构造函数的调⽤顺序是对象在类中被声明的顺序，⽽不是它们出现在成员初始化表中的顺序。</p>
</blockquote>
<h3 id="33-纯虚函数-（应⽤于接⼝继承和实现继承）"><a href="#33-纯虚函数-（应⽤于接⼝继承和实现继承）" class="headerlink" title="33. 纯虚函数 （应⽤于接⼝继承和实现继承）"></a>33. 纯虚函数 （应⽤于接⼝继承和实现继承）</h3><blockquote>
<p>声明⼀个纯虚函数的⽬的就是为了让派⽣类只继承函数的接⼝，⽽且派⽣类中必需提供⼀个这个纯虚函数的实现，否则含有纯虚函数的类将是抽象类，不能进⾏实例化。</p>
</blockquote>
<h3 id="34-深拷⻉和浅拷⻉的区别（举例说明深拷⻉的安全性）"><a href="#34-深拷⻉和浅拷⻉的区别（举例说明深拷⻉的安全性）" class="headerlink" title="34. 深拷⻉和浅拷⻉的区别（举例说明深拷⻉的安全性）"></a>34. 深拷⻉和浅拷⻉的区别（举例说明深拷⻉的安全性）</h3><p><strong>浅拷⻉</strong></p>
<blockquote>
<p>当出现类的等号赋值时，会调⽤拷⻉函数，在未定义显示拷⻉构造函数的情况下， 系统会调⽤默认的拷⻉函数－即浅拷贝，它能够完成成员的⼀⼀复制。当数据成员中没有指针时，浅拷⻉是可⾏的。</p>
</blockquote>
<p><strong>深拷贝</strong></p>
<blockquote>
<p>但当数据成员中有指针时，如果采⽤简单的浅拷⻉，则两类中的两个指针指向同⼀个地址，当对象快要结束时，会调⽤两次析构函数，⽽导致指野指针的问题。<br>所以，这时必需采⽤深拷⻉。深拷⻉与浅拷⻉之间的区别就在于深拷⻉会在堆内存中另外申请空间来存储数据，从⽽也就解决来野指针的问题。简⽽⾔之，当数据成员中有指针时，必需要⽤深拷⻉更加安全。</p>
</blockquote>
<h3 id="35-什么情况下会调⽤拷⻉构造函数-三种情况"><a href="#35-什么情况下会调⽤拷⻉构造函数-三种情况" class="headerlink" title="35. 什么情况下会调⽤拷⻉构造函数(三种情况)"></a>35. 什么情况下会调⽤拷⻉构造函数(三种情况)</h3><blockquote>
<p>类的对象需要拷⻉时，拷⻉构造函数将会被调⽤，以下的情况都会调⽤拷⻉构造函数：<br>⼀个对象以值传递的⽅式传⼊函数体，需要拷⻉构造函数创建⼀个临时对象压⼊到栈空间中。<br>⼀个对象以值传递的⽅式从函数返回，需要执⾏拷⻉构造函数创建⼀个临时对象作为返回值。<br>⼀个对象需要通过另外⼀个对象进⾏初始化。</p>
</blockquote>
<h3 id="36-为什么拷⻉构造函数必需时引⽤传递，不能是值传递？"><a href="#36-为什么拷⻉构造函数必需时引⽤传递，不能是值传递？" class="headerlink" title="36. 为什么拷⻉构造函数必需时引⽤传递，不能是值传递？"></a>36. 为什么拷⻉构造函数必需时引⽤传递，不能是值传递？</h3><blockquote>
<p>为了防⽌递归调⽤。当⼀个对象需要以值⽅式进⾏传递时，编译器会⽣成代码调⽤它的拷⻉构造函数⽣成⼀个副 本，如果类 A 的拷⻉构造函数的参数不是引⽤传递，⽽是采⽤值传递，那么就⼜需要为了创建传递给拷⻉构造函数的参数的临时对象，⽽⼜⼀次调⽤类 A 的拷⻉构造函数，这就是⼀个⽆限递归。</p>
</blockquote>
<h3 id="37-结构体内存对⻬⽅式"><a href="#37-结构体内存对⻬⽅式" class="headerlink" title="37. 结构体内存对⻬⽅式"></a>37. 结构体内存对⻬⽅式</h3><p><strong>规则1：</strong></p>
<blockquote>
<p>结构体中第一个成员的偏移量是0，以后每个成员的位置是x的倍数；<br>    x = min(#pragma pack(), 该成员自身的长度)</p>
</blockquote>
<p><strong>规则2：</strong></p>
<blockquote>
<p>成员对齐后，结构体自身也要对齐，按照y的倍数进行；<br>     y = min(#pragma pack(), 最大成员尺寸)。</p>
</blockquote>
<h3 id="38-那么内存对⻬的作⽤是什么呢？"><a href="#38-那么内存对⻬的作⽤是什么呢？" class="headerlink" title="38. 那么内存对⻬的作⽤是什么呢？"></a>38. 那么内存对⻬的作⽤是什么呢？</h3><p><strong>CPU 的内存访问速度⼤⼤提升</strong></p>
<blockquote>
<p>经过内存对⻬之后，CPU 的内存访问速度⼤⼤提升。因为 CPU 把内存当成是⼀块⼀块的，块的⼤⼩可以是 2，4，8，16 个字节，因此 CPU 在读取内存的时候是⼀块⼀块进⾏读取的，块的⼤⼩称为内存读取粒度。⽐如说 CPU 要读取⼀个 4 个字节的数据到寄存器中（假设内存读取粒度是 4），如果数据是从 0 字节开始的，那么直接将 0-3 四个字节完全读取到寄存器中进⾏处理即可。</p>
</blockquote>
<p><strong>有的 CPU 遇到未进⾏内存对⻬的处理直接拒绝处理</strong></p>
<blockquote>
<p>另外，还有⼀个就是，有的 CPU 遇到未进⾏内存对⻬的处理直接拒绝处理，不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。所以内存对⻬还有利于平台移植。</p>
</blockquote>
<h3 id="39-内存泄漏的定义，如何检测与避免？"><a href="#39-内存泄漏的定义，如何检测与避免？" class="headerlink" title="39. 内存泄漏的定义，如何检测与避免？"></a>39. 内存泄漏的定义，如何检测与避免？</h3><p><strong>定义：</strong></p>
<blockquote>
<p>内存泄漏简单的说就是申请了⼀块内存空间，使⽤完毕后没有释放掉。  它的⼀般表现⽅式是程序运⾏时间越⻓，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那么这块内存就泄漏了。</p>
</blockquote>
<p><strong>如何检测内存泄漏</strong></p>
<blockquote>
<p>⾸先可以通过观察猜测是否可能发⽣内存泄漏，Linux 中使⽤ swap 命令观察还有多少可⽤的交换空间，在⼀两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。<br>还可以使⽤ 其他⼀些 /usr/bin/stat ⼯具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，⼀个可能的解释就是有个进程出现了内存泄漏。<br>当然也有⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 valgrind 这样的⼯具来进⾏内存泄漏的检测。</p>
</blockquote>
<h3 id="40-说⼀下-define、const、typedef、inline-使⽤⽅法？"><a href="#40-说⼀下-define、const、typedef、inline-使⽤⽅法？" class="headerlink" title="40. 说⼀下 define、const、typedef、inline 使⽤⽅法？"></a>40. 说⼀下 define、const、typedef、inline 使⽤⽅法？</h3><p><strong>1、const 与 #define 的区别</strong></p>
<blockquote>
<p>const 定义的常量是变量带类型，⽽ #define 定义的只是个常数不带类型；<br>define 只在预处理阶段起作⽤，简单的⽂本替换，⽽ const 在编译、链接过程中起作⽤；<br>define 只是简单的字符串替换没有类型检查。⽽const是有数据类型的，是要进⾏判断的，可以避免⼀些低级错误；<br>define 预处理后，占⽤代码段空间，const  占⽤数据段空间；<br>const 不能重定义，⽽ define 可以通过 #undef 取消某个符号的定义，进⾏重定义；<br>define  独特功能，⽐如可以⽤来防⽌⽂件重复引⽤。</p>
</blockquote>
<p><strong>2、#define 和别名 typedef 的区别</strong></p>
<blockquote>
<p>执⾏时间不同，typedef 在编译阶段有效，typedef 有类型检查的功能；#define 是宏定义，发⽣在预处理阶段，不进⾏类型检查；<br>功能差异，typedef  ⽤来定义类型的别名，定义与平台⽆关的数据类型，与 struct  的结合使⽤等。</p>
<h1 id="define-不只是可以为类型取别名，还可以定义常量、变量、编译开关等。"><a href="#define-不只是可以为类型取别名，还可以定义常量、变量、编译开关等。" class="headerlink" title="define  不只是可以为类型取别名，还可以定义常量、变量、编译开关等。"></a>define  不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</h1><p>作⽤域不同，#define没有作⽤域的限制，只要是之前预定义过的宏，在以后的程序中都可以使⽤。<br>⽽ typedef 有⾃⼰的作⽤域。</p>
</blockquote>
<p><strong>3、define 与 inline 的区别</strong></p>
<blockquote>
<h1 id="define是关键字，inline是函数；"><a href="#define是关键字，inline是函数；" class="headerlink" title="define是关键字，inline是函数；"></a>define是关键字，inline是函数；</h1><p>宏定义在预处理阶段进⾏⽂本替换，inline  函数在编译阶段进⾏替换；<br>inline  函数有类型检查，相⽐宏定义⽐较安全；<br>inline  函数不能被调用，只能被调用；</p>
</blockquote>
<h3 id="41-预处理，编译，汇编，链接程序的区别"><a href="#41-预处理，编译，汇编，链接程序的区别" class="headerlink" title="41. 预处理，编译，汇编，链接程序的区别"></a>41. 预处理，编译，汇编，链接程序的区别</h3><blockquote>
<p>⼀段⾼级语⾔代码经过四个阶段的处理形成可执⾏的⽬标⼆进制代码。 预处理器→编译器→汇编器→链接器：最难理解的是编译与汇编的区别。</p>
<p>预处理阶段：写好的⾼级语⾔的程序⽂本⽐如 hello.c，预处理器根据 #开头的命令，修改原始的程序，如 #include<stdio.h> 将把系统中的头⽂件插⼊到程序⽂本中，通常是以 .i 结尾的⽂件。</stdio.h></p>
<p>编译阶段：编译器将 hello.i ⽂件翻译成⽂本⽂件 hello.s，这个是汇编语⾔程序。⾼级语⾔是源程序。所以注意概念之间的区别。汇编语⾔程序是⼲嘛的？每条语句都以标准的⽂本格式确切描述⼀条低级机器语⾔指令。不同的⾼级语⾔翻译的汇编语⾔相同。</p>
<p>汇编阶段：汇编器将 hello.s 翻译成机器语⾔指令。把这些指令打包成可重定位⽬标程序，即 .o⽂件。hello.o是⼀个⼆进制⽂件，它的字节码是机器语⾔指令，不再是字符。前⾯两个阶段都还有字符。</p>
<p>链接阶段：⽐如 hello 程序调⽤ printf 程序，它是每个 C 编译器都会提供的标准库 C 的函数。这个函数存在于⼀个名叫 printf.o 的单独编译好的⽬标⽂件中，这个⽂件将以某种⽅式合并到 hello.o 中。链接器就负责这种合并。得到的是可执⾏⽬标⽂件。</p>
</blockquote>
<h3 id="42-动态链接和静态链接区别"><a href="#42-动态链接和静态链接区别" class="headerlink" title="42. 动态链接和静态链接区别"></a>42. 动态链接和静态链接区别</h3><blockquote>
<p>静态连接库就是把 (lib) ⽂件中⽤到的函数代码直接链接进⽬标程序，程序运⾏的时候不再需要其它的库⽂件；动态链接就是把调⽤的函数所在⽂件模块（DLL）和调⽤函数在⽂件中的位置等信息链接进⽬标程序，程序运⾏的时候再从 DLL 中寻找相应函数代码，因此需要相应 DLL ⽂件的⽀持。</p>
<p>静态链接库与动态链接库都是共享代码的⽅式，如果采⽤静态链接库，则⽆论你愿不愿意，lib 中的指令都全部被直接包含在最终⽣成的 EXE ⽂件中了。但是若使⽤ DLL，该 DLL 不必被包含在最终 EXE ⽂件中，EXE ⽂件执⾏时可以“动态”地引⽤和卸载这个与 EXE 独⽴的 DLL ⽂件。</p>
<p>静态链接库和动态链接库的另外⼀个区别在于静态链接库中不能再包含其他的动态链接库或者静态库，⽽在动态链接库中还可以再包含其他的动态或静态链接库。</p>
<p>动态库就是在需要调⽤其中的函数时，根据函数映射表找到该函数然后调⼊堆栈执⾏。如果在当前⼯程中有多处对 dll⽂件中同⼀个函数的调⽤，那么执⾏时，这个函数只会留下⼀份拷⻉。但如果有多处对 lib ⽂件中同⼀个函数的调⽤，那么执⾏时该函数将在当前程序的执⾏空间⾥留下多份拷⻉，⽽且是⼀处调⽤就产⽣⼀份拷⻉。</p>
</blockquote>
<h3 id="43-动态联编与静态联编"><a href="#43-动态联编与静态联编" class="headerlink" title="43. 动态联编与静态联编"></a>43. 动态联编与静态联编</h3><blockquote>
<p>在 C++ 中，联编是指⼀个计算机程序的不同部分彼此关联的过程。按照联编所进⾏的阶段不同，可以分为静态联编和动态联编；</p>
<p>静态联编是指联编⼯作在编译阶段完成的，这种联编过程是在程序运⾏之前完成的，⼜称为早期联编。要实现静态联编，在编译阶段就必须确定程序中的操作调⽤（如函数调⽤）与执⾏该操作代码间的关系，确定这种关系称为束定，在编译时的束定称为静态束定。静态联编对函数的选择是基于指向对象的指针或者引⽤的类型。其优点是效率⾼，但灵活性差。</p>
<p>动态联编是指联编在程序运⾏时动态地进⾏，根据当时的情况来确定调⽤哪个同名函数，实际上是在运⾏时虚函数的实现。这种联编⼜称为晚期联编，或动态束定。动态联编对成员函数的选择是基于对象的类型，针对不同的对象类型将做出不同的编译结果。</p>
<p>C++中⼀般情况下的联编是静态联编，但是当涉及到多态性和虚函数时应该使⽤动态联编。动态联编的优点是灵活性强，但效率低。动态联编规定，只能通过指向基类的指针或基类对象的引⽤来调⽤虚函数，其格式为：指向基类的指针变量名-&gt;虚函数名（实参表）或基类对象的引⽤名.虚函数名（实参表）</p>
</blockquote>
<p><strong>实现动态联编三个条件：</strong></p>
<blockquote>
<p>必须把动态联编的⾏为定义为类的虚函数；<br>类之间应满⾜⼦类型关系，通常表现为⼀个类从另⼀个类公有派⽣⽽来；<br>必须先使⽤基类指针指向⼦类型的对象，然后直接或间接使⽤基类指针调⽤虚函数； </p>
</blockquote>
<h3 id="44-静态库和动态库"><a href="#44-静态库和动态库" class="headerlink" title="44.静态库和动态库"></a>44.静态库和动态库</h3><pre><code>  1. 什么是静态库，什么是动态库
</code></pre><blockquote>
<p><strong>静态库</strong><br>一般扩展名为（.a或.lib）,这类的函数库通常扩展名为libxxx.a或xxx.lib 。<br>这类库在编译的时候会直接整合到目标程序中，所以利用静态函数库编译成的文件会比较大，<br>这类函数库最大的优点就是编译成功的可执行文件可以独立运行，而不再需要向外部要求读取函数库的内容；但是从升级难易度来看明显没有优势，如果函数库更新，需要重新编译。</p>
<p><strong>动态库</strong><br>动态函数库的扩展名一般为（.so或.dll），这类函数库通常名为libxxx.so或xxx.dll 。<br>与静态函数库被整个捕捉到程序中不同，动态函数库在编译的时候，在程序里只有一个“指向”的位置而已，也就是说当可执行文件需要使用到函数库的机制时，程序才会去读取函数库来使用；也就是说可执行文件无法单独运行。这样从产品功能升级角度方便升级，只要替换对应动态库即可，不必重新编译整个可执行文件。</p>
</blockquote>
<pre><code>  2. 静态库和动态库的区别是什么？
</code></pre><blockquote>
<p>静态连接库就是把(lib)文件中用到的函数代码直接链接进目标程序，程序运行的时候不再需要其它的库文件；动态链接就是把调用的函数所在文件模块（DLL）和调用函数在文件中的位置等信息链接进目标程序，程序运行的时候再从DLL中寻找相应函数代码，因此需要相应DLL文件的支持。</p>
<p>静态编译只需要所需的头文件和对应的lib库文件。</p>
<p>动态编译则需要所需的头文件、对应的lib库文件以及对应的dll库文件。</p>
<p>事实上，静态编译用到的库文件和动态编译用到的库文件有本质区别：前者静态库是一个或者多个obj文件的打包，所以有人干脆把从obj文件生成lib的过程称为Archive，即合并到一起。比如你链接一个静态库，如果其中有错，它会准确的找到是哪个obj有错，即静态lib只是壳子。而后者为动态连接库(DLL）的导入库，它告诉链接器调用的函数在哪个DLL中，函数执行代码在DLL中的什么位置，这也就是为什么需要附加依赖项 .LIB文件，它起到桥梁的作用。</p>
</blockquote>
<h3 id="45-动态编译与静态编译"><a href="#45-动态编译与静态编译" class="headerlink" title="45. 动态编译与静态编译"></a>45. 动态编译与静态编译</h3><p><strong>静态编译</strong></p>
<blockquote>
<p>编译器在编译可执⾏⽂件时，把需要⽤到的对应动态链接库中的部分提取出来，连接到可执⾏⽂件中去，使可执⾏⽂件在运⾏时不需要依赖于动态链接库；</p>
</blockquote>
<p><strong>动态编译</strong></p>
<blockquote>
<p>可执⾏⽂件需要附带⼀个动态链接库，在执⾏时，需要调⽤其对应动态链接库的命令。所以其优点⼀⽅⾯是缩⼩了执⾏⽂件本身的体积，另⼀⽅⾯是加快了编译速度，节省了系统资源。缺点是哪怕是很简单的程序，只⽤到了链接库的⼀两条命令，也需要附带⼀个相对庞⼤的链接库；⼆是如果其他计算机上没有安装对应的运⾏库，则⽤动态编译的可执⾏⽂件就不能运⾏。</p>
</blockquote>
<h3 id="46-VS中的DeBug和Realease区别"><a href="#46-VS中的DeBug和Realease区别" class="headerlink" title="46. VS中的DeBug和Realease区别"></a>46. VS中的DeBug和Realease区别</h3><blockquote>
<p>Debug 通常称为调试版本，它包含调试信息，并且不作任何优化，便于程序员调试程序。<br>Release 称为发布版本，它往往是进行了各种优化，使得程序在代码大小和运行速度上都是最优的，以便用户很好地使用。</p>
</blockquote>
<h3 id="47-strlen和sizeof的区别"><a href="#47-strlen和sizeof的区别" class="headerlink" title="47. strlen和sizeof的区别"></a>47. strlen和sizeof的区别</h3><blockquote>
<p>strlen是字符串的长度，而sizeof是类型的大小。<br>sizeof是一个运算符，strlen是一个函数。<br>strlen后是不加最后的结束标志’\0’，其表示字符串的长度。<br>而sizeof求的是字符串所在内存中的长度，所以它是加上最最后的结束标志’\0’的。<br>sizeof可以用类型做参数，可以用函数做参数。而strlen只能用char*做参数。</p>
</blockquote>
<h3 id="48-a和-amp-a的区别"><a href="#48-a和-amp-a的区别" class="headerlink" title="48. a和&amp;a的区别"></a>48. a和&amp;a的区别</h3><blockquote>
<p>a是一个指针，&amp;a是一个引用</p>
</blockquote>
<h3 id="49-static关键字在C语言和C-中有什么区别"><a href="#49-static关键字在C语言和C-中有什么区别" class="headerlink" title="49. static关键字在C语言和C++中有什么区别"></a>49. static关键字在C语言和C++中有什么区别</h3><ol>
<li><strong>static在C语言中的作用（C++通用）</strong></li>
</ol>
<p><strong>修饰变量</strong></p>
<blockquote>
<p>a、修饰全局变量（全局变量与静态全局变量的对比）<br>修饰全局变量：作用域仅限于变量被定义的文件中，其他文件即使用extern声明也无法直接使用此变量，extern用法详见这里。（可以间接访问，即通过本文件的非static函数返回static变量的值，类似于C++类中的private变量外界没有权限访问，但是可以通过public函数返回private变量的值）。</p>
<p>对比：全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。 这两者在存储方式上并无不同，且都只初始化一次，但静态全局变量对其他文件不可见，全局变量是可见的。<br>总结：把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。  </p>
</blockquote>
<p><strong>修饰局部变量</strong></p>
<blockquote>
<p>修饰局部变量：在函数内定义的局部变量被修饰，可以延长变生命周期，但是作用域不变，只初始化一次。<br>对比：普通局部变量定义后，出了作用域就会被释放，静态局部变量生命周期到程序结束才结束。<br>总结：把局部变量改变为静态变量后是改变了它的存储方式，让静态局部变量出了作用域依然存在，到程序结束，生命周期才结束。</p>
</blockquote>
<p><strong>修饰函数</strong></p>
<blockquote>
<p>和全局变量一样，函数的定义和声明默认情况下是extern的，但静态函数只是在声明它的文件当中可见，不能被其他文件所用。</p>
</blockquote>
<ol>
<li>static在C++中的作用</li>
</ol>
<p><strong>C+ +重用了这个关键字，并赋予它与前面不同的含义：表示属于一个类而不是属于此类的任何特定对象的变量和函数。</strong></p>
<p><strong>静态数据成员</strong></p>
<blockquote>
<p>静态数据成员是属于整个类的，而不是属于某个对象。即不管实例多少个对象，它们都公用一个静态数据成员（如：使用静态数据成员统计类已经实例化了多少对象）。</p>
<p>在c++中，普通数据成员在构造函数的函数体或初始化表中初始化；常量数据成员(const int a )必须在构造函数的初始化表中初始化（const对象或引用只能初始化但是不能赋值。构造函数的函数体内只能做赋值而不是初始化）；而静态数据成员(static int b )则必须在类外初始化（int 类名::b=100），这是因为静态数据成员不属于任何一个对象，而是属于整个类的。</p>
</blockquote>
<p><strong>静态成员函数</strong></p>
<blockquote>
<p>静态成员函数是属于整个类的，而不是属于某个对象。静态成员函数可以被该类的所有对象直接访问；静态成员函数本身只能访问静态成员，不可以访问非静态成员。</p>
</blockquote>
<ol>
<li>常见面试题—为什么static变量值只初始化一次？</li>
</ol>
<blockquote>
<p>对于所有的对象（不仅仅是静态对象），初始化都只有一次，而由于静态变量具有“记忆”功能，初始化后，一直都没有被销毁，都会保存在内存区域中，所以不会再次初始化。存放在静态区的变量的生命周期一般比较长，它与整个程序“同生死、共存亡”，所以它只需初始化一次。而auto变量，即自动变量，由于它存放在栈区，一旦函数调用结束，就会立刻被销毁。</p>
</blockquote>
<h3 id="50-不使用第三方变量交换两个变量的值"><a href="#50-不使用第三方变量交换两个变量的值" class="headerlink" title="50. 不使用第三方变量交换两个变量的值"></a>50. 不使用第三方变量交换两个变量的值</h3><p><strong>代码实现</strong></p>
<figure class="highlight plaintext"><figcaption><span>&#123;.line-numbers&#125;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int num1 = 10, num2 = 20;</span><br><span class="line">num1 = num1 + num2;</span><br><span class="line">num2 = num1 - num2;</span><br><span class="line">num1 = num1 - num2;</span><br></pre></td></tr></table></figure>
<h3 id="51-C-都有哪些版本"><a href="#51-C-都有哪些版本" class="headerlink" title="51. C++都有哪些版本"></a>51. C++都有哪些版本</h3><blockquote>
<p>C++98,C++03,C++11,C++14,C++17,C++20</p>
</blockquote>
<h4 id="C-11-的特性主要包括下⾯⼏个⽅⾯："><a href="#C-11-的特性主要包括下⾯⼏个⽅⾯：" class="headerlink" title="C++11 的特性主要包括下⾯⼏个⽅⾯："></a>C++11 的特性主要包括下⾯⼏个⽅⾯：</h4><blockquote>
<p>提⾼运⾏效率的语⾔特性：右值引⽤、泛化常量表达式<br>原有语法的使⽤性增强：初始化列表、统⼀的初始化语法、类型推导、范围 for 循环、Lambda 表达式、final和 override、构造函数委托<br>语⾔能⼒的提升：空指针 nullptr、default 和 delete、⻓整数、静态 assert<br>C++ 标准库的更新：智能指针、正则表达式、哈希表等</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.totorocatcat.top/">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/2024/06/01/C-%E5%85%AB%E8%82%A1/">http://totorocatcat.top/2024/06/01/C-%E5%85%AB%E8%82%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%89%E8%B6%A3/">有趣</a></div><div class="post_share"><div class="social-share" data-image="https://img.likepoems.com/resource/pc/b702fcf4480034312d58d6f56e30d7624.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/06/02/C-%E9%80%89%E6%8B%A9%E9%A2%98%E5%8A%A0%E8%AE%AD/" title="C++选择题加训"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.37/img_371_3840x2160_72_null_normal.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++选择题加训</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/01/%E4%B8%AD%E5%8D%97%E5%A4%A7%E5%AD%A6%E8%80%83%E8%AF%952/" title="中南大学考试2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.likepoems.com/resource/pc/542bd74d667e4e3db4a077b55b1d074f2.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">中南大学考试2</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/03/C-%E7%BB%83%E4%B9%A0%E9%A2%983/" title="C++练习题3"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/%E5%9B%BE%E5%8C%85webp/%E5%8A%A8%E6%BC%AB%E7%BB%BC%E5%90%881/73207-106.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-03</div><div class="title">C++练习题3</div></div></a></div><div><a href="/2024/05/31/C-%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95-1/" title="C++期末考试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/%E5%9B%BE%E5%8C%85webp/%E5%8A%A8%E6%BC%AB%E7%BB%BC%E5%90%881/86815-106.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-31</div><div class="title">C++期末考试</div></div></a></div><div><a href="/2024/06/03/C-%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%882%EF%BC%89/" title="C++练习题2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.51/img_513_1920x1080_72_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-03</div><div class="title">C++练习题2</div></div></a></div><div><a href="/2024/05/31/C-%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/" title="C++期末考试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.likepoems.com/resource/pc/68e21cc80a435c28fdf4c47e4652ebc17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-31</div><div class="title">C++期末考试</div></div></a></div><div><a href="/2024/05/31/C-%E9%80%89%E6%8B%A9%E9%A2%98/" title="C++选择题"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.likepoems.com/resource/pc/a6d651fa256154756b47262c450a056f4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-31</div><div class="title">C++选择题</div></div></a></div><div><a href="/2024/06/02/C-%E9%80%89%E6%8B%A9%E9%A2%98%E5%8A%A0%E8%AE%AD/" title="C++选择题加训"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.37/img_371_3840x2160_72_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-02</div><div class="title">C++选择题加训</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description">热爱文学的SCUT软件学院学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">794</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-%E5%85%AB%E8%82%A1%E6%96%87"><span class="toc-text">C++八股文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-C-%E5%9F%BA%E7%A1%80%E7%AF%87"><span class="toc-text">第一章 C++基础篇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%83%85%E5%86%B5"><span class="toc-text">1. C++ 中内存分配情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88%EF%BC%88Stack%EF%BC%89"><span class="toc-text">1. 栈（Stack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A0%86%EF%BC%88Heap%EF%BC%89"><span class="toc-text">2. 堆（Heap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%A8%E5%B1%80-%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="toc-text">3. 全局&#x2F;静态存储区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%B8%B8%E9%87%8F%E5%AD%98%E5%82%A8%E5%8C%BA"><span class="toc-text">4. 常量存储区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E5%8C%BA"><span class="toc-text">5. 代码区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%A4%BA"><span class="toc-text">图示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A0%86%E5%92%8C%E6%A0%88%E5%8C%BA%E5%88%AB"><span class="toc-text">2. 堆和栈区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-C-%E4%B8%AD%E5%A6%82%E4%BD%95%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98-C%E8%AF%AD%E8%A8%80"><span class="toc-text">3. C++中如何申请和释放内存&#x2F;C语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-new%E5%92%8Cmalloc%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">4. new和malloc区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0%E7%9A%84%E2%BC%8F%E7%A7%8D%E2%BD%85%E5%BC%8F"><span class="toc-text">5. 函数传递参数的⼏种⽅式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-C-%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E2%BD%A4%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-text">6. C++ 中的指针参数传递和引⽤参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E2%BD%A4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">7. 指针和引⽤的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%AE%80%E5%8D%95%E8%AF%B4%E2%BC%80%E4%B8%8B%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-text">8. 简单说⼀下函数指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E9%87%8E-wild-%E6%8C%87%E9%92%88%E4%B8%8E%E6%82%AC%E7%A9%BA-dangling-%E6%8C%87%E9%92%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">9. 野(wild)指针与悬空(dangling)指针有什么区别？如何避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E8%AF%B4%E2%BC%80%E4%B8%8B-const-%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%EF%BC%9F"><span class="toc-text">10. 说⼀下 const 修饰指针如何区分？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-C-%E4%B8%AD-const-%E5%92%8C-static-%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E5%AE%9A%E4%B9%89%EF%BC%8C%E2%BD%A4%E9%80%94%EF%BC%89"><span class="toc-text">11. C++ 中 const 和 static 关键字（定义，⽤途）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E8%AF%B4%E2%BC%80%E4%B8%8B-C-%E2%BE%A5%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E7%9A%84%EF%BC%9F%E5%B8%B8%E9%87%8F%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%93%AA%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="toc-text">12. 说⼀下 C++ ⾥是怎么定义常量的？常量存放在内存的哪个位置？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%AE%8F%E5%AE%9A%E4%B9%89-define-%E5%92%8C%E5%B8%B8%E9%87%8F-const-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">13. 宏定义 #define 和常量 const 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-C-%E5%92%8C-C-%E5%8C%BA%E5%88%AB-%EF%BC%88%E5%87%BD%E6%95%B0-%E7%B1%BB-struct-class%EF%BC%89"><span class="toc-text">14. C 和 C++ 区别 （函数&#x2F;类&#x2F;struct&#x2F;class）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-C-%E5%92%8C-Java-%E5%8C%BA%E5%88%AB%EF%BC%88%E8%AF%AD%E2%BE%94%E7%89%B9%E6%80%A7%EF%BC%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%8C%E5%BA%94%E2%BD%A4%E5%9C%BA%E6%99%AF%E7%AD%89%EF%BC%89"><span class="toc-text">15. C++ 和 Java 区别（语⾔特性，垃圾回收，应⽤场景等）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-C-%E4%B8%AD%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%EF%BC%8C%E9%87%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">16. C++ 中重载和重写，重定义的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%BB%8B%E7%BB%8D-C-%E6%89%80%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-text">17. 介绍 C++ 所有的构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">18. C++ 的四种强制转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E2%BE%AF%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E2%BC%A4%E7%89%B9%E6%80%A7"><span class="toc-text">19. ⾯向对象的三⼤特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E8%AF%B4%E4%B8%80%E4%B8%8Bc-%E4%B8%AD%E7%B1%BB%E6%9D%83%E9%99%90%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">20. 说一下c++中类权限的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-C-%E4%B8%AD%E5%8F%A6%E4%B8%80%E6%96%87%E4%BB%B6%E5%8F%AF%E4%BB%A5%E8%B0%83%E7%94%A8%E5%85%B6%E4%BB%96%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">21. C++中另一文件可以调用其他文件中的函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0C-%E4%B8%AD%E7%9A%84%E5%A4%9A%E6%80%81"><span class="toc-text">22. 如何实现C++中的多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%EF%BC%88%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">23. 虚函数相关（虚函数表，虚函数指针），虚函数的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-virtual%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-text">24. virtual关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">25. 哪些函数不能是虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8BC-%E4%B8%AD%E7%A8%8B%E5%BA%8F%E4%BB%8E%E7%BC%96%E5%86%99%E5%88%B0%E8%BF%90%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">25. 简单说一下C++中程序从编写到运行的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E7%AE%80%E5%8D%95%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%8C%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9BC-%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">26. 简单说一下什么是编译器，都有哪些C++编译器，区别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E2%BC%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-text">27. 析构函数⼀般写成虚函数的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E2%BC%80%E8%88%AC%E4%B8%8D%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-text">28. 构造函数为什么⼀般不定义为虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%88%96%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E2%BD%A4%E8%99%9A%E5%87%BD%E6%95%B0%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="toc-text">29. 构造函数或析构函数中调⽤虚函数会怎样</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%8F%AF%E5%90%A6%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-text">30. 构造函数析构函数可否抛出异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E2%BD%A4%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B5%B7%E4%BD%9C%E2%BD%A4%EF%BC%9F"><span class="toc-text">31. 析构函数的作⽤，如何起作⽤？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E2%BE%8F%E9%A1%BA%E5%BA%8F%EF%BC%9F%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E2%BE%8F%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="toc-text">32. 构造函数的执⾏顺序？析构函数的执⾏顺序？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0-%EF%BC%88%E5%BA%94%E2%BD%A4%E4%BA%8E%E6%8E%A5%E2%BC%9D%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%EF%BC%89"><span class="toc-text">33. 纯虚函数 （应⽤于接⼝继承和实现继承）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E6%B7%B1%E6%8B%B7%E2%BB%89%E5%92%8C%E6%B5%85%E6%8B%B7%E2%BB%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E6%B7%B1%E6%8B%B7%E2%BB%89%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%89"><span class="toc-text">34. 深拷⻉和浅拷⻉的区别（举例说明深拷⻉的安全性）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E2%BD%A4%E6%8B%B7%E2%BB%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="toc-text">35. 什么情况下会调⽤拷⻉构造函数(三种情况)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%B7%E2%BB%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%9C%80%E6%97%B6%E5%BC%95%E2%BD%A4%E4%BC%A0%E9%80%92%EF%BC%8C%E4%B8%8D%E8%83%BD%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="toc-text">36. 为什么拷⻉构造函数必需时引⽤传递，不能是值传递？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E2%BB%AC%E2%BD%85%E5%BC%8F"><span class="toc-text">37. 结构体内存对⻬⽅式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38-%E9%82%A3%E4%B9%88%E5%86%85%E5%AD%98%E5%AF%B9%E2%BB%AC%E7%9A%84%E4%BD%9C%E2%BD%A4%E6%98%AF%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-text">38. 那么内存对⻬的作⽤是什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="toc-text">39. 内存泄漏的定义，如何检测与避免？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40-%E8%AF%B4%E2%BC%80%E4%B8%8B-define%E3%80%81const%E3%80%81typedef%E3%80%81inline-%E4%BD%BF%E2%BD%A4%E2%BD%85%E6%B3%95%EF%BC%9F"><span class="toc-text">40. 说⼀下 define、const、typedef、inline 使⽤⽅法？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define-%E4%B8%8D%E5%8F%AA%E6%98%AF%E5%8F%AF%E4%BB%A5%E4%B8%BA%E7%B1%BB%E5%9E%8B%E5%8F%96%E5%88%AB%E5%90%8D%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F%E3%80%81%E7%BC%96%E8%AF%91%E5%BC%80%E5%85%B3%E7%AD%89%E3%80%82"><span class="toc-text">define  不只是可以为类型取别名，还可以定义常量、变量、编译开关等。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#define%E6%98%AF%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%8Cinline%E6%98%AF%E5%87%BD%E6%95%B0%EF%BC%9B"><span class="toc-text">define是关键字，inline是函数；</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#41-%E9%A2%84%E5%A4%84%E7%90%86%EF%BC%8C%E7%BC%96%E8%AF%91%EF%BC%8C%E6%B1%87%E7%BC%96%EF%BC%8C%E9%93%BE%E6%8E%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">41. 预处理，编译，汇编，链接程序的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%8C%BA%E5%88%AB"><span class="toc-text">42. 动态链接和静态链接区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E5%8A%A8%E6%80%81%E8%81%94%E7%BC%96%E4%B8%8E%E9%9D%99%E6%80%81%E8%81%94%E7%BC%96"><span class="toc-text">43. 动态联编与静态联编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44-%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93"><span class="toc-text">44.静态库和动态库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-%E5%8A%A8%E6%80%81%E7%BC%96%E8%AF%91%E4%B8%8E%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91"><span class="toc-text">45. 动态编译与静态编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46-VS%E4%B8%AD%E7%9A%84DeBug%E5%92%8CRealease%E5%8C%BA%E5%88%AB"><span class="toc-text">46. VS中的DeBug和Realease区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-strlen%E5%92%8Csizeof%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">47. strlen和sizeof的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48-a%E5%92%8C-amp-a%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">48. a和&amp;a的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49-static%E5%85%B3%E9%94%AE%E5%AD%97%E5%9C%A8C%E8%AF%AD%E8%A8%80%E5%92%8CC-%E4%B8%AD%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-text">49. static关键字在C语言和C++中有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9%E5%8F%98%E9%87%8F%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E7%9A%84%E5%80%BC"><span class="toc-text">50. 不使用第三方变量交换两个变量的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-C-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%88%E6%9C%AC"><span class="toc-text">51. C++都有哪些版本</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-11-%E7%9A%84%E7%89%B9%E6%80%A7%E4%B8%BB%E8%A6%81%E5%8C%85%E6%8B%AC%E4%B8%8B%E2%BE%AF%E2%BC%8F%E4%B8%AA%E2%BD%85%E2%BE%AF%EF%BC%9A"><span class="toc-text">C++11 的特性主要包括下⾯⼏个⽅⾯：</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%80%BB%E5%A4%8D%E4%B9%A0/" title="计算机组成原理总复习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/3b4eb33d14b1ed4f3fad769e360c64c.bmp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="计算机组成原理总复习"/></a><div class="content"><a class="title" href="/2024/12/05/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%80%BB%E5%A4%8D%E4%B9%A0/" title="计算机组成原理总复习">计算机组成原理总复习</a><time datetime="2024-12-05T13:32:39.000Z" title="发表于 2024-12-05 21:32:39">2024-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/05/ch35/" title="Chapter 3 Basic Input/Output(5)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/0260fb5ce221f85d68460aabab231d7.bmp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 3 Basic Input/Output(5)"/></a><div class="content"><a class="title" href="/2024/12/05/ch35/" title="Chapter 3 Basic Input/Output(5)">Chapter 3 Basic Input/Output(5)</a><time datetime="2024-12-05T11:25:36.000Z" title="发表于 2024-12-05 19:25:36">2024-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/05/ch34/" title="Chapter 3 Basic Input/Output(4)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/d24100c3588bfc6c9d67f231e77b9c3.bmp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 3 Basic Input/Output(4)"/></a><div class="content"><a class="title" href="/2024/12/05/ch34/" title="Chapter 3 Basic Input/Output(4)">Chapter 3 Basic Input/Output(4)</a><time datetime="2024-12-05T11:03:09.000Z" title="发表于 2024-12-05 19:03:09">2024-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/05/ch33/" title="Chapter 3 Basic Input/Output(3)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/86180ba3f42f2ac9a9611430ead1ae5.bmp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 3 Basic Input/Output(3)"/></a><div class="content"><a class="title" href="/2024/12/05/ch33/" title="Chapter 3 Basic Input/Output(3)">Chapter 3 Basic Input/Output(3)</a><time datetime="2024-12-05T10:15:31.000Z" title="发表于 2024-12-05 18:15:31">2024-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/12/05/ch32/" title="Chapter 3 Basic Input/Output(2)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/c3109345507e0c37599952b7d00eac6.bmp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 3 Basic Input/Output(2)"/></a><div class="content"><a class="title" href="/2024/12/05/ch32/" title="Chapter 3 Basic Input/Output(2)">Chapter 3 Basic Input/Output(2)</a><time datetime="2024-12-05T09:16:44.000Z" title="发表于 2024-12-05 17:16:44">2024-12-05</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HT1PalaKkPaG1UqAXBhJXIu8-gzGzoHsz',
      appKey: 'iT0TnVVAwf9zuZ7NqwclQItY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="1" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="只此无为身，且前行,忘记过去的人注定重蹈覆辙,我是我，我靠自己站立，我会做好自身,如果我睡大觉，谁给我摘月亮呢,假期和朋友，是人生中顶好的两样东西啊。,去爱，去失去，要不负相遇,没什么想不想通的，只是固执而已,我们深爱星辰，乃至不惧夜的黑,吃，喝，享受幸福，接受奇迹,浊水若长流，自清澄,雅俗共赏,总会有什么也不想的幸福时刻吧,时间顺流而下，生活逆流而上,悟已往之不谏，知来者之可追,希望你的小世界里,山花烂漫,茶酒俱全,安宁清淡,明朗欢愉" data-fontsize="20px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS70の旅/&quot;);" href="javascript:void(0);">CS70の旅</a><span class="categoryBar-list-count">25</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS61B/&quot;);" href="javascript:void(0);">CS61B</a><span class="categoryBar-list-count">76</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/期末の旅/&quot;);" href="javascript:void(0);">期末の旅</a><span class="categoryBar-list-count">99</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACMの旅/&quot;);" href="javascript:void(0);">ACMの旅</a><span class="categoryBar-list-count">68</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/区域赛の旅/&quot;);" href="javascript:void(0);">区域赛の旅</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数学建模/&quot;);" href="javascript:void(0);">数学建模</a><span class="categoryBar-list-count">31</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Codeforcesの旅/&quot;);" href="javascript:void(0);">Codeforcesの旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题计划/&quot;);" href="javascript:void(0);">刷题计划</a><span class="categoryBar-list-count">40</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/牛客の旅/&quot;);" href="javascript:void(0);">牛客の旅</a><span class="categoryBar-list-count">65</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/前端の旅/&quot;);" href="javascript:void(0);">前端の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构/&quot;);" href="javascript:void(0);">数据结构</a><span class="categoryBar-list-count">47</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_24.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Atcoderの旅/&quot;);" href="javascript:void(0);">Atcoderの旅</a><span class="categoryBar-list-count">53</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_25.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-の旅/&quot;);" href="javascript:void(0);">C++の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_26.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CSAPPの旅/&quot;);" href="javascript:void(0);">CSAPPの旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_27.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS知识/&quot;);" href="javascript:void(0);">CS知识</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_28.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程基础/&quot;);" href="javascript:void(0);">编程基础</a><span class="categoryBar-list-count">22</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_29.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/离散数学/&quot;);" href="javascript:void(0);">离散数学</a><span class="categoryBar-list-count">29</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_30.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JAVAの旅/&quot;);" href="javascript:void(0);">JAVAの旅</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_31.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MIT-6-031-Software-Construction/&quot;);" href="javascript:void(0);">MIT 6.031:Software Construction</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_32.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS-110L/&quot;);" href="javascript:void(0);">CS 110L</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_33.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/个人安排/&quot;);" href="javascript:void(0);">个人安排</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_34.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/灵魂の旅/&quot;);" href="javascript:void(0);">灵魂の旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_35.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂项/&quot;);" href="javascript:void(0);">杂项</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_36.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">40</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_37.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文学/&quot;);" href="javascript:void(0);">文学</a><span class="categoryBar-list-count">49</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_38.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/力扣の旅/&quot;);" href="javascript:void(0);">力扣の旅</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_39.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/千里十二行/&quot;);" href="javascript:void(0);">千里十二行</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/🗡指offer/&quot;);" href="javascript:void(0);">🗡指offer</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_41.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/少年游/&quot;);" href="javascript:void(0);">少年游</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_42.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法提高课/&quot;);" href="javascript:void(0);">算法提高课</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_43.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/汇编の旅/&quot;);" href="javascript:void(0);">汇编の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-实训/&quot;);" href="javascript:void(0);">C++实训</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4b31456c6f0f4489f99177f89e936de7286431045.png@1256w_708h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt="">诗录</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/51d37eba99d243607ddedfff6e91568f617436609.jpg@1256w_1884h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">TotoroのPlan</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.48/img_482_1920x1080_96_null_normal.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt="">Markdown格式</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>