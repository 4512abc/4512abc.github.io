<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C++ppt复习 | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="C++PPTIntroduction to C++ C++: A powerful programming language suitable for both beginners and experienced programmers. Software and Hardware: Software (programs) controls hardware (computers). Object">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ppt复习">
<meta property="og:url" content="http://totorocatcat.top/2024/06/08/C-ppt%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="C++PPTIntroduction to C++ C++: A powerful programming language suitable for both beginners and experienced programmers. Software and Hardware: Software (programs) controls hardware (computers). Object">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p4.qhimg.com/bdr/__85/t01d5b63058c5beaba1.jpg">
<meta property="article:published_time" content="2024-06-08T13:44:51.000Z">
<meta property="article:modified_time" content="2024-06-13T12:15:36.354Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="有趣">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://p4.qhimg.com/bdr/__85/t01d5b63058c5beaba1.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/b5ca6e582a7a45e6fde46e616eeb68e.png"><link rel="canonical" href="http://totorocatcat.top/2024/06/08/C-ppt%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":765,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++ppt复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-06-13 20:15:36'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">707</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw iconfont icon-bilibili"></i><span> 追番</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://p4.qhimg.com/bdr/__85/t01d5b63058c5beaba1.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw iconfont icon-bilibili"></i><span> 追番</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++ppt复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-06-08T13:44:51.000Z" title="发表于 2024-06-08 21:44:51">2024-06-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-13T12:15:36.354Z" title="更新于 2024-06-13 20:15:36">2024-06-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C-%E3%81%AE%E6%97%85/">C++の旅</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">101.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>381分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++ppt复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="C-PPT"><a href="#C-PPT" class="headerlink" title="C++PPT"></a>C++PPT</h1><h2 id="Introduction-to-C"><a href="#Introduction-to-C" class="headerlink" title="Introduction to C++"></a>Introduction to C++</h2><ul>
<li><strong>C++</strong>: A powerful programming language suitable for both beginners and experienced programmers.</li>
<li><strong>Software and Hardware</strong>: Software (programs) controls hardware (computers).</li>
<li><strong>Object-Oriented Programming (OOP)</strong>: Key programming methodology that enhances productivity and reduces development costs.</li>
</ul>
<blockquote>
<ul>
<li><strong>C++</strong>: 一种功能强大的编程语言，适合初学者和有经验的程序员使用。</li>
<li><strong>软件和硬件</strong>: 软件（程序）控制硬件（计算机）。</li>
<li><strong>面向对象编程（OOP）</strong>: 关键的编程方法，提高生产力并降低开发成本。</li>
</ul>
</blockquote>
<h4 id="Importance-of-C"><a href="#Importance-of-C" class="headerlink" title="Importance of C++"></a>Importance of C++</h4><ul>
<li><strong>Popularity</strong>: C++ is one of today’s most popular programming languages.</li>
<li><strong>Standardization</strong>: The latest version is C++11, standardized by ISO and IEC.</li>
<li><strong>Widespread Use</strong>: C++ is used in general-purpose computers, smartphones, tablets, etc.</li>
</ul>
<blockquote>
<ul>
<li><strong>受欢迎程度</strong>: C++是当今最受欢迎的编程语言之一。</li>
<li><strong>标准化</strong>: 最新版本是C++11，由ISO和IEC标准化。</li>
<li><strong>广泛使用</strong>: C++用于通用计算机、智能手机、平板电脑等。</li>
</ul>
</blockquote>
<h4 id="Computing-Power"><a href="#Computing-Power" class="headerlink" title="Computing Power"></a>Computing Power</h4><ul>
<li><strong>Performance</strong>: Computers can perform billions of calculations per second.</li>
<li><strong>Advancement</strong>: Supercomputers perform thousands of trillions (quadrillions) of instructions per second.</li>
<li><strong>Programs</strong>: Sequences of instructions that guide the computer, created by programmers.</li>
</ul>
<blockquote>
<ul>
<li><strong>性能</strong>: 计算机每秒钟可以执行数十亿次计算。</li>
<li><strong>进步</strong>: 超级计算机每秒钟可以执行数千万亿（千万亿次）指令。</li>
<li><strong>程序</strong>: 程序是由程序员编写的一系列指示计算机执行操作的指令。</li>
</ul>
</blockquote>
<h4 id="Software-Development"><a href="#Software-Development" class="headerlink" title="Software Development"></a>Software Development</h4><ul>
<li><strong>Costs</strong>: Rapid developments in technology have significantly reduced computing costs.</li>
<li><strong>Moore’s Law</strong>: Computing power doubles approximately every two years, leading to exponential growth in memory, storage, and processing speeds.</li>
<li><strong>Communications</strong>: Similar growth has occurred in the communications field, fostering the Information Revolution.</li>
</ul>
<blockquote>
<ul>
<li><strong>成本</strong>: 技术的快速发展显著降低了计算成本。</li>
<li><strong>摩尔定律</strong>: 计算能力大约每两年翻一番，导致内存、存储和处理速度的指数级增长。</li>
<li><strong>通信</strong>: 通信领域也经历了类似的增长，推动了信息革命。</li>
</ul>
</blockquote>
<h4 id="Computer-Organization"><a href="#Computer-Organization" class="headerlink" title="Computer Organization"></a>Computer Organization</h4><ul>
<li><strong>Logical Units</strong>: Computers are divided into various logical units or sections.</li>
<li><strong>Data Hierarchy</strong>: Data processed by computers form a hierarchy from bits to complex structures.</li>
</ul>
<blockquote>
<ul>
<li><strong>逻辑单元</strong>: 计算机分为多个逻辑单元或部分。</li>
<li><strong>数据层次结构</strong>: 计算机处理的数据形成一个从比特到复杂结构的层次结构。</li>
</ul>
</blockquote>
<h4 id="Programming-Languages"><a href="#Programming-Languages" class="headerlink" title="Programming Languages"></a>Programming Languages</h4><ul>
<li><p><strong>Types of Languages</strong>:</p>
<ul>
<li><strong>Machine Language</strong>: Directly understood by computers but cumbersome for humans.</li>
<li><strong>Assembly Language</strong>: Uses English-like abbreviations, converted to machine language by assemblers.</li>
<li><strong>High-Level Languages</strong>: Easier to use, translated into machine language by compilers. Examples include C++, JavaScript, and PHP.</li>
</ul>
<blockquote>
<p><strong>语言类型</strong>：</p>
<ul>
<li><strong>机器语言</strong>：计算机直接理解的语言，但对人类来说不方便。</li>
<li><strong>汇编语言</strong>：使用类似英语的缩写，由汇编器转换为机器语言。</li>
<li><strong>高级语言</strong>：更易于使用，由编译器转换为机器语言。示例包括C ++、JavaScript和PHP。</li>
</ul>
</blockquote>
</li>
</ul>
<h4 id="Evolution-of-C"><a href="#Evolution-of-C" class="headerlink" title="Evolution of C++"></a>Evolution of C++</h4><ul>
<li><strong>C Language</strong>: Developed by Dennis Ritchie, standardized as ANSI/ISO 9899: 1990.</li>
<li><strong>C++</strong>: Developed by Bjarne Stroustrup, an extension of C with added features for OOP.</li>
<li><strong>C++11</strong>: Latest standard to keep pace with powerful hardware and user demands.</li>
</ul>
<blockquote>
<ul>
<li><strong>C 语言</strong>：由丹尼斯·里奇（Dennis Ritchie）开发，被标准化为 ANSI/ISO 9899:1990。</li>
<li><strong>C++</strong>：由比雅尼·斯特劳斯特鲁普（Bjarne Stroustrup）开发，是 C 语言的扩展，增加了面向对象编程的特性。</li>
<li><strong>C++11</strong>：最新的标准，以适应强大的硬件和用户需求。</li>
</ul>
</blockquote>
<h4 id="C-Standard-Library"><a href="#C-Standard-Library" class="headerlink" title="C++ Standard Library"></a>C++ Standard Library</h4><ul>
<li><strong>Classes and Functions</strong>: Core components of C++ programs.</li>
<li><strong>Rich Library</strong>: Offers a collection of classes and functions to simplify programming tasks.</li>
</ul>
<blockquote>
<ul>
<li><strong>类和函数</strong>：C++程序的核心组件。</li>
<li><strong>丰富的库</strong>：提供了一系列类和函数，以简化编程任务。</li>
</ul>
</blockquote>
<h4 id="Object-Oriented-Programming-Concepts"><a href="#Object-Oriented-Programming-Concepts" class="headerlink" title="Object-Oriented Programming Concepts"></a>Object-Oriented Programming Concepts</h4><ul>
<li><strong>Objects</strong>: Represent real-world entities with attributes and behaviors.</li>
<li><strong>Classes</strong>: Blueprints for creating objects.</li>
<li><strong>Encapsulation</strong>: Wrapping data and functions into a single unit (object).</li>
<li><strong>Inheritance</strong>: Creating new classes from existing ones, inheriting attributes and behaviors.</li>
<li><strong>Modularity</strong>: Breaking down programs into smaller, manageable parts.</li>
</ul>
<blockquote>
<ul>
<li><strong>对象</strong>：用属性和行为表示现实世界的实体。</li>
<li><strong>类</strong>：创建对象的蓝图。</li>
<li><strong>封装</strong>：将数据和函数封装到单个单元（对象）中。</li>
<li><strong>继承</strong>：从现有类创建新类，继承属性和行为。</li>
<li><strong>模块化</strong>：将程序分解为更小、可管理的部分。</li>
</ul>
</blockquote>
<h4 id="Programming-Phases-in-C"><a href="#Programming-Phases-in-C" class="headerlink" title="Programming Phases in C++"></a>Programming Phases in C++</h4><ul>
<li><strong>Editing</strong>: Writing and saving the program using an editor.</li>
<li><strong>Preprocessing</strong>: Executing commands before compilation.</li>
<li><strong>Compiling</strong>: Translating the program into machine language.</li>
<li><strong>Linking</strong>: Combining object code with libraries to create an executable.</li>
<li><strong>Loading</strong>: Transferring the executable to memory for execution.</li>
<li><strong>Execution</strong>: Running the program under CPU control.</li>
</ul>
<blockquote>
<ul>
<li><strong>编辑</strong>：使用编辑器编写和保存程序。</li>
<li><strong>预处理</strong>：在编译之前执行命令。</li>
<li><strong>编译</strong>：将程序翻译成机器语言。</li>
<li><strong>链接</strong>：将目标代码与库结合起来，创建可执行文件。</li>
<li><strong>加载</strong>：将可执行文件传输到内存中以进行执行。</li>
<li><strong>执行</strong>：在 CPU 控制下运行程序。</li>
</ul>
</blockquote>
<h4 id="Integrated-Development-Environments-IDEs"><a href="#Integrated-Development-Environments-IDEs" class="headerlink" title="Integrated Development Environments (IDEs)"></a>Integrated Development Environments (IDEs)</h4><ul>
<li><strong>Tools</strong>: Provide editors and debuggers to aid in software development.</li>
<li><strong>Popular IDEs</strong>: Microsoft Visual Studio, Dev C++, NetBeans, Eclipse, Apple’s Xcode, CodeLite.</li>
</ul>
<blockquote>
<ul>
<li><strong>工具</strong>：提供编辑器和调试器，以帮助软件开发。</li>
<li><strong>流行的集成开发环境（IDE）</strong>：Microsoft Visual Studio、Dev C++、NetBeans、Eclipse、Apple 的 Xcode、CodeLite。</li>
</ul>
</blockquote>
<h4 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges"></a>Challenges</h4><ul>
<li><strong>Debugging</strong>: Programs may not work on the first try, requiring debugging to resolve issues.</li>
</ul>
<blockquote>
<p><strong>调试</strong>：程序可能在第一次尝试时无法正常工作，需要进行调试以解决问题。</p>
</blockquote>
<h3 id="Key-Takeaways"><a href="#Key-Takeaways" class="headerlink" title="Key Takeaways"></a>Key Takeaways</h3><ul>
<li><strong>Understanding C++</strong>: Essential for creating robust and efficient software.</li>
<li><strong>OOP Methodology</strong>: Facilitates the development of modular, reusable, and maintainable code.</li>
<li><strong>Standard Library</strong>: Provides a vast array of tools to streamline the development process.</li>
<li><strong>Development Phases</strong>: Following a structured approach ensures efficient and error-free programming.</li>
</ul>
<blockquote>
<ul>
<li><strong>理解 C++</strong>：对于创建稳健高效的软件至关重要。</li>
<li><strong>面向对象编程方法论</strong>：有助于开发模块化、可重用和易维护的代码。</li>
<li><strong>标准库</strong>：提供了大量工具，以简化开发过程。</li>
<li><strong>开发阶段</strong>：遵循结构化的方法确保高效且无错误的编程。</li>
</ul>
</blockquote>
<p>这一部分都是理论知识，看看就行。</p>
<hr>
<h2 id="C-Programming-Basics-Key-Concepts-from-the-Presentation"><a href="#C-Programming-Basics-Key-Concepts-from-the-Presentation" class="headerlink" title="C++ Programming Basics: Key Concepts from the Presentation"></a>C++ Programming Basics: Key Concepts from the Presentation</h2><ul>
<li><strong>Discipline in Development</strong>: C++ programming encourages a disciplined approach to developing programs.</li>
<li><strong>Data Processing and Display</strong>: Most C++ programs process data and display results.</li>
</ul>
<blockquote>
<ul>
<li><strong>开发中的纪律性</strong>：C++ 编程鼓励采用纪律性的方法来开发程序。</li>
<li><strong>数据处理与显示</strong>：大多数 C++ 程序处理数据并显示结果。</li>
</ul>
</blockquote>
<h4 id="Comments"><a href="#Comments" class="headerlink" title="Comments"></a>Comments</h4><ul>
<li><strong>Single-Line Comments</strong>: Begin with <code>//</code> and extend to the end of the line.</li>
<li><strong>Multi-Line Comments</strong>: Enclosed between <code>/*</code> and <code>*/</code>.</li>
</ul>
<blockquote>
<ul>
<li><strong>单行注释</strong>：以 <code>//</code> 开始，并延伸至行尾。</li>
<li><strong>多行注释</strong>：被包裹在 <code>/*</code> 和 <code>*/</code> 之间。</li>
</ul>
</blockquote>
<h4 id="Preprocessing-Directives"><a href="#Preprocessing-Directives" class="headerlink" title="Preprocessing Directives"></a>Preprocessing Directives</h4><ul>
<li><strong><code>#include &lt;iostream&gt;</code></strong>: Instructs the preprocessor to include the input/output stream header file for data input and output operations.</li>
</ul>
<blockquote>
<p><strong><code>#include &lt;iostream&gt;</code></strong>：指示预处理器包含输入/输出流头文件，用于数据输入和输出操作。</p>
</blockquote>
<h4 id="Whitespace"><a href="#Whitespace" class="headerlink" title="Whitespace"></a>Whitespace</h4><ul>
<li><strong>Whitespace Characters</strong>: Include blank lines, space characters, and tabs, which are ignored by the compiler but help in making the code more readable.</li>
</ul>
<blockquote>
<p><strong>空白字符</strong>：包括空行、空格和制表符，编译器会忽略这些字符，但有助于使代码更易读。</p>
</blockquote>
<h4 id="The-main-Function"><a href="#The-main-Function" class="headerlink" title="The main Function"></a>The <code>main</code> Function</h4><ul>
<li><strong>Function Definition</strong>: Every C++ program must have a <code>main</code> function where execution begins.</li>
<li><strong>Integer Return Type</strong>: The <code>main</code> function returns an integer value, typically 0, to indicate successful program termination.</li>
</ul>
<blockquote>
<ul>
<li><strong>函数定义</strong>：每个 C++ 程序必须有一个 <code>main</code> 函数，程序从这里开始执行。</li>
<li><strong>整数返回类型</strong>：<code>main</code> 函数返回一个整数值，通常是 0，表示程序成功终止。</li>
</ul>
</blockquote>
<h4 id="Basic-Syntax"><a href="#Basic-Syntax" class="headerlink" title="Basic Syntax"></a>Basic Syntax</h4><ul>
<li><strong>Braces <code>&#123;&#125;</code></strong>: Used to delimit the body of functions.</li>
<li><strong>String Literals</strong>: Characters enclosed in double quotes are considered string literals.</li>
<li><strong>Semicolon <code>;</code></strong>: Used to terminate most C++ statements.</li>
</ul>
<blockquote>
<h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ul>
<li><strong>大括号 <code>&#123;&#125;</code></strong>: 用于限定函数的主体部分。</li>
<li><strong>字符串字面值</strong>: 用双引号括起来的字符被视为字符串字面值。</li>
<li><strong>分号 <code>;</code></strong>: 用于终止大多数C++语句。</li>
</ul>
</blockquote>
<h4 id="Input-and-Output"><a href="#Input-and-Output" class="headerlink" title="Input and Output"></a>Input and Output</h4><ul>
<li><strong>Streams</strong>: C++ uses streams for input (<code>cin</code>) and output (<code>cout</code>). </li>
<li><strong>Namespaces</strong>: <code>std::cout</code> and <code>std::cin</code> belong to the <code>std</code> namespace, which can be brought into scope with <code>using namespace std;</code>.</li>
<li><strong>Stream Operators</strong>: The <code>&lt;&lt;</code> operator inserts data into the output stream, and the <code>&gt;&gt;</code> operator extracts data from the input stream.</li>
</ul>
<blockquote>
<ul>
<li><strong>流</strong>：C++ 使用流进行输入（<code>cin</code>）和输出（<code>cout</code>）。</li>
<li><strong>命名空间</strong>：<code>std::cout</code> 和 <code>std::cin</code> 属于 <code>std</code> 命名空间，可以通过 <code>using namespace std;</code> 将其引入作用域。</li>
<li><strong>流运算符</strong>：<code>&lt;&lt;</code> 运算符将数据插入输出流，<code>&gt;&gt;</code> 运算符从输入流中提取数据。</li>
</ul>
</blockquote>
<h4 id="Variables-and-Data-Types"><a href="#Variables-and-Data-Types" class="headerlink" title="Variables and Data Types"></a>Variables and Data Types</h4><ul>
<li><strong>Declaration</strong>: Variables must be declared before use with a name and data type.</li>
<li><strong>Types</strong>: Common data types include <code>int</code> (integer), <code>double</code> (floating-point), and <code>char</code> (character).</li>
<li><strong>Identifiers</strong>: Names for variables, which must start with a letter or underscore and are case-sensitive.</li>
</ul>
<blockquote>
<ul>
<li><strong>声明</strong>：变量在使用前必须用名称和数据类型声明。</li>
<li><strong>类型</strong>：常见的数据类型包括 <code>int</code>（整数）、<code>double</code>（浮点数）和 <code>char</code>（字符）。</li>
<li><strong>标识符</strong>：变量的名称，必须以字母或下划线开头，且区分大小写。</li>
</ul>
</blockquote>
<h4 id="Arithmetic-Operations"><a href="#Arithmetic-Operations" class="headerlink" title="Arithmetic Operations"></a>Arithmetic Operations</h4><ul>
<li><strong>Operators</strong>: Include <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, and <code>%</code> for addition, subtraction, multiplication, division, and modulus operations, respectively.</li>
<li><strong>Operator Precedence</strong>: Operators are applied in a specific order, similar to algebraic expressions.</li>
</ul>
<blockquote>
<ul>
<li><strong>运算符</strong>：包括 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code> 和 <code>%</code>，分别用于加法、减法、乘法、除法和取模运算。</li>
<li><strong>运算符优先级</strong>：运算符按特定顺序应用，类似于代数表达式。</li>
</ul>
</blockquote>
<h4 id="Control-Structures"><a href="#Control-Structures" class="headerlink" title="Control Structures"></a>Control Structures</h4><ul>
<li><strong><code>if</code> Statements</strong>: Allow conditional execution of code based on boolean expressions.</li>
<li><strong>Relational and Equality Operators</strong>: Used to form conditions in <code>if</code> statements, such as <code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, and <code>&gt;=</code>.</li>
</ul>
<blockquote>
<ul>
<li><strong><code>if</code> 语句</strong>：根据布尔表达式的条件执行代码。</li>
<li><strong>关系运算符和相等运算符</strong>：用于形成 <code>if</code> 语句中的条件，如 <code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code> 和 <code>&gt;=</code>。</li>
</ul>
</blockquote>
<h4 id="Example-Programs"><a href="#Example-Programs" class="headerlink" title="Example Programs"></a>Example Programs</h4><ul>
<li><strong>Basic I/O Program</strong>: Reads two integers from the keyboard, computes their sum, and outputs the result.</li>
<li><strong>Escape Sequences</strong>: <code>\n</code> for newline and <code>\t</code> for tab are examples of escape sequences used in output.</li>
</ul>
<blockquote>
<ul>
<li><strong>基本输入/输出程序</strong>：从键盘读取两个整数，计算它们的和，并输出结果。</li>
<li><strong>转义序列</strong>：<code>\n</code> 表示换行，<code>\t</code> 表示制表符，是用于输出的转义序列的示例。</li>
</ul>
</blockquote>
<h4 id="Additional-Concepts"><a href="#Additional-Concepts" class="headerlink" title="Additional Concepts"></a>Additional Concepts</h4><ul>
<li><strong>Using Declarations</strong>: To avoid repeatedly using <code>std::</code>, you can include <code>using namespace std;</code> to simplify the code.</li>
<li><strong>Compound Statements</strong>: Multiple statements can be grouped using braces <code>&#123;&#125;</code> to form a compound statement or block.</li>
<li><strong>Syntax Errors</strong>: Occur when the code does not conform to the grammatical rules of C++.</li>
</ul>
<blockquote>
<ul>
<li><strong>使用声明</strong>：为了避免反复使用 <code>std::</code>，可以包含 <code>using namespace std;</code> 来简化代码。</li>
<li><strong>复合语句</strong>：多个语句可以用大括号 <code>&#123;&#125;</code> 分组形成复合语句或块。</li>
<li><strong>语法错误</strong>：当代码不符合 C++ 的语法规则时发生。</li>
</ul>
</blockquote>
<hr>
<h2 id="Introduction-to-Classes-Objects"><a href="#Introduction-to-Classes-Objects" class="headerlink" title="Introduction to Classes Objects"></a>Introduction to Classes Objects</h2><p><strong>Class Definitions and Member Functions:</strong></p>
<ul>
<li><p>Classes are defined using the <code>class</code> keyword, with names typically following PascalCase convention for readability.</p>
</li>
<li><p>Class bodies are enclosed in curly braces <code>&#123;&#125;</code> and terminate with a semicolon.</p>
</li>
<li><p>Member functions manipulate data and perform tasks related to objects of the class. They are declared within the class and defined outside of it.</p>
</li>
<li><p>Access specifiers (<code>public</code>, <code>private</code>, <code>protected</code>) determine the accessibility of class members. <code>public</code> members are accessible outside the class, while <code>private</code> members are only accessible within the class.</p>
<blockquote>
<ul>
<li>使用 <code>class</code> 关键字定义类，类名通常遵循 PascalCase 约定以提高可读性。</li>
<li>类主体被大括号 <code>&#123;&#125;</code> 包围，并以分号结束。</li>
<li>成员函数操作数据并执行与类对象相关的任务。它们在类内部声明，在外部定义。</li>
<li>访问修饰符（<code>public</code>、<code>private</code>、<code>protected</code>）确定类成员的可访问性。<code>public</code> 成员可以在类外部访问，而 <code>private</code> 成员只能在类内部访问。</li>
</ul>
</blockquote>
</li>
</ul>
<p><strong>Object Creation and Usage:</strong></p>
<ul>
<li>Objects are instances of classes and are created using the class name followed by parentheses to call the constructor.</li>
<li>Constructors are special member functions with the same name as the class. They initialize object attributes and are called automatically when an object is created.</li>
<li>Member functions can be called on objects using the dot operator (<code>.</code>). They may take parameters, which are provided as arguments in the function call.</li>
</ul>
<blockquote>
<ul>
<li>对象是类的实例，通过使用类名后跟括号来创建，以调用构造函数。</li>
<li>构造函数是与类同名的特殊成员函数。它们初始化对象的属性，并在对象创建时自动调用。</li>
<li>成员函数可以使用点运算符（<code>.</code>）在对象上调用。它们可以接受参数，在函数调用中作为参数提供。</li>
</ul>
</blockquote>
<p><strong>Data Hiding and Encapsulation:</strong></p>
<ul>
<li>Data members are variables declared within a class, representing the object’s attributes. They are often declared as <code>private</code> to enforce encapsulation, hiding implementation details from external code.</li>
<li>Member functions provide an interface for interacting with data members, enforcing controlled access to the object’s state.</li>
</ul>
<blockquote>
<ul>
<li>数据成员是在类内部声明的变量，代表对象的属性。它们通常声明为 <code>private</code>，以强制封装，隐藏实现细节不让外部代码访问。</li>
<li>成员函数提供了与数据成员交互的接口，强制控制对对象状态的访问。</li>
</ul>
</blockquote>
<p><strong>Code Reusability and Modularization:</strong></p>
<ul>
<li>By encapsulating related data and behavior within classes, code can be modularized and reused across different parts of a program or in other programs.</li>
<li>Header files (<code>.h</code>) contain class declarations and are included in source files using <code>#include</code> directives. They facilitate code reuse and modularity by providing a clear interface to external code.</li>
</ul>
<blockquote>
<ul>
<li>通过将相关数据和行为封装在类内部，代码可以被模块化，并在程序的不同部分或其他程序中重用。</li>
<li>头文件（<code>.h</code>）包含类的声明，并通过 <code>#include</code> 指令包含在源文件中。它们通过为外部代码提供清晰的接口，促进了代码重用和模块化。</li>
</ul>
</blockquote>
<p><strong>Separation of Header and Source Files</strong>:</p>
<ul>
<li>In C++ programming, it’s common practice to separate the declaration of a class from its implementation. </li>
<li>Declarations are placed in header files (<code>.h</code>), while definitions are placed in source code files (<code>.cpp</code>).</li>
<li>Header files contain the class declaration and any dependencies on other header files, but do not include the actual function implementations.</li>
<li>Source code files contain the concrete implementation of the class, including the definitions of member functions and other implementation details.</li>
</ul>
<blockquote>
<ul>
<li>在C++编程中，通常会将类的声明和定义分开放置。声明放在头文件（.h）中，而定义放在源代码文件（.cpp）中。</li>
<li>头文件包含类的声明和可能依赖的其他头文件，但不包含具体的函数实现。</li>
<li>源代码文件包含类的具体实现，包括成员函数的定义和其他实现细节。</li>
</ul>
</blockquote>
<p><strong>Including Header Files</strong>:</p>
<ul>
<li>Header files are included using the <code>#include</code> preprocessor directive to make class declarations available in a program.</li>
<li>Header files should be enclosed in double quotes to allow the preprocessor to search for them in the current directory.</li>
</ul>
<blockquote>
<ul>
<li>通过使用<code>#include</code>预处理指令来包含头文件，以便在程序中使用类的声明。</li>
<li>头文件应该使用双引号括起来，以便预处理器在当前目录中查找头文件。</li>
</ul>
</blockquote>
<p><strong>Public Interface of a Class</strong>:</p>
<ul>
<li>The public interface of a class includes its public member functions, defining the services that clients of the class can use and how to request those services without revealing the implementation details.</li>
<li>By declaring member function prototypes (function declarations) in the header file, the public interface of the class is exposed to client code.</li>
</ul>
<blockquote>
<ul>
<li>类的公共接口包括类的公共成员函数，定义了类的客户端可以使用的服务及如何请求这些服务，但不包括具体实现。</li>
<li>通过在头文件中定义类的成员函数原型（函数声明），可以向客户端公开类的公共接口。</li>
</ul>
</blockquote>
<p><strong>Class Implementation</strong>:</p>
<ul>
<li>The concrete implementation of a class should be hidden in the source code file to prevent direct access to the internal details by client code.</li>
<li>In the source code file, member functions’ definitions are linked to the class declaration using the scope resolution operator <code>::</code>.</li>
</ul>
<blockquote>
<ul>
<li>类的具体实现应该隐藏在源代码文件中，以防止客户端代码直接访问类的内部细节。</li>
<li>在源代码文件中，使用范围解析运算符<code>::</code>来连接成员函数的定义与类的声明。</li>
</ul>
</blockquote>
<p><strong>Compilation and Linking</strong>:</p>
<ul>
<li>Before executing a program, all source code files need to be compiled into object files, which are then linked together to generate an executable file.</li>
<li>The compiler checks for correct function calls based on the declarations in header files to ensure that the code can be linked and executed properly.</li>
</ul>
<blockquote>
<ul>
<li>在编译和链接程序之前，需要将所有的源代码文件编译成目标文件，然后将这些目标文件链接在一起生成可执行文件。</li>
<li>编译器根据头文件中的声明来检查函数调用是否正确，确保代码能够正确链接并运行。</li>
</ul>
</blockquote>
<p><strong>Modifying Member Functions of a Class</strong>:</p>
<ul>
<li>If changes are made to a class’s member functions, client code doesn’t need to be modified as long as the class’s interface remains unchanged.</li>
<li>After modifying a class’s member functions, the program needs to be recompiled and linked to ensure that the new implementation is correctly invoked.</li>
</ul>
<blockquote>
<ul>
<li>如果需要修改类的成员函数，只要类的接口保持不变，就无需修改客户端代码。</li>
<li>修改类的成员函数后，需要重新编译并链接程序，以确保新的实现被正确地调用</li>
</ul>
</blockquote>
<hr>
<h1 id="Control-Statements"><a href="#Control-Statements" class="headerlink" title="Control Statements"></a>Control Statements</h1><ol>
<li><p><strong>Problem Understanding and Program Planning</strong>:</p>
<ul>
<li>Before writing a program, understanding the problem thoroughly is essential.（在编写程序之前，深入了解问题至关重要。）</li>
<li>A well-planned approach is crucial for problem-solving.（对问题的解决方案进行精心规划至关重要。）</li>
<li>Employing proven program construction techniques enhances program development.（采用经过验证的程序构建技术可以增强程序开发。）</li>
</ul>
</li>
<li><p><strong>Algorithm Definition</strong>:</p>
<ul>
<li>An algorithm is a step-by-step procedure for solving a problem, specifying actions to execute and their order.（算法是解决问题的逐步过程，指定要执行的操作及其顺序。）</li>
<li>It defines program control by specifying the sequence of actions to execute.（它通过指定要执行的操作顺序来定义程序控制。）</li>
</ul>
</li>
<li><p><strong>Pseudocode</strong>:</p>
<ul>
<li>Pseudocode is an informal language resembling everyday English, aiding algorithm development.（伪代码是一种类似于日常英语的非正式语言，有助于算法的开发。）</li>
<li>It’s user-friendly, helps in visualizing a program’s logic, and can be easily translated into code.（它用户友好，有助于可视化程序的逻辑，并且可以轻松转换为代码。）</li>
<li>Typically, pseudocode describes only executable statements, excluding declarations without initializers or constructor calls.（通常，伪代码仅描述可执行语句，不包括没有初始化程序或构造函数调用的声明。）</li>
</ul>
</li>
<li><p><strong>Control Structures</strong>:</p>
<ul>
<li>Programs execute a series of actions, typically in sequence, but control structures allow deviations.（程序执行一系列操作，通常按顺序执行，但控制结构允许偏差。）</li>
<li>Three fundamental control structures include sequence, selection, and repetition.（三种基本的控制结构包括顺序，选择和重复。）</li>
</ul>
</li>
<li><p><strong>Sequence Structure</strong>:</p>
<ul>
<li>In sequence structure, statements execute one after another in the order they are written.（在序列结构中，语句按照编写顺序依次执行。）</li>
<li>Various actions can be placed in sequence, facilitating program flow.（各种动作可以按顺序排列，以促进程序流程。）</li>
</ul>
</li>
<li><p><strong>Selection Structures</strong>:</p>
<ul>
<li>Selection structures enable choosing alternative actions based on conditions.（选择结构使得可以根据条件选择替代动作。）</li>
<li>C++ provides <code>if</code>, <code>if...else</code>, and <code>switch</code> selection statements.（C++提供了<code>if</code>，<code>if...else</code>和<code>switch</code>选择语句。）</li>
<li><code>if</code> performs an action if a condition is true, <code>if...else</code> selects between two actions, and <code>switch</code> selects among many actions based on an integer expression.（<code>if</code>在条件为真时执行动作，<code>if...else</code>在两个动作之间进行选择，<code>switch</code>根据整数表达式选择多个动作。）</li>
</ul>
</li>
<li><p><strong>Repetition Structures</strong>:</p>
<ul>
<li>Repetition structures allow executing statements repeatedly based on a condition.（重复结构允许根据条件重复执行语句。）</li>
<li>C++ provides <code>while</code>, <code>do...while</code>, and <code>for</code> loops.（C++提供<code>while</code>，<code>do...while</code>和<code>for</code>循环。）</li>
<li><code>while</code> and <code>for</code> perform actions zero or more times, while <code>do...while</code> executes at least once.（<code>while</code>和<code>for</code>零次或多次执行动作，而<code>do...while</code>至少执行一次。）</li>
</ul>
</li>
<li><p><strong>Keywords</strong>:</p>
<ul>
<li>C++ keywords like <code>if</code>, <code>else</code>, <code>switch</code>, <code>while</code>, <code>do</code>, and <code>for</code> are reserved and used to implement control structures.（C++关键字如<code>if</code>，<code>else</code>，<code>switch</code>，<code>while</code>，<code>do</code>和<code>for</code>是保留的，用于实现控制结构。）</li>
<li>Keywords cannot be used as identifiers (e.g., variable names).（关键字不能用作标识符（例如，变量名）。）</li>
</ul>
</li>
<li><p><strong>Control Statement Modeling</strong>:</p>
<ul>
<li>Control statements can be modeled as activity diagrams, illustrating their entry and exit points.（控制语句可以建模为活动图，说明它们的输入和输出点。）</li>
<li>Statements can be connected via control-statement stacking or nesting.（语句可以通过控制语句堆叠或嵌套连接。）</li>
</ul>
</li>
<li><p><strong>Nested Control Statements</strong>:</p>
<ul>
<li>Nested control statements enable testing multiple cases by embedding one inside another.（嵌套的控制语句通过将一个语句嵌套到另一个语句中来测试多个情况。）</li>
<li>Proper indentation and brace placement are crucial to avoid ambiguity, such as the dangling-else problem.（适当的缩进和括号放置至关重要，以避免歧义，例如悬挂else问题。）</li>
</ul>
</li>
<li><p><strong>Compound Statements and Null Statements</strong>:</p>
<ul>
<li>Compound statements (blocks) allow grouping multiple statements.（复合语句（块）允许将多个语句分组。）</li>
<li>Null statements, represented by a semicolon, are useful when no action is required.（空语句，由分号表示，在不需要执行动作时很有用。）</li>
</ul>
</li>
</ol>
<p>好的，我会按照您的要求重新生成笔记，确保英文在外面，中文在括号里，并且提供更详细的解释。</p>
<ol>
<li><p><strong>Repetition Statement (循环语句)</strong>:</p>
<ul>
<li>A repetition statement allows you to specify that a program should repeat an action while some condition remains true.（循环语句允许指定程序在某个条件保持为真时重复执行某个动作。）</li>
<li>While there are more items on my shopping list, purchase the next item and cross it off my list.（当我的购物清单上还有更多物品时，执行“购买下一个物品并在清单上划掉它”。）</li>
<li>“There are more items on my shopping list” is true or false. If true, “Purchase next item and cross it off my list” is performed. Performed repeatedly while the condition remains true.（“还有更多物品在我的购物清单上”是真还是假。如果是真，则执行“购买下一个物品并在清单上划掉它”。此过程重复执行，直到条件为假为止。）</li>
<li>The statement contained in the repetition statement constitutes the body of the loop, which can be a single statement or a block.（循环语句中包含的语句构成了循环体，它可以是单个语句或一个代码块。）</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Find the first power of 3 larger than 100</span></span><br><span class="line"><span class="type">int</span> product = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">while</span> (product &lt;= <span class="number">100</span>)</span><br><span class="line">    product = <span class="number">3</span> * product;</span><br><span class="line"><span class="comment">// At the end of the loop, &#x27;product&#x27; contains the result</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>Class Average Problem (班级平均分问题)</strong>:</p>
<ul>
<li>A class of ten students took a quiz. The grades (0 to 100) for this quiz are available to you. Calculate and display the total of the grades and the class average.（一个由十名学生组成的班级参加了一次测验。这次测验的分数（0到100）可供您使用。计算并显示所有分数的总和和班级平均分。）</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counters and variables initialization</span></span><br><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> gradeCounter = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Input grades and calculate total</span></span><br><span class="line"><span class="keyword">while</span> (gradeCounter &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">// Input grade</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter grade: &quot;</span>;</span><br><span class="line">    cin &gt;&gt; grade;</span><br><span class="line">    <span class="comment">// Add grade to total</span></span><br><span class="line">    total += grade;</span><br><span class="line">    <span class="comment">// Increment grade counter</span></span><br><span class="line">    gradeCounter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Calculate and print total and average</span></span><br><span class="line"><span class="keyword">if</span> (gradeCounter != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="type">double</span> average = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(total) / gradeCounter;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total of all grades: &quot;</span> &lt;&lt; total &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Class average: &quot;</span> &lt;&lt; average &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;No grades were entered.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>Additional Notes (其他说明)</strong>:</p>
<ul>
<li>Use sentinel-controlled repetition to process grades for an arbitrary number of students.（使用标记控制的循环处理任意数量的学生的成绩。）</li>
<li>Use list initialization (C++11) to initialize variables, avoiding data loss.（使用列表初始化（C++11）初始化变量，避免数据损失。）</li>
<li>Use assignment operators to abbreviate assignment expressions, e.g., use <code>+=</code> operator.（使用赋值运算符简化赋值表达式，例如，使用<code>+=</code>运算符。）</li>
</ul>
</li>
<li><p><strong>Counter-Controlled Repetition (计数控制循环)</strong>:</p>
<ul>
<li>Counter-controlled repetition uses a variable called a counter to control the number of times a group of statements will execute.（计数控制循环使用一个叫做计数器的变量来控制一组语句执行的次数。）</li>
<li>It’s often called definite repetition because the number of repetitions is known before the loop begins executing.（通常被称为明确的重复，因为在循环开始执行之前，重复的次数是已知的。）</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Counter-controlled repetition example</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (count &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Count: &quot;</span> &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">    count++; <span class="comment">// Increment counter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>Sentinel-Controlled Repetition (标记控制循环)</strong>:</p>
<ul>
<li>Sentinel-controlled repetition uses a special value called a sentinel value to indicate “end of data entry”.（标记控制循环使用一个特殊值称为标记值来指示“数据输入结束”。）</li>
<li>The number of repetitions is not known in advance.（重复的次数事先是不知道的。）</li>
<li>The sentinel value must not be an acceptable input value.（标记值不能是可接受的输入值。）</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sentinel-controlled repetition example</span></span><br><span class="line"><span class="type">int</span> number;</span><br><span class="line"><span class="keyword">while</span> (number != <span class="number">-1</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Enter a number (-1 to quit): &quot;</span>;</span><br><span class="line">    cin &gt;&gt; number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>Preventing Arithmetic Overflow (防止算术溢出)</strong>:</p>
<ul>
<li>Arithmetic overflow can occur when adding integers, resulting in a value too large to store in an int variable.（在加法中，可能会发生算术溢出，导致一个值太大而无法存储在int变量中。）</li>
<li>To prevent overflow, ensure that arithmetic calculations do not exceed the maximum value that can be stored in the data type.（为了防止溢出，确保算术计算不超过数据类型可以存储的最大值。）</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Example of preventing arithmetic overflow</span></span><br><span class="line"><span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> grade = <span class="number">90</span>;</span><br><span class="line">total += grade; <span class="comment">// Add grade to total, ensuring no overflow</span></span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong><code>&lt;climits&gt;</code> 头文件</strong>:</p>
<ul>
<li><code>&lt;climits&gt;</code> is a header file in the C++ Standard Library that provides specific information about data types, such as the maximum and minimum values of integer types.(<code>&lt;climits&gt;</code> 是 C++ 标准库中的一个头文件，用于提供有关数据类型的特定信息，如整数类型的最大值和最小值等。)</li>
</ul>
</li>
<li><p><strong>常用的 <code>&lt;climits&gt;</code> 常量</strong>:</p>
<ul>
<li><code>INT_MAX</code>: int 类型的最大值。（<code>INT_MAX</code>: Maximum value for the int type.）</li>
<li><code>INT_MIN</code>: int 类型的最小值。（<code>INT_MIN</code>: Minimum value for the int type.）</li>
<li><code>UINT_MAX</code>: unsigned int 类型的最大值。（<code>UINT_MAX</code>: Maximum value for the unsigned int type.）</li>
<li>其他类型（如 short、long、long long 等）也有相应的常量。（Other types such as short, long, long long, etc., have corresponding constants as well.）</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Maximum value for int: &quot;</span> &lt;&lt; INT_MAX &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Minimum value for int: &quot;</span> &lt;&lt; INT_MIN &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Maximum value for unsigned int: &quot;</span> &lt;&lt; UINT_MAX &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>for循环</strong>：Regarding counter-controlled repetition, the <code>for</code> loop statement is commonly used. This type of loop requires four elements:（关于计数器控制的循环重复，通常使用 <code>for</code> 循环语句。这种循环需要四个要素：）</p>
<ul>
<li><p>The name of the control variable (or loop counter) 控制变量的名称（或循环计数器）</p>
</li>
<li><p>The initial value of the control variable 控制变量的初始值</p>
</li>
<li><p>The loop-continuation condition (i.e., whether looping should continue) 循环继续条件（即循环是否应该继续执行的条件）</p>
</li>
<li><p>The increment (or decrement) by which the control variable is modified each time through the loop 控制变量每次循环中的增量（或减量）接下来是 <code>for</code> 循环语句头部的组成部分：</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for ( 初始化; 循环继续条件; 增量 )    语句</span><br></pre></td></tr></table></figure>
<p>这里的初始化表达式初始化循环的控制变量，循环继续条件确定循环是否应该继续执行，增量则是控制变量的增加量。</p>
<p><code>for</code> 循环语句的一般形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">初始化;while ( 循环继续条件 )&#123;   语句   增量;&#125;</span><br></pre></td></tr></table></figure>
<p>接下来是关于 <code>for</code> 循环语句头部中的表达式的一些注意事项：</p>
<ul>
<li><code>for</code> 循环语句头部中的三个表达式是可选的，但是两个分号分隔符是必需的。</li>
<li>如果省略了循环继续条件，C++ 将假定条件为真，从而创建一个无限循环。</li>
<li>如果控制变量的初始化表达式被省略，那么如果在程序的早期已经对控制变量进行了初始化，就可以省略它。</li>
<li>如果增量表达式被省略，那么增量可以通过 <code>for</code> 循环体内的语句计算，或者如果不需要增量，就可以省略它。</li>
</ul>
<p>接下来是关于增量表达式的一些注意事项：</p>
<ul>
<li>在 <code>for</code> 循环语句中，增量表达式 acts like a standalone statement at the end of the for statement’s body。</li>
<li><p>在没有其他代码的情况下，<code>counter = counter + 1</code>, <code>counter += 1</code>, <code>++counter</code>, <code>counter++</code> 这些表达式在增量表达式中都是等价的。</p>
</li>
<li><p><code>for</code> 循环语句的初始化、循环继续条件和增量表达式都可以包含算术表达式。</p>
</li>
<li><code>for</code> 循环语句的“增量”可以是负数，这样它实际上是一个递减，并且循环实际上是向下计数的。</li>
<li>如果循环继续条件最初为假，则不执行 <code>for</code> 循环语句的主体。</li>
</ul>
<p>21.<strong>do while</strong></p>
<ul>
<li><p><code>do...while</code> 循环是一种后测试循环，它先执行循环体中的代码，然后再检查循环条件是否为真。因此，即使循环条件一开始就为假，循环体也至少会被执行一次。</p>
</li>
<li><p><code>do...while</code> 循环的语法格式如下：</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    // 循环体代码</span><br><span class="line">&#125; while (循环条件);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在 <code>do...while</code> 循环中，循环条件通常是一个布尔表达式，它决定是否继续执行循环。如果循环条件为真，则继续执行循环；如果为假，则退出循环。</p>
</li>
<li><p><code>do...while</code> 循环的主要特点是它至少会执行一次循环体中的代码，即使循环条件一开始就为假。</p>
</li>
<li><p>使用 <code>do...while</code> 循环时要特别注意循环条件的更新，以避免出现无限循环的情况。通常在循环体内部更新循环条件。</p>
</li>
<li><p>在 <code>do...while</code> 循环中，如果循环体内部使用了 <code>break</code> 语句，它会导致立即退出循环，并且循环条件在下一次迭代开始之前不会被重新检查。</p>
</li>
<li><p>可以在 <code>do...while</code> 循环中使用 <code>continue</code> 语句来跳过循环的剩余部分并立即执行下一次迭代。</p>
</li>
<li><p><code>do...while</code> 循环通常用于需要至少执行一次循环体代码的情况，或者在循环体执行之前无法确定循环条件的情况下使用。</p>
</li>
</ul>
<ol>
<li><p><code>break</code> 语句：</p>
<ul>
<li><code>break</code> 语句用于立即终止当前所在的循环（例如 <code>for</code>、<code>while</code>、<code>do...while</code> 循环）或 <code>switch</code> 语句，并将控制转移到循环或 <code>switch</code> 语句后面的下一个语句。</li>
<li>使用 <code>break</code> 语句可提前退出循环，即使循环条件仍然为真。</li>
<li>在嵌套循环中，<code>break</code> 语句只会中断最内层的循环，并跳出该循环的代码块。</li>
<li><code>break</code> 语句通常用于跳出循环的情况，例如当达到特定条件时，不再需要执行循环的剩余代码。</li>
<li><code>break</code>语句记住一点就是终止当前循环，是这一层都跳掉了。</li>
</ul>
</li>
<li><p><code>continue</code> 语句：</p>
<ul>
<li><code>continue</code> 语句用于跳过循环体中剩余的代码，并立即开始下一次循环迭代。</li>
<li>当遇到 <code>continue</code> 语句时，循环会立即转到下一次迭代的开始处，而不执行循环体内 <code>continue</code> 语句之后的任何代码。</li>
<li><p><code>continue</code> 语句通常用于跳过特定迭代或条件下的代码执行，而不中断整个循环的执行。</p>
</li>
<li><p>在 <code>for</code>、<code>while</code> 和 <code>do...while</code> 循环中，<code>continue</code> 和 <code>break</code> 语句通常与条件语句一起使用，以便在特定条件满足时提前退出循环，或者跳过特定条件下的代码执行。</p>
</li>
<li><p>在 <code>switch</code> 语句中，<code>break</code> 语句用于退出 <code>switch</code> 语句块，防止执行下一个 <code>case</code> 标签后面的语句。</p>
</li>
<li><p><code>continue</code>就是跳出当前的循环一次，直接进入当前循环的下一次迭代。 </p>
</li>
</ul>
</li>
</ol>
<h2 id="Logic-Operations"><a href="#Logic-Operations" class="headerlink" title="Logic Operations"></a>Logic Operations</h2><p>Stream manipulator boolalpha (a sticky manipulator) </p>
<p>有一个要点就是<code>boolalpha</code></p>
<p><code>boolalpha</code> 是一个流操纵器，用于指定布尔表达式的输出格式。它使得布尔值 <code>true</code> 和 <code>false</code> 被输出为字符串 <code>&quot;true&quot;</code> 和 <code>&quot;false&quot;</code>，而不是默认的 <code>1</code> 和 <code>0</code>。它的作用是将布尔值转换为对应的文字形式，使输出更易读。</p>
<ol>
<li><p><strong>作用</strong>：</p>
<ul>
<li><code>boolalpha</code> 用于更改流的状态，以便布尔值按照文字形式输出。</li>
</ul>
</li>
<li><p><strong>用法</strong>：</p>
<ul>
<li>要激活 <code>boolalpha</code>，只需在流输出之前使用 <code>boolalpha</code> 操纵器。</li>
<li>可以通过插入 <code>std::boolalpha</code> 到 <code>std::cout</code> 或 <code>std::ostream</code> 对象中来激活 <code>boolalpha</code>。</li>
<li>可以通过插入 <code>std::noboolalpha</code> 来取消 <code>boolalpha</code> 的激活状态，使布尔值按照默认的数字形式输出。</li>
</ul>
</li>
<li><p><strong>示例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">    cout &lt;&lt; boolalpha &lt;&lt; value &lt;&lt; endl; <span class="comment">// 输出 &quot;true&quot;</span></span><br><span class="line">    cout &lt;&lt; noboolalpha &lt;&lt; value &lt;&lt; endl; <span class="comment">// 输出 &quot;1&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>注意事项</strong>：</p>
<ul>
<li><code>boolalpha</code> 是一个“粘性”操纵器，一旦激活，它会影响流中之后所有的布尔值输出，直到被取消激活。</li>
<li>在取消激活 <code>boolalpha</code> 后，后续的布尔值输出会恢复为默认的数字形式。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="Functions-and-an-Introduction-to-Recursion"><a href="#Functions-and-an-Introduction-to-Recursion" class="headerlink" title="Functions and an  Introduction to Recursion"></a><strong>Functions and an  Introduction to Recursion</strong></h2><p>C++ programs are typically written by combining new functions and classes you write with “prepackaged” functions and classes available in the C++ Standard Library. The C++ Standard Library provides a rich collection of functions. Functions allow you to modularize a program by separating its tasks into self-contained units. Functions you write are referred to as user-defined functions. The statements in function bodies are written only once, are reused from perhaps several locations in a program and are hidden from other functions.(C++ 程序通常是通过将您编写的新函数和类与 C++ 标准库中提供的“预打包”函数和类组合而成的。C++ 标准库提供了丰富的函数集合。函数允许您通过将其任务分解为自包含单元来模块化程序。您编写的函数被称为用户定义函数。函数体中的语句只需编写一次，可以从程序中的多个位置重用，并且对其他函数隐藏起来。)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User-defined function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is a user-defined function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">myFunction</span>(); <span class="comment">// Function call</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A function is invoked by a function call, and when the called function completes its task, it either returns a result or simply returns control to the caller. An analogy to this program structure is the hierarchical form of management (Figure 6.1). A boss (similar to the calling function) asks a worker (similar to the called function) to perform a task and report back (i.e., return) the results after completing the task. The boss function does not know how the worker function performs its designated tasks. The worker may also call other worker functions, unknown to the boss. This hiding of implementation details promotes good software engineering.</p>
<p>(函数通过函数调用进行调用，当被调用的函数完成其任务时，它要么返回一个结果，要么只是将控制返回给调用者。这种程序结构的类比是管理的分层形式（见图 6.1）。老板（类似于调用函数）要求工人（类似于被调用函数）执行一个任务，并在完成任务后报告（即返回）结果。老板函数不知道工人函数如何执行其指定的任务。工人还可以调用其他工人函数，老板不知道这些函数。)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// User-defined function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">workerFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Worker function performing a task&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Another user-defined function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bossFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Boss function assigning task&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">workerFunction</span>(); <span class="comment">// Call to another user-defined function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">bossFunction</span>(); <span class="comment">// Call to user-defined function</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sometimes functions are not members of a class. Called global functions. Function prototypes for global functions are placed in header files, so that the global functions can be reused in any program that includes the header file and that can link to the function’s object code.</p>
<p>(有时函数不是类的成员。它们被称为全局函数。全局函数的函数原型放在头文件中，以便全局函数可以在包含头文件的任何程序中重用，并且可以链接到函数的目标代码。)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Header file with function prototype</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MY_FUNCTIONS_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MY_FUNCTIONS_H</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myGlobalFunction</span><span class="params">()</span></span>; <span class="comment">// Function prototype for a global function</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementation file with function definition</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;my_functions.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition of the global function</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myGlobalFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is a global function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>&lt;cmath&gt;</code> header file provides a collection of functions that enable you to perform common mathematical calculations. All functions in the <code>&lt;cmath&gt;</code> header file are global functions—therefore, each is called simply by specifying the name of the function followed by parentheses containing the function’s arguments.</p>
<p>(<code>&lt;cmath&gt;</code> 头文件提供了一组函数，使您能够执行常见的数学计算。<code>&lt;cmath&gt;</code> 头文件中的所有函数都是全局函数，因此，可以通过简单指定函数名称后跟包含函数参数的括号来调用每个函数。)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> <span class="comment">// Include the &lt;cmath&gt; header file</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> x = <span class="number">4.0</span>;</span><br><span class="line">    <span class="type">double</span> result = <span class="built_in">sqrt</span>(x); <span class="comment">// Call to a global function from &lt;cmath&gt;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Square root of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Functions often require more than one piece of information to perform their tasks. Such functions have multiple parameters.</p>
<p>(函数通常需要多个信息来执行其任务。这样的函数具有多个参数。)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function with multiple parameters</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>, y = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> total = <span class="built_in">sum</span>(x, y); <span class="comment">// Call to a function with multiple parameters</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; total &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The compiler refers to the function prototype to check that calls to <code>sum</code> contain the correct number and types of arguments and that the types of the arguments are in the correct order. In addition, the compiler uses the prototype to ensure that the value returned by the function can be used correctly in the expression that called the function (e.g., a function call that returns <code>void</code> cannot be used as the right side of an assignment statement). Each argument must be consistent with the type of the corresponding parameter. If the arguments passed to a function do not match the types specified in the function’s prototype, the compiler attempts to convert the arguments to those types.</p>
<p>(编译器参考函数原型来检查对 <code>sum</code> 的调用是否包含正确数量和类型的参数，以及参数的类型是否按正确的顺序排列。此外，编译器使用函数原型来确保函数返回的值可以在调用函数的表达式中正确使用（例如，返回 <code>void</code> 的函数调用不能作为赋值语句的右侧）。每个参数必须与相应参数的类型一致。如果传递给函数的参数与函数原型中指定的类型不匹配，则编译器尝试将参数转换为这些类型。)</p>
<p>函数原型的一个重要特性是参数强制转换，强制将参数转换为参数声明中指定的适当类型。这些转换按照 C++ 的提升规则进行。提升规则指示如何在不丢失数据的情况下在类型之间进行转换。提升规则适用于包含两种或多种数据类型值的表达式，也称为混合类型表达式。混合类型表达式中每个值的类型将提升到表达式中的“最高”类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.5</span>;</span><br><span class="line">    <span class="type">double</span> result = a + b; <span class="comment">// Implicit type promotion</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当函数参数的类型与函数定义或原型中指定的参数类型不匹配时，也会发生提升。图 6.6 列出了算术数据类型，从“最高类型”到“最低类型”的顺序。将值转换为较低的基本类型可能导致不正确的值。因此，只有通过将值显式赋值给较低类型的变量或使用转换运算符，才能将值转换为较低的基本类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> b = <span class="number">3.5</span>;</span><br><span class="line">    <span class="type">int</span> result = a + b; <span class="comment">// Implicit type promotion (may lead to loss of data)</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++ 标准库被划分为许多部分，每个部分都有自己的头文件。头文件包含相关函数的函数原型，这些函数形成库的每个部分。头文件还包含各种类类型和函数的定义，以及这些函数所需的常量。头文件“指示”编译器如何与库和用户编写的组件进行交互。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> <span class="comment">// Standard input/output stream objects</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span> <span class="comment">// Mathematical functions</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// Standard general utilities library</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span> <span class="comment">// Date and time functions</span></span></span><br></pre></td></tr></table></figure>
<p>可以通过使用 C++ 标准库函数 rand 在计算机应用程序中引入机会元素。函数 rand 生成一个介于 0 和 RAND_MAX（在 <code>&lt;cstdlib&gt;</code>头文件中定义的符号常量）之间的无符号整数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// For rand function</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span> <span class="comment">// For time function</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>)); <span class="comment">// Seed the random number generator</span></span><br><span class="line">    <span class="type">int</span> randomNumber = <span class="built_in">rand</span>(); <span class="comment">// Generate a random number</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Random number: &quot;</span> &lt;&lt; randomNumber &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了在特定范围内产生随机数，可以使用以下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// For rand function</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span> <span class="comment">// For time function</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>)); <span class="comment">// Seed the random number generator</span></span><br><span class="line">    <span class="type">int</span> shiftingValue = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> scalingFactor = <span class="number">6</span>;</span><br><span class="line">    <span class="type">int</span> randomNumber = shiftingValue + <span class="built_in">rand</span>() % scalingFactor; <span class="comment">// Generate a random number in the range 1 to 6</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Random number: &quot;</span> &lt;&lt; randomNumber &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-中的枚举"><a href="#C-中的枚举" class="headerlink" title="C++ 中的枚举"></a>C++ 中的枚举</h3><h3 id="基本枚举"><a href="#基本枚举" class="headerlink" title="基本枚举"></a>基本枚举</h3><p>枚举（enumerations）是由用户定义的一组命名整型常量。它们通过为一组值赋予有意义的名称来提高代码的可读性和可维护性。</p>
<h3 id="基本枚举示例"><a href="#基本枚举示例" class="headerlink" title="基本枚举示例"></a>基本枚举示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Months</span> &#123;</span><br><span class="line">    JAN = <span class="number">1</span>, FEB, MAR, APR, MAY, JUN, JUL, AUG, SEP, OCT, NOV, DEC</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Months month = FEB;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Month: &quot;</span> &lt;&lt; month &lt;&lt; std::endl; <span class="comment">// 输出: Month: 2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，<code>Months</code> 是一个枚举，包含表示一年中月份的常量。第一个值 <code>JAN</code> 被显式设置为 1，其余常量自动递增，因此 <code>FEB</code> 为 2，<code>MAR</code> 为 3，依此类推。</p>
<h3 id="赋予自定义值"><a href="#赋予自定义值" class="headerlink" title="赋予自定义值"></a>赋予自定义值</h3><p>你可以为任意枚举常量赋予自定义整数值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">ErrorCodes</span> &#123;</span><br><span class="line">    SUCCESS = <span class="number">0</span>,</span><br><span class="line">    ERROR_NOT_FOUND = <span class="number">404</span>,</span><br><span class="line">    ERROR_ACCESS_DENIED = <span class="number">403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="作用域枚举（C-11）"><a href="#作用域枚举（C-11）" class="headerlink" title="作用域枚举（C++11）"></a>作用域枚举（C++11）</h3><p>未限定作用域的枚举存在一个缺点，即多个枚举可能包含相同的标识符，导致命名冲突。C++11 引入了作用域枚举来解决这个问题。作用域枚举使用 <code>enum class</code>（或 <code>enum struct</code>）语法声明。</p>
<h3 id="作用域枚举示例"><a href="#作用域枚举示例" class="headerlink" title="作用域枚举示例"></a>作用域枚举示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span> &#123;</span><br><span class="line">    CONTINUE,</span><br><span class="line">    WON,</span><br><span class="line">    LOST</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Status gameStatus = Status::CONTINUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (gameStatus == Status::CONTINUE) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Game is ongoing.&quot;</span> &lt;&lt; std::endl; <span class="comment">// 输出: Game is ongoing.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>Status::CONTINUE</code> 明确地将 <code>CONTINUE</code> 标识为 <code>Status</code> 枚举类中的常量，从而避免了与其他枚举的命名冲突。</p>
<h3 id="指定枚举常量的类型"><a href="#指定枚举常量的类型" class="headerlink" title="指定枚举常量的类型"></a>指定枚举常量的类型</h3><p>默认情况下，未限定作用域枚举的基础类型取决于其常量值，保证类型足够大以存储这些常量值。对于作用域枚举，默认的基础类型是 <code>int</code>。然而，C++11 允许明确指定枚举的基础类型。</p>
<h3 id="带指定类型的作用域枚举示例"><a href="#带指定类型的作用域枚举示例" class="headerlink" title="带指定类型的作用域枚举示例"></a>带指定类型的作用域枚举示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Status</span> : <span class="type">unsigned</span> <span class="type">int</span> &#123;</span><br><span class="line">    CONTINUE,</span><br><span class="line">    WON,</span><br><span class="line">    LOST</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Status gameStatus = Status::CONTINUE;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Game status: &quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(gameStatus) &lt;&lt; std::endl; <span class="comment">// 输出: Game status: 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>Status</code> 枚举类的基础类型被指定为 <code>unsigned int</code>，这意味着 <code>Status</code> 中的每个常量都将是 <code>unsigned int</code> 类型。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>C++ 中的枚举提供了一种定义一组命名整型常量的方法。未限定作用域的枚举可能会导致命名冲突，而 C++11 引入的作用域枚举解决了这个问题。作用域枚举要求使用其类型名和作用域解析运算符进行限定。此外，C++11 允许指定枚举常量的基础类型，从而更好地控制常量的大小和表示方式。</p>
<h3 id="带有混合类型表达式的枚举示例"><a href="#带有混合类型表达式的枚举示例" class="headerlink" title="带有混合类型表达式的枚举示例"></a>带有混合类型表达式的枚举示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum class</span> <span class="title class_">Color</span> : <span class="type">char</span> &#123; RED = <span class="string">&#x27;R&#x27;</span>, GREEN = <span class="string">&#x27;G&#x27;</span>, BLUE = <span class="string">&#x27;B&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Color myColor = Color::RED;</span><br><span class="line">    <span class="type">char</span> colorChar = <span class="built_in">static_cast</span>&lt;<span class="type">char</span>&gt;(myColor); <span class="comment">// 类型转换</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Color: &quot;</span> &lt;&lt; colorChar &lt;&lt; std::endl; <span class="comment">// 输出: Color: R</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>毫无疑问，random的随机性是不够强的，因此需要其他的随机数生成。</p>
<p>根据CERT的指导原则MSC30-CPP，函数<code>rand</code>不具有“良好的统计属性”，且可能是可预测的，这使得使用<code>rand</code>的程序安全性较差。为了解决这一问题，C++11提供了一个新的、更安全的随机数库，可以生成非确定性的随机数，适用于模拟和需要不可预测性的安全场景。新的随机数功能位于C++标准库的<code>&lt;random&gt;</code>头文件中。</p>
<h3 id="随机数生成的引擎和分布"><a href="#随机数生成的引擎和分布" class="headerlink" title="随机数生成的引擎和分布"></a>随机数生成的引擎和分布</h3><p>C++11提供了许多类来表示各种随机数生成引擎和分布，以根据程序中随机数的使用方式提供灵活性。</p>
<ul>
<li><strong>引擎（Engine）</strong>：实现随机数生成算法，生成伪随机数。</li>
<li><strong>分布（Distribution）</strong>：控制引擎生成的值的范围，这些值的类型（如<code>int</code>，<code>double</code>等）以及这些值的统计属性。</li>
</ul>
<p>例如，<code>uniform_int_distribution</code>可以在指定范围内均匀地分布伪随机整数。</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个使用C++11随机数库生成均匀分布的整数随机数的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span> <span class="comment">// 包含随机数库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>  <span class="comment">// 包含时间函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个随机数引擎</span></span><br><span class="line">    <span class="function">std::default_random_engine <span class="title">engine</span><span class="params">(<span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(std::time(<span class="number">0</span>)))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个均匀分布的随机数生成器，范围为1到6</span></span><br><span class="line">    <span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成并打印10个随机数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> random_number = <span class="built_in">distribution</span>(engine);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Random number: &quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>包含头文件</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>包含必要的头文件以使用随机数库和时间函数。</p>
</li>
<li><p><strong>创建随机数引擎</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::default_random_engine <span class="title">engine</span><span class="params">(<span class="keyword">static_cast</span>&lt;<span class="type">unsigned</span> <span class="type">int</span>&gt;(std::time(<span class="number">0</span>)))</span></span>;</span><br></pre></td></tr></table></figure>
<p>创建一个随机数引擎，使用当前时间作为种子，以确保每次运行程序时生成不同的随机数序列。</p>
</li>
<li><p><strong>定义均匀分布的随机数生成器</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">distribution</span><span class="params">(<span class="number">1</span>, <span class="number">6</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>定义一个生成1到6之间均匀分布整数的分布对象。</p>
</li>
<li><p><strong>生成并打印随机数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> random_number = <span class="built_in">distribution</span>(engine);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Random number: &quot;</span> &lt;&lt; random_number &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用分布对象生成10个随机数，并打印出来。</p>
</li>
</ol>
<h3 id="C-中的存储持续时间、作用域和链接"><a href="#C-中的存储持续时间、作用域和链接" class="headerlink" title="C++中的存储持续时间、作用域和链接"></a>C++中的存储持续时间、作用域和链接</h3><p>在C++中，每个标识符还有其他属性，包括存储持续时间、作用域和链接。C++提供了几个存储类说明符来确定变量的存储持续时间：<code>register</code>、<code>extern</code>、<code>mutable</code>和<code>static</code>。</p>
<h3 id="存储持续时间（Storage-Duration）"><a href="#存储持续时间（Storage-Duration）" class="headerlink" title="存储持续时间（Storage Duration）"></a>存储持续时间（Storage Duration）</h3><p>标识符的存储持续时间决定了该标识符在内存中存在的时间段。有些标识符存在时间较短，有些则会在程序的整个执行期间一直存在。C++中可以将存储类说明符分为四种存储持续时间：自动、静态、动态和线程。</p>
<h4 id="局部变量和自动存储持续时间（Local-Variables-and-Automatic-Storage-Duration）"><a href="#局部变量和自动存储持续时间（Local-Variables-and-Automatic-Storage-Duration）" class="headerlink" title="局部变量和自动存储持续时间（Local Variables and Automatic Storage Duration）"></a>局部变量和自动存储持续时间（Local Variables and Automatic Storage Duration）</h4><p>自动存储持续时间的变量包括：</p>
<ul>
<li>在函数中声明的局部变量</li>
<li>函数参数</li>
<li>使用<code>register</code>声明的局部变量或函数参数</li>
</ul>
<p>这些变量在程序执行进入其定义所在的代码块时被创建，在该代码块活动期间存在，并在程序退出该代码块时被销毁。自动变量仅存在于定义它们的函数体内的最近的花括号内，或者在函数参数的情况下存在于整个函数体内。局部变量默认具有自动存储持续时间。我们通常称具有自动存储持续时间的变量为自动变量。</p>
<h5 id="示例代码-1"><a href="#示例代码-1" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">automaticStorage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 自动变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Automatic variable a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">automaticStorage</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="寄存器变量（Register-Variables）"><a href="#寄存器变量（Register-Variables）" class="headerlink" title="寄存器变量（Register Variables）"></a>寄存器变量（Register Variables）</h4><p>在程序的机器语言版本中，数据通常会加载到寄存器中进行计算和其他处理。编译器可能会忽略寄存器声明。<code>register</code>关键字只能用于局部变量和函数参数。</p>
<h5 id="示例代码-2"><a href="#示例代码-2" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">registerStorage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> a = <span class="number">20</span>;  <span class="comment">// 寄存器变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Register variable a = &quot;</span> &lt;&lt; a &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">registerStorage</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="静态存储持续时间（Static-Storage-Duration）"><a href="#静态存储持续时间（Static-Storage-Duration）" class="headerlink" title="静态存储持续时间（Static Storage Duration）"></a>静态存储持续时间（Static Storage Duration）</h4><p>关键字<code>extern</code>和<code>static</code>用于声明具有静态存储持续时间的变量和函数。此类变量从程序开始执行时存在，直到程序终止。这样的变量在其声明被遇到时初始化一次。</p>
<h5 id="具有静态存储持续时间的标识符（Identifiers-with-Static-Storage-Duration）"><a href="#具有静态存储持续时间的标识符（Identifiers-with-Static-Storage-Duration）" class="headerlink" title="具有静态存储持续时间的标识符（Identifiers with Static Storage Duration）"></a>具有静态存储持续时间的标识符（Identifiers with Static Storage Duration）</h5><p>具有静态存储持续时间的标识符有两种类型：</p>
<ul>
<li>外部标识符（如全局变量和全局函数名）</li>
<li>使用存储类说明符<code>static</code>声明的局部变量</li>
</ul>
<h4 id="静态局部变量（static-Local-Variables）"><a href="#静态局部变量（static-Local-Variables）" class="headerlink" title="静态局部变量（static Local Variables）"></a>静态局部变量（static Local Variables）</h4><p>使用<code>static</code>声明的局部变量仍然只能在其声明所在的函数中访问，但与自动变量不同，静态局部变量在函数返回给调用者时保留其值。下次调用该函数时，静态局部变量包含上次执行函数完成时的值。</p>
<h5 id="示例代码-3"><a href="#示例代码-3" class="headerlink" title="示例代码"></a>示例代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">staticStorage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>;  <span class="comment">// 静态局部变量</span></span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Static variable count = &quot;</span> &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">staticStorage</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用域（Scope）"><a href="#作用域（Scope）" class="headerlink" title="作用域（Scope）"></a>作用域（Scope）</h3><p>标识符的作用域是指在程序中可以引用该标识符的区域。有些标识符可以在整个程序中引用，而另一些标识符只能在程序的某些部分引用。</p>
<p>作用域分为以下几种：</p>
<ul>
<li>块作用域（Block Scope）</li>
<li>函数作用域（Function Scope）</li>
<li>全局命名空间作用域（Global Namespace Scope）</li>
<li>函数原型作用域（Function-Prototype Scope）</li>
</ul>
<h3 id="块作用域（Block-Scope）"><a href="#块作用域（Block-Scope）" class="headerlink" title="块作用域（Block Scope）"></a>块作用域（Block Scope）</h3><p>在块内部声明的标识符具有块作用域。块作用域从标识符声明开始，到块的结束右花括号<code>&#125;</code>结束。局部变量和函数参数都具有块作用域。任何块都可以包含变量声明。当块嵌套时，如果外部块的标识符与内部块的标识符同名，外部块的标识符会被“隐藏”，直到内部块结束。内部块“看到”的是它自己的局部标识符值，而不是外部块的同名标识符值。</p>
<p>即使声明为静态的局部变量也具有块作用域，尽管它们从程序开始执行时就存在。存储持续时间不影响标识符的作用域。</p>
<h4 id="示例代码-4"><a href="#示例代码-4" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">blockScopeExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;  <span class="comment">// 外部块的局部变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outer block x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">20</span>;  <span class="comment">// 内部块的局部变量，隐藏外部块的x</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inner block x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Outer block x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;  <span class="comment">// 再次引用外部块的x</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">blockScopeExample</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数作用域（Function-Scope）"><a href="#函数作用域（Function-Scope）" class="headerlink" title="函数作用域（Function Scope）"></a>函数作用域（Function Scope）</h3><p>标签（标识符后跟一个冒号，例如<code>start:</code>或<code>switch</code>语句中的<code>case</code>标签）是唯一具有函数作用域的标识符。标签可以在它们出现的函数的任何地方使用，但不能在函数体外部引用。</p>
<h4 id="示例代码-5"><a href="#示例代码-5" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionScopeExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    start:</span><br><span class="line">    x++;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Label &#x27;start&#x27; x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">functionScopeExample</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="全局命名空间作用域（Global-Namespace-Scope）"><a href="#全局命名空间作用域（Global-Namespace-Scope）" class="headerlink" title="全局命名空间作用域（Global Namespace Scope）"></a>全局命名空间作用域（Global Namespace Scope）</h3><p>在任何函数或类外部声明的标识符具有全局命名空间作用域。全局变量、函数定义和放在函数外部的函数原型都具有全局命名空间作用域。</p>
<h4 id="示例代码-6"><a href="#示例代码-6" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">100</span>;  <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">globalNamespaceScopeExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Global variable globalVar = &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">globalNamespaceScopeExample</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数原型作用域（Function-Prototype-Scope）"><a href="#函数原型作用域（Function-Prototype-Scope）" class="headerlink" title="函数原型作用域（Function-Prototype Scope）"></a>函数原型作用域（Function-Prototype Scope）</h3><p>唯一具有函数原型作用域的标识符是函数原型参数列表中使用的标识符。</p>
<h4 id="示例代码-7"><a href="#示例代码-7" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionPrototypeScopeExample</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">functionPrototypeScopeExample</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionPrototypeScopeExample</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;  <span class="comment">// 参数x具有函数原型作用域</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Function parameter x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="作用域演示"><a href="#作用域演示" class="headerlink" title="作用域演示"></a>作用域演示</h3><p>下面的程序演示了全局变量、自动局部变量和静态局部变量的作用域问题。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">scopeDemonstration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 静态局部变量</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 自动局部变量</span></span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside function scopeDemonstration:\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Global variable: &quot;</span> &lt;&lt; globalVar &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Static local variable: &quot;</span> &lt;&lt; staticVar &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Automatic local variable: &quot;</span> &lt;&lt; localVar &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    globalVar++;</span><br><span class="line">    staticVar++;</span><br><span class="line">    localVar++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First call to scopeDemonstration:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">scopeDemonstration</span>();</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nSecond call to scopeDemonstration:\n&quot;</span>;</span><br><span class="line">    <span class="built_in">scopeDemonstration</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码解释-1"><a href="#代码解释-1" class="headerlink" title="代码解释"></a>代码解释</h3><ul>
<li><strong>全局变量</strong>：<code>globalVar</code>在整个程序执行期间都存在，并在两个函数调用中保持其值。</li>
<li><strong>静态局部变量</strong>：<code>staticVar</code>在第一次函数调用时初始化，并在函数返回后保留其值。第二次调用该函数时，它将保持第一次调用后的值。</li>
<li><strong>自动局部变量</strong>：<code>localVar</code>在每次函数调用时都会重新创建，并在函数返回后销毁。因此，它在每次调用时都重新初始化为3。</li>
</ul>
<h3 id="链接（Linkage）"><a href="#链接（Linkage）" class="headerlink" title="链接（Linkage）"></a>链接（Linkage）</h3><p>标识符的链接决定了它是否仅在声明它的源文件中可见，还是在编译并链接在一起的多个文件中可见。</p>
<p>标识符的链接有三种类型：</p>
<ol>
<li><strong>无链接（No Linkage）</strong>：标识符只能在声明它的作用域中使用。</li>
<li><strong>内部链接（Internal Linkage）</strong>：标识符在声明它的源文件中可见，但不能在其他源文件中访问。</li>
<li><strong>外部链接（External Linkage）</strong>：标识符可以在多个源文件中共享和使用。</li>
</ol>
<h3 id="链接类型的具体解释"><a href="#链接类型的具体解释" class="headerlink" title="链接类型的具体解释"></a>链接类型的具体解释</h3><h4 id="无链接（No-Linkage）"><a href="#无链接（No-Linkage）" class="headerlink" title="无链接（No Linkage）"></a>无链接（No Linkage）</h4><p>局部变量和函数参数具有无链接。它们只能在声明它们的块中使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">10</span>; <span class="comment">// localVar 具有无链接</span></span><br><span class="line">    <span class="comment">// localVar 只能在这个函数中使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内部链接（Internal-Linkage）"><a href="#内部链接（Internal-Linkage）" class="headerlink" title="内部链接（Internal Linkage）"></a>内部链接（Internal Linkage）</h4><p>通过在变量或函数前加上 <code>static</code> 关键字，可以将它们的链接类型设为内部链接。这意味着它们只能在声明它们的源文件中使用，不能在其他源文件中访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> internalVar = <span class="number">10</span>; <span class="comment">// internalVar 具有内部链接</span></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">internalFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个函数只能在 file1.cpp 中使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> internalVar; <span class="comment">// 错误，internalVar 只能在 file1.cpp 中使用</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">internalFunction</span>(); <span class="comment">// 错误，internalFunction 只能在 file1.cpp 中使用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="外部链接（External-Linkage）"><a href="#外部链接（External-Linkage）" class="headerlink" title="外部链接（External Linkage）"></a>外部链接（External Linkage）</h4><p>全局变量和函数默认具有外部链接。这意味着它们可以在多个源文件中共享和使用。通过使用 <code>extern</code> 关键字，我们可以在一个源文件中声明在另一个源文件中定义的变量或函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="type">int</span> externalVar = <span class="number">10</span>; <span class="comment">// externalVar 具有外部链接</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">externalFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个函数可以在其他源文件中使用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> externalVar; <span class="comment">// 声明 externalVar，它在 file1.cpp 中定义</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">externalFunction</span><span class="params">()</span></span>; <span class="comment">// 声明 externalFunction，它在 file1.cpp 中定义</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">anotherFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    externalVar = <span class="number">20</span>; <span class="comment">// 可以访问并修改 externalVar</span></span><br><span class="line">    <span class="built_in">externalFunction</span>(); <span class="comment">// 可以调用 externalFunction</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="链接类型的总结"><a href="#链接类型的总结" class="headerlink" title="链接类型的总结"></a>链接类型的总结</h3><ul>
<li><strong>无链接</strong>：标识符只能在声明它的块中使用（局部变量和函数参数）。</li>
<li><strong>内部链接</strong>：标识符只能在声明它的源文件中使用（通过 <code>static</code> 关键字）。</li>
<li><strong>外部链接</strong>：标识符可以在多个源文件中共享和使用（全局变量和函数默认具有外部链接，可以用 <code>extern</code> 声明）。</li>
</ul>
<h3 id="理解C-中的函数调用机制：函数调用栈"><a href="#理解C-中的函数调用机制：函数调用栈" class="headerlink" title="理解C++中的函数调用机制：函数调用栈"></a>理解C++中的函数调用机制：函数调用栈</h3><p>为了理解C++如何执行函数调用，我们需要首先了解一种数据结构，即栈（stack）。栈类似于一堆盘子，当一个盘子放在堆上时，它通常放在顶部——这称为“推入”（pushing）。同样，当一个盘子从堆上取出时，它通常从顶部取出——这称为“弹出”（popping）。栈是一种后进先出（LIFO, Last-In, First-Out）数据结构——最后推入的项是第一个弹出的项。</p>
<h3 id="函数调用栈（Function-Call-Stack）"><a href="#函数调用栈（Function-Call-Stack）" class="headerlink" title="函数调用栈（Function-Call Stack）"></a>函数调用栈（Function-Call Stack）</h3><p>函数调用栈（或程序执行栈）是计算机科学中一个非常重要的机制，支持函数调用/返回机制，并且支持每个被调用函数的自动变量的创建、维护和销毁。</p>
<h4 id="栈帧（Stack-Frames）"><a href="#栈帧（Stack-Frames）" class="headerlink" title="栈帧（Stack Frames）"></a>栈帧（Stack Frames）</h4><p>每个函数最终必须将控制返回给调用它的函数。每当一个函数调用另一个函数时，一个条目被推入函数调用栈。这个条目被称为栈帧或活动记录，包含被调用函数需要返回到调用函数的返回地址。</p>
<h4 id="自动变量和栈帧（Automatic-Variables-and-Stack-Frames）"><a href="#自动变量和栈帧（Automatic-Variables-and-Stack-Frames）" class="headerlink" title="自动变量和栈帧（Automatic Variables and Stack Frames）"></a>自动变量和栈帧（Automatic Variables and Stack Frames）</h4><p>当一个函数调用返回时，该函数调用的栈帧被弹出，控制转移到弹出的栈帧中的返回地址。</p>
<h4 id="栈溢出（Stack-Overflow）"><a href="#栈溢出（Stack-Overflow）" class="headerlink" title="栈溢出（Stack Overflow）"></a>栈溢出（Stack Overflow）</h4><p>计算机中的内存是有限的，所以只有一定量的内存可以用来在函数调用栈上存储活动记录。如果发生的函数调用超过了函数调用栈可以存储的活动记录的数量，就会发生一个称为栈溢出的致命错误。</p>
<h3 id="示例代码和解释"><a href="#示例代码和解释" class="headerlink" title="示例代码和解释"></a>示例代码和解释</h3><p>以下是一个简单的示例程序，展示了函数调用栈的工作原理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数原型</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">square</span>(a);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The square of &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="代码解释-2"><a href="#代码解释-2" class="headerlink" title="代码解释"></a>代码解释</h4><ol>
<li><p><strong>操作系统调用<code>main</code>函数</strong>：</p>
<ul>
<li><p>一个活动记录被推入栈，包含<code>main</code>的返回地址（R1）和自动变量<code>a</code>的内存。</p>
</li>
<li><p>此时，栈看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| R1 | a=10 |</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong><code>main</code>调用<code>square</code>函数</strong>：</p>
<ul>
<li><p>一个<code>square</code>的栈帧被推入栈，包含<code>square</code>的返回地址（R2）和自动变量<code>x</code>的内存。</p>
</li>
<li><p>栈现在看起来像这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">| R2 | x=10 |</span><br><span class="line">| R1 | a=10 |</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong><code>square</code>函数计算结果并返回</strong>：</p>
<ul>
<li><p><code>square</code>的栈帧被弹出栈，返回地址R2被使用以返回到<code>main</code>。</p>
</li>
<li><p>栈恢复为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">| R1 | a=10 |</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong><code>main</code>函数完成执行</strong>：</p>
<ul>
<li><code>main</code>的栈帧被弹出，控制返回给操作系统。</li>
</ul>
</li>
</ol>
<h3 id="C-函数与参数"><a href="#C-函数与参数" class="headerlink" title="C++ 函数与参数"></a>C++ 函数与参数</h3><h4 id="空参数列表"><a href="#空参数列表" class="headerlink" title="空参数列表"></a>空参数列表</h4><p>在 C++ 中，可以通过以下两种方式指定空参数列表：</p>
<ol>
<li>在括号中使用 <code>void</code>。</li>
<li>直接留空括号。</li>
</ol>
<p>这两种方式都表示该函数不接收任何参数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 void 作为参数列表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionWithVoid</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;使用 void 参数列表的函数\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空参数列表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">functionWithoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;空参数列表的函数\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">functionWithVoid</span>();</span><br><span class="line">    <span class="built_in">functionWithoutParams</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>内联函数通过建议编译器在每个调用点生成函数代码的副本来减少函数调用的开销。这可能会使程序变大，因为函数代码被重复了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 内联函数定义</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">cube</span><span class="params">(<span class="type">const</span> <span class="type">int</span> side)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> side * side * side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> sideLength = <span class="number">3</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;立方体的体积: &quot;</span> &lt;&lt; <span class="built_in">cube</span>(sideLength) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>const 关键字</strong>：在函数 <code>cube</code> 中，<code>const</code> 确保变量 <code>side</code> 在计算过程中不会被修改。</li>
</ul>
<h4 id="向函数传递参数"><a href="#向函数传递参数" class="headerlink" title="向函数传递参数"></a>向函数传递参数</h4><ol>
<li><p><strong>值传递</strong>：</p>
<ul>
<li>将参数的值复制一份传递给被调用函数。</li>
<li>对副本的修改不会影响调用者中的原始变量。</li>
</ul>
</li>
<li><p><strong>引用传递</strong>：</p>
<ul>
<li>调用者允许被调用函数直接访问和修改调用者的数据。</li>
<li>使用 <code>&amp;</code> 符号在函数原型和定义中指示引用传递。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 值传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyByValue</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">    number = <span class="number">10</span>; <span class="comment">// 不会影响原始变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用传递</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyByReference</span><span class="params">(<span class="type">int</span> &amp;number)</span> </span>&#123;</span><br><span class="line">    number = <span class="number">10</span>; <span class="comment">// 会影响原始变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> value = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">modifyByValue</span>(value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;经过 modifyByValue 后: &quot;</span> &lt;&lt; value &lt;&lt; std::endl; <span class="comment">// 输出: 5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">modifyByReference</span>(value);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;经过 modifyByReference 后: &quot;</span> &lt;&lt; value &lt;&lt; std::endl; <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数内作为别名的引用"><a href="#函数内作为别名的引用" class="headerlink" title="函数内作为别名的引用"></a>函数内作为别名的引用</h3><p>引用可以作为函数内其他变量的别名。引用在声明时必须初始化，且不能重新赋值为其他变量的别名。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> original = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> &amp;alias = original; <span class="comment">// alias 是 original 的引用</span></span><br><span class="line"></span><br><span class="line">    alias = <span class="number">20</span>; <span class="comment">// 修改 original</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original: &quot;</span> &lt;&lt; original &lt;&lt; std::endl; <span class="comment">// 输出: 20</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从函数返回引用"><a href="#从函数返回引用" class="headerlink" title="从函数返回引用"></a>从函数返回引用</h3><p>从函数返回引用可能是危险的，因为它可能会导致悬空引用（dangling reference），如果引用指向的是局部变量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险示例：返回局部变量的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">dangerousFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> localVar; <span class="comment">// 局部变量在函数返回后超出作用域</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全示例：返回静态变量的引用</span></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">safeFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> localVar = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> localVar; <span class="comment">// 静态变量在程序生命周期内一直存在</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> &amp;ref = <span class="built_in">safeFunction</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;安全引用: &quot;</span> &lt;&lt; ref &lt;&lt; std::endl; <span class="comment">// 输出: 10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>空参数列表</strong>：可以通过 <code>void</code> 或空括号来指定。</li>
<li><strong>内联函数</strong>：使用 <code>inline</code> 关键字减少函数调用开销。</li>
<li><strong>值传递</strong>：传递参数值的副本。</li>
<li><strong>引用传递</strong>：直接修改原始参数。</li>
<li><strong>函数内引用</strong>：必须初始化且不可重新赋值。</li>
<li><strong>返回引用</strong>：避免返回局部变量的引用，以防悬空引用。</li>
</ul>
<h3 id="默认参数和作用域解析运算符"><a href="#默认参数和作用域解析运算符" class="headerlink" title="默认参数和作用域解析运算符"></a>默认参数和作用域解析运算符</h3><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>在 C++ 中，可以为函数的某些参数指定默认值。这样，当函数调用省略这些参数时，编译器会自动使用默认值。这对于减少重复代码非常有用，特别是当多次调用函数时传递相同的参数值。</p>
<h5 id="使用默认参数的规则"><a href="#使用默认参数的规则" class="headerlink" title="使用默认参数的规则"></a>使用默认参数的规则</h5><ul>
<li>默认参数必须是参数列表中最右边（最后）的参数。</li>
<li>可以在函数声明或定义时指定默认参数，但不能同时在两处都指定。</li>
</ul>
<h5 id="示例：计算盒子的体积"><a href="#示例：计算盒子的体积" class="headerlink" title="示例：计算盒子的体积"></a>示例：计算盒子的体积</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明带有默认参数</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">boxVolume</span><span class="params">(<span class="type">double</span> length = <span class="number">1.0</span>, <span class="type">double</span> width = <span class="number">1.0</span>, <span class="type">double</span> height = <span class="number">1.0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用所有默认参数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;体积1: &quot;</span> &lt;&lt; <span class="built_in">boxVolume</span>() &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用一个默认参数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;体积2: &quot;</span> &lt;&lt; <span class="built_in">boxVolume</span>(<span class="number">2.0</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用两个默认参数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;体积3: &quot;</span> &lt;&lt; <span class="built_in">boxVolume</span>(<span class="number">2.0</span>, <span class="number">3.0</span>) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用所有参数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;体积4: &quot;</span> &lt;&lt; <span class="built_in">boxVolume</span>(<span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">boxVolume</span><span class="params">(<span class="type">double</span> length, <span class="type">double</span> width, <span class="type">double</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * width * height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">体积1: 1</span><br><span class="line">体积2: 2</span><br><span class="line">体积3: 6</span><br><span class="line">体积4: 24</span><br></pre></td></tr></table></figure>
<h4 id="作用域解析运算符"><a href="#作用域解析运算符" class="headerlink" title="作用域解析运算符"></a>作用域解析运算符</h4><p>在 C++ 中，可能会出现局部变量和全局变量同名的情况。此时，可以使用一元作用域解析运算符 <code>::</code> 来访问全局变量。</p>
<blockquote>
<p>这是一个陌生知识点，：：可以访问全局变量，在此之前并不知道。</p>
</blockquote>
<h5 id="使用-访问全局变量"><a href="#使用-访问全局变量" class="headerlink" title="使用 :: 访问全局变量"></a>使用 <code>::</code> 访问全局变量</h5><p>当局部变量和全局变量同名时，默认情况下局部变量会隐藏全局变量。使用 <code>::</code> 可以显式访问全局变量。</p>
<h5 id="示例：局部变量和全局变量同名"><a href="#示例：局部变量和全局变量同名" class="headerlink" title="示例：局部变量和全局变量同名"></a>示例：局部变量和全局变量同名</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useLocalVariable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">2</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;局部变量 x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;全局变量 x = &quot;</span> &lt;&lt; ::x &lt;&lt; std::endl; <span class="comment">// 使用 :: 访问全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;全局变量 x = &quot;</span> &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 默认访问全局变量</span></span><br><span class="line">    <span class="built_in">useLocalVariable</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">全局变量 x = 1</span><br><span class="line">局部变量 x = 2</span><br><span class="line">全局变量 x = 1</span><br></pre></td></tr></table></figure>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>默认参数</strong>：在函数调用省略参数时，编译器会使用默认值。默认参数必须是参数列表中的最后几个参数。</li>
<li><strong>作用域解析运算符 <code>::</code></strong>：用于在局部变量和全局变量同名时访问全局变量。</li>
</ul>
<h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><p>在 C++ 中，允许定义多个同名函数，只要它们的参数列表不同，这就是函数重载。函数重载允许创建一组函数，它们执行类似的任务，但操作的数据类型不同。</p>
<h4 id="如何区分重载函数"><a href="#如何区分重载函数" class="headerlink" title="如何区分重载函数"></a>如何区分重载函数</h4><p>重载函数通过它们的签名来区分。签名是函数名和参数类型（按顺序）的组合。编译器将每个函数标识符编码为其参数类型的组合，以便进行类型安全的链接。</p>
<h4 id="示例：使用函数重载计算平方"><a href="#示例：使用函数重载计算平方" class="headerlink" title="示例：使用函数重载计算平方"></a>示例：使用函数重载计算平方</h4><p>下面的示例展示了如何使用函数重载计算整数和浮点数的平方。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数：计算整数的平方</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">square</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;整数的平方：&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> num * num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载函数：计算浮点数的平方</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">square</span><span class="params">(<span class="type">double</span> num)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;浮点数的平方：&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> num * num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> intNum = <span class="number">5</span>;</span><br><span class="line">    <span class="type">double</span> doubleNum = <span class="number">3.5</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用重载函数计算整数的平方</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">square</span>(intNum) &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 调用重载函数计算浮点数的平方</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">square</span>(doubleNum) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">整数的平方：25</span><br><span class="line">浮点数的平方：12.25</span><br></pre></td></tr></table></figure>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>函数重载</strong>：允许定义多个同名函数，通过参数列表的不同来区分。</li>
<li><strong>重载函数的区分</strong>：编译器根据函数的参数类型来区分重载函数。</li>
</ul>
<p>函数重载使得代码更加灵活，可以根据不同的参数类型执行相似的操作。</p>
<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><p>如果程序逻辑和操作对于每种数据类型都是相同的，可以使用函数模板来更加紧凑和方便地进行重载。</p>
<h4 id="定义函数模板"><a href="#定义函数模板" class="headerlink" title="定义函数模板"></a>定义函数模板</h4><p>下面是一个定义最大值函数模板的示例，它确定三个值中的最大值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数模板定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">maximum</span><span class="params">(T x, T y, T z)</span> </span>&#123;</span><br><span class="line">    T max = x; <span class="comment">// 假设 x 为最大值</span></span><br><span class="line">    <span class="keyword">if</span> (y &gt; max) &#123;</span><br><span class="line">        max = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (z &gt; max) &#123;</span><br><span class="line">        max = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> intMax = <span class="built_in">maximum</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>); <span class="comment">// 调用函数模板，传入三个整数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最大整数值：&quot;</span> &lt;&lt; intMax &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> doubleMax = <span class="built_in">maximum</span>(<span class="number">3.5</span>, <span class="number">2.5</span>, <span class="number">4.5</span>); <span class="comment">// 调用函数模板，传入三个双精度浮点数</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最大浮点数值：&quot;</span> &lt;&lt; doubleMax &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> charMax = <span class="built_in">maximum</span>(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;b&#x27;</span>); <span class="comment">// 调用函数模板，传入三个字符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最大字符值：&quot;</span> &lt;&lt; charMax &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最大整数值：30</span><br><span class="line">最大浮点数值：4.5</span><br><span class="line">最大字符值：b</span><br></pre></td></tr></table></figure>
<h4 id="返回类型后置（这个也是一个未知知识点）"><a href="#返回类型后置（这个也是一个未知知识点）" class="headerlink" title="返回类型后置（这个也是一个未知知识点）"></a>返回类型后置（这个也是一个未知知识点）</h4><p>C++11 引入了返回类型后置语法，用于指定函数的返回类型。示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回类型后置的函数模板定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">maximum</span><span class="params">(T x, T y, T z)</span> -&gt; T </span>&#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主要是用于外部不知道参数究竟应该怎么进行计算，因此也不知道参数究竟应该怎么进行推导，所以需要直接拿到返回值，直接进行推导。不一定总是a+b这种可以直接相同的类型，可能会需要进行自动类型推导。</p>
</blockquote>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul>
<li><strong>函数模板</strong>：可以使用函数模板来定义一次性适用于多种数据类型的函数。</li>
<li><strong>返回类型后置</strong>：C++11 提供了返回类型后置的语法，使函数模板的返回类型更加灵活。</li>
</ul>
<p>函数模板使得代码更加通用和可重用，可以方便地处理不同类型的数据。</p>
<p>递归是一种函数调用自身的编程技巧，通常用于解决可以被分解为相同问题的子问题的情况。在递归过程中，问题被分解为更小的子问题，直到达到某个基本条件，然后逐级返回解决方案。下面是关于递归的详细说明以及一个计算阶乘的示例代码：</p>
<h3 id="递归的特点："><a href="#递归的特点：" class="headerlink" title="递归的特点："></a>递归的特点：</h3><ol>
<li><strong>调用自身</strong>：递归函数会在其定义中调用自身，以处理较小的子问题。</li>
<li><strong>基本条件</strong>：递归函数必须有一个基本条件，用于终止递归调用，防止无限循环。</li>
<li><strong>递归步骤</strong>：递归函数通过调用自身来解决更小的子问题，直到达到基本条件为止。</li>
</ol>
<h3 id="阶乘的递归定义："><a href="#阶乘的递归定义：" class="headerlink" title="阶乘的递归定义："></a>阶乘的递归定义：</h3><p>阶乘是一个典型的递归问题。正整数 n 的阶乘（表示为 n!）定义为从 1 到 n 的所有正整数的乘积。其递归定义如下：</p>
<ul>
<li>如果 n 为 0 或 1，则 n 的阶乘为 1。</li>
<li>否则，n 的阶乘为 n 乘以 (n-1) 的阶乘。</li>
</ul>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归计算阶乘</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">factorial</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本条件：n 为 0 或 1 时，阶乘为 1</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归步骤：n 的阶乘为 n 乘以 (n-1) 的阶乘</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> result = <span class="built_in">factorial</span>(n);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial of &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，我们定义了一个名为 <code>factorial</code> 的递归函数来计算给定正整数的阶乘。递归函数通过不断调用自身来解决较小的子问题，直到达到基本条件（n 为 0 或 1）为止，然后逐级返回解决方案。</p>
<p>迭代和递归都是基于控制语句的编程技巧。迭代使用重复结构，而递归使用选择结构。</p>
<ul>
<li>迭代和递归都涉及重复：迭代明确使用重复结构；递归通过重复调用函数实现重复。</li>
<li>迭代和递归都包含终止测试：迭代在循环继续条件失败时终止；递归在识别到基本情况时终止。</li>
<li>迭代和递归都逐渐接近终止：迭代通过修改计数器直到计数器取得使循环继续条件失败的值；递归通过产生原始问题的简化版本，直到达到基本情况。</li>
</ul>
<p>下面是计算阶乘问题的迭代解决方案示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 迭代计算阶乘</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title">factorial</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> result = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 从 1 到 n 逐个相乘</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">unsigned</span> <span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        result *= i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> result = <span class="built_in">factorial</span>(n);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Factorial of &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; is: &quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例代码中，我们使用迭代方式计算了给定正整数的阶乘。迭代通过循环从 1 到 n 逐个相乘，直到达到 n。与递归不同，迭代直接使用循环结构来完成这一过程，而不需要通过函数调用来实现重复。</p>
<hr>
<h2 id="Class-Templates-array-and-vector-Catching-Exceptions"><a href="#Class-Templates-array-and-vector-Catching-Exceptions" class="headerlink" title="Class Templates array and vector; Catching Exceptions"></a>Class Templates array and vector; Catching Exceptions</h2><h3 id="数据结构：std-array"><a href="#数据结构：std-array" class="headerlink" title="数据结构：std::array"></a>数据结构：std::array</h3><p><code>std::array</code> 是一个容器类，它封装了原始数组，使其具有更方便的接口和更多的功能。它的大小是固定的，且在编译时就确定了。<code>std::array</code> 是在 C++11 中引入的，位于头文件 <code>&lt;array&gt;</code> 中。</p>
<h4 id="定义和声明"><a href="#定义和声明" class="headerlink" title="定义和声明"></a>定义和声明</h4><p>要定义一个 <code>std::array</code>，你需要指定元素的类型和数组的大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::array&lt;<span class="type">int</span>, 5&gt; arr; <span class="comment">// 声明一个包含 5 个整数的 std::array</span></span><br></pre></td></tr></table></figure>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>可以使用列表初始化来初始化 <code>std::array</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h4><ul>
<li><strong>访问元素</strong>: 使用下标运算符 <code>[]</code> 或成员函数 <code>at()</code> 访问元素。<code>at()</code> 会进行边界检查。</li>
<li><strong>获取大小</strong>: 使用 <code>size()</code> 成员函数获取数组大小。</li>
<li><strong>填充</strong>: 使用 <code>fill()</code> 成员函数填充数组。</li>
</ul>
<h4 id="示例代码-8"><a href="#示例代码-8" class="headerlink" title="示例代码"></a>示例代码</h4><p>下面是几个使用 <code>std::array</code> 的示例，展示了其常见操作。</p>
<ol>
<li><strong>声明并初始化数组</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>使用 <code>at()</code> 访问元素</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element at index 2: &quot;</span> &lt;&lt; arr.<span class="built_in">at</span>(<span class="number">2</span>) &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 试图访问越界元素，会抛出 std::out_of_range 异常</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Element at index 10: &quot;</span> &lt;&lt; arr.<span class="built_in">at</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Out of range error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>填充数组</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 5&gt; arr;</span><br><span class="line">    arr.<span class="built_in">fill</span>(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>求和数组元素</strong></li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="type">int</span>, 4&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : arr) &#123;</span><br><span class="line">        sum += element;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sum of array elements: &quot;</span> &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="静态局部数组的初始化"><a href="#静态局部数组的初始化" class="headerlink" title="静态局部数组的初始化"></a>静态局部数组的初始化</h3><ol>
<li><p><strong>静态局部数组的声明和初始化</strong>：</p>
<ul>
<li>静态局部数组是在函数内声明的，但是它们在整个程序执行期间只初始化一次，并且在整个程序的生命周期内保持其值。</li>
<li>如果没有显式初始化，编译器会将静态局部数组的每个元素初始化为零。</li>
</ul>
</li>
<li><p><strong>首次遇到声明时初始化</strong>：</p>
<ul>
<li>当程序首次遇到静态局部数组的声明时，会进行初始化。之后每次进入该函数时，静态数组保持上一次的状态，而不会重新初始化。</li>
</ul>
</li>
<li><p><strong>零初始化</strong>：</p>
<ul>
<li>如果没有提供显式初始化器，静态局部数组的所有元素会被自动初始化为零。</li>
</ul>
</li>
</ol>
<h3 id="示例代码-9"><a href="#示例代码-9" class="headerlink" title="示例代码"></a>示例代码</h3><p>下面是一些示例代码，展示了静态局部数组的声明、初始化和使用。</p>
<h4 id="示例-1-静态局部数组的零初始化"><a href="#示例-1-静态局部数组的零初始化" class="headerlink" title="示例 1: 静态局部数组的零初始化"></a>示例 1: 静态局部数组的零初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printStaticArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> arr[<span class="number">5</span>]; <span class="comment">// 声明一个静态局部数组，但没有显式初始化</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printStaticArray</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>arr</code> 是一个静态局部数组。因为它没有显式初始化，所以编译器会将它的每个元素初始化为零。程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array elements: 0 0 0 0 0</span><br></pre></td></tr></table></figure>
<h4 id="示例-2-静态局部数组的显式初始化"><a href="#示例-2-静态局部数组的显式初始化" class="headerlink" title="示例 2: 静态局部数组的显式初始化"></a>示例 2: 静态局部数组的显式初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initializeAndPrintStaticArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;; <span class="comment">// 显式初始化前三个元素，其余元素自动初始化为零</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">initializeAndPrintStaticArray</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>arr</code> 的前三个元素显式初始化为 <code>1, 2, 3</code>，其余元素自动初始化为零。程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array elements: 1 2 3 0 0</span><br></pre></td></tr></table></figure>
<h4 id="示例-3-静态局部数组的值保持"><a href="#示例-3-静态局部数组的值保持" class="headerlink" title="示例 3: 静态局部数组的值保持"></a>示例 3: 静态局部数组的值保持</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modifyAndPrintStaticArray</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">    arr[<span class="number">0</span>] += <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">    arr[<span class="number">2</span>] += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Array elements: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">modifyAndPrintStaticArray</span>();</span><br><span class="line">    <span class="built_in">modifyAndPrintStaticArray</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>arr</code> 在第一次调用 <code>modifyAndPrintStaticArray</code> 时被修改，然后在第二次调用时保留了这些修改。程序输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array elements: 2 3 4 0 0</span><br><span class="line">Array elements: 3 4 5 0 0</span><br></pre></td></tr></table></figure>
<h3 id="范围基于范围的for语句和数组处理-Range-Based-for-Statement"><a href="#范围基于范围的for语句和数组处理-Range-Based-for-Statement" class="headerlink" title="范围基于范围的for语句和数组处理(Range-Based for Statement )"></a>范围基于范围的for语句和数组处理(<strong>Range-Based</strong> <strong>for</strong> <strong>Statement</strong> )</h3><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li><p><strong>范围基于for语句</strong>：</p>
<ul>
<li><p>C++11引入了范围基于for语句，使得迭代数组元素更简单且避免越界错误。</p>
</li>
<li><p>语法格式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ( rangeVariableDeclaration : expression )</span><br><span class="line">   statement</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>rangeVariableDeclaration</code> 包含类型和标识符，如 <code>int item</code>。</p>
</li>
<li><p><code>expression</code> 是要迭代的数组或容器。</p>
</li>
<li><p><code>rangeVariableDeclaration</code> 中的类型必须与数组元素的类型一致。</p>
</li>
</ul>
</li>
<li><p><strong>迭代和修改数组元素</strong>：</p>
<ul>
<li>可以使用范围基于for语句来显示数组内容或修改数组内容。</li>
<li>通过引用类型（如 <code>int&amp; itemRef</code>）可以修改数组元素值。</li>
</ul>
</li>
<li><p><strong>C++标准库容器支持</strong>：</p>
<ul>
<li>范围基于for语句可以用于C++标准库的大多数预构建数据结构（容器），如 <code>array</code> 和 <code>vector</code>。</li>
</ul>
</li>
<li><p><strong>当需要访问元素下标时</strong>：</p>
<ul>
<li>范围基于for语句不提供元素下标访问。如果需要下标，仍需使用计数器控制的for语句。</li>
</ul>
</li>
</ol>
<h4 id="示例代码-10"><a href="#示例代码-10" class="headerlink" title="示例代码"></a>示例代码</h4><h5 id="示例-1：使用范围基于for语句显示数组内容"><a href="#示例-1：使用范围基于for语句显示数组内容" class="headerlink" title="示例 1：使用范围基于for语句显示数组内容"></a>示例 1：使用范围基于for语句显示数组内容</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; items = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用范围基于for语句显示数组内容</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Array items: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> item : items) &#123;</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array items: 1 2 3 4 5</span><br></pre></td></tr></table></figure>
<h5 id="示例-2：使用范围基于for语句修改数组内容"><a href="#示例-2：使用范围基于for语句修改数组内容" class="headerlink" title="示例 2：使用范围基于for语句修改数组内容"></a>示例 2：使用范围基于for语句修改数组内容</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; items = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用范围基于for语句将每个元素乘以2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>&amp; itemRef : items) &#123;</span><br><span class="line">        itemRef *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示修改后的数组内容</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Modified array items: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> item : items) &#123;</span><br><span class="line">        cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Modified array items: 2 4 6 8 10</span><br></pre></td></tr></table></figure>
<h5 id="示例-3：使用下标访问数组元素"><a href="#示例-3：使用下标访问数组元素" class="headerlink" title="示例 3：使用下标访问数组元素"></a>示例 3：使用下标访问数组元素</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    array&lt;<span class="type">int</span>, 5&gt; items = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用计数器控制的for语句显示数组元素和它们的下标</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Array items with indices: &quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; items.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Index &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; items[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array items with indices: </span><br><span class="line">Index 0: 1</span><br><span class="line">Index 1: 2</span><br><span class="line">Index 2: 3</span><br><span class="line">Index 3: 4</span><br><span class="line">Index 4: 5</span><br></pre></td></tr></table></figure>
<h3 id="静态数据成员"><a href="#静态数据成员" class="headerlink" title="静态数据成员"></a>静态数据成员</h3><h4 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li><p><strong>静态数据成员</strong>：</p>
<ul>
<li>静态数据成员使用 <code>static</code> 关键字声明，表示它是类级别的成员，而不是对象级别的成员。</li>
<li>静态数据成员对类的所有对象共享，不会为每个对象单独存储一个副本。</li>
<li>可以在类定义和成员函数定义中像访问其他数据成员一样访问静态数据成员。</li>
</ul>
</li>
<li><p><strong>常量静态数据成员</strong>：</p>
<ul>
<li>使用 <code>const</code> 关键字将静态数据成员声明为常量，表示它的值在程序执行期间不会改变。</li>
<li>常量静态数据成员通常用于定义类常量，如数组大小等。</li>
</ul>
</li>
<li><p><strong>访问静态数据成员</strong>：</p>
<ul>
<li>可以通过类名和作用域解析运算符 <code>::</code> 访问公共静态数据成员，即使没有创建类的对象。</li>
<li>例如，<code>ClassName::staticMemberName</code>。</li>
</ul>
</li>
</ol>
<h4 id="示例代码-11"><a href="#示例代码-11" class="headerlink" title="示例代码"></a>示例代码</h4><h5 id="示例-1：静态常量数据成员"><a href="#示例-1：静态常量数据成员" class="headerlink" title="示例 1：静态常量数据成员"></a>示例 1：静态常量数据成员</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明静态常量数据成员</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> students = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">const</span> string&amp; name) : <span class="built_in">name</span>(name) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数，用于访问静态数据成员</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getStudentCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name; <span class="comment">// 学生姓名</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count; <span class="comment">// 静态数据成员，所有对象共享</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并初始化静态数据成员</span></span><br><span class="line"><span class="type">int</span> Student::count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total students: &quot;</span> &lt;&lt; Student::students &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Student <span class="title">s2</span><span class="params">(<span class="string">&quot;Bob&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Number of Student objects created: &quot;</span> &lt;&lt; Student::<span class="built_in">getStudentCount</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Total students: 30</span><br><span class="line">Number of Student objects created: 2</span><br></pre></td></tr></table></figure>
<h5 id="示例-2：公共静态数据成员的访问"><a href="#示例-2：公共静态数据成员的访问" class="headerlink" title="示例 2：公共静态数据成员的访问"></a>示例 2：公共静态数据成员的访问</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公共静态数据成员</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态成员函数，用于修改静态数据成员</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">setValue</span><span class="params">(<span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义并初始化静态数据成员</span></span><br><span class="line"><span class="type">int</span> Example::value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过类名访问静态数据成员</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Initial value: &quot;</span> &lt;&lt; Example::value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改静态数据成员</span></span><br><span class="line">    Example::<span class="built_in">setValue</span>(<span class="number">10</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Modified value: &quot;</span> &lt;&lt; Example::value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建对象并访问静态数据成员</span></span><br><span class="line">    Example e;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value accessed through object: &quot;</span> &lt;&lt; e.value &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Initial value: 0</span><br><span class="line">Modified value: 10</span><br><span class="line">Value accessed through object: 10</span><br></pre></td></tr></table></figure>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul>
<li>静态数据成员对于需要在所有对象之间共享的数据非常有用。</li>
<li>常量静态数据成员通常用于定义类常量。</li>
<li>静态数据成员可以通过类名和作用域解析运算符 <code>::</code> 访问，而无需创建类的对象。</li>
</ul>
<h3 id="使用C-标准库进行排序和二分查找"><a href="#使用C-标准库进行排序和二分查找" class="headerlink" title="使用C++标准库进行排序和二分查找"></a>使用C++标准库进行排序和二分查找</h3><h4 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li><p><strong>排序 (Sorting)</strong>：</p>
<ul>
<li>排序是将数据按升序或降序排列的过程，是计算中非常重要的应用之一。</li>
<li>C++标准库提供了 <code>std::sort</code> 函数，可以方便地对数组或容器中的元素进行排序。</li>
</ul>
</li>
<li><p><strong>搜索 (Searching)</strong>：</p>
<ul>
<li>搜索是确定数组中是否包含与某个键值匹配的值的过程。</li>
<li>二分查找 (binary search) 是一种高效的搜索算法，要求数据序列是有序的。</li>
<li>C++标准库提供了 <code>std::binary_search</code> 函数来进行二分查找。</li>
</ul>
</li>
<li><p><strong>std::sort</strong>：</p>
<ul>
<li>用于对元素进行排序。</li>
<li>语法：<code>std::sort(begin, end)</code>，其中 <code>begin</code> 和 <code>end</code> 是迭代器，表示要排序的范围。</li>
</ul>
</li>
<li><p><strong>std::binary_search</strong>：</p>
<ul>
<li>用于在有序范围内进行二分查找。</li>
<li>语法：<code>std::binary_search(begin, end, value)</code>，其中 <code>begin</code> 和 <code>end</code> 是迭代器，表示要搜索的范围，<code>value</code> 是要查找的值。</li>
<li>返回 <code>bool</code> 值，表示是否找到了该值。</li>
</ul>
</li>
</ol>
<h4 id="示例代码-12"><a href="#示例代码-12" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// 包含sort和binary_search</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span>     <span class="comment">// 包含array容器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>    <span class="comment">// 包含string类型</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义并初始化一个字符串数组</span></span><br><span class="line">    std::array&lt;std::string, 7&gt; colors = &#123;<span class="string">&quot;red&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;indigo&quot;</span>, <span class="string">&quot;violet&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示未排序的数组</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Unsorted array:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; color : colors) &#123;</span><br><span class="line">        std::cout &lt;&lt; color &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::sort对数组进行升序排序</span></span><br><span class="line">    std::<span class="built_in">sort</span>(colors.<span class="built_in">begin</span>(), colors.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示已排序的数组</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Sorted array:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; color : colors) &#123;</span><br><span class="line">        std::cout &lt;&lt; color &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用std::binary_search在数组中查找值</span></span><br><span class="line">    std::string searchKey1 = <span class="string">&quot;yellow&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> found1 = std::<span class="built_in">binary_search</span>(colors.<span class="built_in">begin</span>(), colors.<span class="built_in">end</span>(), searchKey1);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value \&quot;&quot;</span> &lt;&lt; searchKey1 &lt;&lt; <span class="string">&quot;\&quot; is &quot;</span> </span><br><span class="line">              &lt;&lt; (found1 ? <span class="string">&quot;found&quot;</span> : <span class="string">&quot;not found&quot;</span>) &lt;&lt; <span class="string">&quot; in the array.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次查找一个不同的值</span></span><br><span class="line">    std::string searchKey2 = <span class="string">&quot;purple&quot;</span>;</span><br><span class="line">    <span class="type">bool</span> found2 = std::<span class="built_in">binary_search</span>(colors.<span class="built_in">begin</span>(), colors.<span class="built_in">end</span>(), searchKey2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;The value \&quot;&quot;</span> &lt;&lt; searchKey2 &lt;&lt; <span class="string">&quot;\&quot; is &quot;</span> </span><br><span class="line">              &lt;&lt; (found2 ? <span class="string">&quot;found&quot;</span> : <span class="string">&quot;not found&quot;</span>) &lt;&lt; <span class="string">&quot; in the array.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>运行上述程序时，将输出以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Unsorted array:</span><br><span class="line">red orange yellow green blue indigo violet </span><br><span class="line">Sorted array:</span><br><span class="line">blue green indigo orange red violet yellow </span><br><span class="line">The value &quot;yellow&quot; is found in the array.</span><br><span class="line">The value &quot;purple&quot; is not found in the array.</span><br></pre></td></tr></table></figure>
<h3 id="使用二维数组表示表格数据"><a href="#使用二维数组表示表格数据" class="headerlink" title="使用二维数组表示表格数据"></a>使用二维数组表示表格数据</h3><h4 id="知识点-3"><a href="#知识点-3" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li><p><strong>二维数组 (Two-Dimensional Arrays)</strong>：</p>
<ul>
<li>二维数组用于表示表格数据，这些数据由按行和列排列的信息组成。</li>
<li>要标识特定的表格元素，必须指定两个下标——通常，第一个下标标识元素的行，第二个下标标识元素的列。</li>
<li>二维数组也被称为2-D数组，多维数组指的是具有两个或更多维度的数组。</li>
</ul>
</li>
<li><p><strong>二维数组的初始化</strong>：</p>
<ul>
<li>可以在声明时初始化二维数组。</li>
<li>元素的类型由数组的定义指定。例如：<code>array&lt;int, columns&gt;</code> 表示每个元素都是包含三个 <code>int</code> 值的数组，其中 <code>columns</code> 是常量，值为3。</li>
</ul>
</li>
<li><p><strong>嵌套的范围基于的for语句 (Nested Range-Based for Statements)</strong>：</p>
<ul>
<li>为了处理二维数组的元素，我们使用嵌套循环，其中外层循环遍历行，内层循环遍历给定行的列。</li>
<li>C++11引入的 <code>auto</code> 关键字可以让编译器根据变量的初始化值推断变量的数据类型。</li>
</ul>
</li>
<li><p><strong>嵌套的计数器控制的for语句 (Nested Counter-Controlled for Statements)</strong>：</p>
<ul>
<li>可以使用计数器控制的嵌套循环来实现二维数组的遍历。</li>
</ul>
</li>
</ol>
<h4 id="示例代码-13"><a href="#示例代码-13" class="headerlink" title="示例代码"></a>示例代码</h4><h5 id="使用-array-模板初始化二维数组"><a href="#使用-array-模板初始化二维数组" class="headerlink" title="使用 array 模板初始化二维数组"></a>使用 <code>array</code> 模板初始化二维数组</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化一个3x4的二维数组</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> rows = <span class="number">3</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> columns = <span class="number">4</span>;</span><br><span class="line">    std::array&lt;std::array&lt;<span class="type">int</span>, columns&gt;, rows&gt; a = &#123;&#123;</span><br><span class="line">        &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用嵌套的范围基于的for语句遍历二维数组</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using range-based for loop:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; row : a) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; element : row) &#123;</span><br><span class="line">            std::cout &lt;&lt; element &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用嵌套的计数器控制的for语句遍历二维数组</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nUsing counter-controlled for loop:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> row = <span class="number">0</span>; row &lt; a.<span class="built_in">size</span>(); ++row) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> column = <span class="number">0</span>; column &lt; a[row].<span class="built_in">size</span>(); ++column) &#123;</span><br><span class="line">            std::cout &lt;&lt; a[row][column] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h4><ol>
<li><p><strong>初始化二维数组</strong>：</p>
<ul>
<li>使用 <code>std::array</code> 模板初始化一个3x4的二维数组 <code>a</code>，其中包含整数值。</li>
</ul>
</li>
<li><p><strong>嵌套的范围基于的for语句</strong>：</p>
<ul>
<li>使用范围基于的for语句遍历二维数组，<code>auto</code> 关键字用于推断变量的数据类型。</li>
<li>外层循环遍历数组的每一行，内层循环遍历行中的每个元素。</li>
</ul>
</li>
<li><p><strong>嵌套的计数器控制的for语句</strong>：</p>
<ul>
<li>使用计数器控制的for语句遍历二维数组。</li>
<li>外层循环控制行索引，内层循环控制列索引，通过数组索引访问每个元素。</li>
</ul>
</li>
</ol>
<h4 id="进一步的应用"><a href="#进一步的应用" class="headerlink" title="进一步的应用"></a>进一步的应用</h4><p>假设在一个学期中，学生会参加多次考试，教授们可能希望分析整个学期的成绩，包括单个学生和整个班级的成绩。</p>
<h5 id="示例代码：存储学生成绩的二维数组"><a href="#示例代码：存储学生成绩的二维数组" class="headerlink" title="示例代码：存储学生成绩的二维数组"></a>示例代码：存储学生成绩的二维数组</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GradeBook</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> students = <span class="number">10</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">size_t</span> exams = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">GradeBook</span>(std::array&lt;std::array&lt;<span class="type">int</span>, exams&gt;, students&gt;&amp; gradesArray) : <span class="built_in">grades</span>(gradesArray) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayGrades</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;The grades are:\n&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> student = <span class="number">0</span>; student &lt; grades.<span class="built_in">size</span>(); ++student) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Student &quot;</span> &lt;&lt; student + <span class="number">1</span> &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> exam = <span class="number">0</span>; exam &lt; grades[student].<span class="built_in">size</span>(); ++exam) &#123;</span><br><span class="line">                std::cout &lt;&lt; grades[student][exam] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::array&lt;std::array&lt;<span class="type">int</span>, exams&gt;, students&gt; grades;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::array&lt;std::array&lt;<span class="type">int</span>, GradeBook::exams&gt;, GradeBook::students&gt; studentGrades = &#123;&#123;</span><br><span class="line">        &#123;<span class="number">87</span>, <span class="number">96</span>, <span class="number">70</span>&#125;,</span><br><span class="line">        &#123;<span class="number">68</span>, <span class="number">87</span>, <span class="number">90</span>&#125;,</span><br><span class="line">        &#123;<span class="number">94</span>, <span class="number">100</span>, <span class="number">90</span>&#125;,</span><br><span class="line">        &#123;<span class="number">100</span>, <span class="number">81</span>, <span class="number">82</span>&#125;,</span><br><span class="line">        &#123;<span class="number">83</span>, <span class="number">65</span>, <span class="number">85</span>&#125;,</span><br><span class="line">        &#123;<span class="number">78</span>, <span class="number">87</span>, <span class="number">65</span>&#125;,</span><br><span class="line">        &#123;<span class="number">85</span>, <span class="number">75</span>, <span class="number">83</span>&#125;,</span><br><span class="line">        &#123;<span class="number">91</span>, <span class="number">94</span>, <span class="number">100</span>&#125;,</span><br><span class="line">        &#123;<span class="number">76</span>, <span class="number">72</span>, <span class="number">84</span>&#125;,</span><br><span class="line">        &#123;<span class="number">87</span>, <span class="number">93</span>, <span class="number">73</span>&#125;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">GradeBook <span class="title">myGradeBook</span><span class="params">(studentGrades)</span></span>;</span><br><span class="line">    myGradeBook.<span class="built_in">displayGrades</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h4><ol>
<li><p><strong>定义和初始化二维数组</strong>：</p>
<ul>
<li><code>GradeBook</code> 类中包含一个静态常量数据成员 <code>students</code> 和 <code>exams</code>，分别表示学生人数和考试次数。</li>
<li>初始化一个包含10个学生和每个学生3次考试成绩的二维数组 <code>studentGrades</code>。</li>
</ul>
</li>
<li><p><strong>GradeBook 类</strong>：</p>
<ul>
<li>构造函数接受一个二维数组并初始化成员变量 <code>grades</code>。</li>
<li><code>displayGrades</code> 函数用于显示所有学生的成绩，使用嵌套的计数器控制的for语句遍历二维数组并输出每个学生的成绩。</li>
</ul>
</li>
</ol>
<h3 id="C-标准库模板类-vector"><a href="#C-标准库模板类-vector" class="headerlink" title="C++ 标准库模板类 vector"></a>C++ 标准库模板类 <code>vector</code></h3><h4 id="知识点-4"><a href="#知识点-4" class="headerlink" title="知识点"></a>知识点</h4><ol>
<li><p><strong><code>vector</code> 类模板</strong>：</p>
<ul>
<li><code>vector</code> 类模板与 <code>array</code> 类模板类似，但支持动态调整大小。</li>
<li>定义在头文件 <code>&lt;vector&gt;</code> 中，并属于 <code>std</code> 命名空间。</li>
</ul>
</li>
<li><p><strong>初始化和默认值</strong>：</p>
<ul>
<li>默认情况下，<code>vector</code> 对象的所有元素都设置为0。</li>
<li><code>vector</code> 可以定义来存储大多数数据类型。</li>
</ul>
</li>
<li><p><strong>获取元素数量</strong>：</p>
<ul>
<li>可以使用 <code>size</code> 成员函数获取 <code>vector</code> 中元素的数量。</li>
<li>也可以使用计数器控制的循环和下标 (<code>[]</code>) 操作符。</li>
</ul>
</li>
<li><p><strong>赋值操作</strong>：</p>
<ul>
<li>可以使用赋值 (<code>=</code>) 操作符与 <code>vector</code> 对象。</li>
<li>与数组一样，C++ 在使用方括号访问 <code>vector</code> 元素时不需要执行边界检查。</li>
<li><code>vector</code> 类模板提供成员函数 <code>at</code> 来执行边界检查，如果参数是无效的下标，会抛出异常。</li>
</ul>
</li>
<li><p><strong>异常处理</strong>：</p>
<ul>
<li>异常处理允许创建容错程序，解决执行期间出现的问题。</li>
<li>当函数检测到问题时，例如无效的数组下标或无效的参数，会抛出异常。</li>
<li>使用 <code>try</code> 语句包含可能抛出异常的代码，使用 <code>catch</code> 块处理异常。</li>
<li><code>vector</code> 的 <code>at</code> 成员函数提供边界检查，并在无效下标时抛出异常，默认情况下这会导致 C++ 程序终止。</li>
</ul>
</li>
<li><p><strong>动态调整大小</strong>：</p>
<ul>
<li><code>vector</code> 可以动态增长以容纳更多元素。</li>
<li>使用 <code>push_back</code> 成员函数向 <code>vector</code> 末尾添加新元素。</li>
</ul>
</li>
<li><p><strong>C++11 列表初始化</strong>：</p>
<ul>
<li>可以使用列表初始化器为 <code>vector</code>（以及其他 C++ 标准库数据结构）指定初始元素值。</li>
</ul>
</li>
</ol>
<h4 id="示例代码-14"><a href="#示例代码-14" class="headerlink" title="示例代码"></a>示例代码</h4><h5 id="使用-vector-的示例代码"><a href="#使用-vector-的示例代码" class="headerlink" title="使用 vector 的示例代码"></a>使用 <code>vector</code> 的示例代码</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span> <span class="comment">// For standard exception classes</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个包含10个整数的 vector</span></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">integers</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用范围基于的for循环显示 vector 的内容</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Initial vector contents:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : integers) &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改 vector 的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; integers.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">        integers[i] = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 显示修改后的 vector 内容</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified vector contents:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : integers) &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 at 成员函数进行边界检查</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Accessing element at position 20: &quot;</span>;</span><br><span class="line">        std::cout &lt;&lt; integers.<span class="built_in">at</span>(<span class="number">20</span>) &lt;&lt; std::endl; <span class="comment">// 这将抛出一个异常</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态调整 vector 的大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Current size of vector: &quot;</span> &lt;&lt; integers.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    integers.<span class="built_in">push_back</span>(<span class="number">1000</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;New size of vector: &quot;</span> &lt;&lt; integers.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vector contents after push_back:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : integers) &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 C++11 列表初始化 vector</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; anotherVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Another vector initialized with list initializer:\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; item : anotherVector) &#123;</span><br><span class="line">        std::cout &lt;&lt; item &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解释-2"><a href="#解释-2" class="headerlink" title="解释"></a>解释</h4><ol>
<li><p><strong>定义和初始化 <code>vector</code></strong>：</p>
<ul>
<li>定义一个包含10个整数的 <code>vector</code>，初始值为0。</li>
<li>使用范围基于的 <code>for</code> 循环遍历 <code>vector</code> 并显示其内容。</li>
</ul>
</li>
<li><p><strong>修改 <code>vector</code> 元素</strong>：</p>
<ul>
<li>使用下标访问和修改 <code>vector</code> 的元素。</li>
<li>显示修改后的 <code>vector</code> 内容。</li>
</ul>
</li>
<li><p><strong>边界检查和异常处理</strong>：</p>
<ul>
<li>使用 <code>at</code> 成员函数进行边界检查，并在尝试访问超出范围的元素时抛出异常。</li>
<li>使用 <code>try</code> 和 <code>catch</code> 块处理异常并输出异常信息。</li>
</ul>
</li>
<li><p><strong>动态调整 <code>vector</code> 的大小</strong>：</p>
<ul>
<li>显示 <code>vector</code> 的当前大小，使用 <code>push_back</code> 添加新元素，并显示新的大小和内容。</li>
</ul>
</li>
<li><p><strong>C++11 列表初始化</strong>：</p>
<ul>
<li>使用列表初始化器为另一个 <code>vector</code> 赋初始值，并显示其内容。</li>
</ul>
</li>
</ol>
<h3 id="指针的基础知识"><a href="#指针的基础知识" class="headerlink" title="指针的基础知识"></a>指针的基础知识</h3><h4 id="1-指针简介"><a href="#1-指针简介" class="headerlink" title="1. 指针简介"></a>1. <strong>指针简介</strong></h4><p>指针是C++中功能强大但使用起来具有挑战性的能力之一。指针可以包含变量的内存地址，通过指针可以间接引用该变量的值。正确和负责地使用指针是编程的重要技能之一。</p>
<h4 id="2-何时使用指针"><a href="#2-何时使用指针" class="headerlink" title="2. 何时使用指针"></a>2. <strong>何时使用指针</strong></h4><ul>
<li><strong>传递引用</strong>：指针使得传递引用（pass-by-reference）成为可能。</li>
<li><strong>动态数据结构</strong>：指针用于创建和操作可以动态增长和收缩的数据结构，如链表、队列、堆栈和树。</li>
</ul>
<h4 id="3-间接引用（Indirection）"><a href="#3-间接引用（Indirection）" class="headerlink" title="3. 间接引用（Indirection）"></a>3. <strong>间接引用（Indirection）</strong></h4><ul>
<li><strong>定义</strong>：间接引用是通过指针引用变量的值。指针包含变量的内存地址，通过这个地址可以访问变量的值。</li>
<li><strong>图示</strong>：通常用箭头表示指针，从包含地址的变量指向内存中该地址所在的变量。</li>
</ul>
<h4 id="4-空指针（Null-Pointers）"><a href="#4-空指针（Null-Pointers）" class="headerlink" title="4. 空指针（Null Pointers）"></a>4. <strong>空指针（Null Pointers）</strong></h4><ul>
<li><strong>C++11之前</strong>：空指针的值是0或NULL。NULL在几个标准库头文件中定义为0。</li>
<li><strong>初始化空指针</strong>：将指针初始化为NULL等价于将指针初始化为0。在C++11之前，约定使用0表示空指针。0是唯一可以直接赋值给指针变量的整数值，无需首先将整数转换为指针类型。</li>
</ul>
<h4 id="5-地址运算符（-amp-）"><a href="#5-地址运算符（-amp-）" class="headerlink" title="5. 地址运算符（&amp;）"></a>5. <strong>地址运算符（&amp;）</strong></h4><ul>
<li><p><strong>定义</strong>：地址运算符（&amp;）是一个一元运算符，用于获取其操作数的内存地址。</p>
</li>
<li><p><strong>示例声明</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> y = <span class="number">5</span>; <span class="comment">// 声明变量 y</span></span><br><span class="line"><span class="type">int</span> *yPtr = <span class="literal">nullptr</span>; <span class="comment">// 声明指针变量 yPtr</span></span><br><span class="line">yPtr = &amp;y; <span class="comment">// 将变量 y 的地址赋给指针变量 yPtr</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="示例代码-15"><a href="#示例代码-15" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="指针基础示例"><a href="#指针基础示例" class="headerlink" title="指针基础示例"></a>指针基础示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">5</span>;            <span class="comment">// 声明整型变量 y 并初始化为 5</span></span><br><span class="line">    <span class="type">int</span> *yPtr = <span class="literal">nullptr</span>;  <span class="comment">// 声明指针变量 yPtr 并初始化为 nullptr</span></span><br><span class="line"></span><br><span class="line">    yPtr = &amp;y;            <span class="comment">// 将变量 y 的地址赋给指针变量 yPtr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 y 的值和地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value of y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Address of y: &quot;</span> &lt;&lt; &amp;y &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用指针 yPtr 访问 y 的值和地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value pointed to by yPtr: &quot;</span> &lt;&lt; *yPtr &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Address stored in yPtr: &quot;</span> &lt;&lt; yPtr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="空指针示例"><a href="#空指针示例" class="headerlink" title="空指针示例"></a>空指针示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> *ptr = <span class="literal">nullptr</span>; <span class="comment">// 将指针变量初始化为 nullptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查指针是否为 nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr is a null pointer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr is not a null pointer&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="指针与数组的关系"><a href="#指针与数组的关系" class="headerlink" title="指针与数组的关系"></a>指针与数组的关系</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> numbers[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 声明并初始化数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用指针遍历数组</span></span><br><span class="line">    <span class="type">int</span> *ptr = numbers; <span class="comment">// 数组名本身是指向数组首元素的指针</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value of numbers[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]: &quot;</span> &lt;&lt; *(ptr + i) &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解释-3"><a href="#解释-3" class="headerlink" title="解释"></a>解释</h3><ol>
<li><p><strong>基本指针操作</strong>：</p>
<ul>
<li>通过地址运算符 <code>&amp;</code> 获取变量的内存地址。</li>
<li>通过指针访问和修改变量的值。</li>
</ul>
</li>
<li><p><strong>空指针</strong>：</p>
<ul>
<li>指针初始化为 <code>nullptr</code>。</li>
<li>使用条件语句检查指针是否为空。</li>
</ul>
</li>
<li><p><strong>指针与数组</strong>：</p>
<ul>
<li>数组名本身是指向数组首元素的指针。</li>
<li>使用指针遍历和访问数组元素。</li>
</ul>
</li>
</ol>
<h3 id="指针和地址运算符示例"><a href="#指针和地址运算符示例" class="headerlink" title="指针和地址运算符示例"></a>指针和地址运算符示例</h3><h4 id="间接引用运算符"><a href="#间接引用运算符" class="headerlink" title="间接引用运算符"></a><strong>间接引用运算符</strong></h4><ul>
<li><strong>定义</strong>：<code>*</code> 运算符，也称为间接引用或解引用运算符，用于返回指针操作数指向的对象的变量。</li>
<li><strong>解引用指针</strong>：称为对指针进行解引用，即获取指针指向的对象的值。</li>
<li><strong>左值</strong>：解引用指针后的结果可以作为赋值语句的左值使用。</li>
</ul>
<h4 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a><strong>示例程序</strong></h4><p>下面的示例程序演示了地址运算符 <code>&amp;</code> 和间接引用运算符 <code>*</code> 的使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> y = <span class="number">10</span>;         <span class="comment">// 声明并初始化整数变量 y</span></span><br><span class="line">    <span class="type">int</span> *yPtr = <span class="literal">nullptr</span>; <span class="comment">// 声明指针变量 yPtr 并初始化为 nullptr</span></span><br><span class="line"></span><br><span class="line">    yPtr = &amp;y;          <span class="comment">// 将变量 y 的地址赋给指针变量 yPtr</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Address of y: &quot;</span> &lt;&lt; &amp;y &lt;&lt; std::endl;  <span class="comment">// 输出变量 y 的地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value of yPtr: &quot;</span> &lt;&lt; yPtr &lt;&lt; std::endl; <span class="comment">// 输出指针变量 yPtr 存储的地址</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value pointed to by yPtr: &quot;</span> &lt;&lt; *yPtr &lt;&lt; std::endl; <span class="comment">// 输出指针变量 yPtr 指向的值</span></span><br><span class="line"></span><br><span class="line">    *yPtr = <span class="number">20</span>;         <span class="comment">// 使用指针 yPtr 修改变量 y 的值</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;New value of y: &quot;</span> &lt;&lt; y &lt;&lt; std::endl; <span class="comment">// 输出修改后的变量 y 的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="解释-4"><a href="#解释-4" class="headerlink" title="解释"></a>解释</h4><ol>
<li><p><strong>基本概念</strong>：</p>
<ul>
<li>展示了整数变量 <code>y</code> 和指针变量 <code>yPtr</code> 的内存地址。</li>
<li>介绍了地址运算符 <code>&amp;</code> 和间接引用运算符 <code>*</code> 的概念。</li>
</ul>
</li>
<li><p><strong>示例程序</strong>：</p>
<ul>
<li>使用地址运算符 <code>&amp;</code> 获取变量的地址，并将其赋给指针变量。</li>
<li>使用间接引用运算符 <code>*</code> 解引用指针，获取其指向的变量的值。</li>
<li>示例程序还展示了如何修改指针指向的变量的值。</li>
</ul>
</li>
</ol>
<h3 id="指针传递的引用传递"><a href="#指针传递的引用传递" class="headerlink" title="指针传递的引用传递"></a>指针传递的引用传递</h3><h4 id="1-引言"><a href="#1-引言" class="headerlink" title="1. 引言"></a>1. <strong>引言</strong></h4><p>在C++中，有三种方式可以将参数传递给函数：按值传递、按引用传递（使用引用参数）和按引用传递（使用指针参数）。这里我们解释使用指针参数的引用传递。</p>
<h4 id="2-引用传递示例"><a href="#2-引用传递示例" class="headerlink" title="2. 引用传递示例"></a>2. <strong>引用传递示例</strong></h4><ul>
<li><strong>引用传递的基本概念</strong>：指针和引用一样，可以用于修改调用者的一个或多个变量，或者将指向大型数据对象的指针传递给函数，以避免通过值传递这些对象所带来的开销。</li>
<li><strong>通过指针进行引用传递</strong>：当调用需要修改的参数的函数时，传递该参数的地址。函数内部使用间接引用操作符 (*) 来访问该地址处的值，从而实现引用传递。</li>
</ul>
<h4 id="3-示例代码"><a href="#3-示例代码" class="headerlink" title="3. 示例代码"></a>3. <strong>示例代码</strong></h4><p>下面是一个使用指针参数进行引用传递的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function prototype</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cubeByReference</span><span class="params">(<span class="type">int</span> *nPtr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Original value of number: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pass the address of number to the function</span></span><br><span class="line">    <span class="built_in">cubeByReference</span>(&amp;number);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;New value of number after cubeByReference: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function definition to cube a number by reference</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cubeByReference</span><span class="params">(<span class="type">int</span> *nPtr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Dereference the pointer and cube the value</span></span><br><span class="line">    *nPtr = *nPtr * *nPtr * *nPtr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内置数组"><a href="#内置数组" class="headerlink" title="内置数组"></a>内置数组</h3><h4 id="1-声明内置数组"><a href="#1-声明内置数组" class="headerlink" title="1. 声明内置数组"></a>1. 声明内置数组</h4><ul>
<li>使用以下形式的声明来指定元素的类型和所需的元素数量：<code>type arrayName[arraySize];</code></li>
<li>编译器会为数组保留适当数量的内存空间。</li>
<li><code>arraySize</code> 必须是大于零的整数常量。</li>
</ul>
<h4 id="2-访问内置数组的元素"><a href="#2-访问内置数组的元素" class="headerlink" title="2. 访问内置数组的元素"></a>2. 访问内置数组的元素</h4><ul>
<li>与数组对象一样，使用下标（<code>[]</code>）运算符来访问内置数组的各个元素。</li>
</ul>
<h4 id="3-初始化内置数组"><a href="#3-初始化内置数组" class="headerlink" title="3. 初始化内置数组"></a>3. 初始化内置数组</h4><ul>
<li>可以使用初始化器列表来初始化内置数组的元素。</li>
<li>如果提供的初始化器数量少于数组元素的数量，则剩余元素会进行值初始化。</li>
<li>如果提供的初始化器数量多于数组元素的数量，则会引发编译错误。</li>
</ul>
<h4 id="4-内置数组的参数传递"><a href="#4-内置数组的参数传递" class="headerlink" title="4. 内置数组的参数传递"></a>4. 内置数组的参数传递</h4><ul>
<li>内置数组的名称的值隐式转换为内置数组第一个元素的地址。</li>
<li>在将内置数组传递给函数时，不需要取内置数组的地址（<code>&amp;</code>）—只需传递内置数组的名称。</li>
<li>对于内置数组，被调用的函数可以修改调用者的所有元素，除非函数在相应的内置数组参数前面加上 <code>const</code>，以指示不应修改元素。</li>
</ul>
<h4 id="5-声明内置数组参数"><a href="#5-声明内置数组参数" class="headerlink" title="5. 声明内置数组参数"></a>5. 声明内置数组参数</h4><ul>
<li><p>可以在函数头中声明内置数组参数，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumElements</span><span class="params">(<span class="type">const</span> <span class="type">int</span> values[], <span class="type">const</span> <span class="type">size_t</span> numberOfElements)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这表明函数的第一个参数应该是一个一维的 <code>int</code> 类型的内置数组，并且该函数不应该修改这个数组。</p>
</li>
</ul>
<h4 id="6-C-11：标准库函数-begin-和-end"><a href="#6-C-11：标准库函数-begin-和-end" class="headerlink" title="6. C++11：标准库函数 begin 和 end"></a>6. C++11：标准库函数 <code>begin</code> 和 <code>end</code></h4><ul>
<li>C++11 引入了 <code>begin</code> 和 <code>end</code> 函数（在头文件 <code>&lt;iterator&gt;</code> 中），用于返回指向内置数组开头和结尾的指针。</li>
<li>这些函数可用于指定要在标准库函数（如 <code>sort</code>）中处理的元素范围。</li>
</ul>
<h4 id="7-内置数组的局限性"><a href="#7-内置数组的局限性" class="headerlink" title="7. 内置数组的局限性"></a>7. 内置数组的局限性</h4><ul>
<li>内置数组有一些限制：<ul>
<li>不能使用关系和相等运算符进行比较，必须使用循环逐个比较数组元素。</li>
<li>不能相互赋值。</li>
<li>无法确定自己的大小，通常需要将数组的名称和大小一起作为参数传递给处理数组的函数。</li>
<li>不提供自动边界检查，必须确保数组访问表达式中的下标在数组的边界内。</li>
</ul>
</li>
</ul>
<p>使用类模板 <code>array</code> 和 <code>vector</code> 的对象比内置数组更安全、更健壮，并提供更多的功能。</p>
<h3 id="最小权限原则"><a href="#最小权限原则" class="headerlink" title="最小权限原则"></a>最小权限原则</h3><p>最小权限原则建议给予函数访问其所需数据的最低权限，同时限制对不必要数据的访问。这有助于确保更好的封装性，减少潜在错误，并提高代码的可维护性。</p>
<h3 id="向函数传递指针的四种方式"><a href="#向函数传递指针的四种方式" class="headerlink" title="向函数传递指针的四种方式"></a>向函数传递指针的四种方式</h3><ol>
<li><p><strong>非常量指针指向非常量数据</strong>：这提供了最高级别的访问权限。指针可以修改其指向的数据和其自身持有的地址。示例：<code>int *ptr</code>。</p>
</li>
<li><p><strong>非常量指针指向常量数据</strong>：指针可以被修改以指向不同的数据，但它所指向的数据不能通过指针进行修改。示例：<code>const int *ptr</code>。</p>
</li>
<li><p><strong>常量指针指向非常量数据</strong>：指针始终指向相同的内存位置，但该位置的数据可以通过指针进行修改。示例：<code>int *const ptr</code>。</p>
</li>
<li><p><strong>常量指针指向常量数据</strong>：这提供了最低级别的访问权限。指针始终指向相同的内存位置，且该位置的数据不能通过指针进行修改。示例：<code>const int *const ptr</code>。</p>
</li>
</ol>
<h3 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h3><ul>
<li><p><strong>非常量指针指向常量数据</strong>：尝试通过非常量指针访问常量数据，编译器报错示例。</p>
</li>
<li><p><strong>常量指针指向非常量数据</strong>：尝试修改常量指针的数据，导致编译器报错。</p>
</li>
<li><p><strong>常量指针指向常量数据</strong>：尝试修改常量指针指向的数据和地址，编译器报错示例。</p>
</li>
</ul>
<h3 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a><code>sizeof</code> 运算符</h3><p><code>sizeof</code> 运算符在程序编译期间确定内置数组或任何其他数据类型、变量或常量的字节大小。</p>
<ol>
<li><p><strong>对内置数组的大小计算</strong>：当应用于内置数组的名称时，<code>sizeof</code> 运算符返回内置数组中的总字节数，返回类型为 <code>size_t</code>。</p>
</li>
<li><p><strong>在函数参数中应用于指针参数</strong>：当应用于接收内置数组作为参数的函数中的指针参数时，<code>sizeof</code> 运算符返回指针的大小（以字节为单位），而不是内置数组的大小。</p>
</li>
</ol>
<h3 id="计算内置数组的元素数量"><a href="#计算内置数组的元素数量" class="headerlink" title="计算内置数组的元素数量"></a>计算内置数组的元素数量</h3><p>要确定内置数组 <code>numbers</code> 中的元素数量，可以使用以下表达式（在编译时计算）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span> numbers / <span class="built_in">sizeof</span>(numbers[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
<p>该表达式将内置数组 <code>numbers</code> 中的字节数除以第一个元素的字节数，从而得到元素的数量。</p>
<h3 id="示例代码-16"><a href="#示例代码-16" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> numbers[<span class="number">10</span>];</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of numbers array: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(numbers) &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of elements in numbers array: &quot;</span></span><br><span class="line">              &lt;&lt; <span class="built_in">sizeof</span>(numbers) / <span class="built_in">sizeof</span>(numbers[<span class="number">0</span>]) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of int: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of char: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">char</span>) &lt;&lt; <span class="string">&quot; byte\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of double: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">double</span>) &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of float: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">float</span>) &lt;&lt; <span class="string">&quot; bytes\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of bool: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">bool</span>) &lt;&lt; <span class="string">&quot; byte\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="示例输出"><a href="#示例输出" class="headerlink" title="示例输出"></a>示例输出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Size of numbers array: 40 bytes</span><br><span class="line">Number of elements in numbers array: 10</span><br><span class="line">Size of int: 4 bytes</span><br><span class="line">Size of char: 1 byte</span><br><span class="line">Size of double: 8 bytes</span><br><span class="line">Size of float: 4 bytes</span><br><span class="line">Size of bool: 1 byte</span><br></pre></td></tr></table></figure>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>sizeof</code> 运算符可应用于任何表达式或类型名称。</li>
<li>如果 <code>sizeof</code> 应用于变量名（而不是内置数组的名称）或其他表达式，则返回用于存储表达式特定类型的字节数。</li>
<li><code>sizeof</code> 运算符的括号仅在其操作数是类型名时是必需的。（唯一一个不太懂的点，只有在操作数是类型名时候括号是必须的）</li>
</ul>
<h3 id="指针算术运算"><a href="#指针算术运算" class="headerlink" title="指针算术运算"></a>指针算术运算</h3><p>指针是有效的操作数，可用于算术表达式、赋值表达式和比较表达式。C++允许进行指针算术，即对指针进行几种算术操作：</p>
<ol>
<li><strong>增加和减少操作</strong>：指针可以通过 <code>++</code> 和 <code>--</code> 运算符进行递增和递减。</li>
<li><strong>指针与整数相加或相减</strong>：可以将整数加到指针上（<code>+</code> 或 <code>+=</code>），或从指针中减去整数（<code>-</code> 或 <code>-=</code>）。</li>
<li><strong>赋值操作</strong>：可以将一个指针赋值给另一个指针。</li>
<li><strong>比较操作</strong>：可以使用等号和关系运算符对指针进行比较。</li>
</ol>
<p>指针算术只有在指针指向内置数组时才有意义。</p>
<h3 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h3><p>假设已经声明了 <code>int v[5]</code>，并且其第一个元素位于内存位置3000。假设指针 <code>vPtr</code> 已初始化为指向 <code>v[0]</code>（即 <code>vPtr</code> 的值为3000）。</p>
<ol>
<li><p><code>vPtr</code> 可以通过以下任一语句初始化为指向 <code>v</code> 的指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *vPtr = v;</span><br><span class="line"><span class="type">int</span> *vPtr = &amp;v[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将整数添加到指针或从指针中减去整数</strong>：</p>
<ul>
<li>在常规算术中，加法 <code>3000 + 2</code> 的结果是3002。但在指针算术中，当整数添加到或从指针中减去时，指针不是简单地增加或减去该整数，而是增加或减去指针所指对象的大小乘以该整数。</li>
<li>例如，语句 <code>vPtr += 2;</code> 将产生3008（从计算结果3000 + 2 * 4），假设一个 int 在四个字节的内存中存储。在内置数组 <code>v</code> 中，<code>vPtr</code> 现在将指向 <code>v[2]</code>。</li>
</ul>
</li>
<li><p><strong>指针相减</strong>：</p>
<ul>
<li>指向同一内置数组的指针变量可以相互减去。例如，如果 <code>vPtr</code> 包含地址3000，<code>v2Ptr</code> 包含地址3008，则语句 <code>x = v2Ptr - vPtr;</code> 将为 <code>x</code> 赋值为从 <code>vPtr</code> 到 <code>v2Ptr</code> 的内置数组元素数量，此处为2。</li>
</ul>
</li>
</ol>
<h3 id="指针赋值和void-指针"><a href="#指针赋值和void-指针" class="headerlink" title="指针赋值和void*指针"></a>指针赋值和<code>void*</code>指针</h3><h4 id="指针赋值"><a href="#指针赋值" class="headerlink" title="指针赋值"></a>指针赋值</h4><p>在C++中，可以将一个指针直接赋值给另一个相同类型的指针，而不需要进行显式的类型转换。这可以确保类型的一致性，并使代码更加清晰易读。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> *ptr1 = &amp;x;</span><br><span class="line"><span class="type">int</span> *ptr2 = ptr1; <span class="comment">// 可以直接将ptr1的值赋给ptr2</span></span><br></pre></td></tr></table></figure>
<h4 id="强制转换操作符"><a href="#强制转换操作符" class="headerlink" title="强制转换操作符"></a>强制转换操作符</h4><p>但是，如果要将一个指针赋值给另一个不同类型的指针，就需要使用强制转换操作符。其中最常见的是 <code>reinterpret_cast</code>。这种情况下，需要确保类型转换是安全的，因为这种转换可能会导致未定义的行为或者错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> y = <span class="number">5.5</span>;</span><br><span class="line"><span class="type">double</span> *ptr3 = &amp;y;</span><br><span class="line"><span class="type">int</span> *ptr4 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(ptr3); <span class="comment">// 将double*转换为int*</span></span><br></pre></td></tr></table></figure>
<h4 id="指向void的指针"><a href="#指向void的指针" class="headerlink" title="指向void的指针"></a>指向<code>void</code>的指针</h4><p>指向 <code>void</code> 的指针（<code>void*</code>）是一种特殊的指针类型，它可以指向任何类型的数据。这使得它非常灵活，特别是在与函数接口和动态内存分配等方面的使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> z = <span class="number">20</span>;</span><br><span class="line"><span class="type">void</span> *ptr5 = &amp;z; <span class="comment">// 将int*指针赋给void*指针，无需转换</span></span><br></pre></td></tr></table></figure>
<h4 id="示例说明-1"><a href="#示例说明-1" class="headerlink" title="示例说明"></a>示例说明</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 直接赋值</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> *ptr1 = &amp;x;</span><br><span class="line">    <span class="type">int</span> *ptr2 = ptr1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 强制转换</span></span><br><span class="line">    <span class="type">double</span> y = <span class="number">5.5</span>;</span><br><span class="line">    <span class="type">double</span> *ptr3 = &amp;y;</span><br><span class="line">    <span class="type">int</span> *ptr4 = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(ptr3);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// void*指针</span></span><br><span class="line">    <span class="type">int</span> z = <span class="number">20</span>;</span><br><span class="line">    <span class="type">void</span> *ptr5 = &amp;z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>使用指针赋值时，确保类型一致，避免产生未定义的行为。</li>
<li>使用强制转换时，需要慎重考虑类型转换的安全性。</li>
<li><code>void*</code>指针是一种通用的指针类型，可以指向任何数据类型的地址。</li>
</ul>
<p>一些更加深层次的考虑：<br>当然可以！在这里，我将深入探讨指针赋值和<code>void*</code>指针的更多细节和用途。</p>
<h3 id="指针赋值的更多考虑"><a href="#指针赋值的更多考虑" class="headerlink" title="指针赋值的更多考虑"></a>指针赋值的更多考虑</h3><h4 id="指针赋值的安全性"><a href="#指针赋值的安全性" class="headerlink" title="指针赋值的安全性"></a>指针赋值的安全性</h4><p>在进行指针赋值时，需要确保源指针和目标指针的生命周期和作用域是符合预期的。如果源指针在目标指针之后被销毁，目标指针可能会指向无效的内存地址，导致未定义的行为。因此，确保源指针的有效性至关重要。</p>
<h4 id="指针赋值的语义"><a href="#指针赋值的语义" class="headerlink" title="指针赋值的语义"></a>指针赋值的语义</h4><p>指针赋值不仅仅是将一个指针的值复制给另一个指针，还涉及到指针所指向的内存区域。如果源指针和目标指针指向相同的内存区域，那么它们将共享同一块内存，并且对其中的数据的修改将会影响到另一个指针。这可能会导致意外的副作用，因此需要谨慎使用指针赋值。</p>
<h3 id="void-指针的更多用途"><a href="#void-指针的更多用途" class="headerlink" title="void*指针的更多用途"></a><code>void*</code>指针的更多用途</h3><h4 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h4><p><code>void*</code>指针是C和C++中一种常用的技术，用于实现泛型编程。通过使用<code>void*</code>指针，可以编写与特定数据类型无关的通用代码，这样的代码可以处理各种类型的数据。</p>
<h3 id="指针比较"><a href="#指针比较" class="headerlink" title="指针比较"></a>指针比较</h3><ul>
<li>可以使用等号和关系运算符来比较指针。</li>
<li>使用关系运算符进行比较时，除非指针指向同一内置数组的元素，否则比较无意义。</li>
<li>指针比较比较指针中存储的地址。</li>
<li>指针比较的常见用法是确定指针是否具有值 <code>nullptr</code>、0 或 <code>NULL</code>（即指针不指向任何东西）。</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> v[<span class="number">5</span>];</span><br><span class="line">    <span class="type">int</span> *vPtr = v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pointer arithmetic</span></span><br><span class="line">    vPtr += <span class="number">2</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;vPtr now points to v[2], address: &quot;</span> &lt;&lt; vPtr &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pointer subtraction</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *v2Ptr = vPtr + <span class="number">2</span>;</span><br><span class="line">    x = v2Ptr - vPtr;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of elements between vPtr and v2Ptr: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pointer assignment</span></span><br><span class="line">    <span class="type">int</span> *ptr1 = v;</span><br><span class="line">    <span class="type">int</span> *ptr2 = <span class="literal">nullptr</span>;</span><br><span class="line">    ptr2 = ptr1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pointer comparison</span></span><br><span class="line">    <span class="keyword">if</span> (ptr1 == ptr2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;ptr1 and ptr2 point to the same location.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>指针算术仅在指向内置数组时才有意义。</li>
<li>要小心指针的解引用，确保不会访问无效内存地址。</li>
</ul>
<p>指针可以用于执行任何涉及数组下标的操作。假设有以下声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建5个元素的int数组b；b是一个const指针</span></span><br><span class="line"><span class="type">int</span> b[<span class="number">5</span>];</span><br><span class="line"><span class="comment">// 创建int指针bPtr，它不是一个const指针</span></span><br><span class="line"><span class="type">int</span> *bPtr;</span><br></pre></td></tr></table></figure>
<p>我们可以用如下语句将bPtr设置为指向内置数组b的第一个元素的地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将内置数组b的地址赋给bPtr</span></span><br><span class="line">bPtr = b;</span><br></pre></td></tr></table></figure>
<p>这相当于将第一个元素的地址赋值给bPtr的另一种方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同样将内置数组b的地址赋给bPtr</span></span><br><span class="line">bPtr = &amp;b[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>指针/偏移表示法</p>
<p>可以用指针表达式 <code>*(bPtr + 3)</code> 来引用内置数组元素 b[3]。这里的 3 是指针的偏移量。这种表示法被称为指针/偏移表示法。括号是必需的，因为 * 的优先级高于 +。</p>
<p>同样，内置数组元素的地址 <code>&amp;b[3]</code> 可以用指针表达式 <code>bPtr + 3</code> 来表示。</p>
<p>使用内置数组的名称作为指针的偏移表示法</p>
<p>内置数组名称可以被视为指针，并用于指针算术运算。例如，表达式 <code>*(b + 3)</code> 也引用了元素 b[3]。通常来说，所有带有下标的内置数组表达式都可以用指针和偏移量来写。</p>
<p>指针/下标表示法</p>
<p>指针可以像内置数组一样进行下标操作。例如，表达式 <code>bPtr[1]</code> 引用了 b[1]；这种表达方式使用了指针/下标表示法。</p>
<h3 id="C字符串。"><a href="#C字符串。" class="headerlink" title="C字符串。"></a>C字符串。</h3><ul>
<li><p><strong>字符和字符常量</strong>：字符是C++源程序的基本构建块。字符常量是以单引号表示的整数值。字符常量的值是机器字符集中字符的整数值。</p>
</li>
<li><p><strong>字符串</strong>：字符串是一系列字符，被视为单个单元。可以包括字母、数字和各种特殊字符，如+、-、*、/和$。在C++中，字符串文字或字符串常量用双引号括起来。</p>
</li>
<li><p><strong>基于指针的字符串</strong>：基于指针的字符串是以空字符(‘\0’)结尾的字符数组。通过指向其第一个字符的指针来访问字符串。字符串文字的sizeof是字符串的长度，包括终止空字符。</p>
</li>
<li><p><strong>字符常量作为初始化器</strong>：当声明一个包含字符串的字符数组时，字符数组必须足够大，以存储字符串及其终止空字符。</p>
</li>
<li><p><strong>访问C字符串中的字符</strong>：由于C字符串是一个字符数组，因此可以直接使用数组下标表示法访问字符串中的单个字符。</p>
</li>
<li><p><strong>使用cin读取char类型的内置数组中的字符串</strong>：可以使用cin的流提取运算符将字符串读入char类型的内置数组中。setw流操作符可用于确保读入到word中的字符串不超过内置数组的大小。</p>
</li>
<li><p><strong>使用cin.getline读取char类型的内置数组中的文本行</strong>：在某些情况下，希望将整行文本输入到char类型的内置数组中。为此，cin对象提供了成员函数getline，它接受三个参数：将存储文本行的char类型的内置数组、长度和分隔符字符。当遇到分隔符字符’\n’、输入结束符或已读取的字符数少于第二个参数中指定的长度减一时，该函数停止读取字符。cin.getline的第三个参数有’\n’作为默认值。</p>
</li>
<li><p><strong>显示C字符串</strong>：用表示以空字符终止的字符串的char类型的内置数组可以用cout和&lt;&lt;输出。直到遇到终止空字符为止，字符都会被输出；终止空字符不会显示。cin和cout假定char类型的内置数组应被处理为以空字符终止的字符串；cin和cout不为其他类型的char类型的内置数组提供类似的输入和输出处理能力。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 字符串常量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* str = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串常量：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串数组</span></span><br><span class="line">    <span class="type">char</span> text[] = <span class="string">&quot;C strings&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;字符串数组：&quot;</span> &lt;&lt; text &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问单个字符</span></span><br><span class="line">    <span class="type">char</span> ch = text[<span class="number">2</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第三个字符是：&quot;</span> &lt;&lt; ch &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用cin读取字符串</span></span><br><span class="line">    <span class="type">char</span> word[<span class="number">20</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一个单词：&quot;</span>;</span><br><span class="line">    cin &gt;&gt; <span class="built_in">setw</span>(<span class="number">20</span>) &gt;&gt; word;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你输入的单词是：&quot;</span> &lt;&lt; word &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用cin.getline读取整行文本</span></span><br><span class="line">    <span class="type">char</span> line[<span class="number">100</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入一行文本：&quot;</span>;</span><br><span class="line">    cin.<span class="built_in">ignore</span>(); <span class="comment">// 清除输入缓冲区</span></span><br><span class="line">    cin.<span class="built_in">getline</span>(line, <span class="number">100</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;你输入的文本是：&quot;</span> &lt;&lt; line &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Classes-A-Deeper-Look-Throwing-Exceptions"><a href="#Classes-A-Deeper-Look-Throwing-Exceptions" class="headerlink" title="Classes: A Deeper Look; Throwing Exceptions"></a>Classes: A Deeper Look; Throwing Exceptions</h2><p>这一章主要就是对类比较深入的剖析了。</p>
<h3 id="防止头文件被重复包含"><a href="#防止头文件被重复包含" class="headerlink" title="防止头文件被重复包含"></a>防止头文件被重复包含</h3><p>这是第一个知识点，经常在写头文件的时候加上</p>
<p><strong>1. 包含保护的目的：</strong></p>
<ul>
<li>包含保护防止头文件在同一编译单元中被多次包含，避免由于重复定义而产生错误。</li>
</ul>
<p><strong>2. 语法：</strong></p>
<ul>
<li>包含保护通常由三个指令组成：<code>#ifndef</code>、<code>#define</code> 和 <code>#endif</code>。</li>
<li><code>#ifndef</code>：检查特定标识符是否未被定义。</li>
<li><code>#define</code>：定义标识符以防止后续包含头文件。</li>
<li><code>#endif</code>：关闭条件包含块。</li>
</ul>
<p><strong>3. 示例实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> TIME_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 头文件内容放在这里</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// TIME_H</span></span></span><br></pre></td></tr></table></figure>
<p><strong>4. 工作原理：</strong></p>
<ul>
<li>当头文件首次包含在编译单元中时，<code>TIME_H</code> 标识符未定义。</li>
<li>因此，预处理器使用 <code>#define</code> 定义 <code>TIME_H</code>。</li>
<li>然后包含头文件内容。</li>
<li>如果相同的头文件再次在同一编译单元中被包含，<code>#ifndef</code> 指令检查是否已经定义了 <code>TIME_H</code>。</li>
<li>由于 <code>TIME_H</code> 已经定义，预处理器跳过头文件内容的包含。</li>
</ul>
<p><strong>5. 好处和重要性：</strong></p>
<ul>
<li>防止多次定义类、函数或对象，从而避免多次包含头文件可能导致的问题。</li>
<li>仅处理声明一次，提高编译效率。</li>
<li>确保在不同编译单元中具有一致的行为。</li>
</ul>
<p><strong>6. 最佳实践：</strong></p>
<ul>
<li>对于包含保护，始终使用唯一标识符，通常派生自头文件名。</li>
<li>确保命名约定一致，以避免冲突和混淆。</li>
<li>将包含保护放置在每个头文件的开头和结尾。</li>
</ul>
<p><strong>7. 高级考虑：</strong></p>
<ul>
<li>现代编译器通常支持 <code>#pragma once</code> 指令，它更有效地实现了相同的目的。</li>
<li><code>#pragma once</code> 并未标准化，但被主要编译器广泛支持。</li>
</ul>
<p>一个比较坑的点：</p>
<blockquote>
<p>在C++11之前，只有静态常量整型(static const int)数据成员可以在类主体中声明时进行初始化。这是因为C++03标准不允许对其他类型的数据成员在类主体中进行初始化。这意味着对于其他类型的数据成员（例如非静态数据成员），必须在类的构造函数中进行初始化，否则它们将保持未初始化状态。这对于类的设计和实现可能带来一些不便，特别是在需要在不同构造函数中使用相同的初始化值时。</p>
<p>C++11引入了一种新的特性，即类内初始值设定符（in-class initializer）。这使得我们可以在类的定义中对任何数据成员进行初始化，而不仅限于静态常量整型数据成员。这意味着我们可以直接在类主体中为非静态数据成员提供初始值，而无需依赖构造函数。这种特性的引入提高了代码的可读性和简洁性，使得类的定义更加直观和简单。</p>
<p>使用类内初始值设定符可以让我们更方便地初始化数据成员，并且可以确保对象在创建时具有合适的初始状态。这在实践中提高了代码的可维护性和可靠性，减少了错误的可能性。因此，尽管在C++11之前，我们必须使用构造函数来初始化非静态数据成员，但引入了类内初始值设定符后，我们可以更灵活地进行类的设计和实现。</p>
<p>流操纵符<code>setfill</code>用于指定在将整数输出到宽度大于值的数字字段时显示的填充字符。默认情况下，填充字符会显示在数字的左侧，因为数字是右对齐的——对于左对齐的值，填充字符将显示在右侧。</p>
<p>如果要输出的数字填满了指定的字段，填充字符将不会显示。一旦使用<code>setfill</code>指定了填充字符，它将应用于所有后续在比正在显示的值宽的字段中显示的值。</p>
<p>这种机制允许在输出中对数字进行格式化，并确保它们在字段中对齐。例如，可以使用<code>setfill</code>来填充数字左侧的空白，以确保数字在字段中右对齐。此外，一旦使用了<code>setfill</code>，它将适用于后续的所有输出，直到另一个<code>setfill</code>指令修改了填充字符。这种灵活性使得在输出中实现各种格式化效果变得更加简单和方便。<br>因此说他是sticky的</p>
<p>至于setw则是非粘性的</p>
</blockquote>
<h3 id="定义类外部的成员函数；类作用域"><a href="#定义类外部的成员函数；类作用域" class="headerlink" title="定义类外部的成员函数；类作用域"></a><strong>定义类外部的成员函数；类作用域</strong></h3><p><strong>1. 成员函数的定义</strong></p>
<p>成员函数可以在类内部进行声明，并且在类外部进行定义。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span></span>; <span class="comment">// 在类内声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在类外定义</span></span><br><span class="line">    <span class="comment">// 函数体实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 类作用域</strong></p>
<p>无论成员函数是在类内部定义还是在外部定义，它们都属于类的作用域。这意味着在函数体内可以直接访问类的成员变量和其他成员函数，无需使用任何限定符。</p>
<p><strong>3. 内联展开</strong></p>
<p>如果成员函数是在类内部进行定义，编译器会尝试进行内联展开。内联展开是一种优化技术，它会将函数的代码直接插入到调用处，而不是通过函数调用的方式执行。这样可以减少函数调用的开销，提高程序的执行效率。内联展开的效果取决于编译器和函数的复杂性，因此并不是所有函数都会被内联展开。</p>
<p><strong>4. 示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span></span>; <span class="comment">// 在类内声明</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类外定义成员函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyClass::myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside myFunction&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    obj.<span class="built_in">myFunction</span>(); <span class="comment">// 调用成员函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，<code>myFunction()</code> 被定义在类外部，但它仍然属于 <code>MyClass</code> 类的作用域。在 <code>main()</code> 函数中，我们创建了一个 <code>MyClass</code> 对象 <code>obj</code> 并调用了 <code>myFunction()</code>。</p>
<h3 id="对象大小"><a href="#对象大小" class="headerlink" title="对象大小"></a><strong>对象大小</strong></h3><p>初学面向对象编程的人常常认为对象的大小会很大，因为它们包含了数据成员和成员函数。</p>
<p><strong>逻辑上的大小</strong></p>
<p>从逻辑上讲，这种观点是正确的。我们可以将对象视为包含数据和函数的集合体，这样的观点也在一定程度上得到了鼓励。一个对象的大小确实包括了所有的数据成员和函数成员所占用的空间。</p>
<p><strong>物理上的大小</strong></p>
<p>然而，从物理上来看，这种观点并不完全正确。事实上，在大多数编译器中，对象的大小主要取决于其数据成员的大小和对齐方式，而与成员函数无关。成员函数的代码并不直接存储在对象中，而是存储在类的代码段中，所有对象共享这些函数的代码。</p>
<p><strong>对象的内存布局</strong></p>
<p>一个对象的内存布局通常包括：</p>
<ol>
<li><strong>数据成员</strong>：按照声明的顺序依次存储在内存中。</li>
<li><strong>虚函数表指针（如果有虚函数）</strong>：用于实现多态性，指向对象所属类的虚函数表。</li>
<li><strong>其他的额外信息</strong>：如对齐字节等。</li>
</ol>
<p><strong>示例</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside myFunction&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of MyClass object: &quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(obj) &lt;&lt; <span class="string">&quot; bytes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，虽然 <code>MyClass</code> 包含了一个数据成员 <code>data</code> 和一个成员函数 <code>myFunction</code>，但对象 <code>obj</code> 的大小主要取决于数据成员 <code>data</code> 的大小和对齐方式，而与成员函数 <code>myFunction</code> 无关。</p>
<p>一些更加深入的细节</p>
<blockquote>
<ol>
<li><p><strong>对齐方式</strong>：在某些情况下，编译器会根据平台的要求对数据成员进行对齐，以提高访问速度和效率。这可能会导致对象的大小超出数据成员本身所占用的空间。对齐方式可以通过编译器选项进行调整。</p>
</li>
<li><p><strong>空类的大小</strong>：即使一个类没有任何数据成员，它的大小也不是零。这是因为每个对象都需要一些空间来存储对象的地址，以便在程序中能够引用它。此外，编译器可能会为了对齐而在对象的尾部添加一些额外的填充字节。</p>
</li>
<li><p><strong>虚函数和多态性</strong>：如果一个类包含虚函数，那么它的对象在内存中通常会包含一个指向虚函数表的指针。这个指针的大小与平台有关，通常是一个指针的大小。</p>
</li>
<li><p><strong>继承和派生类</strong>：派生类的对象的大小会包括它继承的基类部分和自身新增的数据成员。此外，如果派生类重写了基类的虚函数，它的虚函数表指针可能会指向自己的虚函数表，导致额外的内存开销。</p>
</li>
<li><p><strong>内存布局的优化</strong>：一些编译器可能会对内存布局进行优化，以减小对象的大小。例如，通过调整数据成员的顺序或使用紧凑的数据类型，可以减少填充字节的数量，从而减小对象的总大小。</p>
</li>
</ol>
</blockquote>
<h3 id="Class-Scope-and-Block-Scope"><a href="#Class-Scope-and-Block-Scope" class="headerlink" title="Class Scope and Block Scope:"></a>Class Scope and Block Scope:</h3><ul>
<li>类的数据成员和成员函数属于该类的作用域。</li>
<li>非成员函数默认在全局命名空间作用域内定义。</li>
<li>在类的作用域内，类成员可以直接被所有该类的成员函数访问，并且可以通过名称引用。</li>
<li>在类的作用域外，公共类成员通过对象的某种句柄进行引用—对象名、对象的引用或对象的指针。</li>
</ul>
<h3 id="Dot-and-Arrow-gt-Member-Selection-Operators"><a href="#Dot-and-Arrow-gt-Member-Selection-Operators" class="headerlink" title="Dot (.) and Arrow (-&gt;) Member Selection Operators:"></a>Dot (.) and Arrow (-&gt;) Member Selection Operators:</h3><ul>
<li>点号成员选择运算符 (.) 前面跟着对象的名称或对象的引用，用于访问对象的成员。</li>
<li>箭头成员选择运算符 (-&gt;) 前面跟着对象的指针，用于访问对象的成员。</li>
</ul>
<h3 id="Accessing-public-Class-Members-Through-Objects-References-and-Pointers"><a href="#Accessing-public-Class-Members-Through-Objects-References-and-Pointers" class="headerlink" title="Accessing public Class Members Through Objects, References and Pointers:"></a>Accessing public Class Members Through Objects, References and Pointers:</h3><p>考虑一个具有公共 setBalance 成员函数的 Account 类，给出以下声明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Account account; <span class="comment">// 一个 Account 对象</span></span><br><span class="line"><span class="comment">// accountRef 引用一个 Account 对象</span></span><br><span class="line">Account &amp;accountRef = account; </span><br><span class="line"><span class="comment">// accountPtr 指向一个 Account 对象</span></span><br><span class="line">Account *accountPtr = &amp;account; </span><br></pre></td></tr></table></figure>
<p>你可以使用点号 (.) 和箭头 (-&gt;) 成员选择运算符调用 member function setBalance，如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 Account 对象调用 setBalance</span></span><br><span class="line">account.<span class="built_in">setBalance</span>(<span class="number">123.45</span>); </span><br><span class="line"><span class="comment">// 通过 Account 对象的引用调用 setBalance</span></span><br><span class="line">accountRef.<span class="built_in">setBalance</span>(<span class="number">123.45</span>);</span><br><span class="line"><span class="comment">// 通过 Account 对象的指针调用 setBalance</span></span><br><span class="line">accountPtr-&gt;<span class="built_in">setBalance</span>(<span class="number">123.45</span>);</span><br></pre></td></tr></table></figure>
<h3 id="Access-Functions"><a href="#Access-Functions" class="headerlink" title="Access Functions:"></a>Access Functions:</h3><ul>
<li>访问函数用于读取或显示数据。</li>
<li>访问函数经常用于测试条件的真假，这些函数通常被称为谓词函数（predicate functions)。</li>
<li><strong>深入剖析：</strong><br>访问函数是类的重要组成部分，它们允许对象的状态得以查看或获取。这些函数允许对类的内部数据进行安全访问，同时隐藏了对象的内部实现细节。通过使用访问函数，可以封装对象的内部状态，并确保数据的一致性和完整性。谓词函数是一种特殊类型的访问函数，它们用于检查对象的属性或状态，通常返回布尔值，用于测试特定条件的真假。</li>
</ul>
<h3 id="Utility-Functions"><a href="#Utility-Functions" class="headerlink" title="Utility Functions:"></a>Utility Functions:</h3><ul>
<li>实用函数（也称为辅助函数）是支持类的其他成员函数运行的私有成员函数。</li>
</ul>
<p><strong>深入剖析：</strong><br>实用函数是用于实现类的其他成员函数的辅助函数。它们通常用于封装重复或共享的代码逻辑，并提供更高级别的抽象，以促进代码的可维护性和可重用性。由于实用函数是私有的，它们仅在类的内部使用，因此可以隐藏类的内部实现细节，并防止外部代码直接访问或修改对象的内部状态。通过将类的功能分解为多个小的实用函数，可以更轻松地管理和测试类的功能，提高代码的可读性和可维护性。</p>
<p>都有解释了，肯定要有例子！</p>
<h3 id="访问函数："><a href="#访问函数：" class="headerlink" title="访问函数："></a>访问函数：</h3><p><strong>示例：</strong></p>
<p>考虑一个 <code>Car</code> 类，其中有一个私有成员变量 <code>speed</code>。我们可以定义一个访问函数 <code>getSpeed()</code> 来获取汽车的当前速度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> speed;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSpeed</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> speed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>getSpeed()</code> 是一个访问函数，允许外部代码获取私有成员变量 <code>speed</code> 的值。这个函数提供了对 <code>Car</code> 对象内部状态的受控访问，确保了数据封装和抽象。</p>
<h3 id="实用函数："><a href="#实用函数：" class="headerlink" title="实用函数："></a>实用函数：</h3><p><strong>示例：</strong></p>
<p>我们考虑一个 <code>Math</code> 类，其中有私有实用函数 <code>calculateSquare()</code> 和 <code>calculateCube()</code>，用于执行数学运算。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Math</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateSquare</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num * num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">calculateCube</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num * num * num;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">squareAndCubeSum</span><span class="params">(<span class="type">int</span> num)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> square = <span class="built_in">calculateSquare</span>(num);</span><br><span class="line">        <span class="type">int</span> cube = <span class="built_in">calculateCube</span>(num);</span><br><span class="line">        <span class="keyword">return</span> square + cube;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>calculateSquare()</code> 和 <code>calculateCube()</code> 是实用函数，用于执行特定的数学运算。这些函数是私有的，只能在类内部访问。公共函数 <code>squareAndCubeSum()</code> 利用这些实用函数来计算给定数字的平方和立方的和。这展示了实用函数如何在内部使用，以协助实现其他成员函数的功能。</p>
<h3 id="默认参数-1"><a href="#默认参数-1" class="headerlink" title="默认参数"></a>默认参数</h3><ol>
<li><p><strong>函数声明中的默认参数</strong>：默认参数通常在函数声明中指定。当定义函数时，可以在参数列表中为某些参数提供默认值。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，函数 <code>foo</code> 有两个参数，<code>x</code> 和 <code>y</code>，其中 <code>y</code> 的默认值为 10。因此，可以这样调用函数 <code>foo</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">foo</span>(<span class="number">5</span>); <span class="comment">// 将使用默认值 10</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="number">5</span>, <span class="number">15</span>); <span class="comment">// 传递了明确的参数值 15，将忽略默认值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数定义中的默认参数</strong>：在函数的定义中也可以提供默认参数的值。通常情况下，将默认参数的值放在函数声明中更具可读性，因为它们提供了函数的接口信息。</p>
</li>
<li><p><strong>默认参数的规则</strong>：</p>
<ul>
<li>如果函数有多个参数，只能从最后一个参数开始使用默认参数。</li>
<li>一旦设置了默认参数，所有后续参数都必须有默认值，不能只给其中的一部分参数提供默认值。</li>
</ul>
</li>
</ol>
<p>下面是一个简单的示例，演示了如何在 C++ 函数中使用默认参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带有默认参数的函数声明</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(std::string name = <span class="string">&quot;World&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">greet</span>(); <span class="comment">// 使用默认参数调用函数</span></span><br><span class="line">    <span class="built_in">greet</span>(<span class="string">&quot;Alice&quot;</span>); <span class="comment">// 传递了自定义的参数值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义，这里也可以再次指定默认参数值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greet</span><span class="params">(std::string name)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，函数 <code>greet</code> 有一个默认参数 <code>name</code>，默认值为 <code>&quot;World&quot;</code>。在 <code>main</code> 函数中，第一个调用没有提供参数，因此将使用默认值 <code>&quot;World&quot;</code>，而第二个调用提供了自定义的参数值 <code>&quot;Alice&quot;</code>。</p>
<p>ppt小窗口有一个关于函数的默认参数值发生变化时候，客户端代码需要进行重新编译。</p>
<p>假设有一个函数 <code>printMessage</code>，它有一个默认参数 <code>message</code>，默认值为 “Hello, world!”。客户端代码调用这个函数来打印消息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(std::string message = <span class="string">&quot;Hello, world!&quot;</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 printMessage() 函数</span></span><br><span class="line">    <span class="built_in">printMessage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，假设我们想要更改 <code>printMessage</code> 函数的默认参数值为 “Welcome to the program!”。我们对函数进行了修改：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printMessage</span><span class="params">(std::string message = <span class="string">&quot;Welcome to the program!&quot;</span>)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; message &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 printMessage() 函数</span></span><br><span class="line">    <span class="built_in">printMessage</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果客户端代码未进行任何修改并重新编译，它仍然调用的是旧版本的 <code>printMessage</code> 函数，这可能导致输出结果与预期不符。为了确保客户端代码与更新后的函数接口相匹配，我们需要重新编译客户端代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp -o main</span><br></pre></td></tr></table></figure>
<p>通过重新编译客户端代码，它将会使用新版本的 <code>printMessage</code> 函数，从而确保程序的正确性。</p>
<h3 id="列表初始化器："><a href="#列表初始化器：" class="headerlink" title="列表初始化器："></a>列表初始化器：</h3><ol>
<li><p><strong>C++11 中的列表初始化器</strong>:</p>
<ul>
<li>C++11 提供了一种统一的初始化语法，称为列表初始化器，可以用于初始化任何变量。</li>
<li>使用列表初始化器可以更简洁地调用类的构造函数。</li>
</ul>
</li>
<li><p><strong>C++11 中的构造函数重载和委托构造函数</strong>:</p>
<ul>
<li>类的构造函数和成员函数也可以进行重载。</li>
<li>重载的构造函数通常允许使用不同类型和/或数量的参数来初始化对象。</li>
<li>要重载构造函数，需要在类定义中为每个版本的构造函数提供原型，并为每个重载的版本提供单独的构造函数定义。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hour;</span><br><span class="line">    <span class="type">int</span> minute;</span><br><span class="line">    <span class="type">int</span> second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> h = <span class="number">0</span>, <span class="type">int</span> m = <span class="number">0</span>, <span class="type">int</span> s = <span class="number">0</span>) : <span class="built_in">hour</span>(h), <span class="built_in">minute</span>(m), <span class="built_in">second</span>(s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set and Get Functions</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHour</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123; hour = h; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setMinute</span><span class="params">(<span class="type">int</span> m)</span> </span>&#123; minute = m; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSecond</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123; second = s; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHour</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> hour; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMinute</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> minute; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getSecond</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> second; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Other Member Functions...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Using C++11 list initializers</span></span><br><span class="line">    Time t2&#123; <span class="number">2</span> &#125;; <span class="comment">// hour specified; minute and second defaulted     </span></span><br><span class="line">    Time t3&#123; <span class="number">21</span>, <span class="number">34</span> &#125;; <span class="comment">// hour and minute specified; second defaulted</span></span><br><span class="line">    Time t4&#123; <span class="number">12</span>, <span class="number">25</span>, <span class="number">42</span> &#125;; <span class="comment">// hour, minute and second specified </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Using overloaded constructors</span></span><br><span class="line">    <span class="function">Time <span class="title">t5</span><span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Time <span class="title">t6</span><span class="params">(<span class="number">5</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line">    Time t7;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Time t5: &quot;</span> &lt;&lt; t5.<span class="built_in">getHour</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t5.<span class="built_in">getMinute</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t5.<span class="built_in">getSecond</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Time t6: &quot;</span> &lt;&lt; t6.<span class="built_in">getHour</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t6.<span class="built_in">getMinute</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t6.<span class="built_in">getSecond</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Time t7: &quot;</span> &lt;&lt; t7.<span class="built_in">getHour</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t7.<span class="built_in">getMinute</span>() &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; t7.<span class="built_in">getSecond</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>构造函数的重载</strong>:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Time</span>(); <span class="comment">// default hour, minute and second to 0</span></span><br><span class="line"><span class="built_in">Time</span>( <span class="type">int</span> ); <span class="comment">// initialize hour; default minute and second to 0</span></span><br><span class="line"><span class="built_in">Time</span>( <span class="type">int</span>, <span class="type">int</span>); <span class="comment">// initialize hour and minute; default second to 0</span></span><br><span class="line"><span class="built_in">Time</span>( <span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span> ); <span class="comment">// initialize hour, minute and second</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>在示例代码中，构造函数 <code>Time</code> 被重载为四个不同的版本，每个版本具有不同数量的参数，并且每个参数都有默认值。</li>
<li>在 C++11 中，构造函数可以相互调用，称为委托构造函数(delegating constructor)。这意味着某些构造函数可以委托其工作给另一个构造函数，以避免代码重复。</li>
</ul>
<p>委托构造在此之前并不知道，可以知道一下。</p>
<ol>
<li><strong>使用成员初始化列表</strong>:<ul>
<li>在示例中，构造函数的委托过程使用了成员初始化列表的形式。这样的语法允许在构造函数体之前初始化类的成员变量，可以更加清晰和高效地编写代码。</li>
</ul>
</li>
</ol>
<blockquote>
<p>当不使用成员初始化列表时，会导致以下情况发生：</p>
<ol>
<li><p><strong>隐式调用默认构造函数</strong>：如果一个成员对象没有通过成员初始化列表进行初始化，那么该成员对象的默认构造函数将会被隐式调用。这意味着对象会被用默认构造函数的默认值初始化。</p>
</li>
<li><p><strong>默认构造函数的默认值</strong>：默认构造函数的默认值可能不符合需求，因此可能需要通过调用成员函数来修改这些默认值。这样的修改可能会在构造函数体内部进行，或者在对象创建后通过外部调用进行。</p>
</li>
<li><p><strong>复杂初始化的额外工作和时间</strong>：对于复杂的初始化过程，如果不使用成员初始化列表，可能会导致代码变得复杂，并且需要更多的时间和精力来维护和调试。这是因为在构造函数体内部进行初始化可能会涉及到额外的逻辑和操作，而且可能会增加代码的复杂性。</p>
</li>
</ol>
</blockquote>
<ol>
<li><p><strong>析构函数</strong>:</p>
<ul>
<li>析构函数是在对象销毁时被隐式调用的特殊成员函数。</li>
<li>它负责在对象的内存被回收之前执行终止清理工作，但实际上并不释放内存。因此，内存可以被重新用于分配给新对象。</li>
<li>析构函数的名称由波浪符号（~）后跟类名组成。</li>
<li>如果不显式定义析构函数，编译器会自动生成一个空的析构函数。</li>
<li>析构函数必须是公有的，不能有返回类型（包括 void）。</li>
</ul>
</li>
<li><p><strong>示例代码</strong>:</p>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor Overloading</span></span><br><span class="line">    <span class="built_in">Time</span>() : <span class="built_in">Time</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> hour) : <span class="built_in">Time</span>(hour, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> hour, <span class="type">int</span> minute) : <span class="built_in">Time</span>(hour, minute, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">Time</span>(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second) : <span class="built_in">hour</span>(hour), <span class="built_in">minute</span>(minute), <span class="built_in">second</span>(second) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destructor</span></span><br><span class="line">    ~<span class="built_in">Time</span>() &#123;</span><br><span class="line">        <span class="comment">// Perform termination housekeeping chores</span></span><br><span class="line">        <span class="comment">// (if needed)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hour;</span><br><span class="line">    <span class="type">int</span> minute;</span><br><span class="line">    <span class="type">int</span> second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一些构造函数和析构函数的知识点，exit和abort在c++八股一文有所提及：</p>
</blockquote>
<p>构造函数和析构函数是类的成员函数，用于对象的创建和销毁。它们的调用是隐式的，不需要手动调用。</p>
<ol>
<li><p><strong>调用顺序</strong>：</p>
<ul>
<li>构造函数和析构函数的调用顺序取决于对象的创建和销毁的作用域。</li>
<li>通常情况下，析构函数的调用顺序与对应构造函数的调用顺序相反。</li>
<li>全局对象和静态对象的析构顺序可能会受到存储类的影响。</li>
</ul>
</li>
<li><p><strong>全局作用域对象的构造和析构</strong>：</p>
<ul>
<li>在全局作用域中定义的对象，在程序执行开始前的任何其他函数（包括main函数）之前会调用其构造函数。</li>
<li>对应的析构函数在main函数终止时调用，或者在程序调用exit函数时调用。</li>
<li>如果程序调用exit或abort函数终止，局部对象的析构函数不会被调用。</li>
</ul>
</li>
<li><p><strong>局部作用域对象的构造和析构</strong>：</p>
<ul>
<li>局部作用域对象的构造和析构与执行进入和离开对象作用域的次数相关。</li>
<li>如果程序通过调用exit或abort函数终止，局部对象的析构函数不会被调用。</li>
</ul>
</li>
<li><p><strong>静态局部对象的构造和析构</strong>：</p>
<ul>
<li>静态局部对象的构造函数只会在程序首次到达对象定义点时调用一次。</li>
<li>对应的析构函数在main函数终止时调用，或者在程序调用exit函数时调用。</li>
<li>静态对象的析构函数在程序调用abort函数时不会被调用。</li>
</ul>
</li>
</ol>
<p>下面是关于这两个关键词的深入剖析：</p>
<p>exit和abort是C++中用于程序终止的函数，它们的行为有一些差异：</p>
<ol>
<li><p><strong>exit函数</strong>：</p>
<ul>
<li><strong>作用</strong>：exit函数用于正常终止程序，它会执行程序终止前的清理工作，包括调用全局对象和静态局部对象的析构函数。</li>
<li><strong>调用时机</strong>：可以在程序的任何地方调用exit函数，以终止程序的执行。一般在满足某些条件时，或者在程序出现严重错误时调用exit函数，以安全地结束程序。</li>
<li><strong>参数</strong>：exit函数可以接受一个整数参数作为退出代码，用于向操作系统传递程序的退出状态。默认情况下，退出代码为0表示程序正常终止，非零值表示程序异常终止。</li>
<li><strong>清理操作</strong>：exit函数会执行全局对象和静态局部对象的析构函数，释放它们占用的资源，并关闭文件等资源。然后，它会终止程序的执行，返回操作系统。</li>
</ul>
</li>
<li><p><strong>abort函数</strong>：</p>
<ul>
<li><strong>作用</strong>：abort函数用于异常终止程序，它会立即终止程序的执行，不执行任何清理工作，包括全局对象和静态局部对象的析构函数。</li>
<li><strong>调用时机</strong>：通常在程序遇到严重错误时调用abort函数，以避免继续执行可能导致更严重后果的代码。abort函数会立即停止程序的执行，不执行任何清理操作。</li>
<li><strong>行为</strong>：调用abort函数会导致程序立即终止，不会执行后续的任何代码。它不会执行全局对象和静态局部对象的析构函数，因此可能导致资源泄漏或其他问题。</li>
<li><strong>调试</strong>：abort函数通常用于调试目的，以快速终止程序并生成调试信息。在某些情况下，程序出现无法恢复的错误时，调用abort函数可以帮助定位问题。</li>
</ul>
</li>
</ol>
<p>总之，exit函数用于正常终止程序，执行清理操作并返回退出代码，而abort函数用于异常终止程序，立即停止执行并不执行任何清理工作。在选择使用哪个函数时，需要根据程序的要求和设计考虑清理操作和终止方式。</p>
<p>当提及引用和私有数据成员的返回值的问题：</p>
<ol>
<li><p><strong>引用的特性</strong>：</p>
<ul>
<li>引用是对象名称的别名，因此可以在赋值语句的左侧使用。引用本身就是一个合法的左值，可以接收一个值。</li>
<li>引用的特性导致了可能存在的问题：公有成员函数可以返回对该类的私有数据成员的引用，这样返回的引用就成为了私有数据成员的别名。</li>
</ul>
</li>
<li><p><strong>私有数据成员的引用返回</strong>：</p>
<ul>
<li>当一个公有成员函数返回对私有数据成员的引用时，实际上是将该成员函数变成了私有数据成员的别名。这意味着通过调用该成员函数返回的引用，可以直接操作私有数据成员，包括在赋值语句中使用作为左值。</li>
<li>如果函数返回的引用被声明为const，则不能用于修改数据，但仍然可以用作左值。</li>
</ul>
</li>
</ol>
<p>一些可能的解决方法：</p>
<blockquote>
<p>要解决公有成员函数返回私有数据成员的引用的问题，可以采取以下方法：</p>
<ol>
<li><strong>不返回引用</strong>：</li>
</ol>
<ul>
<li>最简单的方法是避免在公有成员函数中返回对私有数据成员的引用。这样可以防止直接访问私有数据成员，从而避免破坏类的封装性。</li>
</ul>
<ol>
<li><strong>使用const引用</strong>：</li>
</ol>
<ul>
<li>如果确实需要提供对私有数据成员的只读访问，可以返回一个常量引用。这样，返回的引用不能用于修改数据，但可以用作左值进行读取操作。</li>
</ul>
<ol>
<li><strong>提供访问函数</strong>：</li>
</ol>
<ul>
<li>更好的方法是提供专门的公有成员函数来访问私有数据成员，而不是直接返回引用。这样可以在访问数据时提供更多的控制和保护机制，例如可以添加边界检查或其他逻辑。</li>
</ul>
<ol>
<li><strong>友元函数</strong>：</li>
</ol>
<ul>
<li>如果确实需要在外部访问私有数据成员，可以考虑将其他类或函数声明为友元函数。这样，友元函数可以直接访问类的私有成员，但仅限于特定的情况，并且需要谨慎使用以确保封装性。</li>
</ul>
</blockquote>
<h3 id="关于对象之间的赋值操作和拷贝问题："><a href="#关于对象之间的赋值操作和拷贝问题：" class="headerlink" title="关于对象之间的赋值操作和拷贝问题："></a>关于对象之间的赋值操作和拷贝问题：</h3><ol>
<li><p><strong>赋值操作符的默认行为</strong>：</p>
<ul>
<li>对象之间的赋值操作默认采用成员逐一赋值（也称为复制赋值）。这意味着右侧对象的每个数据成员都会分别赋值给左侧对象对应的数据成员。</li>
</ul>
</li>
<li><p><strong>传递和返回对象</strong>：</p>
<ul>
<li>对象可以作为函数的参数和返回值。默认情况下，采用按值传递的方式进行传递和返回，即会创建一个新的对象，并使用复制构造函数将原始对象的值复制到新对象中。</li>
</ul>
</li>
<li><p><strong>默认复制构造函数</strong>：</p>
<ul>
<li>对于每个类，编译器提供了一个默认的复制构造函数，用于将原始对象的每个成员复制到新对象的对应成员中。这种默认的复制构造函数通常适用于简单的数据成员类型，但对于包含指向动态分配内存的指针的类，可能会导致严重的问题。</li>
</ul>
</li>
<li><p><strong>指针成员的问题</strong>：</p>
<ul>
<li>当一个类的数据成员包含指向动态分配内存的指针时，使用默认的复制构造函数会导致指针的浅拷贝，可能会造成内存泄漏、悬空指针等严重问题。这些问题在待会会进行讨论，并介绍如何通过自定义复制构造函数来解决。</li>
</ul>
</li>
</ol>
<h3 id="Const"><a href="#Const" class="headerlink" title="Const"></a>Const</h3><ol>
<li><p><strong>声明常量对象</strong>：</p>
<ul>
<li>使用关键字 const 可以声明一个对象为常量对象，即不可修改的对象。例如，<code>const Time noon(12, 0, 0);</code> 声明了一个名为 noon 的常量对象，表示中午12点。</li>
<li>可以同时实例化 const 和非 const 类型的对象，它们在同一类中并存。</li>
</ul>
</li>
<li><p><strong>在常量对象上调用成员函数</strong>：</p>
<ul>
<li>在常量对象上调用成员函数时，如果成员函数不修改对象的状态，则需要将成员函数声明为 const。否则，在编译时会发生错误。</li>
<li>即使是不修改对象状态的 get 成员函数，在常量对象上也需要声明为 const。</li>
</ul>
</li>
<li><p><strong>成员函数的 const 限定符</strong>：</p>
<ul>
<li>将成员函数声明为 const 的方法是在函数的参数列表后面插入关键字 const，在函数定义的左大括号之前加上关键字 const。</li>
<li>所有不修改对象状态的成员函数都应该声明为 const，这是良好的编程实践，能够提高代码的可读性和可维护性。</li>
</ul>
</li>
<li><p><strong>构造函数和析构函数的 const 限制</strong>：</p>
<ul>
<li>构造函数必须能够修改对象以便正确初始化，因此不能声明为 const。声明构造函数为 const 会导致编译错误。</li>
<li>析构函数需要在对象的内存被系统回收之前执行终止清理工作，因此也不能声明为 const。</li>
</ul>
</li>
<li><p><strong>编译错误的情况</strong>：</p>
<ul>
<li>如果在常量对象上调用了不带 const 限定符的成员函数，或者尝试声明构造函数或析构函数为 const，都会导致编译错误。</li>
</ul>
</li>
</ol>
<p>在C++中，类中的组合指的是一个类包含另一个类作为其成员变量。这种关系称为“has-a”关系，表示一个类具有另一个类的对象作为其一部分。组合关系允许在一个类中使用另一个类的功能，并在需要时对其进行实例化和操作。</p>
<p>下面是关于类中组合和数据成员构造顺序的详细解释：</p>
<ol>
<li><p><strong>组合关系</strong>：</p>
<ul>
<li>组合是一种对象之间的关系，其中一个对象包含另一个对象。在类的定义中，可以声明另一个类的对象作为成员变量，从而实现组合关系。</li>
<li>组合关系用于描述一个对象包含另一个对象的情况，例如一辆车包含引擎、轮子等部件，或者一个学生包含姓名、年龄等属性。</li>
</ul>
</li>
<li><p><strong>类中数据成员的构造顺序</strong>：</p>
<ul>
<li>在创建一个包含组合关系的类的对象时，类中的数据成员会按照它们在类定义中声明的顺序进行构造。</li>
<li>首先构造基类的成员（如果有的话），然后按照声明的顺序构造类的其他成员。</li>
<li>如果成员变量是基本类型或者内置类型，则按照它们在类定义中声明的顺序进行构造。</li>
<li>如果成员变量是类类型，则会调用对应类的构造函数来构造这些对象。</li>
</ul>
</li>
</ol>
<blockquote>
<p>总之，类中数据成员的构造顺序是按照它们在类定义中声明的顺序进行的。</p>
<h3 id="浅谈一下设计模式中为什么建议多用组合少用继承："><a href="#浅谈一下设计模式中为什么建议多用组合少用继承：" class="headerlink" title="浅谈一下设计模式中为什么建议多用组合少用继承："></a>浅谈一下设计模式中为什么建议多用组合少用继承：</h3></blockquote>
<p>在设计模式中建议多用组合少用继承的原因有几个：</p>
<ol>
<li><p><strong>松耦合</strong>：组合关系比继承关系更加松耦合。使用组合可以使类之间的关系更灵活，降低它们之间的耦合度。当一个类包含另一个类作为成员变量时，它们之间的关系更加灵活，一个类的改变不会影响到另一个类。</p>
</li>
<li><p><strong>更好的封装性</strong>：组合可以提供更好的封装性。通过组合，一个类可以隐藏其内部实现细节，只暴露必要的接口给外部使用。这样可以降低类之间的依赖关系，减少代码的耦合度。</p>
</li>
<li><p><strong>复用性</strong>：组合可以提高代码的复用性。通过将功能划分为独立的组件，并在需要时将它们组合在一起，可以更容易地复用这些组件。相比之下，继承关系通常会导致代码的耦合度增加，降低了代码的可复用性。</p>
</li>
<li><p><strong>更灵活的设计</strong>：使用组合可以实现更灵活的设计。通过组合，可以将一个类的功能拆分成多个独立的组件，然后根据需要组合这些组件来实现不同的功能。这样可以更容易地修改和扩展代码，使系统更具有扩展性和灵活性。</p>
</li>
</ol>
<h3 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h3><p>注意友元函数不是成员函数，而且尽量不要放在任何access specifier后面。<br>友元函数（Friend Functions）是指具有访问类的公有和非公有成员的权限的非成员函数。可以将独立的函数、整个类或其他类的成员函数声明为另一个类的友元。</p>
<p><strong>声明友元函数：</strong><br>要将一个函数声明为类的友元函数，需要在类定义中的函数原型前加上关键字<code>friend</code>。例如，要将<code>ClassTwo</code>类的所有成员函数声明为<code>ClassOne</code>类的友元，可以在<code>ClassOne</code>类的定义中添加如下声明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend class ClassTwo;</span><br></pre></td></tr></table></figure>
<p>友谊是由类主动授予的，而不是被动获得的。如果要让类B成为类A的友元，类A必须显式声明类B是其友元。友谊不是对称的——如果类A是类B的友元，不能推断出类B是类A的友元。友谊也不是传递的——如果类A是类B的友元，而类B是类C的友元，不能推断出类A是类C的友元。</p>
<p><strong>重载的友元函数：</strong><br>可以将重载的函数指定为类的友元函数。每个打算成为类的友元的函数都必须在类定义中显式声明为类的友元。</p>
<p><strong>设计注意事项：</strong></p>
<ul>
<li>友元函数的使用应该谨慎，因为它打破了类的封装性，可能导致代码的可维护性和安全性降低。</li>
<li>如果可能，应该尽量减少友元函数的使用，而优先考虑通过类的成员函数来访问类的私有数据。</li>
</ul>
<h3 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h3><p><strong>this指针的概念：</strong></p>
<ul>
<li>每个对象都可以通过一个指针（称为this，是C++的关键字）访问自己的地址。</li>
<li>this指针并不是对象本身的一部分，即this指针占用的内存不会反映在对对象进行sizeof操作的结果中。</li>
<li>实际上，编译器会将this指针作为一个隐式参数传递给对象的每个非静态成员函数。</li>
</ul>
<p><strong>使用this指针避免命名冲突：</strong></p>
<ul>
<li>成员函数可以隐式（或显式）地使用this指针来引用对象的数据成员和其他成员函数。</li>
<li>显式使用this指针的一个常见情况是避免类的数据成员与成员函数参数（或其他局部变量）之间的命名冲突。</li>
</ul>
<p><strong>例子：</strong><br>考虑Time类中的hour数据成员和setHour成员函数。我们可以将setHour定义为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置小时值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Time::setHour</span><span class="params">(<span class="type">int</span> hour)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hour &gt;= <span class="number">0</span> &amp;&amp; hour &lt; <span class="number">24</span>)</span><br><span class="line">        <span class="keyword">this</span>-&gt;hour = hour; <span class="comment">// 使用this指针访问数据成员</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;hour must be 0-23&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>this指针的类型：</strong></p>
<ul>
<li>this指针的类型取决于对象的类型以及使用this的成员函数是否声明为const。</li>
<li>例如，在Employee类的非const成员函数中，this指针的类型为Employee<em>。在const成员函数中，this指针的类型为const Employee</em>。</li>
</ul>
<p><strong>使用this指针实现级联函数调用：</strong><br>this指针的另一个用途是实现级联成员函数调用。这意味着可以在同一条语句中调用多个函数。</p>
<p><strong>级联函数调用的概念：</strong></p>
<p>级联函数调用是指在同一条语句中连续调用多个函数。这种技术使得代码更加简洁、易读，并且提高了代码的可维护性。</p>
<p><strong>内核：</strong></p>
<ol>
<li><strong>设置函数返回引用：</strong> <ul>
<li>首先，确保类的成员函数设置返回类型为类的引用。这样可以实现函数调用的链式操作，因为每个函数都可以返回调用该函数的对象的引用。</li>
<li>例如，在类Time中，可以将set函数的返回类型设置为Time类的引用。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Time&amp; <span class="title">setTime</span><span class="params">(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second)</span></span>;</span><br><span class="line">    <span class="function">Time&amp; <span class="title">setHour</span><span class="params">(<span class="type">int</span> hour)</span></span>;</span><br><span class="line">    <span class="function">Time&amp; <span class="title">setMinute</span><span class="params">(<span class="type">int</span> minute)</span></span>;</span><br><span class="line">    <span class="function">Time&amp; <span class="title">setSecond</span><span class="params">(<span class="type">int</span> second)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>函数体中返回*this：</strong><ul>
<li>在函数体中，将返回语句设置为返回<em>this，这样就可以返回调用该函数的对象的引用。因此，可以通过返回</em>this来实现级联函数调用。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Time&amp; <span class="title">Time::setTime</span><span class="params">(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置时间</span></span><br><span class="line">    <span class="built_in">setHour</span>(hour).<span class="built_in">setMinute</span>(minute).<span class="built_in">setSecond</span>(second);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>连续调用：</strong><ul>
<li>在调用函数时，通过<code>.</code>或<code>-&gt;</code>操作符连接函数调用，以实现级联调用。</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Time t;</span><br><span class="line">t.<span class="built_in">setTime</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>).<span class="built_in">setHour</span>(<span class="number">11</span>).<span class="built_in">setMinute</span>(<span class="number">45</span>).<span class="built_in">setSecond</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Time</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> hour;</span><br><span class="line">    <span class="type">int</span> minute;</span><br><span class="line">    <span class="type">int</span> second;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Time&amp; <span class="title">setTime</span><span class="params">(<span class="type">int</span> hour, <span class="type">int</span> minute, <span class="type">int</span> second)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置时间</span></span><br><span class="line">        <span class="built_in">setHour</span>(hour).<span class="built_in">setMinute</span>(minute).<span class="built_in">setSecond</span>(second);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Time&amp; <span class="title">setHour</span><span class="params">(<span class="type">int</span> hour)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hour &gt;= <span class="number">0</span> &amp;&amp; hour &lt; <span class="number">24</span>)</span><br><span class="line">            <span class="keyword">this</span>-&gt;hour = hour;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;hour must be 0-23&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Time&amp; <span class="title">setMinute</span><span class="params">(<span class="type">int</span> minute)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minute &gt;= <span class="number">0</span> &amp;&amp; minute &lt; <span class="number">60</span>)</span><br><span class="line">            <span class="keyword">this</span>-&gt;minute = minute;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;minute must be 0-59&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Time&amp; <span class="title">setSecond</span><span class="params">(<span class="type">int</span> second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (second &gt;= <span class="number">0</span> &amp;&amp; second &lt; <span class="number">60</span>)</span><br><span class="line">            <span class="keyword">this</span>-&gt;second = second;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">invalid_argument</span>(<span class="string">&quot;second must be 0-59&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">displayTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Time: &quot;</span> &lt;&lt; hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; minute &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Time t;</span><br><span class="line">    t.<span class="built_in">setTime</span>(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>).<span class="built_in">setHour</span>(<span class="number">11</span>).<span class="built_in">setMinute</span>(<span class="number">45</span>).<span class="built_in">setSecond</span>(<span class="number">0</span>);</span><br><span class="line">    t.<span class="built_in">displayTime</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们通过调用<code>setTime</code>函数来设置时间，并通过级联调用的方式设置小时、分钟和秒。</p>
<p>在级联函数中，传递引用作为参数：</p>
<blockquote>
<ol>
<li><p><strong>避免对象拷贝：</strong> 级联函数通常需要在多个函数之间传递相同的对象，如果直接传递对象而不是引用，每个函数都会创建对象的副本，导致不必要的对象拷贝，增加额外的开销和内存消耗。通过传递引用，可以避免对象的拷贝，提高程序的效率和性能。</p>
</li>
<li><p><strong>保持数据一致性：</strong> 通过传递引用，级联函数可以直接修改原始对象，而不是操作对象的副本。这样可以确保在级联函数链中对数据的修改是一致的，避免出现不一致或者意外的行为。</p>
</li>
</ol>
</blockquote>
<h3 id="static-Class-Members"><a href="#static-Class-Members" class="headerlink" title="static Class Members"></a>static Class Members</h3><p>静态数据成员在类中的使用有几个重要方面：</p>
<ol>
<li><p><strong>共享类范围：</strong> 静态数据成员具有类范围，意味着它们对于该类的所有对象都是共享的。这意味着只有一个副本存在于内存中，被所有实例共享。这对于表示类范围的信息非常有用，例如计数器、配置参数等。</p>
</li>
<li><p><strong>初始化：</strong> 静态数据成员必须被初始化且只能初始化一次。基本类型的静态数据成员默认初始化为0。在C++11之前，静态const数据成员可以在类定义中初始化，而其他静态数据成员必须在类定义外部的全局命名空间范围内进行初始化。C++11引入了内联初始化器，允许在类定义中初始化静态数据成员。</p>
</li>
<li><p><strong>访问控制：</strong> 类的私有和受保护的静态成员通常通过公有成员函数或友元进行访问。公有静态成员可直接通过类名和作用域解析运算符(::)进行访问。而对于私有或受保护的静态成员，则需要提供公有的静态成员函数来访问，通过类名和作用域解析运算符来调用这些函数。</p>
</li>
<li><p><strong>类的静态成员存在性：</strong> 类的静态成员存在于任何类对象存在与否的情况下。这意味着即使没有类的对象被实例化，静态成员仍然可以被访问和使用。静态成员函数是类的服务，而不是特定对象的服务。</p>
</li>
</ol>
<p>看一个问题罢：加深一下对static的理解<br>为什么静态成员函数不能是const？</p>
<p>static在c++中的第五种含义：用static修饰不访问非静态数据成员的类成员函数。这意味着一个静态成员函数只能访问它的参数、类的静态数据成员和全局变量。</p>
<blockquote>
<p>不能用const的原因：<br>这是C++的规则，const修饰符用于表示函数不能修改成员变量的值，该函数必须是含有this指针的类成员函数，函数调用方式为thiscall，而类中的static函数本质上是全局函数，调用规约是<strong>cdecl或</strong>stdcall,不能用const来修饰它。一个静态成员函数访问的值是其参数、静态数据成员和全局变量，而这些数据都不是对象状态的一部分。而对成员函数中使用关键字const是表明：函数不会修改该函数访问的目标对象的数据成员。既然一个静态成员函数根本不访问非静态数据成员，那么就没必要使用const了。<br>什么时候使用静态数据成员和静态函数呢？<br>定义数据成员为静态变量，以表明此全局数据逻辑上属于该类。<br>定义成员函数为静态函数，以表明此全局函数逻辑上属于该类，而且该函数只对静态数据、全局数据或者参数进行操作，而不对非静态数据成员进行操作。</p>
<p>static的第一种含义：修饰全局变量时，表明一个全局变量只对定义在同一文件中的函数可见。<br>static的第二种含义：修饰局部变量时，表明该变量的值不会因为函数终止而丢失。<br>static的第三种含义：修饰函数时，表明该函数只在同一文件中调用。<br>static的第四种含义：修饰类的数据成员，表明对该类所有对象这个数据成员都只有一个实例。即该实例归 所有对象共有。<br>static的第五种含义：修饰类成员函数，如上。</p>
</blockquote>
<hr>
<h2 id="Operator-Overloading-Class-string"><a href="#Operator-Overloading-Class-string" class="headerlink" title="Operator Overloading; Class string"></a>Operator Overloading; Class string</h2><h3 id="关于string的一些重载"><a href="#关于string的一些重载" class="headerlink" title="关于string的一些重载"></a>关于string的一些重载</h3><p>理解类 string 的重载相等和关系运算符，以及其他成员函数的工作方式：</p>
<ul>
<li>类 string 重载了相等运算符（==）、不等运算符（!=）、小于运算符（&lt;）、小于等于运算符（&lt;=）、大于运算符（&gt;）、大于等于运算符（&gt;=），以执行字典顺序的比较。</li>
<li>这些运算符比较两个字符串的字符数值，按照字典顺序进行比较。</li>
<li>类 string 还提供了成员函数 empty()，用于判断字符串是否为空。</li>
<li>使用 += 运算符可以进行字符串连接，例如，<code>str += &quot;append&quot;</code>。</li>
<li>成员函数 substr() 可以返回原字符串的子字符串。<ul>
<li>可以指定起始位置和长度，也可以只指定起始位置。</li>
</ul>
</li>
<li>重载的 [] 运算符可以访问字符串中的字符，但不执行边界检查。</li>
<li>成员函数 at() 提供了边界检查，如果下标无效，会抛出异常。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::string s1 = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    std::string s2 = <span class="string">&quot;Hello, C++!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Equality and relational operators</span></span><br><span class="line">    <span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;s1 is equal to s2\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s1 &lt; s2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;s1 is less than s2\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;s1 is greater than s2\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Empty function</span></span><br><span class="line">    <span class="keyword">if</span> (s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;s1 is empty\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;s1 is not empty\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Concatenation using +=</span></span><br><span class="line">    s1 += <span class="string">&quot; Welcome to C++!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Concatenated string: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Substring using substr()</span></span><br><span class="line">    std::string substr1 = s1.<span class="built_in">substr</span>(<span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// Get first 5 characters</span></span><br><span class="line">    std::string substr2 = s1.<span class="built_in">substr</span>(<span class="number">15</span>);    <span class="comment">// Get substring starting from index 15</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Substring 1: &quot;</span> &lt;&lt; substr1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Substring 2: &quot;</span> &lt;&lt; substr2 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Accessing characters using []</span></span><br><span class="line">    s1[<span class="number">0</span>] = <span class="string">&#x27;h&#x27;</span>;  <span class="comment">// Replace first character with lowercase &#x27;h&#x27;</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Modified string: &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Accessing characters using at() (with bounds checking)</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">char</span> ch = s1.<span class="built_in">at</span>(<span class="number">20</span>);  <span class="comment">// Try to access character at index 20</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Character at index 20: &quot;</span> &lt;&lt; ch &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>姑且利用string类小小编写一下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// For strcpy, strcat, strlen</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyString</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span>* str;</span><br><span class="line">    <span class="type">size_t</span> length;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Default constructor</span></span><br><span class="line">    <span class="built_in">MyString</span>() : <span class="built_in">str</span>(<span class="literal">nullptr</span>), <span class="built_in">length</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Constructor from char array</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> <span class="type">char</span>* s) &#123;</span><br><span class="line">        length = <span class="built_in">strlen</span>(s);</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy constructor</span></span><br><span class="line">    <span class="built_in">MyString</span>(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        length = other.length;</span><br><span class="line">        str = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(str, other.str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destructor</span></span><br><span class="line">    ~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">        <span class="keyword">delete</span>[] str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assignment operator</span></span><br><span class="line">    MyString&amp; <span class="keyword">operator</span>=(<span class="type">const</span> MyString&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] str;</span><br><span class="line">            length = other.length;</span><br><span class="line">            str = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">strcpy</span>(str, other.str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Concatenation operator</span></span><br><span class="line">    MyString <span class="keyword">operator</span>+(<span class="type">const</span> MyString&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        MyString result;</span><br><span class="line">        result.length = length + other.length;</span><br><span class="line">        result.str = <span class="keyword">new</span> <span class="type">char</span>[result.length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(result.str, str);</span><br><span class="line">        <span class="built_in">strcat</span>(result.str, other.str);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append function</span></span><br><span class="line">    <span class="function">MyString&amp; <span class="title">append</span><span class="params">(<span class="type">const</span> MyString&amp; other)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> newLength = length + other.length;</span><br><span class="line">        <span class="type">char</span>* newStr = <span class="keyword">new</span> <span class="type">char</span>[newLength + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(newStr, str);</span><br><span class="line">        <span class="built_in">strcat</span>(newStr, other.str);</span><br><span class="line">        <span class="keyword">delete</span>[] str;</span><br><span class="line">        str = newStr;</span><br><span class="line">        length = newLength;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Accessor for length</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Accessor for C-style string</span></span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">c_str</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overloaded output operator</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> MyString&amp; s) &#123;</span><br><span class="line">        os &lt;&lt; s.str;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Comparison operators</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> MyString&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(str, other.str) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> MyString&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> == other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> MyString&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(str, other.str) &lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> MyString&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">strcmp</span>(str, other.str) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyString <span class="title">s1</span><span class="params">(<span class="string">&quot;Hello&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">MyString <span class="title">s2</span><span class="params">(<span class="string">&quot; World!&quot;</span>)</span></span>;</span><br><span class="line">    MyString s3 = s1 + s2; <span class="comment">// Concatenation</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s3: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Append</span></span><br><span class="line">    s3.<span class="built_in">append</span>(<span class="string">&quot; How are you?&quot;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;s3 after append: &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Comparison</span></span><br><span class="line">    <span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;s1 is equal to s2\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;s1 is not equal to s2\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (s1 &lt; s2) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;s1 is less than s2\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;s1 is not less than s2\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ol>
<li><p><strong>运算符重载简介</strong>：</p>
<ul>
<li>运算符提供了一种简洁直观的方式来操作对象。</li>
<li>C++ 允许大多数现有的运算符进行重载，意味着它们的行为可以针对用户自定义类型进行定制。</li>
</ul>
</li>
<li><p><strong>运算符重载机制</strong>：</p>
<ul>
<li>运算符重载并不是自动的。您需要显式定义运算符重载函数来执行所需的操作。</li>
<li>要重载一个运算符，您需要编写一个函数，其名称以关键字 <code>operator</code> 开头，后跟要重载的运算符的符号。例如，<code>operator+</code> 用于重载加法运算符 <code>+</code>。</li>
</ul>
</li>
<li><p><strong>运算符重载的考虑事项</strong>：</p>
<ul>
<li>当作为成员函数重载运算符时，它们必须是非静态的，通常操作于对象本身。</li>
<li>赋值运算符 (<code>=</code>)、地址运算符 (<code>&amp;</code>) 和逗号运算符 (<code>，</code>) 具有默认行为，可以通过重载进行覆盖。</li>
<li>运算符的优先级、结合性和参数个数不能通过重载来改变。运算符必须保留其原始行为和属性。</li>
</ul>
</li>
</ol>
<ul>
<li>优先级 (precedence)</li>
<li>结合性 (associativity)</li>
<li>参数个数 (number of operands)<ul>
<li>重载的一元和二元运算符必须保持其原始参数个数。例如，一元运算符应保持一元，二元运算符应保持二元。</li>
<li>不能通过运算符重载来创建新的运算符，且无法改变运算符在基本类型上的含义。</li>
</ul>
</li>
</ul>
<ol>
<li><p><strong>限制和约束</strong>：</p>
<ul>
<li>某些运算符，如 <code>()</code>、<code>[]</code>、<code>-&gt;</code> 和赋值运算符，必须作为成员函数进行重载。</li>
<li>相关的运算符，如 <code>+</code> 和 <code>+=</code>，需要单独进行重载。</li>
<li>运算符在基本类型上的行为无法通过运算符重载来改变。</li>
</ul>
</li>
<li><p><strong>运算符重载函数</strong>：</p>
<ul>
<li>重载的运算符函数可以是成员函数，也可以是非成员函数，但某些运算符必须作为成员函数进行重载。</li>
</ul>
</li>
</ol>
<p>在C++中，二元运算符可以通过成员函数或非成员函数进行重载。作为成员函数重载时，只需要一个参数；作为非成员函数重载时，需要两个参数，其中一个必须是类对象或类对象的引用。</p>
<p>输入和输出基本数据类型可以使用流提取运算符 <code>&gt;&gt;</code> 和流插入运算符 <code>&lt;&lt;</code>。C++类库为每种基本类型（包括指针和 <code>char *</code> 字符串）重载了这些二元运算符。你也可以重载这些运算符来实现自定义类型的输入和输出。</p>
<p>下面是一个示例代码，展示了如何重载这些运算符来输入和输出电话号码对象 <code>PhoneNumber</code>，格式为“(000) 000-0000”。该程序假设电话号码已经正确输入。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PhoneNumber</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string areaCode;</span><br><span class="line">    std::string exchange;</span><br><span class="line">    std::string line;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PhoneNumber</span>() : <span class="built_in">areaCode</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">exchange</span>(<span class="string">&quot;&quot;</span>), <span class="built_in">line</span>(<span class="string">&quot;&quot;</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overloaded stream insertion operator for output</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; output, <span class="type">const</span> PhoneNumber&amp; number) &#123;</span><br><span class="line">        output &lt;&lt; <span class="string">&quot;(&quot;</span> &lt;&lt; number.areaCode &lt;&lt; <span class="string">&quot;) &quot;</span> &lt;&lt; number.exchange &lt;&lt; <span class="string">&quot;-&quot;</span> &lt;&lt; number.line;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overloaded stream extraction operator for input</span></span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; input, PhoneNumber&amp; number) &#123;</span><br><span class="line">        input.<span class="built_in">ignore</span>(); <span class="comment">// Skip &#x27;(&#x27;</span></span><br><span class="line">        input &gt;&gt; std::<span class="built_in">setw</span>(<span class="number">3</span>) &gt;&gt; number.areaCode; <span class="comment">// Read area code</span></span><br><span class="line">        input.<span class="built_in">ignore</span>(<span class="number">2</span>); <span class="comment">// Skip &#x27;) &#x27; characters</span></span><br><span class="line">        input &gt;&gt; std::<span class="built_in">setw</span>(<span class="number">3</span>) &gt;&gt; number.exchange; <span class="comment">// Read exchange</span></span><br><span class="line">        input.<span class="built_in">ignore</span>(); <span class="comment">// Skip &#x27;-&#x27; character</span></span><br><span class="line">        input &gt;&gt; std::<span class="built_in">setw</span>(<span class="number">4</span>) &gt;&gt; number.line; <span class="comment">// Read line</span></span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PhoneNumber myNumber;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a phone number in the format (123) 456-7890:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cin &gt;&gt; myNumber; <span class="comment">// Input a phone number</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; myNumber &lt;&lt; std::endl; <span class="comment">// Output the phone number</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作为非成员 friend 函数的重载运算符：</p>
<p>函数 operator&gt;&gt; 和 operator&lt;&lt; 被声明为非成员友元函数。<br>它们是非成员函数，因为类 PhoneNumber 的对象是运算符的右操作数。<br>为什么流插入和流提取运算符作为非成员函数进行重载：</p>
<p>重载的流插入运算符（&lt;&lt;）在表达式中的左操作数为 ostream &amp; 类型时使用，例如 cout &lt;&lt; classObject。<br>要在这种情况下使用运算符，右操作数必须是一个用户定义类的对象，因此必须将其重载为非成员函数。<br>类似地，重载的流提取运算符（&gt;&gt;）在表达式中的左操作数为 istream &amp; 类型时使用，例如 cin &gt;&gt; classObject，并且右操作数是用户定义类的对象，因此也必须是非成员函数。</p>
<h3 id="一元运算符重载"><a href="#一元运算符重载" class="headerlink" title="一元运算符重载"></a>一元运算符重载</h3><p>一元运算符可以被重载为类的非静态成员函数或非成员函数。</p>
<ul>
<li>作为非静态成员函数：无参数。这意味着一元运算符的重载函数作为类的成员函数存在，不需要参数，直接在类内部定义。调用时将针对对象进行操作。</li>
<li>作为非成员函数：一个参数。一元运算符的重载函数作为类的友元函数存在，需要一个参数，这个参数必须是类的对象（或对象的引用）。调用时参数作为函数的参数传递进去。</li>
</ul>
<p>例如，取反运算符（!）可以被重载为一个参数的非成员函数。这意味着可以将取反操作作为类的友元函数进行定义，参数为类的对象或引用。</p>
<p>例子！</p>
<p>好的，下面分别给出非成员函数和成员函数重载取反运算符的示例：</p>
<h3 id="非成员函数重载取反运算符："><a href="#非成员函数重载取反运算符：" class="headerlink" title="非成员函数重载取反运算符："></a>非成员函数重载取反运算符：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">bool</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 友元声明</span></span><br><span class="line">    <span class="keyword">friend</span> MyClass <span class="keyword">operator</span>!(<span class="type">const</span> MyClass&amp; obj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印对象的value</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重载取反运算符为非成员函数</span></span><br><span class="line">MyClass <span class="keyword">operator</span>!(<span class="type">const</span> MyClass&amp; obj) &#123;</span><br><span class="line">    <span class="comment">// 对对象的value进行取反操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">MyClass</span>(!obj.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用重载的取反运算符</span></span><br><span class="line">    MyClass result1 = !obj1;</span><br><span class="line">    MyClass result2 = !obj2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result 1 after negation: &quot;</span>;</span><br><span class="line">    result1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result 2 after negation: &quot;</span>;</span><br><span class="line">    result2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="成员函数重载取反运算符："><a href="#成员函数重载取反运算符：" class="headerlink" title="成员函数重载取反运算符："></a>成员函数重载取反运算符：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">bool</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载取反运算符为成员函数</span></span><br><span class="line">    MyClass <span class="keyword">operator</span>!() <span class="type">const</span> &#123;</span><br><span class="line">        <span class="comment">// 对对象的value进行取反操作</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MyClass</span>(!value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印对象的value</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj1</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj2</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用重载的取反运算符</span></span><br><span class="line">    MyClass result1 = !obj1;</span><br><span class="line">    MyClass result2 = !obj2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印结果</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result 1 after negation: &quot;</span>;</span><br><span class="line">    result1.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Result 2 after negation: &quot;</span>;</span><br><span class="line">    result2.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个示例中，我们都定义了一个 <code>MyClass</code> 类，该类有一个私有成员变量 <code>value</code> 表示一个布尔值。然后，我们分别重载了取反运算符为非成员函数和成员函数。在 <code>main</code> 函数中，我们创建了两个 <code>MyClass</code> 对象 <code>obj1</code> 和 <code>obj2</code>，然后使用重载的取反运算符对它们进行取反操作，并打印出结果。</p>
<h3 id="重载前缀和后缀的递增和递减运算符"><a href="#重载前缀和后缀的递增和递减运算符" class="headerlink" title="重载前缀和后缀的递增和递减运算符"></a>重载前缀和后缀的递增和递减运算符</h3><p>重载前缀和后缀版本的递增和递减运算符时，需要注意它们的不同之处以及如何正确地实现它们。以下是一些关键点和示例代码：</p>
<h3 id="重载前缀递增运算符-i-："><a href="#重载前缀递增运算符-i-：" class="headerlink" title="重载前缀递增运算符 (++i)："></a>重载前缀递增运算符 (++i)：</h3><ul>
<li>当重载前缀递增运算符时，通常将其实现为成员函数或非成员函数。</li>
<li>成员函数的原型为 <code>T&amp; operator++();</code>，其中 <code>T</code> 是类的类型。</li>
<li>非成员函数的原型为 <code>T&amp; operator++(T&amp;);</code>，其中 <code>T</code> 是类的类型。</li>
<li>下面是一个重载前缀递增运算符的示例代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> d) : <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载前缀递增运算符为成员函数</span></span><br><span class="line">    Date&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        ++day;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载前缀递增运算符为非成员函数</span></span><br><span class="line">    <span class="keyword">friend</span> Date&amp; <span class="keyword">operator</span>++(Date&amp; d) &#123;</span><br><span class="line">        ++d.day;</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日期</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Day: &quot;</span> &lt;&lt; day &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用重载的前缀递增运算符</span></span><br><span class="line">    ++d1;</span><br><span class="line">    d1.<span class="built_in">print</span>();  <span class="comment">// 输出 Day: 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="重载后缀递增运算符-i-："><a href="#重载后缀递增运算符-i-：" class="headerlink" title="重载后缀递增运算符 (i++)："></a>重载后缀递增运算符 (i++)：</h3><ul>
<li>后缀递增运算符的区别在于，它需要一个额外的参数来区分前缀和后缀版本。</li>
<li>当重载后缀递增运算符时，通常将其实现为成员函数或非成员函数。</li>
<li>成员函数的原型为 <code>T operator++(int);</code>，其中 <code>T</code> 是类的类型。</li>
<li>非成员函数的原型为 <code>T operator++(T&amp;, int);</code>，其中 <code>T</code> 是类的类型。</li>
<li>下面是一个重载后缀递增运算符的示例代码：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Date</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Date</span>(<span class="type">int</span> d) : <span class="built_in">day</span>(d) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载后缀递增运算符为成员函数</span></span><br><span class="line">    Date <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;</span><br><span class="line">        <span class="function">Date <span class="title">temp</span><span class="params">(day)</span></span>;</span><br><span class="line">        ++day;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载后缀递增运算符为非成员函数</span></span><br><span class="line">    <span class="keyword">friend</span> Date <span class="keyword">operator</span>++(Date&amp; d, <span class="type">int</span>) &#123;</span><br><span class="line">        <span class="function">Date <span class="title">temp</span><span class="params">(d.day)</span></span>;</span><br><span class="line">        ++d.day;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印日期</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Day: &quot;</span> &lt;&lt; day &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用重载的后缀递增运算符</span></span><br><span class="line">    d1++;</span><br><span class="line">    d1.<span class="built_in">print</span>();  <span class="comment">// 输出 Day: 6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>返回局部变量的引用是一个常见的编程错误，它会导致未定义的行为（Undefined Behavior）。这个错误通常发生在函数中返回了一个对局部变量的引用，并且在函数返回后尝试使用该引用。</p>
<h3 id="为什么会出错："><a href="#为什么会出错：" class="headerlink" title="为什么会出错："></a>为什么会出错：</h3><ol>
<li><strong>生命周期问题：</strong> 局部变量是在函数内部定义的，当函数执行完毕时，这些局部变量的生命周期也会结束，它们的内存空间会被释放。</li>
<li><strong>返回引用：</strong> 如果函数返回了一个对局部变量的引用，那么在函数返回后，引用指向的内存空间已经被释放，这样使用该引用就会访问无效的内存地址。</li>
<li><strong>未定义的行为：</strong> 访问已释放的内存是未定义的行为，这意味着程序可能会出现任何不确定的行为，包括崩溃、输出错误结果等。</li>
</ol>
<h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> x; <span class="comment">// 返回对局部变量 x 的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; ref = <span class="built_in">foo</span>();</span><br><span class="line">    std::cout &lt;&lt; ref &lt;&lt; std::endl; <span class="comment">// 使用返回的引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，函数 <code>foo()</code> 返回了一个对局部变量 <code>x</code> 的引用。当 <code>foo()</code> 函数执行完毕后，<code>x</code> 的生命周期结束，它的内存空间被释放。但是在 <code>main()</code> 函数中，我们仍然尝试使用对 <code>x</code> 的引用 <code>ref</code>，这会导致未定义的行为。</p>
<h3 id="如何避免："><a href="#如何避免：" class="headerlink" title="如何避免："></a>如何避免：</h3><ul>
<li><strong>避免返回对局部变量的引用：</strong> 在函数中不要返回对局部变量的引用，而是返回一个对象或者在堆上分配内存。</li>
<li><strong>使用静态变量或静态成员变量：</strong> 如果需要返回一个固定的变量，可以使用静态变量或静态成员变量，它们的生命周期延长到程序结束。</li>
<li><strong>使用堆内存：</strong> 如果需要返回一个动态分配的对象，可以使用 <code>new</code> 关键字在堆上分配内存，并返回指向该对象的指针。</li>
</ul>
</blockquote>
<p>动态内存管理允许程序员在运行时控制对象和任何内置或用户定义类型的数组的分配和释放。这是通过使用 <code>new</code> 和 <code>delete</code> 操作符实现的。</p>
<h3 id="使用-new-分配动态内存："><a href="#使用-new-分配动态内存：" class="headerlink" title="使用 new 分配动态内存："></a>使用 <code>new</code> 分配动态内存：</h3><ul>
<li><code>new</code> 操作符用于在程序运行时动态分配所需大小的内存空间。</li>
<li>分配的对象或数组在自由存储区（也称为堆）中创建，堆是每个程序用于存储动态分配对象的一块内存区域。</li>
<li><code>new</code> 操作符返回指向分配的内存空间的指针，可以通过该指针访问该内存。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Time *ptr = <span class="keyword">new</span> Time; <span class="comment">// 分配一个 Time 对象并返回指针</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-delete-释放动态内存："><a href="#使用-delete-释放动态内存：" class="headerlink" title="使用 delete 释放动态内存："></a>使用 <code>delete</code> 释放动态内存：</h3><ul>
<li><code>delete</code> 操作符用于释放通过 <code>new</code> 分配的动态内存空间。</li>
<li>使用 <code>delete</code> 操作符时，首先调用对象的析构函数，然后释放与对象关联的内存，将其返回到自由存储区。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> ptr; <span class="comment">// 释放动态分配的对象的内存空间</span></span><br></pre></td></tr></table></figure>
<h3 id="动态分配数组："><a href="#动态分配数组：" class="headerlink" title="动态分配数组："></a>动态分配数组：</h3><ul>
<li>使用 <code>new</code> 操作符可以动态分配数组。</li>
<li>可以指定数组的大小，并使用圆括号初始化数组元素。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *gradesArray = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>](); <span class="comment">// 分配一个包含10个元素的整型数组并将其初始化为0</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-delete-释放动态分配的数组："><a href="#使用-delete-释放动态分配的数组：" class="headerlink" title="使用 delete[] 释放动态分配的数组："></a>使用 <code>delete[]</code> 释放动态分配的数组：</h3><ul>
<li>对于动态分配的数组，必须使用 <code>delete[]</code> 操作符释放内存，否则会导致内存泄漏。</li>
<li><code>delete[]</code> 操作符会先调用数组中每个对象的析构函数，然后释放与数组关联的内存。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] gradesArray; <span class="comment">// 释放动态分配的数组的内存空间</span></span><br></pre></td></tr></table></figure>
<h3 id="C-11-中的-unique-ptr："><a href="#C-11-中的-unique-ptr：" class="headerlink" title="C++11 中的 unique_ptr："></a>C++11 中的 <code>unique_ptr</code>：</h3><ul>
<li>C++11 引入了 <code>unique_ptr</code>，它是一种智能指针，用于管理动态分配的内存。</li>
<li>当 <code>unique_ptr</code> 超出作用域时，它的析构函数会自动将管理的内存返回到自由存储区。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;Time&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> Time)</span></span>; <span class="comment">// 使用 unique_ptr 管理动态分配的对象</span></span><br></pre></td></tr></table></figure>
<p>以下是使用 <code>unique_ptr</code> 进行动态内存管理的示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass constructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass destructor called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Displaying MyClass object&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 unique_ptr 动态分配一个 MyClass 对象</span></span><br><span class="line">    <span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> MyClass)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用对象的成员函数</span></span><br><span class="line">    ptr-&gt;<span class="built_in">display</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要显式释放内存，unique_ptr 超出作用域时会自动释放内存</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们创建了一个名为 <code>MyClass</code> 的类，然后使用 <code>unique_ptr</code> 动态分配了一个 <code>MyClass</code> 对象。当 <code>unique_ptr</code> 超出作用域时，它会自动释放管理的内存，因此无需显式调用 <code>delete</code>。这种自动内存管理可以避免内存泄漏和悬挂指针问题。</p>
<p>两个问题的解释：</p>
<ol>
<li><p><strong>内存泄漏</strong>：<br>内存泄漏指的是程序在分配了一块内存后，再也没有释放或回收它，导致该内存块无法再被使用，但却一直占据着内存。内存泄漏可能会导致程序运行时内存消耗过多，最终耗尽系统资源，甚至导致程序崩溃。内存泄漏通常发生在程序员忘记释放动态分配的内存、释放内存的顺序错误或者无法访问释放内存的代码路径等情况下。</p>
</li>
<li><p><strong>悬挂指针</strong>：<br>悬挂指针是指指向已被释放的内存的指针。当程序中的某个指针被释放了但没有被设置为 <code>nullptr</code> 或者被重新分配，而其他部分仍然尝试通过该指针来访问内存时，就会导致悬挂指针问题。悬挂指针可能会导致程序崩溃、数据损坏或者未定义的行为。悬挂指针的产生通常是由于指针被重复释放、指针被释放后未被置空、或者指针超出了其作用域而未被及时释放等情况引起的。</p>
</li>
</ol>
<p>下面是一个示例，展示了内存泄漏和悬挂指针问题的情况：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">memoryLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内存泄漏：未释放分配的内存</span></span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 没有 delete ptr;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">danglingPointer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 悬挂指针：释放后的内存仍被访问</span></span><br><span class="line">    <span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">delete</span> ptr;</span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; std::endl; <span class="comment">// 尝试访问已释放的内存</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内存泄漏示例</span></span><br><span class="line">    <span class="built_in">memoryLeak</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 悬挂指针示例</span></span><br><span class="line">    <span class="built_in">danglingPointer</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>memoryLeak</code> 函数展示了内存泄漏问题，因为在动态分配内存后没有释放它。而 <code>danglingPointer</code> 函数展示了悬挂指针问题，因为在释放内存后，仍然尝试通过指针访问已经释放的内存。</p>
<p>实例：<br>内置数组存在很多问题：</p>
<ol>
<li><p><strong>越界访问</strong>：</p>
<ul>
<li>程序可以很容易地访问数组的两端之外的内存，因为C++不会检查下标是否超出了数组的范围。</li>
</ul>
</li>
<li><p><strong>固定下标范围</strong>：</p>
<ul>
<li>内置数组的大小为n时，其元素必须编号为0到n-1，不允许使用其他下标范围。</li>
</ul>
</li>
<li><p><strong>无法整体输入或输出</strong>：</p>
<ul>
<li>整个内置数组无法一次性输入或输出。</li>
</ul>
</li>
<li><p><strong>无法比较</strong>：</p>
<ul>
<li>两个内置数组不能使用相等或关系运算符进行有意义的比较。</li>
</ul>
</li>
<li><p><strong>需要传递数组大小</strong>：</p>
<ul>
<li>当数组传递给处理任意大小数组的通用函数时，必须将数组的大小作为附加参数传递。</li>
</ul>
</li>
<li><p><strong>不能直接赋值</strong>：</p>
<ul>
<li>一个内置数组不能用赋值运算符直接赋值给另一个数组。</li>
</ul>
</li>
</ol>
<p>为了解决这些问题，我们可以通过类和运算符重载来实现更强大的数组功能，例如C++标准库中的<code>array</code>和<code>vector</code>类模板。在这个部分，我们将开发一个自定义的数组类，这个类相比于内置数组具有以下优点：</p>
<ul>
<li><p><strong>范围检查</strong>：</p>
<ul>
<li>实现数组范围检查，防止越界访问。</li>
</ul>
</li>
<li><p><strong>赋值运算符</strong>：</p>
<ul>
<li>允许一个数组对象通过赋值运算符赋值给另一个数组对象。</li>
</ul>
</li>
<li><p><strong>自知大小</strong>：</p>
<ul>
<li>数组对象知道自己的大小。</li>
</ul>
</li>
<li><p><strong>输入输出运算符</strong>：</p>
<ul>
<li>可以通过流提取和插入运算符分别输入和输出整个数组。</li>
</ul>
</li>
<li><p><strong>比较运算符</strong>：</p>
<ul>
<li>可以使用相等运算符<code>==</code>和不等运算符<code>!=</code>比较数组。</li>
</ul>
</li>
</ul>
<p>C++标准库中的<code>vector</code>类模板也提供了许多类似的功能。以下是一个实现自定义数组类的详细笔记和代码示例：</p>
<h3 id="Array类的实现"><a href="#Array类的实现" class="headerlink" title="Array类的实现"></a>Array类的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span> <span class="comment">// for std::out_of_range</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span>   <span class="comment">// for std::memcpy</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Array</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">size_t</span> size) : <span class="built_in">size_</span>(size), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[size]) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Destructor</span></span><br><span class="line">    ~<span class="built_in">Array</span>() &#123; <span class="keyword">delete</span>[] data_; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy constructor</span></span><br><span class="line">    <span class="built_in">Array</span>(<span class="type">const</span> Array&amp; other) : <span class="built_in">size_</span>(other.size_), <span class="built_in">data_</span>(<span class="keyword">new</span> <span class="type">int</span>[other.size_]) &#123;</span><br><span class="line">        std::<span class="built_in">memcpy</span>(data_, other.data_, size_ * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assignment operator</span></span><br><span class="line">    Array&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Array&amp; other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;other) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] data_;</span><br><span class="line">            size_ = other.size_;</span><br><span class="line">            data_ = <span class="keyword">new</span> <span class="type">int</span>[size_];</span><br><span class="line">            std::<span class="built_in">memcpy</span>(data_, other.data_, size_ * <span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Access operator with range checking</span></span><br><span class="line">    <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size_) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Index out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data_[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Const access operator with range checking</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span>&amp; <span class="keyword">operator</span>[](<span class="type">size_t</span> index) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size_) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Index out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> data_[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Equality operator</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Array&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (size_ != other.size_) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; size_; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (data_[i] != other.data_[i]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Inequality operator</span></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> Array&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> == other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stream insertion operator</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Array&amp; array) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; array.size_; ++i) &#123;</span><br><span class="line">            os &lt;&lt; array.data_[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stream extraction operator</span></span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Array&amp; array) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; array.size_; ++i) &#123;</span><br><span class="line">            is &gt;&gt; array.data_[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get size of the array</span></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> size_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> size_; <span class="comment">// size of the array</span></span><br><span class="line">    <span class="type">int</span>* data_;   <span class="comment">// pointer to the array data</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">Array <span class="title">arr1</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter 5 integers for arr1: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; arr1;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr1: &quot;</span> &lt;&lt; arr1 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    Array arr2 = arr1; <span class="comment">// Copy constructor</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr2 (copy of arr1): &quot;</span> &lt;&lt; arr2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="function">Array <span class="title">arr3</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line">    arr3 = arr1; <span class="comment">// Assignment operator</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr3 (assigned from arr1): &quot;</span> &lt;&lt; arr3 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr1 == arr2: &quot;</span> &lt;&lt; (arr1 == arr2 ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;arr1 != arr3: &quot;</span> &lt;&lt; (arr1 != arr3 ? <span class="string">&quot;true&quot;</span> : <span class="string">&quot;false&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Accessing arr1[10]: &quot;</span> &lt;&lt; arr1[<span class="number">10</span>] &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::out_of_range&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码解释-3"><a href="#代码解释-3" class="headerlink" title="代码解释"></a>代码解释</h3><ol>
<li><p><strong>构造函数和析构函数</strong>：</p>
<ul>
<li><code>Array(size_t size)</code>：构造函数，初始化数组大小并分配内存。</li>
<li><code>~Array()</code>：析构函数，释放分配的内存。</li>
</ul>
</li>
<li><p><strong>复制构造函数</strong>：</p>
<ul>
<li><code>Array(const Array&amp; other)</code>：复制构造函数，创建一个新数组并将另一个数组的数据复制到新数组中。</li>
</ul>
</li>
<li><p><strong>赋值运算符</strong>：</p>
<ul>
<li><code>Array&amp; operator=(const Array&amp; other)</code>：赋值运算符，释放当前数组的内存，然后复制另一个数组的数据。</li>
</ul>
</li>
<li><p><strong>访问运算符</strong>：</p>
<ul>
<li><code>int&amp; operator[](size_t index)</code> 和 <code>const int&amp; operator[](size_t index) const</code>：带有范围检查的访问运算符，用于访问数组元素。</li>
</ul>
</li>
<li><p><strong>比较运算符</strong>：</p>
<ul>
<li><code>bool operator==(const Array&amp; other) const</code> 和 <code>bool operator!=(const Array&amp; other) const</code>：比较运算符，用于比较两个数组是否相等或不等。</li>
</ul>
</li>
<li><p><strong>流插入和提取运算符</strong>：</p>
<ul>
<li><code>friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Array&amp; array)</code>：用于输出数组内容的流插入运算符。</li>
<li><code>friend std::istream&amp; operator&gt;&gt;(std::istream&amp; is, Array&amp; array)</code>：用于输入数组内容的流提取运算符。</li>
</ul>
</li>
<li><p><strong>获取数组大小的成员函数</strong>：</p>
<ul>
<li><code>size_t size() const</code>：返回数组的大小。</li>
</ul>
</li>
</ol>
<p>通过上述代码实现的自定义数组类，我们可以避免使用内置数组时遇到的一些常见问题，并提供更强大、更安全的功能。</p>
<blockquote>
<p>重载有一个需要注意的点就是：交换性运算符<br>为了使运算符交换性（如加法），可以将其实现为非成员函数。非成员函数可以交换其参数并调用成员函数。</p>
</blockquote>
<h3 id="类型转换与转换运算符详细笔记"><a href="#类型转换与转换运算符详细笔记" class="headerlink" title="类型转换与转换运算符详细笔记"></a>类型转换与转换运算符详细笔记</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>在C++中，类型转换是一项重要功能，允许将一种数据类型转换为另一种数据类型。对于内置类型，编译器可以执行一些自动转换。但是，对于用户定义的类型之间以及用户定义的类型和内置类型之间的转换，必须显式指定如何进行。</p>
<h4 id="转换构造函数"><a href="#转换构造函数" class="headerlink" title="转换构造函数"></a>转换构造函数</h4><p>转换构造函数是一种可以通过单个参数调用的构造函数，用于将其他类型（包括内置类型）的对象转换为特定类的对象。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 转换构造函数</span></span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123;</span><br><span class="line">        <span class="comment">// 将int类型的x转换为MyClass类型的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass obj = <span class="number">10</span>; <span class="comment">// 使用转换构造函数将int转换为MyClass对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，构造函数 <code>MyClass(int x)</code> 可以通过一个整数参数调用，因此它是一个转换构造函数。它允许将 <code>int</code> 类型的值自动转换为 <code>MyClass</code> 类型的对象。</p>
<h4 id="转换运算符（Cast-Operators）"><a href="#转换运算符（Cast-Operators）" class="headerlink" title="转换运算符（Cast Operators）"></a>转换运算符（Cast Operators）</h4><p>转换运算符，也称为类型转换运算符或强制转换运算符，是用于将一个类的对象转换为另一种类型的运算符。转换运算符必须是非静态成员函数。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换运算符，将MyClass对象转换为int</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> val = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(obj); <span class="comment">// 使用转换运算符将MyClass对象转换为int</span></span><br><span class="line">    std::cout &lt;&lt; val &lt;&lt; std::endl; <span class="comment">// 输出: 42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，<code>operator int() const</code> 是一个转换运算符，用于将 <code>MyClass</code> 类型的对象转换为 <code>int</code> 类型。转换运算符必须返回要转换的目标类型。</p>
<h4 id="转换构造函数与转换运算符的隐式调用"><a href="#转换构造函数与转换运算符的隐式调用" class="headerlink" title="转换构造函数与转换运算符的隐式调用"></a>转换构造函数与转换运算符的隐式调用</h4><p>一个很有用的特性是，当需要时，编译器可以隐式地调用转换构造函数和转换运算符来创建临时对象。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换运算符，将MyClass对象转换为int</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="built_in">printValue</span>(obj); <span class="comment">// 隐式调用转换运算符，将MyClass对象转换为int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述示例中，函数 <code>printValue</code> 需要一个 <code>int</code> 类型的参数。当我们传递 <code>MyClass</code> 对象 <code>obj</code> 时，编译器隐式地调用 <code>operator int()</code> 将 <code>MyClass</code> 对象转换为 <code>int</code>。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><strong>转换构造函数</strong> 通过单个参数调用，可以将其他类型（包括内置类型）转换为特定类的对象。</li>
<li><strong>转换运算符</strong> 是非静态成员函数，用于将一个类的对象转换为另一种类型。</li>
<li>转换运算符的返回类型是隐式的，即转换的目标类型。</li>
<li>编译器可以隐式调用转换构造函数和转换运算符来创建临时对象。</li>
</ul>
<h4 id="详细示例"><a href="#详细示例" class="headerlink" title="详细示例"></a>详细示例</h4><p><strong>转换构造函数和转换运算符结合使用的示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StringConverter</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string str;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 转换构造函数，从const char*转换为StringConverter</span></span><br><span class="line">    <span class="built_in">StringConverter</span>(<span class="type">const</span> <span class="type">char</span>* s) : <span class="built_in">str</span>(s) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换运算符，将StringConverter转换为std::string</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">std::string</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用转换构造函数</span></span><br><span class="line">    StringConverter sc = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用转换运算符</span></span><br><span class="line">    std::string stdStr = sc;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    std::cout &lt;&lt; stdStr &lt;&lt; std::endl; <span class="comment">// 输出: Hello, World!</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中：</p>
<ul>
<li>转换构造函数 <code>StringConverter(const char* s)</code> 将 <code>const char*</code> 类型转换为 <code>StringConverter</code> 对象。</li>
<li>转换运算符 <code>operator std::string() const</code> 将 <code>StringConverter</code> 对象转换为 <code>std::string</code>。</li>
</ul>
<p>有一个东西总会有问题：</p>
<h3 id="隐式转换可能引发的问题"><a href="#隐式转换可能引发的问题" class="headerlink" title="隐式转换可能引发的问题"></a>隐式转换可能引发的问题</h3><p>在C++中，隐式转换可以使代码更简洁，但也可能引发一些意想不到的问题，导致编译错误或运行时逻辑错误。下面详细解释这些问题。</p>
<h4 id="隐式转换导致的编译错误"><a href="#隐式转换导致的编译错误" class="headerlink" title="隐式转换导致的编译错误"></a>隐式转换导致的编译错误</h4><p>当编译器在不明确的上下文中进行隐式转换时，可能会产生二义性，导致编译错误。例如，当有多个重载函数或运算符存在时，编译器可能无法确定应该调用哪个版本。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func(MyClass) called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func(int) called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 编译器无法确定调用哪个版本的func</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，调用 <code>func(10)</code> 时，编译器无法确定是应该调用 <code>func(MyClass)</code> 还是 <code>func(int)</code>，因为 <code>10</code> 可以隐式转换为 <code>MyClass</code> 对象，导致编译错误。</p>
<h4 id="隐式转换导致的运行时逻辑错误"><a href="#隐式转换导致的运行时逻辑错误" class="headerlink" title="隐式转换导致的运行时逻辑错误"></a>隐式转换导致的运行时逻辑错误</h4><p>即使编译成功，隐式转换也可能导致逻辑错误。特别是在没有明确意识到隐式转换发生的情况下，代码的行为可能与预期不符。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x) : <span class="built_in">value</span>(x) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换运算符，将MyClass对象转换为int</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MyClass <span class="title">obj</span><span class="params">(<span class="number">42</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (obj) &#123; <span class="comment">// obj被隐式转换为int，然后与0比较</span></span><br><span class="line">        val = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printValue</span>(val); <span class="comment">// 输出的值可能不是预期的</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>if (obj)</code> 会隐式调用 <code>operator int()</code>，将 <code>MyClass</code> 对象转换为 <code>int</code>，然后与 <code>0</code> 进行比较。这可能不是预期的逻辑，导致 <code>val</code> 的值不是预期的 <code>100</code>。</p>
<h3 id="避免隐式转换问题的方法"><a href="#避免隐式转换问题的方法" class="headerlink" title="避免隐式转换问题的方法"></a>避免隐式转换问题的方法</h3><ol>
<li><p><strong>使用 <code>explicit</code> 关键字：</strong></p>
<p>使用 <code>explicit</code> 关键字可以防止隐式转换，只有在显式调用时才会进行转换。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">MyClass</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(MyClass obj)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func(MyClass) called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;func(int) called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">func</span>(<span class="number">10</span>); <span class="comment">// 调用func(int)，没有歧义</span></span><br><span class="line">    <span class="built_in">func</span>(<span class="built_in">MyClass</span>(<span class="number">10</span>)); <span class="comment">// 必须显式转换</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>限制转换运算符的使用：</strong></p>
<p>避免定义过多的转换运算符，尤其是那些可能导致模糊转换的运算符。</p>
</li>
<li><p><strong>明确传递参数类型：</strong></p>
<p>确保在调用函数时传递的参数类型明确，避免不必要的隐式转换。</p>
</li>
</ol>
<h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>隐式转换虽然在某些情况下提高了代码的简洁性和可读性，但也带来了潜在的编译错误和运行时逻辑错误风险。通过使用 <code>explicit</code> 关键字和限制转换运算符的使用，可以有效地避免这些问题，确保代码的正确性和可维护性。</p>
<h3 id="重载函数调用运算符（）"><a href="#重载函数调用运算符（）" class="headerlink" title="重载函数调用运算符（）"></a>重载函数调用运算符（）</h3><p>重载函数调用运算符 <code>()</code> 是 C++ 中一种强大的功能，因为它允许函数接受任意数量的用逗号分隔的参数。在自定义的类中，函数调用运算符可以用来实现各种功能，比如从字符串中选取子字符串，或者提供一个替代的数组下标访问方式。</p>
<h4 id="示例：重载函数调用运算符以选取子字符串"><a href="#示例：重载函数调用运算符以选取子字符串" class="headerlink" title="示例：重载函数调用运算符以选取子字符串"></a>示例：重载函数调用运算符以选取子字符串</h4><p>假设我们有一个自定义的 <code>String</code> 类，我们可以重载 <code>operator()</code> 来实现从字符串中选取子字符串的功能。这个操作符可以接收两个整数参数，分别表示子字符串的起始位置和长度。</p>
<h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>我们首先在 <code>String</code> 类中定义 <code>operator()</code>，该函数应该是一个非静态成员函数，并且因为选取子字符串不会修改原始字符串对象，所以它应该是一个 <code>const</code> 成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数和其他成员函数的定义</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载函数调用运算符</span></span><br><span class="line">    <span class="function">String <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> length)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查参数的合法性</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= strLength || length &lt; <span class="number">0</span> || index + length &gt; strLength) &#123;</span><br><span class="line">            <span class="comment">// 处理错误情况，比如抛出异常或返回空字符串</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">String</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 选取子字符串并返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(<span class="built_in">substr</span>(index, length));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">char</span> *strData;   <span class="comment">// 存储字符串数据的指针</span></span><br><span class="line">    <span class="type">size_t</span> strLength; <span class="comment">// 字符串长度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助函数，用于获取子字符串</span></span><br><span class="line">    <span class="function">String <span class="title">substr</span><span class="params">(<span class="type">size_t</span> index, <span class="type">size_t</span> length)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> *subStr = <span class="keyword">new</span> <span class="type">char</span>[length + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strncpy</span>(subStr, strData + index, length);</span><br><span class="line">        subStr[length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">String</span>(subStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h5><p>假设 <code>string1</code> 是一个包含字符串 “AEIOU” 的 <code>String</code> 对象，当编译器遇到表达式 <code>string1(2, 3)</code> 时，它会生成成员函数调用 <code>string1.operator()(2, 3)</code>，该调用将返回一个包含 “IOU” 的 <code>String</code> 对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">string1</span><span class="params">(<span class="string">&quot;AEIOU&quot;</span>)</span></span>;</span><br><span class="line">String subString = <span class="built_in">string1</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 返回 &quot;IOU&quot;</span></span><br></pre></td></tr></table></figure>
<h4 id="示例：重载函数调用运算符以实现二维数组的下标访问"><a href="#示例：重载函数调用运算符以实现二维数组的下标访问" class="headerlink" title="示例：重载函数调用运算符以实现二维数组的下标访问"></a>示例：重载函数调用运算符以实现二维数组的下标访问</h4><p>除了选取子字符串外，函数调用运算符还可以用来实现二维数组的下标访问。这样，我们可以用 <code>chessBoard(row, column)</code> 代替传统的 <code>chessBoard[row][column]</code> 访问方式。</p>
<h5 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h5><p>我们可以在二维数组类中定义 <code>operator()</code> 来实现这种访问方式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ChessBoard</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">ChessBoard</span>(<span class="type">size_t</span> rows, <span class="type">size_t</span> cols) : <span class="built_in">rows</span>(rows), <span class="built_in">cols</span>(cols) &#123;</span><br><span class="line">        board = <span class="keyword">new</span> <span class="type">int</span>*[rows];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            board[i] = <span class="keyword">new</span> <span class="type">int</span>[cols];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">ChessBoard</span>() &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] board[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span>[] board;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">size_t</span> row, <span class="type">size_t</span> col)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 检查参数的合法性</span></span><br><span class="line">        <span class="keyword">if</span> (row &gt;= rows || col &gt;= cols) &#123;</span><br><span class="line">            <span class="keyword">throw</span> std::<span class="built_in">out_of_range</span>(<span class="string">&quot;Index out of range&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board[row][col];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">size_t</span> rows, cols;</span><br><span class="line">    <span class="type">int</span> **board;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="使用：-1"><a href="#使用：-1" class="headerlink" title="使用："></a>使用：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ChessBoard <span class="title">chessBoard</span><span class="params">(<span class="number">8</span>, <span class="number">8</span>)</span></span>;</span><br><span class="line"><span class="built_in">chessBoard</span>(<span class="number">0</span>, <span class="number">0</span>) = <span class="number">1</span>; <span class="comment">// 访问并设置第 0 行第 0 列的元素</span></span><br><span class="line"><span class="type">int</span> value = <span class="built_in">chessBoard</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 访问第 0 行第 0 列的元素</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="Object-Oriented-Programming-Inheritance"><a href="#Object-Oriented-Programming-Inheritance" class="headerlink" title="Object-Oriented Programming: Inheritance"></a>Object-Oriented Programming: Inheritance</h2><h3 id="继承与关系"><a href="#继承与关系" class="headerlink" title="继承与关系"></a>继承与关系</h3><p>在面向对象编程中，我们通常关注系统中对象之间的共性，而不是特例。</p>
<h4 id="is-a-和-has-a-关系"><a href="#is-a-和-has-a-关系" class="headerlink" title="is-a 和 has-a 关系"></a>is-a 和 has-a 关系</h4><p><strong>is-a 关系</strong> 表示继承。在 is-a 关系中，派生类的对象也可以被视为其基类的对象。相反，<strong>has-a 关系</strong> 表示组合。</p>
<h3 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h3><p>继承是一种软件重用形式，它使得我们可以创建一个类，它吸收了现有类的数据和行为，并且增加了新的功能。我们可以指定一个新类应该继承现有类的成员。现有的类称为基类，而新的类称为派生类。派生类表示更专业化的对象组。</p>
<h3 id="C-中的继承类型"><a href="#C-中的继承类型" class="headerlink" title="C++ 中的继承类型"></a>C++ 中的继承类型</h3><p>在 C++ 中，我们有三种类型的继承：公有继承、受保护继承和私有继承。使用公有继承时，派生类的每个对象也是该派生类的基类对象。然而，基类对象不是其派生类的对象。</p>
<h3 id="继承的层次结构"><a href="#继承的层次结构" class="headerlink" title="继承的层次结构"></a>继承的层次结构</h3><p>继承关系构成了类层次结构。基类存在于与其派生类的层次关系中。一旦类在继承关系中被使用，它们就会与其他类关联起来。一个类可以成为基类，为其他类提供成员，也可以成为派生类，从其他类继承成员，或者两者兼而有之。</p>
<h4 id="继承关系示例"><a href="#继承关系示例" class="headerlink" title="继承关系示例"></a>继承关系示例</h4><p>在继承关系中，基类通常更通用，而派生类通常更具体。每个派生类对象都是其基类的对象，一个基类可以有多个派生类，因此由基类表示的对象集合通常比任何一个派生类表示的对象集合都要大。</p>
<h3 id="类图示例"><a href="#类图示例" class="headerlink" title="类图示例"></a>类图示例</h3><p>以下是一个简单的类图示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+         +------------------+</span><br><span class="line">|     基类  A      |         |    派生类 B      |</span><br><span class="line">+-------------------+         +------------------+</span><br><span class="line">|                   |         |                  |</span><br><span class="line">|  属性: int x      |         |  属性: int y    |</span><br><span class="line">|  方法: void func()|         |  方法: void func()|</span><br><span class="line">+-------------------+         +------------------+</span><br><span class="line">            |                           |</span><br><span class="line">            | 继承                    |</span><br><span class="line">            +---------------------------+</span><br><span class="line">                         |</span><br><span class="line">                         |</span><br><span class="line">              +------------------+</span><br><span class="line">              |     派生类 C     |</span><br><span class="line">              +------------------+</span><br><span class="line">              |                  |</span><br><span class="line">              |  属性: int z    |</span><br><span class="line">              |  方法: void func()|</span><br><span class="line">              +------------------+</span><br></pre></td></tr></table></figure>
<p>在上面的类图中，类 <code>B</code> 和类 <code>C</code> 继承自基类 <code>A</code>，并且类 <code>C</code> 也继承自类 <code>B</code>。</p>
<h3 id="示例：员工类的继承关系"><a href="#示例：员工类的继承关系" class="headerlink" title="示例：员工类的继承关系"></a>示例：员工类的继承关系</h3><p>我们以一个公司的工资单应用程序中的员工类型为例，来说明基类和派生类之间的关系。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类：提成员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommissionEmployee</span> &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    string firstName;</span><br><span class="line">    string lastName;</span><br><span class="line">    string socialSecurityNumber;</span><br><span class="line">    <span class="type">double</span> grossSales;</span><br><span class="line">    <span class="type">double</span> commissionRate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CommissionEmployee</span>(<span class="type">const</span> string&amp; first, <span class="type">const</span> string&amp; last, <span class="type">const</span> string&amp; ssn,</span><br><span class="line">                       <span class="type">double</span> sales = <span class="number">0.0</span>, <span class="type">double</span> rate = <span class="number">0.0</span>)</span><br><span class="line">        : <span class="built_in">firstName</span>(first), <span class="built_in">lastName</span>(last), <span class="built_in">socialSecurityNumber</span>(ssn),</span><br><span class="line">          <span class="built_in">grossSales</span>(sales), <span class="built_in">commissionRate</span>(rate) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取提成员工的工资</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">earnings</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grossSales * commissionRate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印提成员工的信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Commission employee: &quot;</span> &lt;&lt; firstName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; lastName</span><br><span class="line">             &lt;&lt; <span class="string">&quot;\nSocial security number: &quot;</span> &lt;&lt; socialSecurityNumber</span><br><span class="line">             &lt;&lt; <span class="string">&quot;\nGross sales: &quot;</span> &lt;&lt; grossSales</span><br><span class="line">             &lt;&lt; <span class="string">&quot;\nCommission rate: &quot;</span> &lt;&lt; commissionRate &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类：有底薪的提成员工</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePlusCommissionEmployee</span> : <span class="keyword">public</span> CommissionEmployee &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> baseSalary;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BasePlusCommissionEmployee</span>(<span class="type">const</span> string&amp; first, <span class="type">const</span> string&amp; last, <span class="type">const</span> string&amp; ssn,</span><br><span class="line">                               <span class="type">double</span> sales = <span class="number">0.0</span>, <span class="type">double</span> rate = <span class="number">0.0</span>, <span class="type">double</span> salary = <span class="number">0.0</span>)</span><br><span class="line">        : <span class="built_in">CommissionEmployee</span>(first, last, ssn, sales, rate), <span class="built_in">baseSalary</span>(salary) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取有底薪的提成员工的工资</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">earnings</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseSalary + CommissionEmployee::<span class="built_in">earnings</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印有底薪的提成员工的信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base-salaried &quot;</span> &lt;&lt; firstName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; lastName</span><br><span class="line">             &lt;&lt; <span class="string">&quot;\nSocial security number: &quot;</span> &lt;&lt; socialSecurityNumber</span><br><span class="line">             &lt;&lt; <span class="string">&quot;\nGross sales: &quot;</span> &lt;&lt; grossSales</span><br><span class="line">             &lt;&lt; <span class="string">&quot;\nCommission rate: &quot;</span> &lt;&lt; commissionRate</span><br><span class="line">             &lt;&lt; <span class="string">&quot;\nBase salary: &quot;</span> &lt;&lt; baseSalary &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 测试提成员工类</span></span><br><span class="line">    <span class="function">CommissionEmployee <span class="title">emp1</span><span class="params">(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="string">&quot;123-45-6789&quot;</span>, <span class="number">10000</span>, <span class="number">0.1</span>)</span></span>;</span><br><span class="line">    emp1.<span class="built_in">print</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Earnings: $&quot;</span> &lt;&lt; emp1.<span class="built_in">earnings</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试有底薪的提成员工类</span></span><br><span class="line">    <span class="function">BasePlusCommissionEmployee <span class="title">emp2</span><span class="params">(<span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="string">&quot;987-65-4321&quot;</span>, <span class="number">5000</span>, <span class="number">0.05</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line">    emp2.<span class="built_in">print</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Earnings: $&quot;</span> &lt;&lt; emp2.<span class="built_in">earnings</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们定义了基类 <code>CommissionEmployee</code> 和派生类 <code>BasePlusCommissionEmployee</code>，并进行了测试。基类表示提成员工，派生类表示有底薪的提成员工。</p>
<h3 id="使用受保护数据的注意事项："><a href="#使用受保护数据的注意事项：" class="headerlink" title="使用受保护数据的注意事项："></a><strong>使用受保护数据的注意事项：</strong></h3><ol>
<li><p><strong>性能影响：</strong></p>
<ul>
<li>继承受保护的数据成员可以提高性能，因为可以直接访问成员而无需调用设置或获取成员函数。</li>
</ul>
</li>
<li><p><strong>使用受保护数据可能引发的严重问题：</strong></p>
<ul>
<li>直接访问基类受保护数据可能导致：<ul>
<li>封装违规：派生类可以直接修改基类数据而无需使用成员函数。</li>
<li>基类与派生类之间紧密耦合：派生类可能依赖于基类实现，这可能使代码变得脆弱且难以维护。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>最佳软件工程实践：</strong></p>
<ul>
<li><strong>私有数据成员：</strong> 将数据成员声明为私有以强制封装。</li>
<li><strong>成员函数操作：</strong> 使用成员函数操作私有数据成员。</li>
<li><strong>成员初始化器：</strong> 在构造函数中使用成员初始化器来设置私有数据成员。</li>
</ul>
</li>
<li><p><strong>对类 CommissionEmployee 的更改：</strong></p>
<ul>
<li>将数据成员（<code>firstName</code>、<code>lastName</code>、<code>socialSecurityNumber</code>、<code>grossSales</code> 和 <code>commissionRate</code>）声明为私有。</li>
<li>在构造函数中使用成员初始化器设置私有数据成员。</li>
<li>提供用于访问私有数据成员的设置器和获取器函数。</li>
</ul>
</li>
<li><p><strong>对类 BasePlusCommissionEmployee 的更改：</strong></p>
<ul>
<li>重新定义成员函数以区分其与以前版本的类。</li>
<li>利用基类成员函数来操作私有数据成员。</li>
<li>示例：<ul>
<li><code>earnings</code> 函数计算基本工资加销售佣金的员工的收入，并调用 <code>CommissionEmployee</code> 的 <code>earnings</code> 函数。</li>
<li><code>print</code> 函数输出基本工资加销售佣金的员工的信息。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>良好的软件工程实践：</strong></p>
<ul>
<li><strong>代码重用性：</strong> 调用基类成员函数而不是重复代码逻辑。</li>
<li><strong>继承用法：</strong> 有效地利用继承来隐藏数据并确保一致性。</li>
</ul>
</li>
</ol>
<p>通过遵循这些实践，构建了一个良好的类层次结构，促进了代码的可重用性、可维护性和封装性。</p>
<p>以下是一些示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 CommissionEmployee 的示例代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommissionEmployee</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string firstName;</span><br><span class="line">    string lastName;</span><br><span class="line">    string socialSecurityNumber;</span><br><span class="line">    <span class="type">double</span> grossSales;</span><br><span class="line">    <span class="type">double</span> commissionRate;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CommissionEmployee</span>(string first, string last, string ssn, <span class="type">double</span> sales, <span class="type">double</span> rate)</span><br><span class="line">        : <span class="built_in">firstName</span>(first), <span class="built_in">lastName</span>(last), <span class="built_in">socialSecurityNumber</span>(ssn), <span class="built_in">grossSales</span>(sales), <span class="built_in">commissionRate</span>(rate) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFirstName</span><span class="params">(string first)</span> </span>&#123; firstName = first; &#125;</span><br><span class="line">    <span class="function">string <span class="title">getFirstName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line">    <span class="comment">// 同样的方式实现其他设置器和获取器函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类 BasePlusCommissionEmployee 的示例代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePlusCommissionEmployee</span> : <span class="keyword">public</span> CommissionEmployee &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> baseSalary;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BasePlusCommissionEmployee</span>(string first, string last, string ssn, <span class="type">double</span> sales, <span class="type">double</span> rate, <span class="type">double</span> salary)</span><br><span class="line">        : <span class="built_in">CommissionEmployee</span>(first, last, ssn, sales, rate), <span class="built_in">baseSalary</span>(salary) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">earnings</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseSalary + (grossSales * commissionRate);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; <span class="built_in">getFirstName</span>() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">getLastName</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Social Security Number: &quot;</span> &lt;&lt; <span class="built_in">getSocialSecurityNumber</span>() &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Gross Sales: &quot;</span> &lt;&lt; grossSales &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Commission Rate: &quot;</span> &lt;&lt; commissionRate &lt;&lt; endl;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base Salary: &quot;</span> &lt;&lt; baseSalary &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="派生类对象的构造和析构过程："><a href="#派生类对象的构造和析构过程：" class="headerlink" title="派生类对象的构造和析构过程："></a><strong>派生类对象的构造和析构过程：</strong></h3><ol>
<li><p><strong>构造过程：</strong></p>
<ul>
<li>实例化一个派生类对象会启动一个构造函数调用链，在此链中，派生类的构造函数在执行自己的任务之前，显式（通过基类成员初始化器）或隐式（调用基类的默认构造函数）地调用其直接基类的构造函数。</li>
<li>如果基类又派生自另一个类，则基类的构造函数需要调用层次结构中更高一级的类的构造函数，依次类推。</li>
<li>在此链中，最后一个调用的构造函数是层次结构底部类的构造函数，其实际完成执行的顺序最早。</li>
<li>最派生类的构造函数的体最后执行。</li>
</ul>
</li>
<li><p><strong>析构过程：</strong></p>
<ul>
<li>当销毁一个派生类对象时，程序会调用该对象的析构函数。</li>
<li>这会启动一个析构函数调用链（或级联），其中派生类的析构函数以及直接和间接基类的析构函数以及这些类的成员的析构函数按照构造函数执行的顺序的相反顺序执行。</li>
<li>当调用派生类对象的析构函数时，析构函数会执行其任务，然后调用层次结构中更高一级的基类的析构函数。</li>
<li>这个过程重复直到调用了层次结构顶部的最后一个基类的析构函数，然后对象从内存中删除。</li>
</ul>
</li>
</ol>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> baseValue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">int</span> value) : <span class="built_in">baseValue</span>(value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Constructor. BaseValue: &quot;</span> &lt;&lt; baseValue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Destructor. BaseValue: &quot;</span> &lt;&lt; baseValue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Intermediate</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string intermediateName;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Intermediate</span>(<span class="type">int</span> value, <span class="type">const</span> std::string&amp; name) : <span class="built_in">Base</span>(value), <span class="built_in">intermediateName</span>(name) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Intermediate Constructor. Name: &quot;</span> &lt;&lt; intermediateName &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Intermediate</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Intermediate Destructor. Name: &quot;</span> &lt;&lt; intermediateName &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Intermediate &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> derivedValue;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">int</span> value, <span class="type">const</span> std::string&amp; name, <span class="type">double</span> dValue) : <span class="built_in">Intermediate</span>(value, name), <span class="built_in">derivedValue</span>(dValue) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Constructor. DerivedValue: &quot;</span> &lt;&lt; derivedValue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Destructor. DerivedValue: &quot;</span> &lt;&lt; derivedValue &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Creating Derived Object...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="function">Derived <span class="title">derivedObj</span><span class="params">(<span class="number">10</span>, <span class="string">&quot;DerivedObject&quot;</span>, <span class="number">3.14</span>)</span></span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Derived Object Created.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nDestroying Derived Object...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 当程序执行结束时，对象的析构函数被调用。</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ol>
<li>定义了三个类：<code>Base</code>、<code>Intermediate</code> 和 <code>Derived</code>，它们分别代表层次结构中的基类、中间类和派生类。</li>
<li>每个类都有一个构造函数和一个析构函数，用于在对象的创建和销毁时执行相应的操作。</li>
<li>在 <code>main</code> 函数中，创建了一个 <code>Derived</code> 类对象 <code>derivedObj</code>，实例化过程会启动构造函数调用链。首先调用 <code>Base</code> 类构造函数，然后是 <code>Intermediate</code> 类构造函数，最后是 <code>Derived</code> 类构造函数。每个构造函数都会输出相应的信息。</li>
<li>然后程序运行结束时，会销毁 <code>derivedObj</code> 对象，析构函数调用链会按照相反的顺序执行，首先调用 <code>Derived</code> 类析构函数，然后是 <code>Intermediate</code> 类析构函数，最后是 <code>Base</code> 类析构函数。每个析构函数都会输出相应的信息。</li>
</ol>
<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Creating Derived Object...</span><br><span class="line">Base Constructor. BaseValue: 10</span><br><span class="line">Intermediate Constructor. Name: DerivedObject</span><br><span class="line">Derived Constructor. DerivedValue: 3.14</span><br><span class="line">Derived Object Created.</span><br><span class="line"></span><br><span class="line">Destroying Derived Object...</span><br><span class="line">Derived Destructor. DerivedValue: 3.14</span><br><span class="line">Intermediate Destructor. Name: DerivedObject</span><br><span class="line">Base Destructor. BaseValue: 10</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>构造函数、析构函数和重载的赋值运算符不会被继承：</strong><ul>
<li>派生类不会继承基类的构造函数、析构函数和重载的赋值运算符。</li>
<li>然而，派生类的构造函数、析构函数和重载的赋值运算符可以调用基类版本。</li>
</ul>
</li>
</ol>
<p>下面是一个具体的代码示例，说明派生类的构造函数、析构函数和重载的赋值运算符不会被继承，但可以调用基类版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Base</span>(<span class="type">const</span> Base&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Copy Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Base</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Base&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Assignment Operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类的构造函数不会继承基类的构造函数</span></span><br><span class="line">    <span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 派生类的析构函数不会继承基类的析构函数</span></span><br><span class="line">    ~<span class="built_in">Derived</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Destructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 派生类可以调用基类的构造函数</span></span><br><span class="line">    <span class="built_in">Derived</span>(<span class="type">const</span> Base&amp; other) : <span class="built_in">Base</span>(other) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Copy Constructor&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 派生类可以调用基类的重载赋值运算符</span></span><br><span class="line">    Derived&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Base&amp; other) &#123;</span><br><span class="line">        Base::<span class="keyword">operator</span>=(other);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Assignment Operator&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Creating Base Object...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Base baseObj;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nCreating Derived Object...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nAssigning Base Object to Derived Object...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    derivedObj = baseObj;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nEnd of Program.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ol>
<li><code>Base</code> 类具有默认构造函数、复制构造函数、析构函数和重载的赋值运算符。</li>
<li><code>Derived</code> 类继承了 <code>Base</code> 类。</li>
<li>在 <code>main</code> 函数中创建了 <code>Base</code> 类对象 <code>baseObj</code> 和 <code>Derived</code> 类对象 <code>derivedObj</code>。</li>
<li>创建 <code>Base</code> 类对象时，会调用 <code>Base</code> 类的构造函数，输出 “Base Constructor”。</li>
<li>创建 <code>Derived</code> 类对象时，会先调用 <code>Base</code> 类的构造函数，然后调用 <code>Derived</code> 类的构造函数，输出 “Base Constructor” 和 “Derived Constructor”。</li>
<li>将 <code>Base</code> 类对象赋值给 <code>Derived</code> 类对象时，会调用 <code>Base</code> 类的赋值运算符，输出 “Base Assignment Operator” 和 “Derived Assignment Operator”。</li>
</ol>
<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Creating Base Object...</span><br><span class="line">Base Constructor</span><br><span class="line"></span><br><span class="line">Creating Derived Object...</span><br><span class="line">Base Constructor</span><br><span class="line">Derived Constructor</span><br><span class="line"></span><br><span class="line">Assigning Base Object to Derived Object...</span><br><span class="line">Base Assignment Operator</span><br><span class="line">Derived Assignment Operator</span><br><span class="line"></span><br><span class="line">End of Program.</span><br></pre></td></tr></table></figure>
<p>以上代码示例说明了派生类的构造函数、析构函数和重载的赋值运算符不会继承，但可以调用基类版本。</p>
<h3 id="C-11中的基类构造函数继承："><a href="#C-11中的基类构造函数继承：" class="headerlink" title="C++11中的基类构造函数继承："></a><strong>C++11中的基类构造函数继承：</strong></h3><ol>
<li><p><strong>继承基类构造函数：</strong></p>
<ul>
<li>有时，派生类的构造函数只是模仿基类的构造函数。</li>
<li>C++11中引入的一个经常被请求的便利功能是能够继承基类的构造函数。</li>
<li>现在可以通过在派生类定义中显式包含形如 <code>using BaseClass::BaseClass;</code> 的using声明来实现这一点。</li>
<li>在这个声明中，BaseClass是基类的名称。</li>
</ul>
</li>
<li><p><strong>注意事项：</strong></p>
<ul>
<li>默认情况下，每个继承的构造函数的访问级别（public、protected或private）与其对应的基类构造函数相同。</li>
<li>默认、拷贝和移动构造函数不会被继承。</li>
<li>如果在基类中通过在原型中放置 <code>= delete</code> 来删除一个构造函数，则派生类中对应的构造函数也会被删除。</li>
<li>如果派生类没有显式定义构造函数，编译器会在派生类中生成默认构造函数，即使它从基类继承了其他构造函数。</li>
<li>如果你在派生类中显式定义一个与基类构造函数具有相同参数列表的构造函数，那么基类构造函数不会被继承。</li>
<li>基类构造函数的默认参数不会被继承，而是由编译器在派生类中生成重载的构造函数。</li>
</ul>
</li>
</ol>
<p><strong>基类成员的可访问性总结：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>基类访问说明</th>
<th>公有继承</th>
<th>保护继承</th>
<th>私有继承</th>
</tr>
</thead>
<tbody>
<tr>
<td>公有成员</td>
<td>公有</td>
<td>保护</td>
<td>私有</td>
</tr>
<tr>
<td>保护成员</td>
<td>保护</td>
<td>保护</td>
<td>私有</td>
</tr>
<tr>
<td>私有成员</td>
<td>不可见</td>
<td>不可见</td>
<td>不可见</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>使用保护和私有继承的情况较为罕见，通常使用公有继承。</strong></p>
</blockquote>
<h3 id="继承的作用："><a href="#继承的作用：" class="headerlink" title="继承的作用："></a><strong>继承的作用：</strong></h3><p>当我们使用继承从一个现有类创建一个新类时，新类会继承现有类的数据成员和成员函数。我们可以通过重新定义基类成员和添加额外成员来定制新类，而不需要访问基类的源代码。派生类程序员可以在C++中实现这一点，而不必访问基类的源代码（派生类必须能够链接到基类的目标代码）。</p>
<p><strong>具体笔记：</strong></p>
<p>通过继承，新类可以利用现有类的功能，并在此基础上进行扩展和定制。下面是一个示例说明：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baseFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Base Function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类，继承自基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 新的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derivedFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Derived Function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新定义基类的成员函数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">baseFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Redefined Base Function&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用基类的成员函数</span></span><br><span class="line">    derivedObj.<span class="built_in">baseFunction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用派生类的成员函数</span></span><br><span class="line">    derivedObj.<span class="built_in">derivedFunction</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码示例解释：</strong></p>
<ul>
<li>我们定义了一个基类 <code>Base</code>，其中包含一个成员函数 <code>baseFunction</code>。</li>
<li>然后，我们创建了一个派生类 <code>Derived</code>，它继承了基类 <code>Base</code>。</li>
<li>在派生类中，我们添加了一个新的成员函数 <code>derivedFunction</code>。</li>
<li>我们还重新定义了基类的成员函数 <code>baseFunction</code>，以便在派生类中定制它。</li>
<li>在 <code>main</code> 函数中，我们创建了一个 <code>Derived</code> 类对象 <code>derivedObj</code>，并演示了如何调用基类和派生类的成员函数。</li>
</ul>
<p><strong>运行结果：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Redefined Base Function</span><br><span class="line">Derived Function</span><br></pre></td></tr></table></figure>
<p><strong>继承与软件开发的相关知识点：</strong></p>
<ol>
<li><p><strong>开发专有类（Proprietary Classes）：</strong></p>
<ul>
<li>软件开发人员可以开发专有类，用于销售或许可。</li>
<li>用户可以快速从这些库类派生新类，而无需访问专有源代码。</li>
<li>软件开发人员需要提供头文件以及目标代码（object code）。</li>
</ul>
</li>
<li><p><strong>类库的重要性：</strong></p>
<ul>
<li>大量且有用的类库的可用性通过继承实现了最大的软件重用优势。</li>
<li>类库中包含了常见的功能和模块，开发人员可以通过继承和定制来快速构建新的应用程序。</li>
</ul>
</li>
<li><p><strong>设计阶段的继承使用：</strong></p>
<ul>
<li>在面向对象系统的设计阶段，设计师通常确定某些类之间存在密切关联。</li>
<li>设计师应该将共同的属性和行为“分离”出来，并将它们放置在一个基类中，然后使用继承形成派生类。</li>
<li>这种设计方式有助于提高代码的可维护性和灵活性，同时也提高了代码的复用性。</li>
</ul>
</li>
<li><p><strong>继承的影响：</strong></p>
<ul>
<li>创建派生类不会影响其基类的源代码。</li>
<li>继承保持了基类的完整性，使得基类的功能和行为得以保留和使用。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="Object-Oriented-Programming-Polymorphism"><a href="#Object-Oriented-Programming-Polymorphism" class="headerlink" title="Object-Oriented Programming: Polymorphism"></a>Object-Oriented Programming: Polymorphism</h2><blockquote>
<p>多态性使我们能够“以通用方式编程”而不是“以具体方式编程”。<br>它使我们能够编写处理属于同一类层次结构的类对象的程序，就好像它们都是该层次结构的基类对象一样。<br>多态性基于基类指针句柄和基类引用句柄工作，但不基于名称句柄。<br>依靠每个对象知道如何在对相同函数调用的响应中“做正确的事情”是多态性的关键概念。<br>发送给各种对象的相同消息具有“多种形式”的结果，因此称为多态性。<br>通过多态性，我们可以设计和实现易于扩展的系统。<br>只要新类是程序通常处理的继承层次结构的一部分，就可以很少或几乎不修改程序的一般部分来添加新类。<br>必须更改的程序部分仅是需要直接了解您将添加到层次结构的新类的部分。</p>
</blockquote>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><blockquote>
<p>多态性使您能够处理通用性，并让执行时环境处理具体细节。您可以使各种对象按照其自身特定的行为方式行事，而无需了解它们的类型 - 只要这些对象属于相同的继承层次结构，并且通过一个公共基类指针或一个公共基类引用进行访问。多态性促进了以下方面的发展：</p>
<p><strong>可扩展性（Extensibility）</strong>：编写用于调用多态行为的软件与发送消息的对象的特定类型无关。因此，新类型的对象可以响应现有消息并纳入到系统中，而无需修改基本系统。只需修改实例化新对象的客户端代码即可适应新类型。</p>
</blockquote>
<p>这一系列示例演示了如何使用基类和派生类指针来指向基类和派生类对象，并且如何使用这些指针来调用操作这些对象的成员函数。这些示例的关键概念是展示派生类对象可以被视为基类对象。尽管派生类对象是不同类型的，但编译器允许这样做，因为每个派生类对象都是其基类对象。然而，我们不能将基类对象视为其任何派生类的对象。is-a关系仅适用于从派生类到其直接和间接基类的情况。</p>
<p>在示例中，我们创建了类CommissionEmployee和BasePlusCommissionEmployee的最终版本。</p>
<ul>
<li>首先，我们将一个基类指针指向一个基类对象，并调用基类的功能。</li>
<li>然后，我们将一个派生类指针指向一个派生类对象，并调用派生类的功能。</li>
<li>接着，我们演示了派生类和基类之间的关系（即继承中的is-a关系），将一个基类指针指向一个派生类对象，并展示了在派生类对象中确实可用的基类功能。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommissionEmployee.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> COMMISSIONEMPLOYEE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> COMMISSIONEMPLOYEE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommissionEmployee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CommissionEmployee</span>(<span class="type">const</span> std::string&amp; first, <span class="type">const</span> std::string&amp; last, <span class="type">const</span> std::string&amp; ssn, <span class="type">double</span> sales = <span class="number">0.0</span>, <span class="type">double</span> rate = <span class="number">0.0</span>)</span><br><span class="line">        : <span class="built_in">firstName</span>(first), <span class="built_in">lastName</span>(last), <span class="built_in">socialSecurityNumber</span>(ssn) &#123;</span><br><span class="line">        <span class="built_in">setGrossSales</span>(sales);</span><br><span class="line">        <span class="built_in">setCommissionRate</span>(rate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFirstName</span><span class="params">(<span class="type">const</span> std::string&amp; first)</span> </span>&#123; firstName = first; &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getFirstName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLastName</span><span class="params">(<span class="type">const</span> std::string&amp; last)</span> </span>&#123; lastName = last; &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getLastName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> lastName; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSocialSecurityNumber</span><span class="params">(<span class="type">const</span> std::string&amp; ssn)</span> </span>&#123; socialSecurityNumber = ssn; &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getSocialSecurityNumber</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> socialSecurityNumber; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setGrossSales</span><span class="params">(<span class="type">double</span> sales)</span> </span>&#123; grossSales = (sales &lt; <span class="number">0.0</span>) ? <span class="number">0.0</span> : sales; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getGrossSales</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> grossSales; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setCommissionRate</span><span class="params">(<span class="type">double</span> rate)</span> </span>&#123; commissionRate = (rate &gt; <span class="number">0.0</span> &amp;&amp; rate &lt; <span class="number">1.0</span>) ? rate : <span class="number">0.0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getCommissionRate</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> commissionRate; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">earnings</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> commissionRate * grossSales; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;commission employee: &quot;</span> &lt;&lt; firstName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; lastName</span><br><span class="line">            &lt;&lt; <span class="string">&quot;\nsocial security number: &quot;</span> &lt;&lt; socialSecurityNumber</span><br><span class="line">            &lt;&lt; <span class="string">&quot;\ngross sales: &quot;</span> &lt;&lt; grossSales</span><br><span class="line">            &lt;&lt; <span class="string">&quot;\ncommission rate: &quot;</span> &lt;&lt; commissionRate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string firstName;</span><br><span class="line">    std::string lastName;</span><br><span class="line">    std::string socialSecurityNumber;</span><br><span class="line">    <span class="type">double</span> grossSales;</span><br><span class="line">    <span class="type">double</span> commissionRate;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// COMMISSIONEMPLOYEE_H</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BasePlusCommissionEmployee.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BASEPLUSCOMMISSIONEMPLOYEE_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASEPLUSCOMMISSIONEMPLOYEE_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CommissionEmployee.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BasePlusCommissionEmployee</span> : <span class="keyword">public</span> CommissionEmployee &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BasePlusCommissionEmployee</span>(<span class="type">const</span> std::string&amp; first, <span class="type">const</span> std::string&amp; last, <span class="type">const</span> std::string&amp; ssn, <span class="type">double</span> sales = <span class="number">0.0</span>, <span class="type">double</span> rate = <span class="number">0.0</span>, <span class="type">double</span> salary = <span class="number">0.0</span>)</span><br><span class="line">        : <span class="built_in">CommissionEmployee</span>(first, last, ssn, sales, rate), <span class="built_in">baseSalary</span>(salary) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setBaseSalary</span><span class="params">(<span class="type">double</span> salary)</span> </span>&#123; baseSalary = (salary &lt; <span class="number">0.0</span>) ? <span class="number">0.0</span> : salary; &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBaseSalary</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> baseSalary; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">earnings</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">getBaseSalary</span>() + CommissionEmployee::<span class="built_in">earnings</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;base-salaried &quot;</span> &lt;&lt; CommissionEmployee::<span class="built_in">getFirstName</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; CommissionEmployee::<span class="built_in">getLastName</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;\nsocial security number: &quot;</span> &lt;&lt; CommissionEmployee::<span class="built_in">getSocialSecurityNumber</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;\ngross sales: &quot;</span> &lt;&lt; CommissionEmployee::<span class="built_in">getGrossSales</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;\ncommission rate: &quot;</span> &lt;&lt; CommissionEmployee::<span class="built_in">getCommissionRate</span>()</span><br><span class="line">            &lt;&lt; <span class="string">&quot;\nbase salary: &quot;</span> &lt;&lt; baseSalary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> baseSalary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">// BASEPLUSCOMMISSIONEMPLOYEE_H</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CommissionEmployee.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;BasePlusCommissionEmployee.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">CommissionEmployee <span class="title">commissionEmployee</span><span class="params">(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="string">&quot;123-45-6789&quot;</span>, <span class="number">5000</span>, <span class="number">.05</span>)</span></span>;</span><br><span class="line">    <span class="function">BasePlusCommissionEmployee <span class="title">basePlusCommissionEmployee</span><span class="params">(<span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="string">&quot;987-65-4321&quot;</span>, <span class="number">3000</span>, <span class="number">.04</span>, <span class="number">300</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    CommissionEmployee* commissionEmployeePtr = &amp;commissionEmployee;</span><br><span class="line">    BasePlusCommissionEmployee* basePlusCommissionEmployeePtr = &amp;basePlusCommissionEmployee;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Aiming a Base-Class Pointer at a Base-Class Object</span></span><br><span class="line">    commissionEmployeePtr-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Aiming a Derived-Class Pointer at a Derived-Class Object</span></span><br><span class="line">    basePlusCommissionEmployeePtr-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Aiming a Base-Class Pointer at a Derived-Class Object</span></span><br><span class="line">    commissionEmployeePtr = &amp;basePlusCommissionEmployee;</span><br><span class="line">    commissionEmployeePtr-&gt;<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将基类指针<code>commissionEmployeePtr</code>指向基类对象<code>commissionEmployee</code>，然后调用<code>print</code>成员函数，这会调用基类<code>CommissionEmployee</code>中定义的<code>print</code>版本。</li>
<li>将派生类指针<code>basePlusCommissionEmployeePtr</code>指向派生类对象<code>basePlusCommissionEmployee</code>，然后调用<code>print</code>成员函数，这会调用派生类<code>BasePlusCommissionEmployee</code>中定义的<code>print</code>版本。</li>
<li>将基类指针<code>commissionEmployeePtr</code>指向派生类对象<code>basePlusCommissionEmployee</code>，然后调用<code>print</code>成员函数，这依然会调用基类<code>CommissionEmployee</code>中定义的<code>print</code>版本，而不是派生类<code>BasePlusCommissionEmployee</code>中的版本。</li>
</ul>
<p>这些成员函数的调用表明，调用的功能取决于用于调用函数的指针（或引用）的类型，而不是调用成员函数的对象的类型。</p>
<p>如果我们尝试将一个派生类指针指向一个基类对象。具体来说，我们将一个指向<code>BasePlusCommissionEmployee</code>类的指针试图指向一个<code>CommissionEmployee</code>类的对象。</p>
<p>在C++中，指针之间的赋值需要满足类型兼容性的要求。基类指针可以指向派生类对象，因为派生类对象包含了基类的所有成员，但是派生类指针却不能指向基类对象。这是因为派生类可能包含了基类没有的成员或者行为，如果允许将派生类指针指向基类对象，那么在访问派生类特有的成员时会出现问题。</p>
<p>因此，尝试将一个指向基类对象的指针赋值给一个指向派生类的指针会导致编译器报错，提示类型不匹配。这是编译器对类型安全性的一种保护机制，确保在程序中正确使用基类和派生类的关系。</p>
<p>在C++中，通过向下转型（downcasting），可以将基类指针或引用转换为指向派生类的指针或引用，从而访问派生类特有的成员函数或数据成员。下面是一个简单的示例：</p>
<p>假设我们有一个基类 <code>Shape</code> 和一个派生类 <code>Circle</code>，并且 <code>Circle</code> 类有一个特有的成员函数 <code>getRadius()</code>。首先，我们创建一个指向基类对象的指针，并将其指向一个派生类对象。然后，我们使用向下转型将基类指针转换为指向派生类的指针，从而调用派生类的特有函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Shape\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Circle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Circle\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getRadius</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Radius: 5\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个指向基类对象的指针，并将其指向一个派生类对象</span></span><br><span class="line">    Shape* shapePtr = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 向下转型</span></span><br><span class="line">    Circle* circlePtr = <span class="built_in">dynamic_cast</span>&lt;Circle*&gt;(shapePtr);</span><br><span class="line">    <span class="keyword">if</span> (circlePtr) &#123;</span><br><span class="line">        <span class="comment">// 调用派生类特有的成员函数</span></span><br><span class="line">        circlePtr-&gt;<span class="built_in">getRadius</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Failed to cast to Circle\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> shapePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们使用 <code>dynamic_cast</code> 将 <code>shapePtr</code> 指针转换为 <code>Circle</code> 类型的指针 <code>circlePtr</code>。然后，我们检查是否成功进行了转型。如果成功，我们就可以使用 <code>circlePtr</code> 指针来调用派生类特有的成员函数 <code>getRadius()</code>。需要注意的是，向下转型只有在基类指针指向的确实是派生类对象时才会成功。</p>
<p>在C++中，虚函数（virtual functions）的使用非常有用。假设我们有一个基类 <code>Shape</code> 和一些派生类，如 <code>Circle</code>、<code>Triangle</code>、<code>Rectangle</code> 和 <code>Square</code>，每个派生类都可能具有绘制自身的能力，但每个形状的绘制方式可能会有所不同。在一个绘制形状的程序中，我们希望能够将所有形状都当作基类 <code>Shape</code> 的对象来处理。为了实现这一点，我们可以声明基类中的绘制函数为虚函数，并在每个派生类中重写该函数，以实现多态行为。</p>
<p>以下是一个简单示例，展示了如何使用虚函数来实现多态行为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Circle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Triangle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a triangle\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapes[<span class="number">2</span>]; <span class="comment">// 基类指针数组</span></span><br><span class="line">    shapes[<span class="number">0</span>] = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shapes[<span class="number">1</span>] = <span class="keyword">new</span> <span class="built_in">Triangle</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过基类指针调用虚函数，实现多态行为</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        shapes[i]-&gt;<span class="built_in">draw</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">delete</span> shapes[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们通过基类指针数组存储了两个派生类的对象，并使用循环来调用基类的虚函数 <code>draw()</code>。尽管我们只有一个指针类型，但在运行时，程序会根据实际对象的类型来动态选择调用相应的派生类函数，从而实现多态行为。</p>
<p>这种动态绑定或者晚绑定（dynamic binding or late binding）是虚函数的重要特性之一。另外，值得注意的是，如果通过对象名和点运算符来调用虚函数，那么函数调用会在编译时（静态绑定）解析，这时调用的是对象所属类的函数，而不是实现了多态行为。<br>在C++中，一旦一个函数被声明为虚函数，它将一直保持虚函数的属性，直到继承层次结构的最底层。即使在派生类覆盖该函数时没有显式地声明为虚函数，在继承层次结构中的后续类中，该函数仍然会被视为虚函数。</p>
<p>尽管某些函数由于在类层次结构的更高层次上的声明而隐式成为虚函数，但为了提高程序的清晰度，建议在类层次结构的每个级别都显式声明这些函数为虚函数。</p>
<p>当派生类选择不覆盖基类的虚函数时，派生类会简单地继承基类的虚函数实现。</p>
<p>在C++11中，可以使用 <code>override</code> 关键字来标记派生类中重写的每个虚函数。这样做会强制编译器检查基类是否有与之相同名称和参数列表（即相同签名）的成员函数。如果没有，则编译器会生成一个错误。</p>
<p>示例代码，演示了如何使用 <code>override</code> 关键字：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a shape\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类 Circle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Circle circle;</span><br><span class="line">    circle.<span class="built_in">draw</span>(); <span class="comment">// 调用派生类的虚函数</span></span><br><span class="line">    </span><br><span class="line">    Shape&amp; shapeRef = circle; <span class="comment">// 基类引用指向派生类对象</span></span><br><span class="line">    shapeRef.<span class="built_in">draw</span>(); <span class="comment">// 通过基类引用调用虚函数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们显式地使用了 <code>override</code> 关键字来重写基类 <code>Shape</code> 中的 <code>draw()</code> 函数。这样做可以提高代码的清晰度，并让编译器能够在派生类中进行更严格的检查。</p>
<blockquote>
<p>使用 switch 语句来检查对象的字段值以确定对象类型是一种常见的方法。这允许我们区分对象类型，然后针对特定对象执行适当的操作。然而，使用 switch 逻辑会暴露程序面临各种潜在问题。例如，可能会忘记在必要时包含类型测试，或者可能会忘记在 switch 语句中测试所有可能的情况。当通过添加新类型来修改基于 switch 的系统时，可能会忘记在所有相关的 switch 语句中插入新的情况。每次添加或删除一个类都需要修改系统中的每个 switch 语句；追踪这些语句可能会耗费大量时间并且容易出错。</p>
<p>多态编程可以消除对 switch 逻辑的需求。通过使用多态机制执行等效逻辑，可以避免与 switch 逻辑通常相关的各种错误。使用多态的一个有趣后果是，程序呈现出更简化的外观。它们包含更少的分支逻辑和更简单的顺序代码。</p>
</blockquote>
<p>抽象类是指那些你不打算实例化任何对象的类。这样的类通常被称为抽象基类，因为它们通常用作继承层次结构中的基类。这些类不能用来实例化对象，因为抽象类是不完整的——派生类必须定义“缺失的部分”。抽象类是其他类可以继承的基类。可以用来实例化对象的类称为具体类。这些类定义了它们声明的每个成员函数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>; <span class="comment">// pure virtual function</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shapePtr = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>(); <span class="comment">// Output: Drawing a circle</span></span><br><span class="line"></span><br><span class="line">    shapePtr = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line">    shapePtr-&gt;<span class="built_in">draw</span>(); <span class="comment">// Output: Drawing a rectangle</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shapePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象基类通过声明一个或多个虚函数为“纯虚函数”来定义。纯虚函数的声明中会使用“= 0”，例如 <code>virtual void draw() const = 0;</code>。纯虚函数通常不提供实现，虽然它们可以。每个具体的派生类必须重写所有基类的纯虚函数，否则该派生类也会是抽象的。虚函数和纯虚函数的区别在于，虚函数有一个实现，并且让派生类有选择地覆盖该函数。相比之下，纯虚函数没有实现，要求派生类为了变成具体类而必须重写该函数。纯虚函数在基类没有实现函数的情况下使用，但是你希望所有具体的派生类都实现该函数。</p>
<p>尽管我们不能实例化抽象基类的对象，但我们可以使用抽象基类声明指针和引用，这些指针和引用可以引用从抽象类派生出的任何具体类的对象。程序通常使用这些指针和引用以多态方式操作派生类对象。</p>
<blockquote>
<p>纯虚函数是一种在C++中使用的特殊类型的虚函数。它的本质是定义了一个接口或协议，但没有提供具体的实现。换句话说，纯虚函数没有函数体，只有函数的声明，且在声明的结尾处使用 “= 0” 表示。这使得纯虚函数成为抽象基类的一部分，因为它要求任何派生类都必须提供对该函数的具体实现，以便被实例化。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="built_in">Employee</span>(<span class="type">const</span> std::string&amp; firstName, <span class="type">const</span> std::string&amp; lastName, <span class="type">const</span> std::string&amp; socialSecurityNumber)</span><br><span class="line">        : <span class="built_in">firstName</span>(firstName), <span class="built_in">lastName</span>(lastName), <span class="built_in">socialSecurityNumber</span>(socialSecurityNumber) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Virtual destructor</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Employee</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set functions</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFirstName</span><span class="params">(<span class="type">const</span> std::string&amp; firstName)</span> </span>&#123; <span class="keyword">this</span>-&gt;firstName = firstName; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLastName</span><span class="params">(<span class="type">const</span> std::string&amp; lastName)</span> </span>&#123; <span class="keyword">this</span>-&gt;lastName = lastName; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSocialSecurityNumber</span><span class="params">(<span class="type">const</span> std::string&amp; socialSecurityNumber)</span> </span>&#123; <span class="keyword">this</span>-&gt;socialSecurityNumber = socialSecurityNumber; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get functions</span></span><br><span class="line">    <span class="function">std::string <span class="title">getFirstName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> firstName; &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getLastName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> lastName; &#125;</span><br><span class="line">    <span class="function">std::string <span class="title">getSocialSecurityNumber</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> socialSecurityNumber; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pure virtual function for calculating earnings</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">earnings</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Virtual function to print employee information</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Employee: &quot;</span> &lt;&lt; <span class="built_in">getFirstName</span>() &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; <span class="built_in">getLastName</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;Social Security Number: &quot;</span> &lt;&lt; <span class="built_in">getSocialSecurityNumber</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string firstName;</span><br><span class="line">    std::string lastName;</span><br><span class="line">    std::string socialSecurityNumber;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Derived classes for specific types of employees will override the earnings function and possibly the print function</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;Employee.h&quot;</span> <span class="comment">// Include the header file for the Employee class</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Derived class for salaried employees</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalariedEmployee</span> : <span class="keyword">public</span> Employee &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Constructor</span></span><br><span class="line">    <span class="built_in">SalariedEmployee</span>(<span class="type">const</span> std::string&amp; firstName, <span class="type">const</span> std::string&amp; lastName, <span class="type">const</span> std::string&amp; socialSecurityNumber, <span class="type">double</span> weeklySalary)</span><br><span class="line">        : <span class="built_in">Employee</span>(firstName, lastName, socialSecurityNumber), <span class="built_in">weeklySalary</span>(weeklySalary) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Override the earnings function</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">earnings</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weeklySalary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Override the print function</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Salaried Employee: &quot;</span>;</span><br><span class="line">        Employee::<span class="built_in">print</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Weekly Salary: &quot;</span> &lt;&lt; weeklySalary &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> weeklySalary; <span class="comment">// Additional data member for salaried employees</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Similar derived classes for other types of employees (e.g., CommissionEmployee, BasePlusCommissionEmployee)</span></span><br></pre></td></tr></table></figure>
<p>这段代码定义了一个员工类（<code>Employee</code>），其中包含了虚拟函数 <code>earnings</code> 和 <code>print</code>，<code>earnings</code> 函数是一个纯虚拟函数，因此 <code>Employee</code> 类是一个抽象类。派生类（例如 <code>SalariedEmployee</code>）将覆盖这些函数以提供适当的实现。</p>
<h3 id="虚函数表"><a href="#虚函数表" class="headerlink" title="虚函数表"></a>虚函数表</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Abstract base class Employee</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string firstName;</span><br><span class="line">    std::string lastName;</span><br><span class="line">    std::string socialSecurityNumber;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Employee</span>(<span class="type">const</span> std::string&amp; first, <span class="type">const</span> std::string&amp; last, <span class="type">const</span> std::string&amp; ssn)</span><br><span class="line">        : <span class="built_in">firstName</span>(first), <span class="built_in">lastName</span>(last), <span class="built_in">socialSecurityNumber</span>(ssn) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Virtual destructor</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Employee</span>() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Pure virtual function</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">earnings</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Virtual function</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Employee: &quot;</span> &lt;&lt; firstName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; lastName &lt;&lt; <span class="string">&quot;\nSSN: &quot;</span> &lt;&lt; socialSecurityNumber &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Derived class SalariedEmployee</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SalariedEmployee</span> : <span class="keyword">public</span> Employee &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> weeklySalary;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SalariedEmployee</span>(<span class="type">const</span> std::string&amp; first, <span class="type">const</span> std::string&amp; last, <span class="type">const</span> std::string&amp; ssn, <span class="type">double</span> salary)</span><br><span class="line">        : <span class="built_in">Employee</span>(first, last, ssn), <span class="built_in">weeklySalary</span>(salary) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Override earnings function</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">earnings</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weeklySalary;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Override print function</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Salaried Employee: &quot;</span> &lt;&lt; firstName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; lastName &lt;&lt; <span class="string">&quot;\nSSN: &quot;</span> &lt;&lt; socialSecurityNumber </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;\nWeekly Salary: &quot;</span> &lt;&lt; weeklySalary &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Derived class CommissionEmployee</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CommissionEmployee</span> : <span class="keyword">public</span> Employee &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> grossSales;</span><br><span class="line">    <span class="type">double</span> commissionRate;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CommissionEmployee</span>(<span class="type">const</span> std::string&amp; first, <span class="type">const</span> std::string&amp; last, <span class="type">const</span> std::string&amp; ssn, <span class="type">double</span> sales, <span class="type">double</span> rate)</span><br><span class="line">        : <span class="built_in">Employee</span>(first, last, ssn), <span class="built_in">grossSales</span>(sales), <span class="built_in">commissionRate</span>(rate) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Override earnings function</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">earnings</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grossSales * commissionRate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Override print function</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Commission Employee: &quot;</span> &lt;&lt; firstName &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; lastName &lt;&lt; <span class="string">&quot;\nSSN: &quot;</span> &lt;&lt; socialSecurityNumber </span><br><span class="line">                  &lt;&lt; <span class="string">&quot;\nGross Sales: &quot;</span> &lt;&lt; grossSales &lt;&lt; <span class="string">&quot;\nCommission Rate: &quot;</span> &lt;&lt; commissionRate &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;Employee*&gt; employees;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add instances of derived classes to the vector</span></span><br><span class="line">    employees.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">SalariedEmployee</span>(<span class="string">&quot;John&quot;</span>, <span class="string">&quot;Doe&quot;</span>, <span class="string">&quot;123-45-6789&quot;</span>, <span class="number">1000.0</span>));</span><br><span class="line">    employees.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">CommissionEmployee</span>(<span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;Smith&quot;</span>, <span class="string">&quot;987-65-4321&quot;</span>, <span class="number">5000.0</span>, <span class="number">0.05</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Call earnings and print functions for each employee polymorphically</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span>&amp; emp : employees) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Earnings: &quot;</span> &lt;&lt; emp-&gt;<span class="built_in">earnings</span>() &lt;&lt; std::endl;</span><br><span class="line">        emp-&gt;<span class="built_in">print</span>();</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Cleanup</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; emp : employees) &#123;</span><br><span class="line">        <span class="keyword">delete</span> emp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虚函数表是一种用于实现多态性、虚函数和动态绑定的内部数据结构。它是为拥有一个或多个虚函数的类构建的。</p>
<p>当一个类有虚函数时，C++编译器会为该类构建一个虚函数表。这个虚函数表存储了该类的虚函数的地址，以便在调用虚函数时动态确定要调用的实际函数。</p>
<p>虚函数表的第一列是指向虚函数的指针。例如，假设有一个Employee类，它有一个纯虚函数earnings()和一个虚函数print()。Employee类的虚函数表的第一个指针通常是空指针，因为纯虚函数没有实现，而第二个指针会指向print()函数的地址。</p>
<p>当一个类的对象被实例化时，编译器会将指向该类虚函数表的指针附加到对象上。这个指针通常位于对象的前面，但并不一定要实现成这样。</p>
<p>在多态性的执行过程中，使用三级指针来实现。第一级指针是虚函数表中的函数指针，用于调用实际的函数。第二级指针是附加到对象上的指向虚函数表的指针。第三级指针是指向接收虚函数调用的对象的句柄。这些句柄也可以是引用。</p>
<p>当我们调用一个虚函数时，编译器会首先确定这是通过一个基类指针进行调用的，并查找该函数在虚函数表中的位置。然后，编译器会生成代码，执行一系列操作，包括选择正确的函数指针，并执行相应的虚函数。</p>
<p>这些操作使得程序能够动态地选择要执行的虚函数，从而实现了多态性和动态绑定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------</span><br><span class="line">|            虚函数表 (vtable)          |</span><br><span class="line">----------------------------------------</span><br><span class="line">|          |            |              |</span><br><span class="line">|   Ptr1   |    Ptr2    |    Ptr3      |</span><br><span class="line">|          |            |              |</span><br><span class="line">----------------------------------------</span><br></pre></td></tr></table></figure>
<p>在上面的图表中，我们展示了一个简化的虚函数表示例。每个指针（Ptr1、Ptr2、Ptr3）指向一个虚函数的地址。这些指针是在编译时由编译器生成的。</p>
<p>接下来，让我们看看如何将虚函数表与对象相关联：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------</span><br><span class="line">|      虚函数表指针 (vptr)             |</span><br><span class="line">----------------------------------------</span><br><span class="line">|          |                           |</span><br><span class="line">|   vptr   |                           |</span><br><span class="line">|          |                           |</span><br><span class="line">----------------------------------------</span><br><span class="line">|      数据成员                        |</span><br><span class="line">----------------------------------------</span><br></pre></td></tr></table></figure>
<p>在这个图表中，我们展示了一个对象的内部结构。在对象的开头，有一个指向虚函数表的指针（vptr）。这个指针指向该对象所属类的虚函数表。</p>
<p>最后，让我们看看如何使用虚函数表进行动态绑定：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----------------------------------------</span><br><span class="line">|      虚函数表指针 (vptr)             |</span><br><span class="line">----------------------------------------</span><br><span class="line">|          |                           |</span><br><span class="line">|   vptr   |          对象              |</span><br><span class="line">|          |                           |</span><br><span class="line">----------------------------------------</span><br><span class="line">|      数据成员                        |</span><br><span class="line">----------------------------------------</span><br></pre></td></tr></table></figure>
<p>当调用一个虚函数时，编译器首先查找对象的虚函数表指针。然后，它根据对象的实际类型在虚函数表中找到正确的函数指针，并调用相应的虚函数。</p>
<p>这就是虚函数表是如何实现多态性和动态绑定的。通过使用虚函数表，程序能够在运行时动态地确定要调用的函数，从而实现了多态性和动态绑定的特性。</p>
<p>运行时类型信息（RTTI，Runtime Type Information）是一种C++特性，允许程序在运行时获取对象的类型信息。RTTI提供了一种在程序执行期间查询对象类型的机制，这对于实现多态行为以及在处理对象时进行类型检查是非常有用的。</p>
<p>在C++中，可以使用 <code>typeid</code> 运算符和 <code>dynamic_cast</code> 运算符来实现RTTI。</p>
<h3 id="使用-typeid-运算符获取对象的类型信息："><a href="#使用-typeid-运算符获取对象的类型信息：" class="headerlink" title="使用 typeid 运算符获取对象的类型信息："></a>使用 <code>typeid</code> 运算符获取对象的类型信息：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用typeid获取对象的类型信息</span></span><br><span class="line">    <span class="type">const</span> std::type_info&amp; typeInfo = <span class="built_in">typeid</span>(*basePtr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 输出类型信息的名称</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Object belongs to type: &quot;</span> &lt;&lt; typeInfo.<span class="built_in">name</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们创建了一个基类 <code>Base</code> 和一个派生类 <code>Derived</code>。然后，我们创建了一个指向 <code>Derived</code> 类对象的基类指针 <code>basePtr</code>。接着，我们使用 <code>typeid</code> 运算符获取 <code>basePtr</code> 指向对象的类型信息，并将其存储在 <code>typeInfo</code> 中。最后，我们通过调用 <code>name()</code> 函数来获取类型信息的名称，并将其打印到控制台上。</p>
<h3 id="使用-dynamic-cast-运算符进行动态类型转换："><a href="#使用-dynamic-cast-运算符进行动态类型转换：" class="headerlink" title="使用 dynamic_cast 运算符进行动态类型转换："></a>使用 <code>dynamic_cast</code> 运算符进行动态类型转换：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用dynamic_cast进行动态类型转换</span></span><br><span class="line">    Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object successfully cast to Derived class.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Object cannot be cast to Derived class.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> basePtr;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在上面的示例中，我们首先创建了一个基类 <code>Base</code> 和一个派生类 <code>Derived</code>。然后，我们创建了一个指向 <code>Derived</code> 类对象的基类指针 <code>basePtr</code>。接着，我们使用 <code>dynamic_cast</code> 运算符将 <code>basePtr</code> 动态转换为 <code>Derived*</code> 类型的指针 <code>derivedPtr</code>。如果转换成功，<code>derivedPtr</code> 将指向同一个对象，并且我们会在控制台上输出成功的信息；否则，转换失败，我们将输出相应的信息。</p>
</blockquote>
<p>好的，让我用例子重新解释动态联编和静态联编。</p>
<p><strong>静态联编（Static Binding）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class display()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class display()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base obj;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line"></span><br><span class="line">    Base *ptr1 = &amp;obj;</span><br><span class="line">    Base *ptr2 = &amp;derivedObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 静态联编，根据指针类型确定调用的函数</span></span><br><span class="line">    ptr1-&gt;<span class="built_in">display</span>(); <span class="comment">// 调用 Base 类的 display() 函数</span></span><br><span class="line">    ptr2-&gt;<span class="built_in">display</span>(); <span class="comment">// 调用 Base 类的 display() 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们有一个基类 <code>Base</code> 和一个派生类 <code>Derived</code>。当我们通过基类指针调用 <code>display()</code> 函数时，无论指针指向哪种类型的对象，都会调用基类中的 <code>display()</code> 函数。这是因为编译器在编译时根据指针的类型确定调用的函数，这就是静态联编。</p>
<p><strong>动态联编（Dynamic Binding）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Base class display()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Derived class display()&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Base obj;</span><br><span class="line">    Derived derivedObj;</span><br><span class="line"></span><br><span class="line">    Base *ptr1 = &amp;obj;</span><br><span class="line">    Base *ptr2 = &amp;derivedObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态联编，根据对象的实际类型确定调用的函数</span></span><br><span class="line">    ptr1-&gt;<span class="built_in">display</span>(); <span class="comment">// 调用 Base 类的 display() 函数</span></span><br><span class="line">    ptr2-&gt;<span class="built_in">display</span>(); <span class="comment">// 调用 Derived 类的 display() 函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的示例中，我们仍然有相同的基类 <code>Base</code> 和派生类 <code>Derived</code>。但现在，当我们通过基类指针调用 <code>display()</code> 函数时，实际调用的函数取决于指针指向的对象的类型。这是因为在动态联编中，函数调用的实现在运行时根据对象的实际类型确定。</p>
<hr>
<h2 id="Stream-Input-Output"><a href="#Stream-Input-Output" class="headerlink" title="Stream Input/Output"></a><strong>Stream Input/Output</strong></h2><blockquote>
<p>C++使用类型安全的输入输出（I/O）。<br>每个I/O操作都以一种对数据类型敏感的方式执行。<br>如果一个I/O函数已经被定义来处理特定的数据类型，那么调用该成员函数来处理该数据类型。<br>如果实际数据的类型与处理该数据类型的函数不匹配，则编译器会生成一个错误。<br>因此，不适当的数据无法“潜入”系统。<br>用户可以通过重载流插入运算符（&lt;&lt;）和流提取运算符（&gt;&gt;）来指定如何对用户定义类型的对象执行I/O操作。</p>
</blockquote>
<p><strong>C++ 输入/输出（I/O）流:</strong></p>
<ul>
<li>流是C++中的字节序列。</li>
<li>输入操作：字节从设备（例如键盘、磁盘驱动器）流向主存储器。</li>
<li>输出操作：字节从主存储器流向设备（例如显示屏、打印机）。</li>
<li>应用程序将含义与字节相关联。</li>
</ul>
<p><strong>系统I/O机制:</strong></p>
<ul>
<li>确保字节在设备和内存之间的传输一致可靠。</li>
<li>通常涉及机械运动（例如磁盘旋转、键盘输入）。</li>
<li>传输时间通常远大于处理器内部操作时间，需要精心规划以确保最佳性能。</li>
</ul>
<p><strong>C++ I/O能力:</strong></p>
<ul>
<li><p><strong>低级I/O（未格式化I/O）:</strong></p>
<ul>
<li>指定字节在设备和内存之间传输。</li>
<li>个别字节是感兴趣的项。</li>
<li>提供高速、高容量传输，但不太方便。</li>
</ul>
</li>
<li><p><strong>高级I/O（格式化I/O）:</strong></p>
<ul>
<li>字节分组为有意义的单位：整数、浮点数、字符、字符串和用户定义类型。</li>
<li>大多数I/O首选此方法，除了高容量文件处理。</li>
</ul>
</li>
</ul>
<p><strong>C++ 中的字符输入/输出（I/O）:</strong></p>
<ul>
<li>传统的 C++ 流库允许对字符进行输入和输出。</li>
<li>由于一个 char 通常占用一个字节，因此它只能表示一组有限的字符（如 ASCII 字符集中的字符）。</li>
<li>然而，许多语言使用的字母表包含比单字节 char 可表示的字符更多的字符。</li>
<li>ASCII 字符集并不提供这些字符；Unicode® 字符集提供了这些字符。</li>
<li>Unicode 是一个庞大的国际字符集，代表了世界上大多数“商业可行”的语言、数学符号等等。</li>
</ul>
<p><strong>C++ 标准流库:</strong></p>
<ul>
<li>C++ 包含标准流库，使开发人员能够构建能够处理 Unicode 字符的 I/O 操作系统。</li>
<li>为此，C++ 包含了类型 wchar_t，它可以存储 2 个字节的 Unicode 字符。</li>
<li>C++ 标准还重新设计了传统的 C++ 流类，原来只处理 char 的类模板，现在分别为处理 char 和 wchar_t 类型的字符提供了单独的专门化。</li>
<li>我们使用 char 的专门化。</li>
<li>类型 wchar_t 的大小没有被标准指定。C++11 引入了新的 char16_t 和 char32_t 类型，用于表示具有明确定义大小的 Unicode 字符。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用 char 类型的专门化来处理字符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using char specialization:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">char</span> asciiChar = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;ASCII char: &quot;</span> &lt;&lt; asciiChar &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 wchar_t 类型的专门化来处理 Unicode 字符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nUsing wchar_t specialization:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">wchar_t</span> unicodeChar = <span class="string">L&#x27;文&#x27;</span>; <span class="comment">// 使用 L 前缀来表示宽字符</span></span><br><span class="line">    std::wcout &lt;&lt; <span class="string">&quot;Unicode char: &quot;</span> &lt;&lt; unicodeChar &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 char16_t 和 char32_t 类型来处理具有明确定义大小的 Unicode 字符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nUsing char16_t and char32_t:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">char16_t</span> utf16Char = <span class="string">u&#x27;𐍈&#x27;</span>; <span class="comment">// 使用 u 前缀来表示UTF-16字符</span></span><br><span class="line">    <span class="type">char32_t</span> utf32Char = <span class="string">U&#x27;𐍈&#x27;</span>; <span class="comment">// 使用 U 前缀来表示UTF-32字符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UTF-16 char: &quot;</span> &lt;&lt; utf16Char &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;UTF-32 char: &quot;</span> &lt;&lt; utf32Char &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码示例演示了如何使用C++标准流库以及处理Unicode字符的各种数据类型。</p>
<ul>
<li><code>char</code>: 是C++中最基本的字符类型，通常用于表示ASCII字符集中的字符。在示例中，我们使用<code>char</code>来存储和输出ASCII字符’A’。</li>
<li><code>wchar_t</code>: 是一种宽字符类型，用于存储Unicode字符，它通常占用2个字节。在示例中，我们使用<code>wchar_t</code>来存储和输出一个Unicode字符’文’。</li>
<li><code>char16_t</code> 和 <code>char32_t</code>: 是C++11引入的两种新的字符类型，用于明确表示UTF-16和UTF-32编码的Unicode字符。在示例中，我们使用<code>char16_t</code>来存储和输出一个UTF-16编码的Unicode字符，使用<code>char32_t</code>来存储和输出一个UTF-32编码的Unicode字符。</li>
</ul>
<h3 id="C-iostream库概述"><a href="#C-iostream库概述" class="headerlink" title="C++ iostream库概述:"></a><strong>C++ iostream库概述:</strong></h3><ul>
<li>C++ iostream库提供了许多I/O功能。</li>
<li>多个头文件包含了该库的接口的部分。</li>
<li>大多数C++程序包含 <code>&lt;iostream&gt;</code> 头文件，它声明了所有流I/O操作所需的基本服务。</li>
<li><code>&lt;iostream&gt;</code>头文件定义了 cin、cout、cerr 和 clog 对象，分别对应于标准输入流、标准输出流、无缓冲标准错误流和带缓冲的标准错误流。</li>
<li>提供了格式化和未格式化的I/O服务。</li>
</ul>
<p><strong><code>&lt;iomanip&gt;</code> 头文件:</strong></p>
<p>-<code>&lt;iomanip&gt;</code>头文件声明了一些有用的服务，用于使用所谓的带参数的流操作符（manipulators）执行格式化I/O，如 setw 和 setprecision。</p>
<p><strong><code>&lt;fstream&gt;</code> 头文件:</strong></p>
<p>-<code>&lt;fstream&gt;</code>头文件声明了用于文件处理的服务。</p>
<p>好的，让我们来深入剖析这些知识点，并给出相应的代码示例。</p>
<hr>
<p><strong>模板类 basic_istream、basic_ostream 和 basic_iostream:</strong></p>
<ul>
<li><code>basic_istream</code>: 支持流输入操作。</li>
<li><code>basic_ostream</code>: 支持流输出操作。</li>
<li><code>basic_iostream</code>: 同时支持流输入和流输出操作。</li>
<li>每个模板都有一个预定义的模板专门化，使得 char I/O 成为可能。</li>
</ul>
<p><strong>typedef 声明:</strong></p>
<ul>
<li><code>istream</code>: 表示一个 <code>basic_istream&lt;char&gt;</code> 实例，支持 char 输入。</li>
<li><code>ostream</code>: 表示一个 <code>basic_ostream&lt;char&gt;</code> 实例，支持 char 输出。</li>
<li><code>iostream</code>: 表示一个 <code>basic_iostream&lt;char&gt;</code> 实例，同时支持 char 输入和输出。</li>
</ul>
<p><strong>继承关系:</strong></p>
<ul>
<li><code>basic_istream</code> 和 <code>basic_ostream</code> 都通过单继承从基本模板 <code>basic_ios</code> 派生。</li>
<li><code>basic_iostream</code> 通过多继承从 <code>basic_istream</code> 和 <code>basic_ostream</code> 派生。</li>
</ul>
<p><strong>cin、cout、cerr 和 clog:</strong></p>
<ul>
<li><code>cin</code>: 是一个 <code>istream</code> 实例，连接到标准输入设备，通常是键盘。</li>
<li><code>cout</code>: 是一个 <code>ostream</code> 实例，连接到标准输出设备，通常是显示屏。</li>
<li><code>cerr</code>: 是一个 <code>ostream</code> 实例，连接到标准错误设备，通常也是显示屏，但输出是无缓冲的，适合用于立即通知用户有关错误的信息。</li>
<li><code>clog</code>: 是一个 <code>ostream</code> 实例，连接到标准错误设备，输出是带缓冲的。</li>
</ul>
<p><strong>文件处理模板:</strong></p>
<ul>
<li>文件处理使用 <code>basic_ifstream</code>（文件输入）、<code>basic_ofstream</code>（文件输出）和 <code>basic_fstream</code>（文件输入输出）模板。</li>
<li>类似于标准流，C++为这些类模板提供了 typedefs。</li>
</ul>
<p><strong>代码示例:</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 文件输入流</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line">    inputFile &gt;&gt; number;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Read from file: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件输出流</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">outputFile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;</span><br><span class="line">    outputFile &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data written to file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件输入输出流</span></span><br><span class="line">    <span class="function">std::fstream <span class="title">ioFile</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>, std::ios::in | std::ios::out)</span></span>;</span><br><span class="line">    std::string data;</span><br><span class="line">    ioFile &gt;&gt; data;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Read from file: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    ioFile &lt;&lt; <span class="string">&quot;Adding more data.&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Data appended to file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>C++中的格式化和未格式化输出：</strong></p>
<p>在C++中，<code>ostream</code>类提供了格式化和未格式化输出的能力。</p>
<p><strong>重载<code>&lt;&lt;</code>操作符用于<code>char*</code>输出：</strong></p>
<p>C++中已经重载了<code>&lt;&lt;</code>操作符，可以将<code>char*</code>输出为以空字符结尾的C风格字符串。要输出地址而不是字符串内容，可以将<code>char*</code>转换为<code>void*</code>。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 作为字符串输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;字符串输出：&quot;</span> &lt;&lt; str &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 作为地址输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;地址输出：&quot;</span> &lt;&lt; <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(str) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个示例演示了以字符串和地址格式打印<code>char*</code>变量。</p>
<p><strong>使用<code>put</code>成员函数：</strong></p>
<p>C++中的<code>put</code>成员函数可以用于输出单个字符。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 输出单个字符 &#x27;A&#x27;</span></span><br><span class="line">    std::cout.<span class="built_in">put</span>(<span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 &#x27;A&#x27; 后接换行字符</span></span><br><span class="line">    std::cout.<span class="built_in">put</span>(<span class="string">&#x27;A&#x27;</span>).<span class="built_in">put</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出ASCII值为65的字符，表示为 &#x27;A&#x27;</span></span><br><span class="line">    std::cout.<span class="built_in">put</span>(<span class="number">65</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，使用<code>put</code>函数以各种方式输出字符。可以级联调用<code>put</code>，它还可以接受表示ASCII值的数值表达式。</p>
<p><strong>分析：</strong></p>
<ul>
<li><code>put</code>成员函数提供了一种输出单个字符的方法，相比<code>&lt;&lt;</code>操作符，更灵活。</li>
<li>由于<code>put</code>返回对<code>ostream</code>对象的引用，因此可以级联调用，允许按顺序执行输出操作。</li>
<li>通过重载<code>&lt;&lt;</code>操作符，C++提供了一种方便的方法来输出C风格字符串，同时还允许直接输出其他数据类型和表达式。</li>
</ul>
<h3 id="C-中的格式化和未格式化输入功能："><a href="#C-中的格式化和未格式化输入功能：" class="headerlink" title="C++中的格式化和未格式化输入功能："></a><strong>C++中的格式化和未格式化输入功能：</strong></h3><p>在C++中，<code>istream</code>类提供了格式化和未格式化的输入功能。</p>
<p><strong>流提取操作符 (&gt;&gt;)：</strong></p>
<ul>
<li>流提取操作符 (&gt;&gt;) 通常会跳过输入流中的空白字符（如空格、制表符和换行符）；稍后我们将了解如何更改此行为。</li>
<li>每次输入后，流提取操作符返回一个对接收到提取消息的流对象的引用（例如，在表达式<code>cin &gt;&gt; grade</code>中是<code>cin</code>）。</li>
<li>如果将该引用用作条件，则流的重载<code>void*</code>转换操作符函数将隐式调用，以根据最后一次输入操作的成功或失败将引用转换为非空指针值或空指针。</li>
<li>非空指针转换为布尔值<code>true</code>表示成功，空指针转换为布尔值<code>false</code>表示失败。</li>
<li>当尝试读取流的结尾时，流的重载<code>void*</code>转换操作符返回空指针以表示文件结尾。</li>
</ul>
<p><strong>流对象的状态位：</strong></p>
<ul>
<li>每个流对象包含一组状态位，用于控制流的状态（如格式化、设置错误状态等）。</li>
<li>这些位由流的重载<code>void*</code>转换操作符使用，以确定是否返回非空指针或空指针。</li>
<li>如果输入错误类型的数据，则流提取会导致设置流的<code>failbit</code>，如果操作失败，则会设置<code>badbit</code>。</li>
</ul>
<p><strong>get成员函数：</strong></p>
<ul>
<li>无参数的<code>get</code>成员函数从指定的流中输入一个字符（包括空白字符和其他非图形字符，如表示文件结尾的键序列），并将其作为函数调用的返回值。</li>
<li>当在流上遇到文件结尾时，此版本的<code>get</code>返回EOF。</li>
</ul>
<p><strong>使用成员函数eof、get和put：</strong></p>
<p>下面的程序演示了如何在输入流<code>cin</code>上使用成员函数<code>eof</code>和<code>get</code>，以及在输出流<code>cout</code>上使用成员函数<code>put</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> character;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter text, end with EOF (Ctrl+Z on Windows, Ctrl+D on Linux/Mac):&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((character = std::cin.<span class="built_in">get</span>()) != EOF) &#123;</span><br><span class="line">        std::cout.<span class="built_in">put</span>(character);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (std::cin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\nEnd of file reached.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\nInput error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>get成员函数的其他版本：</strong></p>
<ul>
<li>带字符引用参数的<code>get</code>成员函数从输入流中输入下一个字符（即使是空白字符）并将其存储在字符参数中。</li>
<li>第三种版本的<code>get</code>接收三个参数：一个字符数组、一个大小限制和一个分隔符（默认值为<code>\n</code>）。这种版本从输入流中读取字符，直到读取到指定的最大字符数减一或读取到分隔符为止。在用作缓冲区的字符数组中插入一个空字符以终止输入字符串。分隔符不放入字符数组中，但仍保留在输入流中。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用带字符引用参数的get函数</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>(c);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Character read using get: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用带字符数组、大小限制和分隔符的get函数</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>(buffer, <span class="number">100</span>, <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;String read using get: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>getline成员函数：</strong></p>
<ul>
<li><code>getline</code>成员函数与第三种版本的<code>get</code>成员函数类似，并在字符数组的行后插入一个空字符。</li>
<li><code>getline</code>函数从流中删除分隔符（即，读取字符并将其丢弃），但不将其存储在字符数组中。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a line of text:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cin.<span class="built_in">getline</span>(buffer, <span class="number">100</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Line read using getline: &quot;</span> &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-中-istream-类的成员函数-ignore、putback-和-peek："><a href="#C-中-istream-类的成员函数-ignore、putback-和-peek：" class="headerlink" title="C++ 中 istream 类的成员函数 ignore、putback 和 peek："></a><strong>C++ 中 <code>istream</code> 类的成员函数 <code>ignore</code>、<code>putback</code> 和 <code>peek</code>：</strong></h3><h3 id="ignore-成员函数"><a href="#ignore-成员函数" class="headerlink" title="ignore 成员函数"></a><code>ignore</code> 成员函数</h3><ul>
<li><strong>功能</strong>：<code>ignore</code> 成员函数读取并丢弃指定数量的字符（默认是一个字符），或在遇到指定的分隔符时终止（默认是 EOF，当从文件读取时，导致 <code>ignore</code> 跳到文件末尾）。</li>
<li><strong>使用场景</strong>：当需要跳过输入流中的某些字符时，<code>ignore</code> 非常有用，例如跳过不需要的分隔符或注释。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a line of text: &quot;</span>;</span><br><span class="line">    std::cin.<span class="built_in">ignore</span>(<span class="number">5</span>, <span class="string">&#x27; &#x27;</span>); <span class="comment">// 忽略最多5个字符，直到遇到空格为止</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(c); <span class="comment">// 读取下一个字符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First character after ignore: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="putback-成员函数"><a href="#putback-成员函数" class="headerlink" title="putback 成员函数"></a><code>putback</code> 成员函数</h3><ul>
<li><strong>功能</strong>：<code>putback</code> 成员函数将由 <code>get</code> 从输入流中获取的前一个字符放回到该流中。</li>
<li><strong>使用场景</strong>：对于扫描输入流并查找以特定字符开头的字段的应用程序非常有用。当输入该字符时，应用程序将字符返回到流中，以便字符可以包含在输入数据中。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a character: &quot;</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    std::cin.<span class="built_in">get</span>(c); <span class="comment">// 读取一个字符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Character read: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">putback</span>(c); <span class="comment">// 将字符放回流中</span></span><br><span class="line">    std::cin.<span class="built_in">get</span>(c); <span class="comment">// 再次读取字符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Character read again after putback: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="peek-成员函数"><a href="#peek-成员函数" class="headerlink" title="peek 成员函数"></a><code>peek</code> 成员函数</h3><ul>
<li><strong>功能</strong>：<code>peek</code> 成员函数返回输入流中的下一个字符，但不从流中移除该字符。</li>
<li><strong>使用场景</strong>：当需要查看下一个字符但不希望影响流状态时，<code>peek</code> 非常有用。例如，在决定如何处理接下来的输入之前查看下一个字符。</li>
</ul>
<p><strong>示例代码</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a character: &quot;</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    c = std::cin.<span class="built_in">peek</span>(); <span class="comment">// 查看下一个字符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Next character (using peek): &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cin.<span class="built_in">get</span>(c); <span class="comment">// 读取并移除该字符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Character read: &quot;</span> &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h3><p>结合使用 <code>ignore</code>、<code>putback</code> 和 <code>peek</code> 来处理更复杂的输入流场景：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a line of text ending with a period: &quot;</span>;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        c = std::cin.<span class="built_in">peek</span>(); <span class="comment">// 查看下一个字符</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 如果是句号，则退出循环</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            std::cin.<span class="built_in">ignore</span>(); <span class="comment">// 如果是空格，则忽略</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cin.<span class="built_in">get</span>(c); <span class="comment">// 否则，读取并显示字符</span></span><br><span class="line">            std::cout &lt;&lt; c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\nEnd of input processing.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个综合示例展示了如何使用 <code>ignore</code>、<code>putback</code> 和 <code>peek</code> 来处理更复杂的输入流，处理字符的同时忽略空格并检测特定终止符。</p>
<h3 id="类型安全I-O概述"><a href="#类型安全I-O概述" class="headerlink" title="类型安全I/O概述"></a>类型安全I/O概述</h3><p>C++ 提供了类型安全的输入输出（I/O）机制，通过重载 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符来处理特定类型的数据项。这种机制确保了输入和输出操作的安全性和正确性，避免了类型错误。</p>
<h3 id="重载的-lt-lt-和-gt-gt-操作符"><a href="#重载的-lt-lt-和-gt-gt-操作符" class="headerlink" title="重载的 &lt;&lt; 和 &gt;&gt; 操作符"></a>重载的 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符</h3><ul>
<li><strong>重载操作符</strong>：在C++中，<code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符被重载以接受特定类型的数据。例如，<code>int</code>、<code>double</code>、<code>char</code>、<code>string</code>等基本类型。</li>
<li><strong>用户自定义类型</strong>：如果用户定义了自己的类型（例如类或结构体），则需要显式重载 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符来支持该类型的输入输出操作。如果未重载这些操作符，编译器会在尝试进行I/O操作时报告错误。</li>
</ul>
<h3 id="I-O错误处理"><a href="#I-O错误处理" class="headerlink" title="I/O错误处理"></a>I/O错误处理</h3><ul>
<li><strong>错误位</strong>：C++标准库提供了多种错误位来表示I/O操作的状态。这些错误位包括：<ul>
<li><code>eofbit</code>：表示已到达输入流的末尾。</li>
<li><code>failbit</code>：表示I/O操作失败，例如试图读取非数字字符到整数变量中。</li>
<li><code>badbit</code>：表示I/O操作遇到不可恢复的错误。</li>
<li><code>goodbit</code>：表示没有错误发生（这是默认状态）。</li>
</ul>
</li>
<li><strong>测试错误位</strong>：用户可以测试这些错误位来确定I/O操作是否成功。例如，使用成员函数 <code>good()</code>、<code>fail()</code>、<code>bad()</code> 和 <code>eof()</code> 来检查对应的错误状态。</li>
</ul>
<h3 id="示例代码-17"><a href="#示例代码-17" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一些示例代码，展示如何重载 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 操作符，如何进行类型安全的I/O操作，以及如何检查I/O错误状态。</p>
<h4 id="重载操作符示例"><a href="#重载操作符示例" class="headerlink" title="重载操作符示例"></a>重载操作符示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义类型</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载输入操作符 &gt;&gt;</span></span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; input, Person&amp; p) &#123;</span><br><span class="line">        input &gt;&gt; p.name &gt;&gt; p.age;</span><br><span class="line">        <span class="keyword">return</span> input;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重载输出操作符 &lt;&lt;</span></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; output, <span class="type">const</span> Person&amp; p) &#123;</span><br><span class="line">        output &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; p.name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; p.age;</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Person person;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入自定义类型</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter name and age: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; person;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查输入操作是否成功</span></span><br><span class="line">    <span class="keyword">if</span> (std::cin.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error reading input.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 输出自定义类型</span></span><br><span class="line">        std::cout &lt;&lt; person &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="测试错误位示例"><a href="#测试错误位示例" class="headerlink" title="测试错误位示例"></a>测试错误位示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a number: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; number;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查错误位</span></span><br><span class="line">    <span class="keyword">if</span> (std::cin.<span class="built_in">good</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::cin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;End of file reached.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::cin.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Input mismatch. Failed to read an integer.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 清除错误状态并忽略错误输入</span></span><br><span class="line">        std::cin.<span class="built_in">clear</span>();</span><br><span class="line">        std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::cin.<span class="built_in">bad</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Unrecoverable error occurred during input.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展内容：I-O状态管理"><a href="#扩展内容：I-O状态管理" class="headerlink" title="扩展内容：I/O状态管理"></a>扩展内容：I/O状态管理</h3><h4 id="清除错误状态"><a href="#清除错误状态" class="headerlink" title="清除错误状态"></a>清除错误状态</h4><p>当检测到输入错误时，可以使用 <code>clear()</code> 成员函数清除错误状态，以便继续进行后续的I/O操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cin.<span class="built_in">clear</span>(); <span class="comment">// 清除所有错误位</span></span><br></pre></td></tr></table></figure>
<h4 id="忽略错误输入"><a href="#忽略错误输入" class="headerlink" title="忽略错误输入"></a>忽略错误输入</h4><p>使用 <code>ignore()</code> 成员函数忽略错误输入，避免影响后续的I/O操作。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 忽略当前行中的所有字符，直到遇到换行符</span></span><br></pre></td></tr></table></figure>
<h4 id="复位输入流"><a href="#复位输入流" class="headerlink" title="复位输入流"></a>复位输入流</h4><p>在检测到 <code>failbit</code> 或 <code>badbit</code> 后，可以通过 <code>clear()</code> 和 <code>ignore()</code> 来复位输入流，从而确保后续输入操作正常进行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::cin.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">    std::cin.<span class="built_in">clear</span>(); <span class="comment">// 清除错误状态</span></span><br><span class="line">    std::cin.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>); <span class="comment">// 忽略错误输入</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-中的非格式化输入-输出"><a href="#C-中的非格式化输入-输出" class="headerlink" title="C++中的非格式化输入/输出"></a>C++中的非格式化输入/输出</h3><p>在C++中，非格式化输入/输出通过<code>istream</code>和<code>ostream</code>类的<code>read</code>和<code>write</code>成员函数进行。这些函数直接操作字节，不进行任何格式化处理，适用于需要处理原始字节数据的情况。</p>
<hr>
<h3 id="主要成员函数"><a href="#主要成员函数" class="headerlink" title="主要成员函数"></a>主要成员函数</h3><h4 id="read-成员函数"><a href="#read-成员函数" class="headerlink" title="read 成员函数"></a><code>read</code> 成员函数</h4><ul>
<li><strong>功能</strong>：从输入流中读取指定数量的字符到内存中的字符数组。</li>
<li><strong>使用场景</strong>：适用于从文件或其他输入流读取原始数据，不进行格式化处理。</li>
</ul>
<h4 id="write-成员函数"><a href="#write-成员函数" class="headerlink" title="write 成员函数"></a><code>write</code> 成员函数</h4><ul>
<li><strong>功能</strong>：将内存中的字符数组中的指定数量的字符写入输出流。</li>
<li><strong>使用场景</strong>：适用于将原始数据写入文件或其他输出流。</li>
</ul>
<h4 id="gcount-成员函数"><a href="#gcount-成员函数" class="headerlink" title="gcount 成员函数"></a><code>gcount</code> 成员函数</h4><ul>
<li><strong>功能</strong>：返回上一次输入操作读取的字符数。</li>
<li><strong>使用场景</strong>：在使用<code>read</code>成员函数后，获取实际读取的字符数。</li>
</ul>
<h3 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h3><p>以下代码示例演示了<code>istream</code>的<code>read</code>和<code>gcount</code>成员函数以及<code>ostream</code>的<code>write</code>成员函数的使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开一个文件进行读取</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;input.txt&quot;</span>, std::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inputFile) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error opening file for reading.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个字符数组用于存储读取的数据</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> bufferSize = <span class="number">100</span>;</span><br><span class="line">    <span class="type">char</span> buffer[bufferSize];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中读取指定数量的字符</span></span><br><span class="line">    inputFile.<span class="built_in">read</span>(buffer, bufferSize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否读取失败</span></span><br><span class="line">    <span class="keyword">if</span> (inputFile.<span class="built_in">fail</span>() &amp;&amp; !inputFile.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error reading file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取实际读取的字符数</span></span><br><span class="line">    std::streamsize bytesRead = inputFile.<span class="built_in">gcount</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bytes read: &quot;</span> &lt;&lt; bytesRead &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输入文件</span></span><br><span class="line">    inputFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开一个文件进行写入</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">outputFile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>, std::ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!outputFile) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error opening file for writing.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将读取的数据写入输出文件</span></span><br><span class="line">    outputFile.<span class="built_in">write</span>(buffer, bytesRead);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否写入失败</span></span><br><span class="line">    <span class="keyword">if</span> (!outputFile) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error writing to file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭输出文件</span></span><br><span class="line">    outputFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展内容：非格式化I-O的应用场景"><a href="#扩展内容：非格式化I-O的应用场景" class="headerlink" title="扩展内容：非格式化I/O的应用场景"></a>扩展内容：非格式化I/O的应用场景</h3><h4 id="1-处理二进制文件"><a href="#1-处理二进制文件" class="headerlink" title="1. 处理二进制文件"></a>1. 处理二进制文件</h4><p>非格式化I/O非常适合处理二进制文件（如图片、音频、视频等），因为这些文件的数据不能被解释为文本。</p>
<h4 id="2-提高性能"><a href="#2-提高性能" class="headerlink" title="2. 提高性能"></a>2. 提高性能</h4><p>由于非格式化I/O不涉及数据转换和格式化处理，相对于格式化I/O，性能更高。</p>
<h4 id="3-存储和传输原始数据"><a href="#3-存储和传输原始数据" class="headerlink" title="3. 存储和传输原始数据"></a>3. 存储和传输原始数据</h4><p>在网络传输和数据存储中，使用非格式化I/O可以确保数据的准确性和一致性。</p>
<h3 id="错误处理和状态管理"><a href="#错误处理和状态管理" class="headerlink" title="错误处理和状态管理"></a>错误处理和状态管理</h3><p>在使用<code>read</code>和<code>write</code>时，需要注意以下几点：</p>
<ul>
<li><strong>检查流状态</strong>：通过检查<code>failbit</code>、<code>eofbit</code>和<code>badbit</code>来判断I/O操作是否成功。</li>
<li><strong>处理部分读取</strong>：当读取的字符数少于指定数量时，使用<code>gcount</code>获取实际读取的字符数，并采取适当措施。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理读取错误</span></span><br><span class="line"><span class="keyword">if</span> (inputFile.<span class="built_in">fail</span>() &amp;&amp; !inputFile.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Error reading file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 清除错误状态</span></span><br><span class="line">    inputFile.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="comment">// 忽略剩余输入</span></span><br><span class="line">    inputFile.<span class="built_in">ignore</span>(std::numeric_limits&lt;std::streamsize&gt;::<span class="built_in">max</span>(), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-流操作符及其格式化任务"><a href="#C-流操作符及其格式化任务" class="headerlink" title="C++ 流操作符及其格式化任务"></a>C++ 流操作符及其格式化任务</h3><p>C++ 提供了各种流操作符用于执行格式化任务。这些流操作符能够设置字段宽度、精度、格式状态、填充字符、刷新流、在输出流中插入换行符或空字符，以及在输入流中跳过空白字符。</p>
<h4 id="1-数字的基数设置"><a href="#1-数字的基数设置" class="headerlink" title="1. 数字的基数设置"></a>1. 数字的基数设置</h4><p>整数通常被解释为十进制（基数 10）值。可以使用以下流操作符更改流中的整数基数：</p>
<ul>
<li><code>hex</code>：将基数设置为十六进制（基数 16）。</li>
<li><code>oct</code>：将基数设置为八进制（基数 8）。</li>
<li><code>dec</code>：将基数重置为十进制（基数 10）。</li>
<li><code>setbase</code>：通过参数设置基数，可以接受 10、8 或 16 作为参数。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Decimal: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hexadecimal: &quot;</span> &lt;&lt; std::hex &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Octal: &quot;</span> &lt;&lt; std::oct &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back to Decimal: &quot;</span> &lt;&lt; std::dec &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Using setbase manipulator:&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">16</span>) &lt;&lt; number &lt;&lt; <span class="string">&quot; (Hex)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">8</span>) &lt;&lt; number &lt;&lt; <span class="string">&quot; (Oct)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setbase</span>(<span class="number">10</span>) &lt;&lt; number &lt;&lt; <span class="string">&quot; (Dec)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-设置浮点数精度"><a href="#2-设置浮点数精度" class="headerlink" title="2. 设置浮点数精度"></a>2. 设置浮点数精度</h4><p>通过 <code>setprecision</code> 流操作符或 <code>ios_base</code> 类的 <code>precision</code> 成员函数可以控制浮点数的精度（即小数点右侧的位数）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> value = <span class="built_in">sqrt</span>(<span class="number">2.0</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default precision: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Precision &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; std::<span class="built_in">setprecision</span>(i) &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-设置字段宽度"><a href="#3-设置字段宽度" class="headerlink" title="3. 设置字段宽度"></a>3. 设置字段宽度</h4><p>通过 <code>ios_base</code> 类的 <code>width</code> 成员函数可以设置字段宽度，或者使用 <code>setw</code> 流操作符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;Value&quot;</span> &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="string">&quot;Square&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; i &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; i * i &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-自定义流操作符"><a href="#4-自定义流操作符" class="headerlink" title="4. 自定义流操作符"></a>4. 自定义流操作符</h4><p>可以创建自己的流操作符。例如，创建一个 <code>bell</code> 操作符，当调用时打印一个铃声字符（<code>\a</code>）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">bell</span><span class="params">(std::ostream&amp; os)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">&#x27;\a&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">carriageReturn</span><span class="params">(std::ostream&amp; os)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">&#x27;\r&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">tab</span><span class="params">(std::ostream&amp; os)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::ostream&amp; <span class="title">endLine</span><span class="params">(std::ostream&amp; os)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello&quot;</span> &lt;&lt; bell &lt;&lt; tab &lt;&lt; <span class="string">&quot;world&quot;</span> &lt;&lt; carriageReturn &lt;&lt; endLine;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="扩展内容"><a href="#扩展内容" class="headerlink" title="扩展内容"></a>扩展内容</h3><h4 id="1-设置填充字符"><a href="#1-设置填充字符" class="headerlink" title="1. 设置填充字符"></a>1. 设置填充字符</h4><p>可以通过 <code>fill</code> 成员函数或 <code>setfill</code> 流操作符设置填充字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">123</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-刷新流"><a href="#2-刷新流" class="headerlink" title="2. 刷新流"></a>2. 刷新流</h4><p>可以使用 <code>flush</code> 操作符强制刷新流。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;This is a test&quot;</span> &lt;&lt; std::flush;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-插入换行符和跳过空白字符"><a href="#3-插入换行符和跳过空白字符" class="headerlink" title="3. 插入换行符和跳过空白字符"></a>3. 插入换行符和跳过空白字符</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter a character: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; std::noskipws &gt;&gt; ch;  <span class="comment">// 禁止跳过空白字符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span> &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>确实如此，<code>setw</code> 是唯一一个非粘性的流操纵器，它只影响紧随其后的单个输出操作。下面是详细的笔记和代码示例，以更好地理解 C++ 中的流操纵器及其“粘性”特性。</p>
<h3 id="C-流操纵器"><a href="#C-流操纵器" class="headerlink" title="C++ 流操纵器"></a>C++ 流操纵器</h3><p>C++ 提供了一些流操纵器，用于格式化输入和输出。这些操纵器可以设置字段宽度、精度、填充字符等。有些操纵器是粘性的，这意味着一旦设置，它们会影响后续所有的输出操作，直到明确地重新设置它们或重置为默认值。而 <code>setw</code> 是唯一一个非粘性的操纵器，它只对一次输出操作有效。</p>
<h4 id="粘性流操纵器"><a href="#粘性流操纵器" class="headerlink" title="粘性流操纵器"></a>粘性流操纵器</h4><p>以下是一些常见的粘性流操纵器：</p>
<ul>
<li><code>hex</code>：将流设置为十六进制模式。</li>
<li><code>dec</code>：将流设置为十进制模式。</li>
<li><code>oct</code>：将流设置为八进制模式。</li>
<li><code>setfill</code>：设置填充字符。</li>
<li><code>fixed</code>：将浮点数设置为定点表示。</li>
<li><code>scientific</code>：将浮点数设置为科学计数法表示。</li>
<li><code>setprecision</code>：设置浮点数的精度。</li>
<li><code>left</code>、<code>right</code> 和 <code>internal</code>：设置对齐方式。</li>
</ul>
<h4 id="非粘性流操纵器"><a href="#非粘性流操纵器" class="headerlink" title="非粘性流操纵器"></a>非粘性流操纵器</h4><p>唯一的非粘性流操纵器是：</p>
<ul>
<li><code>setw</code>：设置字段宽度，仅对当前操作有效。</li>
</ul>
<h3 id="代码示例-2"><a href="#代码示例-2" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面的代码示例展示了粘性和非粘性流操纵器的使用及其效果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> number = <span class="number">255</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认情况下，数字以十进制格式显示</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Default (decimal): &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置流为十六进制模式</span></span><br><span class="line">    std::cout &lt;&lt; std::hex;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hexadecimal: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流仍然处于十六进制模式</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Still Hexadecimal: &quot;</span> &lt;&lt; <span class="number">100</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置流为十进制模式</span></span><br><span class="line">    std::cout &lt;&lt; std::dec;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Back to Decimal: &quot;</span> &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置填充字符为 &#x27;*&#x27;</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>);</span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 填充字符仍然是 &#x27;*&#x27;</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">100</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 setw 仅对当前操作有效</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; number &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; number &lt;&lt; std::endl;  <span class="comment">// 不受 setw 影响</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置精度为 3</span></span><br><span class="line">    std::cout &lt;&lt; std::<span class="built_in">setprecision</span>(<span class="number">3</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="number">3.14159</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><ol>
<li><p><strong>粘性流操纵器</strong>：</p>
<ul>
<li>一旦设置了 <code>hex</code>，输出就会以十六进制格式显示，直到使用 <code>dec</code> 将其重置为十进制。</li>
<li><code>setfill(&#39;*&#39;)</code> 设置的填充字符会影响后续的所有 <code>setw</code> 操作，直到再次更改填充字符。</li>
<li><code>setprecision(3)</code> 设置的精度会影响后续所有的浮点数输出，直到重新设置。</li>
</ul>
</li>
<li><p><strong>非粘性流操纵器</strong>：</p>
<ul>
<li><code>setw(10)</code> 仅对紧随其后的单个输出操作有效，后续的输出操作不会受到影响。</li>
</ul>
</li>
</ol>
<h3 id="C-流操纵器类别"><a href="#C-流操纵器类别" class="headerlink" title="C++ 流操纵器类别"></a>C++ 流操纵器类别</h3><p>这些操纵器都属于 <code>ios_base</code> 类。</p>
<h4 id="常见的流操纵器"><a href="#常见的流操纵器" class="headerlink" title="常见的流操纵器"></a>常见的流操纵器</h4><ol>
<li><p><strong>showpoint 和 noshowpoint</strong></p>
<ul>
<li><code>showpoint</code>：强制输出浮点数时显示小数点和尾随零。</li>
<li><code>noshowpoint</code>：重置 <code>showpoint</code> 设置。</li>
</ul>
</li>
<li><p><strong>left 和 right</strong></p>
<ul>
<li><code>left</code>：将字段左对齐，右侧用填充字符填充。</li>
<li><code>right</code>：将字段右对齐，左侧用填充字符填充。</li>
</ul>
</li>
<li><p><strong>internal</strong></p>
<ul>
<li><code>internal</code>：将符号（或基数，使用 <code>showbase</code> 时）左对齐，数值部分右对齐，中间用填充字符填充。</li>
</ul>
</li>
<li><p><strong>fill 和 setfill</strong></p>
<ul>
<li><code>fill</code>：指定用于对齐字段的填充字符，默认填充字符是空格。</li>
<li><code>setfill</code>：参数化流操纵器，用于设置填充字符。</li>
</ul>
</li>
<li><p><strong>dec、hex 和 oct</strong></p>
<ul>
<li><code>dec</code>：指定整数以十进制显示。</li>
<li><code>hex</code>：指定整数以十六进制显示。</li>
<li><code>oct</code>：指定整数以八进制显示。</li>
</ul>
</li>
<li><p><strong>showbase 和 noshowbase</strong></p>
<ul>
<li><code>showbase</code>：强制输出整数时显示基数前缀（十进制无前缀，八进制前缀为 0，十六进制前缀为 0x 或 0X）。</li>
<li><code>noshowbase</code>：重置 <code>showbase</code> 设置。</li>
</ul>
</li>
<li><p><strong>setprecision</strong></p>
<ul>
<li><code>setprecision</code>：设置浮点数的精度。</li>
</ul>
</li>
<li><p><strong>setw</strong></p>
<ul>
<li><code>setw</code>：设置字段宽度（非粘性，只对紧随其后的单个输出操作有效）。</li>
</ul>
</li>
</ol>
<h4 id="代码示例-3"><a href="#代码示例-3" class="headerlink" title="代码示例"></a>代码示例</h4><p>以下代码示例展示了各种流操纵器的使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// showpoint 和 noshowpoint 示例</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Default: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; showpoint &lt;&lt; <span class="string">&quot;Showpoint: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; noshowpoint &lt;&lt; <span class="string">&quot;No Showpoint: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// left 和 right 示例</span></span><br><span class="line">    cout &lt;&lt; left &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot;left&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; right &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot;right&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// internal 示例</span></span><br><span class="line">    cout &lt;&lt; internal &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">-123</span> &lt;&lt; <span class="string">&quot;internal&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill 和 setfill 示例</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;*&#x27;</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot;setfill&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27; &#x27;</span>) &lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>) &lt;&lt; <span class="number">123</span> &lt;&lt; <span class="string">&quot;default fill&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dec、hex 和 oct 示例</span></span><br><span class="line">    <span class="type">int</span> number = <span class="number">255</span>;</span><br><span class="line">    cout &lt;&lt; dec &lt;&lt; <span class="string">&quot;Decimal: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; <span class="string">&quot;Hexadecimal: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; oct &lt;&lt; <span class="string">&quot;Octal: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// showbase 和 noshowbase 示例</span></span><br><span class="line">    cout &lt;&lt; showbase &lt;&lt; hex &lt;&lt; <span class="string">&quot;Showbase Hex: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; showbase &lt;&lt; oct &lt;&lt; <span class="string">&quot;Showbase Oct: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; noshowbase &lt;&lt; dec &lt;&lt; <span class="string">&quot;No Showbase Dec: &quot;</span> &lt;&lt; number &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setprecision 示例</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">setprecision</span>(<span class="number">2</span>) &lt;&lt; <span class="string">&quot;Set precision: &quot;</span> &lt;&lt; pi &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Default: <span class="number">3.14159</span></span><br><span class="line">Showpoint: <span class="number">3.141590</span></span><br><span class="line">No Showpoint: <span class="number">3.14159</span></span><br><span class="line"><span class="number">123</span>       left</span><br><span class="line">       <span class="number">123</span>right</span><br><span class="line">-       <span class="number">123</span>internal</span><br><span class="line">*******<span class="number">123</span>setfill</span><br><span class="line">       <span class="number">123</span><span class="keyword">default</span> fill</span><br><span class="line">Decimal: <span class="number">255</span></span><br><span class="line">Hexadecimal: ff</span><br><span class="line">Octal: <span class="number">377</span></span><br><span class="line">Showbase Hex: <span class="number">0xff</span></span><br><span class="line">Showbase Oct: <span class="number">0377</span></span><br><span class="line">No Showbase Dec: <span class="number">255</span></span><br><span class="line">Set precision: <span class="number">3.14</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="boolalpha的使用"><a href="#boolalpha的使用" class="headerlink" title="boolalpha的使用"></a>boolalpha的使用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用流操作符 boolalpha 来控制输出布尔值的格式。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">bool</span> booleanValue&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 显示默认的 0/1 输出</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;booleanValue is &quot;</span> &lt;&lt; booleanValue;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用 boolalpha 将布尔值显示为 true 或 false</span></span><br><span class="line">   cout &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;\nbooleanValue is &quot;</span> &lt;&lt; booleanValue;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将输出流设置为默认的 0/1 格式</span></span><br><span class="line">   cout &lt;&lt; noboolalpha &lt;&lt; <span class="string">&quot;\nbooleanValue is &quot;</span> &lt;&lt; booleanValue &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// end main</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用成员函数 flags 来保存和恢复输出流的格式状态。</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="type">bool</span> booleanValue&#123;<span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 保存原始的格式状态</span></span><br><span class="line">   ios_base::fmtflags originalFormat = cout.<span class="built_in">flags</span>();</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 显示默认的 true/false 输出</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;booleanValue is &quot;</span> &lt;&lt; booleanValue;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用 boolalpha 将布尔值显示为 true 或 false</span></span><br><span class="line">   cout &lt;&lt; boolalpha &lt;&lt; <span class="string">&quot;\nbooleanValue is &quot;</span> &lt;&lt; booleanValue;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 将输出流设置为默认的 0/1 格式</span></span><br><span class="line">   cout &lt;&lt; noboolalpha &lt;&lt; <span class="string">&quot;\nbooleanValue is &quot;</span> &lt;&lt; booleanValue;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 恢复原始的格式状态</span></span><br><span class="line">   cout.<span class="built_in">flags</span>(originalFormat);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;\n重置格式状态后，booleanValue 为 &quot;</span> </span><br><span class="line">        &lt;&lt; booleanValue &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; <span class="comment">// end main</span></span><br></pre></td></tr></table></figure>
<h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><p>在第一个程序（Fig. 13.20）中，我们演示了如何使用 <code>boolalpha</code> 和 <code>noboolalpha</code> 操纵符来控制布尔值的输出格式。初始时，布尔值 <code>booleanValue</code> 使用默认格式进行输出，然后使用 <code>boolalpha</code> 将其显示为 “true” 或 “false”，最后使用 <code>noboolalpha</code> 恢复为默认格式，显示为 0 或 1。</p>
<p>在第二个程序（Fig. 13.21）中，我们展示了如何使用 <code>flags()</code> 成员函数来保存和恢复输出流的原始格式状态。在应用任何操纵之前，我们使用 <code>cout.flags()</code> 来保存原始的格式状态，并将其存储在 <code>originalFormat</code> 中。在执行操纵后，我们使用 <code>cout.flags(originalFormat)</code> 来恢复原始的格式状态，将格式状态设置回其初始设置。</p>
<h3 id="附加说明："><a href="#附加说明：" class="headerlink" title="附加说明："></a>附加说明：</h3><ul>
<li>C++ 中的流操纵符提供了一种方便的方式来控制输入和输出操作的格式。</li>
<li><code>ios_base</code> 类的 <code>flags()</code> 成员函数允许我们访问和修改输出流的格式标志。</li>
<li>通过保存和恢复原始的格式状态，我们确保后续的输出操作保持所需的格式，而不受先前操纵的意外副作用影响。</li>
<li>理解流操纵符和格式标志对于编写健壮且易于维护的 C++ 代码至关重要，特别是在处理输入/输出操作时。</li>
</ul>
<h2 id="处理流状态"><a href="#处理流状态" class="headerlink" title="处理流状态"></a>处理流状态</h2><h3 id="流状态位"><a href="#流状态位" class="headerlink" title="流状态位"></a>流状态位</h3><ul>
<li><strong><code>eofbit</code>：</strong> 在输入流遇到文件结束时设置。</li>
<li><strong><code>failbit</code>：</strong> 当流发生格式错误且没有输入字符时设置。</li>
<li><strong><code>badbit</code>：</strong> 当发生导致数据丢失的错误时设置。</li>
<li><strong><code>goodbit</code>：</strong> 如果流中没有设置<code>eofbit</code>、<code>failbit</code>或<code>badbit</code>，则设置为好。</li>
</ul>
<h3 id="用于测试状态的成员函数"><a href="#用于测试状态的成员函数" class="headerlink" title="用于测试状态的成员函数"></a>用于测试状态的成员函数</h3><ul>
<li><strong><code>eof()</code>：</strong> 在尝试提取流末尾之外的数据后，确定是否遇到了文件末尾。</li>
<li><strong><code>fail()</code>：</strong> 报告流操作是否由于格式错误而失败。</li>
<li><strong><code>bad()</code>：</strong> 报告流操作是否由于严重错误导致数据丢失而失败。</li>
<li><strong><code>good()</code>：</strong> 如果没有错误位（<code>bad()</code>、<code>fail()</code>、<code>eof()</code>）设置，则返回true。</li>
<li><strong><code>rdstate()</code>：</strong> 返回流的错误状态。</li>
<li><strong><code>clear()</code>：</strong> 将流的状态恢复为“好”，以便继续I/O操作。</li>
</ul>
<p>C++代码示例，演示了如何使用流状态位和成员函数来处理流状态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个输入流</span></span><br><span class="line">    <span class="function">std::istringstream <span class="title">iss</span><span class="params">(<span class="string">&quot;Hello, World!&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取流中的字符直到遇到文件结束</span></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> (iss.<span class="built_in">get</span>(ch)) &#123;</span><br><span class="line">        std::cout &lt;&lt; ch; <span class="comment">// 输出字符</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查流的状态并输出相应信息</span></span><br><span class="line">    <span class="keyword">if</span> (iss.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\nReached end of file.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iss.<span class="built_in">fail</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\nFormat error occurred.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iss.<span class="built_in">bad</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\nCritical error occurred. Data loss possible.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (iss.<span class="built_in">good</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\nStream is in good state.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用rdstate()函数获取流的状态并输出</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Stream state: &quot;</span> &lt;&lt; iss.<span class="built_in">rdstate</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除流的状态，使其恢复为“好”</span></span><br><span class="line">    iss.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次检查流的状态并输出</span></span><br><span class="line">    <span class="keyword">if</span> (iss.<span class="built_in">good</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Stream state reset to good.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码片段执行以下操作：</p>
<ol>
<li>创建一个字符串流<code>iss</code>，其中包含字符串”Hello, World!”。</li>
<li>使用<code>get()</code>函数逐个字符读取流中的字符，并将它们输出到标准输出。</li>
<li>使用成员函数<code>eof()</code>、<code>fail()</code>、<code>bad()</code>和<code>good()</code>检查流的状态，并根据状态输出相应的信息。</li>
<li>使用<code>rdstate()</code>函数获取流的状态并输出。</li>
<li>使用<code>clear()</code>函数清除流的状态，使其恢复为“好”状态。</li>
<li>再次检查流的状态并输出。</li>
</ol>
<h3 id="流状态测试的成员函数"><a href="#流状态测试的成员函数" class="headerlink" title="流状态测试的成员函数"></a>流状态测试的成员函数</h3><ul>
<li><strong><code>operator!</code>：</strong> 如果设置了<code>badbit</code>或<code>failbit</code>，则返回true。</li>
<li><strong><code>operator void *</code>：</strong> 如果设置了<code>badbit</code>或<code>failbit</code>，则返回false。</li>
</ul>
<h3 id="在文件处理中的使用"><a href="#在文件处理中的使用" class="headerlink" title="在文件处理中的使用"></a>在文件处理中的使用</h3><p>这些函数在文件处理循环或条件中测试真/假条件时非常有用。</p>
<hr>
<h2 id="同步输入和输出流"><a href="#同步输入和输出流" class="headerlink" title="同步输入和输出流"></a>同步输入和输出流</h2><h3 id="使用cin-tie"><a href="#使用cin-tie" class="headerlink" title="使用cin.tie()"></a>使用<code>cin.tie()</code></h3><ul>
<li><strong>目的：</strong> 确保提示在输入操作之前出现。</li>
<li><strong>用法：</strong> <code>cin.tie(&amp;cout);</code></li>
<li><strong>效果：</strong> 将<code>cout</code>（一个<code>ostream</code>）与<code>cin</code>（一个<code>istream</code>）绑定，同步它们的操作。</li>
</ul>
<h3 id="示例用法"><a href="#示例用法" class="headerlink" title="示例用法"></a>示例用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将cin和cout绑定在一起，以实现输入/输出同步</span></span><br><span class="line">    std::cin.<span class="built_in">tie</span>(&amp;std::cout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提示消息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入一个数字：&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入操作</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    std::cin &gt;&gt; num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出输入的数字</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你输入的数字是：&quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="缓冲和绑定机制"><a href="#缓冲和绑定机制" class="headerlink" title="缓冲和绑定机制"></a>缓冲和绑定机制</h3><h3 id="输出缓冲"><a href="#输出缓冲" class="headerlink" title="输出缓冲"></a>输出缓冲</h3><p>输出缓冲是指系统将输出数据暂时存储在内存中，直到满足某些条件后才将其写入到输出设备（如显示器或文件）。这样做的好处是可以提高程序的性能，减少对IO设备的访问次数，从而提高效率。</p>
<p>在 C++ 中，设置缓冲区对于提高程序性能和资源管理具有重要意义。缓冲区是一块用于临时存储数据的内存区域，常用于 I/O 操作中。以下是缓冲区在 C++ 中的主要用途和意义：</p>
<h3 id="1-提高-I-O-操作效率"><a href="#1-提高-I-O-操作效率" class="headerlink" title="1. 提高 I/O 操作效率"></a>1. 提高 I/O 操作效率</h3><p>I/O 操作（例如文件读写、网络通信）通常比内存操作慢得多。缓冲区通过减少 I/O 操作的频率来提高效率。例如，当从文件中读取数据时，将数据块读入缓冲区，而不是每次读取一个字节。这样，程序可以在内存中处理数据，而不是频繁地与外部设备交互。</p>
<h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置缓冲区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">char</span> buffer[bufferSize];</span><br><span class="line">    file.<span class="built_in">rdbuf</span>()-&gt;<span class="built_in">pubsetbuf</span>(buffer, bufferSize);</span><br><span class="line"></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(file, line)) &#123;</span><br><span class="line">        std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-减少系统调用次数"><a href="#2-减少系统调用次数" class="headerlink" title="2. 减少系统调用次数"></a>2. 减少系统调用次数</h3><p>每次 I/O 操作都会涉及系统调用，这通常是昂贵的操作。通过使用缓冲区，可以一次性执行较大块的数据传输，从而减少系统调用的次数，提高性能。</p>
<h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE* file = <span class="built_in">fopen</span>(<span class="string">&quot;example.txt&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置缓冲区</span></span><br><span class="line">    <span class="type">const</span> <span class="type">size_t</span> bufferSize = <span class="number">1024</span>;</span><br><span class="line">    <span class="type">char</span> buffer[bufferSize];</span><br><span class="line">    <span class="built_in">setvbuf</span>(file, buffer, _IOFBF, bufferSize); <span class="comment">// 全缓冲</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="keyword">while</span> ((ch = <span class="built_in">fgetc</span>(file)) != EOF) &#123;</span><br><span class="line">        <span class="built_in">putchar</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-控制输出行为"><a href="#3-控制输出行为" class="headerlink" title="3. 控制输出行为"></a>3. 控制输出行为</h3><p>使用缓冲区可以控制数据何时实际输出到目标设备。例如，标准输出（<code>stdout</code>）默认是行缓冲模式，即每当遇到换行符时，缓冲区的内容才会被刷新到显示设备。通过手动刷新缓冲区，可以更灵活地控制输出行为。</p>
<h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; std::flush; <span class="comment">// 手动刷新缓冲区</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-提高多线程程序的性能"><a href="#4-提高多线程程序的性能" class="headerlink" title="4. 提高多线程程序的性能"></a>4. 提高多线程程序的性能</h3><p>在多线程程序中，缓冲区可以减少线程间的资源争用。例如，每个线程可以有自己的缓冲区，从而避免频繁地锁定共享资源。</p>
<h3 id="5-提供数据的临时存储"><a href="#5-提供数据的临时存储" class="headerlink" title="5. 提供数据的临时存储"></a>5. 提供数据的临时存储</h3><p>缓冲区可以用于存储临时数据，特别是在数据需要在不同函数或模块之间传递时。例如，在网络编程中，接收到的数据通常先存入缓冲区，然后再进行处理。</p>
<h3 id="总结-7"><a href="#总结-7" class="headerlink" title="总结"></a>总结</h3><p>设置缓冲区在 C++ 中具有以下主要意义：</p>
<ul>
<li>提高 I/O 操作效率。</li>
<li>减少系统调用次数。</li>
<li>控制输出行为。</li>
<li>提高多线程程序的性能。</li>
<li>提供数据的临时存储。</li>
</ul>
<p>通过合理使用缓冲区，可以显著提高程序的性能和响应速度，同时增强对资源的控制和管理。</p>
<ul>
<li><p><strong>工作原理：</strong> 当使用<code>cout</code>进行输出时，输出的数据首先被存储在内存中的输出缓冲区中，直到缓冲区被填满或者手动刷新（使用<code>flush</code>函数），才会将数据写入到输出设备。</p>
</li>
<li><p><strong>刷新缓冲区：</strong> 输出缓冲区在以下情况下会被刷新：</p>
<ol>
<li>缓冲区被填满。</li>
<li>调用<code>endl</code>插入符或者<code>flush</code>函数。</li>
<li>程序正常结束。</li>
</ol>
</li>
</ul>
<h3 id="绑定机制"><a href="#绑定机制" class="headerlink" title="绑定机制"></a>绑定机制</h3><p>绑定机制用于确保输出操作发生在输入操作之前，尤其是在需要用户输入数据时。这样做的目的是为了在用户看到输出并作出相应响应之前先向其展示提示信息或其他输出。</p>
<ul>
<li><p><strong><code>cin.tie()</code>函数：</strong> 用于将一个输出流（通常是<code>cout</code>）绑定到一个输入流（通常是<code>cin</code>）上，以确保在输入操作之前先刷新输出流的缓冲区。</p>
</li>
<li><p><strong>作用：</strong> 绑定机制确保在程序提示用户输入之前，所有之前的输出都已经被显示，避免了输出被延迟到用户输入后才显示的情况。</p>
</li>
</ul>
<h3 id="代码示例-4"><a href="#代码示例-4" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面是一个使用绑定机制的示例代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将cout与cin绑定，确保输出在输入之前显示</span></span><br><span class="line">    std::cin.<span class="built_in">tie</span>(&amp;std::cout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出提示信息</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入您的名字：&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收用户输入</span></span><br><span class="line">    std::string name;</span><br><span class="line">    std::cin &gt;&gt; name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出用户输入的名字</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;你好，&quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，使用<code>cin.tie(&amp;cout)</code>函数将输出流<code>cout</code>绑定到输入流<code>cin</code>上，这样在等待用户输入之前，输出提示信息就会被立即显示出来。</p>
<hr>
<h2 id="C-How-to-Program"><a href="#C-How-to-Program" class="headerlink" title="C++ How to Program"></a>C++ How to Program</h2><blockquote>
<p>内存中的数据存储是临时的。<br>文件用于数据持久性——数据的永久保留。<br>计算机将文件存储在二级存储设备上，如硬盘、CD、DVD、闪存驱动器和磁带。</p>
</blockquote>
<h2 id="文件处理基础概念"><a href="#文件处理基础概念" class="headerlink" title="文件处理基础概念"></a>文件处理基础概念</h2><ul>
<li>C++将每个文件视为一系列字节（图14.1）。</li>
<li>每个文件要么以文件结束标记结束，要么在操作系统维护的特定字节号处结束。</li>
<li>打开文件时，会创建一个对象，并将流与该对象关联。</li>
<li>我们看到当包含 <code>&lt;iostream&gt;</code>时，会创建对象 cin、cout、cerr 和 clog。</li>
<li>与这些对象关联的流提供了程序与特定文件或设备之间的通信渠道。</li>
</ul>
<h3 id="文件处理类模板"><a href="#文件处理类模板" class="headerlink" title="文件处理类模板"></a>文件处理类模板</h3><ul>
<li>要在C++中进行文件处理，必须包含头文件<code>&lt;iostream&gt;</code> 和<code>&lt;fstream&gt;</code>。</li>
<li>头文件 <code>&lt;fstream&gt;</code> 包含了流类模板 basic_ifstream（用于文件输入）、basic_ofstream（用于文件输出）和 basic_fstream（用于文件输入和输出）的定义。</li>
<li>每个类模板都有一个预定义的模板特化，使得可以进行 char 类型的 I/O。</li>
</ul>
<h3 id="lt-fstream-gt-库提供了这些模板特化的-typedef-别名。"><a href="#lt-fstream-gt-库提供了这些模板特化的-typedef-别名。" class="headerlink" title="&lt;fstream&gt; 库提供了这些模板特化的 typedef 别名。"></a><code>&lt;fstream&gt;</code> 库提供了这些模板特化的 typedef 别名。</h3><ul>
<li>typedef ifstream 表示 basic_ifstream 的特化，使得可以从文件进行 char 类型的输入。</li>
<li>typedef ofstream 表示 basic_ofstream 的特化，使得可以向文件进行 char 类型的输出。</li>
<li>typedef fstream 表示 basic_fstream 的特化，使得可以进行 char 类型的输入和输出。</li>
</ul>
<h3 id="这些模板继承自类模板-basic-istream、basic-ostream-和-basic-iostream。"><a href="#这些模板继承自类模板-basic-istream、basic-ostream-和-basic-iostream。" class="headerlink" title="这些模板继承自类模板 basic_istream、basic_ostream 和 basic_iostream。"></a>这些模板继承自类模板 basic_istream、basic_ostream 和 basic_iostream。</h3><ul>
<li>因此，所有属于这些模板的成员函数、操作符和操作符操纵符（我们在第13章中描述过）也可以应用于文件流。</li>
<li>图14.2 总结了我们到目前为止讨论的 I/O 类的继承关系。</li>
</ul>
<blockquote>
<ul>
<li>文件处理在C++中是非常重要的，它允许程序与外部存储设备（如硬盘）进行交互，从而实现数据的永久存储和读取。</li>
</ul>
</blockquote>
<ul>
<li>通过文件处理类模板，我们可以轻松地进行文件的输入和输出操作，使得程序可以读取和修改文件中的数据。</li>
<li>在进行文件处理时，务必注意文件的打开和关闭操作，以确保文件资源被正确释放，避免资源泄漏和文件损坏的情况发生。</li>
<li>另外，在处理文件时，还需要考虑文件的格式化和解析问题，以确保数据的正确读取和写入。</li>
<li>文件处理是C++编程中的重要部分，它为程序提供了与外部环境进行数据交换的能力，是编写高效、实用的程序的关键之一。</li>
</ul>
<h3 id="代码示例-5"><a href="#代码示例-5" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面是一个简单的C++代码示例，演示了如何使用文件流进行文件的输入和输出操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开一个名为 &quot;data.txt&quot; 的文件，用于写入数据</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">outputFile</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据到文件</span></span><br><span class="line">    outputFile &lt;&lt; <span class="string">&quot;Hello, World!\n&quot;</span>;</span><br><span class="line">    outputFile &lt;&lt; <span class="string">&quot;This is a file.\n&quot;</span>;</span><br><span class="line">    outputFile &lt;&lt; <span class="string">&quot;File processing in C++ is awesome!\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    outputFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开刚刚创建的文件，用于读取数据</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inputFile</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件读取数据，并输出到标准输出</span></span><br><span class="line">    std::string line;</span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">getline</span>(inputFile, line)) &#123;</span><br><span class="line">        std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    inputFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的功能是：创建一个名为 “data.txt” 的文件，将数据写入其中，然后再从该文件中读取数据并输出到标准输出。</p>
<h3 id="C-中的文件结构："><a href="#C-中的文件结构：" class="headerlink" title="C++ 中的文件结构："></a><strong>C++ 中的文件结构：</strong></h3><p>C++ 并不会对文件施加任何固定的结构。开发者需要根据应用程序的需求来组织文件。</p>
<p><strong>顺序文件创建：</strong><br>可以创建顺序文件来管理数据，例如在应收账款系统中。文件中的每个记录代表有关客户的信息，通常包括账号、姓名和余额。</p>
<p><strong>记录概念：</strong><br>在 C++ 中，并没有对文件中的“记录”进行明确的定义。但在实际中，可以将记录视为一组相关的数据项，在文件中通常以特定格式组织。</p>
<p><strong>C++ 中的文件打开：</strong><br>要向文件中写入数据，在 C++ 中可以创建一个 <code>ofstream</code> 对象。该对象的构造函数接受两个参数：文件名和文件打开模式。文件打开模式可以是 <code>ios::out</code>（默认）用于向文件输出数据，或者 <code>ios::app</code> 用于将数据附加到现有文件中。</p>
<p><strong>文件打开模式：</strong><br>文件打开模式包括 <code>ios::out</code> 用于输出和 <code>ios::app</code> 用于附加。在 C++11 之前，文件名是指定为基于指针的字符串，但自 C++11 起，也可以指定为字符串对象。</p>
<p><strong>使用 <code>open</code> 成员函数打开文件：</strong><br>也可以使用 <code>ofstream</code> 对象的 <code>open</code> 成员函数打开文件。这允许将文件附加到现有的 <code>ofstream</code> 对象上。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ofstream outClientFile;</span><br><span class="line">outClientFile.<span class="built_in">open</span>(<span class="string">&quot;clients.dat&quot;</span>, ios::out);</span><br></pre></td></tr></table></figure>
<p><strong>检查文件打开成功：</strong><br>在尝试打开文件后，有必要验证操作是否成功。可以使用 <code>ios</code> 的重载 <code>!</code> 运算符来检查 <code>failbit</code> 或 <code>badbit</code>。如果其中任一位被设置，表示文件打开操作失败。</p>
<p><strong>错误处理和程序终止：</strong><br>如果文件打开操作失败或出现其他错误，程序可以使用 <code>exit</code> 函数终止。传递 <code>EXIT_FAILURE</code> 表示错误，而传递 <code>EXIT_SUCCESS</code> 表示成功终止。</p>
<p><strong>代码示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// 用于退出状态宏</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打开输出文件</span></span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;clients.dat&quot;</span>, ios::out)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查文件是否成功打开</span></span><br><span class="line">    <span class="keyword">if</span> (!outFile) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;打开文件时发生错误。&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件操作...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>重载的 <code>void *</code> 运算符：</strong></p>
<ul>
<li><code>operator void *</code> 是 <code>ios</code> 类的一个成员函数，用于将流对象转换为指针。</li>
<li>可以将流对象用作条件，C++ 将空指针解释为 <code>false</code>，非空指针解释为 <code>true</code>。</li>
<li>如果流的 <code>failbit</code> 或 <code>badbit</code> 被设置，<code>operator void *</code> 返回 <code>0</code>，否则返回非零值。</li>
<li>在 <code>while</code> 循环等条件语句中，可以隐式调用 <code>operator void *</code>，例如 <code>while (cin)</code>。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入数据，直到遇到文件结束符</span></span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; num) &#123;</span><br><span class="line">        <span class="comment">// 处理输入的数据</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;输入的数字是：&quot;</span> &lt;&lt; num &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到达文件结束时的处理</span></span><br><span class="line">    <span class="keyword">if</span> (std::cin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;已达到文件结束。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;输入错误或发生其他问题。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li>在 <code>while (std::cin &gt;&gt; num)</code> 循环中，<code>std::cin &gt;&gt; num</code> 表达式会调用 <code>std::istream</code> 类的 <code>operator void *</code> 成员函数，将输入流对象 <code>std::cin</code> 转换为指针。</li>
<li>如果输入操作成功，则表达式返回非零值（<code>true</code>），继续循环；如果遇到文件结束符或输入错误，则返回 <code>0</code>（<code>false</code>），循环结束。</li>
<li><code>std::cin.eof()</code> 可以进一步检查是否达到了文件结束。</li>
</ul>
<p><strong>数据处理：</strong></p>
<ul>
<li>可以使用 <code>operator void *</code> 来测试输入对象是否到达文件结束，也可以调用成员函数 <code>eof()</code>。</li>
<li>不同计算机系统有不同的键盘组合来输入文件结束符。</li>
</ul>
<p><strong>代码示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入数据，直到遇到文件结束符</span></span><br><span class="line">    <span class="keyword">while</span> (std::cin.<span class="built_in">get</span>(ch)) &#123;</span><br><span class="line">        <span class="comment">// 处理输入的字符</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;输入的字符是：&quot;</span> &lt;&lt; ch &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到达文件结束时的处理</span></span><br><span class="line">    <span class="keyword">if</span> (std::cin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;已达到文件结束。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;输入错误或发生其他问题。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li>在 <code>while (std::cin.get(ch))</code> 循环中，<code>std::cin.get(ch)</code> 表达式会调用 <code>std::istream</code> 类的 <code>operator void *</code> 成员函数，将输入流对象 <code>std::cin</code> 转换为指针。</li>
<li>如果输入操作成功，则表达式返回非零值（<code>true</code>），继续循环；如果遇到文件结束符或输入错误，则返回 <code>0</code>（<code>false</code>），循环结束。</li>
<li><code>std::cin.eof()</code> 可以进一步检查是否达到了文件结束。</li>
</ul>
<p><strong>数据处理：</strong></p>
<ul>
<li>当遇到文件结束符或错误数据时，<code>operator void *</code> 返回空指针（转换为布尔值 <code>false</code>），导致循环终止。</li>
<li>用户输入文件结束符来通知程序停止处理额外数据。</li>
<li>文件结束指示符会在用户输入文件结束键组合时被设置。</li>
</ul>
<p><strong>文件写入：</strong></p>
<ul>
<li>使用流插入运算符 <code>&lt;&lt;</code> 可以将数据写入文件。</li>
<li>关联的输出文件流对象（如 <code>outClientFile</code>）可用于向文件中写入数据。</li>
</ul>
<p><strong>文件查看：</strong></p>
<ul>
<li>创建的文件是一个文本文件，可以使用任何文本编辑器查看。</li>
</ul>
<p><strong>关闭文件：</strong></p>
<ul>
<li>当程序终止时，文件流对象的析构函数会被隐式调用，关闭文件。</li>
<li>也可以显式地关闭文件流对象，使用成员函数 <code>close()</code>。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输出文件</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;clients.txt&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据到文件，直到遇到文件结束符或错误数据</span></span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; data) &#123;</span><br><span class="line">        outFile &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件结束时的处理</span></span><br><span class="line">    <span class="keyword">if</span> (std::cin.<span class="built_in">eof</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;文件结束或输入错误数据。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;未知错误发生。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭文件</span></span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解释：</strong></p>
<ul>
<li>这个程序从标准输入（键盘）读取整数数据，并将其写入名为 <code>clients.txt</code> 的文件中。</li>
<li>循环会在遇到文件结束符或错误数据时终止。</li>
<li>当文件结束时，输出相应的消息。</li>
<li>最后，关闭输出文件流对象，确保数据被正确写入文件并且文件被关闭。</li>
</ul>
<h3 id="读文件的基本步骤？"><a href="#读文件的基本步骤？" class="headerlink" title="读文件的基本步骤？"></a>读文件的基本步骤？</h3><p>好的，以下是带有代码示例的总结：</p>
<ol>
<li><p><strong>文件处理基础</strong>：</p>
<ul>
<li>使用<code>ifstream</code>从文件中读取数据。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;clients.txt&quot;</span>)</span></span>; <span class="comment">// 打开文件以供读取</span></span><br><span class="line">    <span class="comment">// 从文件中读取数据</span></span><br><span class="line">    <span class="comment">// 当`inFile`超出作用域时，文件会自动关闭</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>打开文件以供输入</strong>：</p>
<ul>
<li>使用文件名和打开模式创建<code>ifstream</code>对象。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;clients.txt&quot;</span>)</span></span>; <span class="comment">// 打开文件以供读取</span></span><br><span class="line"><span class="comment">// 从文件中读取数据</span></span><br><span class="line">inFile.<span class="built_in">close</span>(); <span class="comment">// 完成后关闭文件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从文件中读取数据</strong>：</p>
<ul>
<li>使用循环读取数据，直到到达文件末尾。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;clients.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> account;</span><br><span class="line">string name;</span><br><span class="line"><span class="type">double</span> balance;</span><br><span class="line"><span class="keyword">while</span> (inFile &gt;&gt; account &gt;&gt; name &gt;&gt; balance) &#123;</span><br><span class="line">    <span class="comment">// 处理数据</span></span><br><span class="line">&#125;</span><br><span class="line">inFile.<span class="built_in">close</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>文件位置指针</strong>：</p>
<ul>
<li>每个<code>istream</code>对象都有一个读取指针，指示下一次输入将发生的文件中的字节号，而每个<code>ostream</code>对象都有一个写入指针，指示下一次输出应该放置的文件中的字节号。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inClientFile.<span class="built_in">seekg</span>(<span class="number">0</span>); <span class="comment">// 将文件位置指针重新定位到文件的开头（位置0）</span></span><br></pre></td></tr></table></figure>
<p> <strong>指定的<code>seekg</code>参数</strong>：</p>
<ul>
<li><code>seekg</code>函数通常接受一个<code>long</code>整数作为参数。可以指定第二个参数以指示搜索方向。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fileObject.<span class="built_in">seekg</span>(n); <span class="comment">// 定位到文件对象的第n个字节（假设`ios::beg`）</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>(n, ios::cur); <span class="comment">// 在文件对象中向前移动n个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>(n, ios::end); <span class="comment">// 从文件对象末尾向后移动n个字节</span></span><br><span class="line">fileObject.<span class="built_in">seekg</span>(<span class="number">0</span>, ios::end); <span class="comment">// 定位到文件对象的末尾</span></span><br></pre></td></tr></table></figure>
<p><strong>成员函数<code>tellg</code>和<code>tellp</code></strong>：</p>
<ul>
<li>提供了<code>tellg</code>和<code>tellp</code>成员函数来分别返回读取和写入指针的当前位置。<br><code>tellg</code>和<code>tellp</code>成员函数分别用于返回读取和写入指针的当前位置。下面是它们的简单示例：</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;example.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!inFile) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to open the file.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取读取指针的当前位置</span></span><br><span class="line">    streampos readPos = inFile.<span class="built_in">tellg</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Current read position: &quot;</span> &lt;&lt; readPos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设在文件中读取一些数据后</span></span><br><span class="line">    string data;</span><br><span class="line">    inFile &gt;&gt; data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次获取读取指针的当前位置</span></span><br><span class="line">    readPos = inFile.<span class="built_in">tellg</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Updated read position: &quot;</span> &lt;&lt; readPos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="function">ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;output.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!outFile) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Failed to create the file.&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取写入指针的当前位置</span></span><br><span class="line">    streampos writePos = outFile.<span class="built_in">tellp</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Current write position: &quot;</span> &lt;&lt; writePos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设写入一些数据到文件后</span></span><br><span class="line">    outFile &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 再次获取写入指针的当前位置</span></span><br><span class="line">    writePos = outFile.<span class="built_in">tellp</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Updated write position: &quot;</span> &lt;&lt; writePos &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不可修改的问题"><a href="#不可修改的问题" class="headerlink" title="不可修改的问题"></a>不可修改的问题</h3><p>在序列文件中，通过格式化和写入的数据是不可修改的，否则会破坏文件中的其他数据。比如，如果需要将名字“White”改为“Worthington”，则无法直接覆盖原有数据而不破坏文件。</p>
<p>原始记录为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">300 White 0.00</span><br></pre></td></tr></table></figure>
<p>如果直接在文件中相同位置上重写记录，并使用更长的名字，则新记录将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">300 Worthington 0.00</span><br></pre></td></tr></table></figure>
<p>新记录比原记录多了六个字符。因此，超出“Worthington”中第二个“o”后的字符将覆盖文件中下一个顺序记录的开始部分。</p>
<h3 id="格式化输入-输出模型的问题"><a href="#格式化输入-输出模型的问题" class="headerlink" title="格式化输入/输出模型的问题"></a>格式化输入/输出模型的问题</h3><p>使用流插入运算符 &lt;&lt; 和流提取运算符 &gt;&gt; 的格式化输入/输出模型中，字段（因此也是记录）的大小是可变的。例如，值为7、14、-117、2074和27383的整数都是 int 类型，内部存储的“原始数据”字节数是相同的（在32位机器上通常为四个字节，在64位机器上为八个字节）。</p>
<p>然而，当这些整数以格式化文本（字符序列）的形式输出时，它们变成了不同大小的字段，取决于它们的实际值。因此，格式化输入/输出模型通常不用于原地更新记录。这样的更新通常会很麻烦。</p>
<p>例如，要进行前述姓名更改，可以将300 White 0.00之前的记录复制到一个新文件中，然后将更新后的记录写入新文件，最后将300 White 0.00之后的记录复制到新文件中。然后删除旧文件并重命名新文件。</p>
<p>这种方法需要处理文件中的每个记录来更新一个记录。但是，如果在一次文件扫描中要更新许多记录，这种技术是可以接受的。</p>
<blockquote>
<p>在格式化输入/输出模型中，由于字段大小的可变性，对记录进行原地更新是有挑战性的。通常，更好的方法是通过复制、更新和重写文件来实现更新操作。这虽然可能需要处理文件中的所有记录，但在一次文件扫描中更新多个记录时，这种方法是可行的。</p>
</blockquote>
<h3 id="随机访问文件"><a href="#随机访问文件" class="headerlink" title="随机访问文件"></a>随机访问文件</h3><p>顺序文件不适合需要立即访问特定记录的应用程序，比如航空订票系统、银行系统、销售点系统、自动取款机以及其他需要快速访问特定数据的交易处理系统。</p>
<p>随机访问文件的单个记录可以直接（并快速地）访问，而无需搜索其他记录。在C++中，文件的结构不是强制的。因此，想要使用随机访问文件的应用程序必须自己创建它们。</p>
<p>创建一个随机访问文件并向其写入记录，可以像打开一个流一样简单。首先，需要指定文件的打开模式为输出模式（ios::out），并使用二进制模式（ios::binary）打开文件，以确保不对记录进行任何格式化。</p>
<p>接下来，可以定义记录的结构，并使用 <code>fstream</code> 类创建一个文件对象。将记录写入文件时，需要使用 <code>write</code> 函数，并将记录的地址强制转换为字符指针，并指定写入的字节数（即记录的大小）。</p>
<p>随机访问文件允许我们从文件中的任何位置读取记录。为了随机读取记录，我们需要使用 <code>seekg</code> 函数来移动文件指针到所需记录的位置。然后使用 <code>read</code> 函数来读取记录的内容。在读取时，需要将记录的地址强制转换为字符指针，并指定要读取的字节数（即记录的大小）。</p>
<p>下面是一个示例代码，演示了如何创建、写入和读取固定长度的记录，并且可以在文件中随机访问记录：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义固定长度的记录结构</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Record</span> &#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">30</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">double</span> salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个随机访问文件并写入记录</span></span><br><span class="line">    <span class="function">fstream <span class="title">file</span><span class="params">(<span class="string">&quot;records.dat&quot;</span>, ios::out | ios::binary)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error creating file!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Record rec1 = &#123;<span class="string">&quot;John Smith&quot;</span>, <span class="number">30</span>, <span class="number">50000.00</span>&#125;;</span><br><span class="line">    Record rec2 = &#123;<span class="string">&quot;Jane Doe&quot;</span>, <span class="number">25</span>, <span class="number">60000.00</span>&#125;;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;rec1), <span class="built_in">sizeof</span>(Record));</span><br><span class="line">    file.<span class="built_in">write</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;rec2), <span class="built_in">sizeof</span>(Record));</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中随机读取记录</span></span><br><span class="line">    file.<span class="built_in">open</span>(<span class="string">&quot;records.dat&quot;</span>, ios::in | ios::binary);</span><br><span class="line">    <span class="keyword">if</span> (!file) &#123;</span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Error opening file!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Record readRec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移动指针到第二个记录的位置</span></span><br><span class="line">    file.<span class="built_in">seekg</span>(<span class="built_in">sizeof</span>(Record), ios::beg);</span><br><span class="line">    file.<span class="built_in">read</span>(<span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;readRec), <span class="built_in">sizeof</span>(Record));</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; readRec.name &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Age: &quot;</span> &lt;&lt; readRec.age &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Salary: &quot;</span> &lt;&lt; readRec.salary &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    file.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们首先创建了一个随机访问文件，并向其写入了两个记录。然后，我们随机读取了第二个记录，并打印了其内容。</p>
<blockquote>
<p>write 函数的使用：write 函数用于向文件中写入固定数量的字节，从指定的内存位置开始。当文件与流相关联时，write 函数将数据写入文件中指定的位置，位置由文件指针决定。</p>
<p>read 函数的使用：read 函数用于从指定的流中读取固定数量的字节到内存中的指定位置。当文件与流相关联时，read 函数将从文件中指定的位置读取字节，位置也由文件指针决定。</p>
<p>reinterpret_cast 操作符的作用：大多数情况下，我们将不同类型的指针传递给 write 函数作为第一个参数，这些指针不是 const char <em> 类型的。为了确保编译器能够编译 write 函数的调用，我们需要将这些指针转换为 const char </em> 类型。这时就需要使用 reinterpret_cast 操作符进行指针类型的转换。该操作符在编译时执行，不会改变其操作数所指向的对象的值。</p>
<p>随机访问文件：在示例中，我们打开了一个二进制文件，并使用 write 函数将数据写入其中。通过移动文件指针，我们可以在文件中定位到指定位置，并在该位置读取或写入数据，这就是随机访问文件的基本原理。</p>
</blockquote>
<h3 id="面向对象的输入-输出风格"><a href="#面向对象的输入-输出风格" class="headerlink" title="面向对象的输入/输出风格"></a>面向对象的输入/输出风格</h3><p>在面向对象的编程中，输入和输出的风格与传统的基于流的输入/输出不同。对象的成员函数不直接与对象的数据进行输入和输出，而是由类的成员函数的一个共享副本来处理这些操作。</p>
<p>当对象的数据成员被输出到磁盘文件时，我们失去了对象的类型信息。在文件中，我们只存储对象属性的值，而不包含对象的类型信息。如果读取数据的程序知道数据对应的对象类型，那么它可以将数据读取到相应类型的对象中。</p>
<h3 id="对象序列化"><a href="#对象序列化" class="headerlink" title="对象序列化"></a>对象序列化</h3><p>在存储不同类型的对象时，我们面临一个问题：如何在读取时区分它们？由于对象通常不包含类型字段，因此我们需要一种方法来保存对象的类型信息。</p>
<p>对象序列化是一种常见的解决方案。序列化对象是对象的字节序列，包括对象的数据以及关于对象类型和数据类型的信息。将序列化对象写入文件后，可以从文件中读取并反序列化，以重新创建对象在内存中的表示。</p>
<h3 id="如何系列化？"><a href="#如何系列化？" class="headerlink" title="如何系列化？"></a>如何系列化？</h3><p>对象序列化是将对象转换为字节序列的过程，以便将其保存到文件或通过网络进行传输。在C++中，可以使用一些技术来实现对象的序列化，其中最常见的方法是通过重载流操作符 (<code>&lt;&lt;</code> 和 <code>&gt;&gt;</code>) 或者使用序列化库（如Boost.Serialization）。</p>
<p>下面是一个简单的示例，演示了如何使用流操作符来序列化和反序列化一个对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Person&amp; person);</span><br><span class="line">    <span class="keyword">friend</span> std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Person&amp; person);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(<span class="type">const</span> std::string&amp; n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Getter methods</span></span><br><span class="line">    <span class="function">std::string <span class="title">getName</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(std::ostream&amp; os, <span class="type">const</span> Person&amp; person) &#123;</span><br><span class="line">    os &lt;&lt; person.name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; person.age &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::istream&amp; <span class="keyword">operator</span>&gt;&gt;(std::istream&amp; is, Person&amp; person) &#123;</span><br><span class="line">    is &gt;&gt; person.name &gt;&gt; person.age;</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建对象</span></span><br><span class="line">    <span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Bob&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化对象到文件</span></span><br><span class="line">    <span class="function">std::ofstream <span class="title">outFile</span><span class="params">(<span class="string">&quot;people.txt&quot;</span>)</span></span>;</span><br><span class="line">    outFile &lt;&lt; p1 &lt;&lt; p2;</span><br><span class="line">    outFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从文件中反序列化对象</span></span><br><span class="line">    <span class="function">std::ifstream <span class="title">inFile</span><span class="params">(<span class="string">&quot;people.txt&quot;</span>)</span></span>;</span><br><span class="line">    <span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span>, <span class="title">p4</span><span class="params">(<span class="string">&quot;&quot;</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    inFile &gt;&gt; p3 &gt;&gt; p4;</span><br><span class="line">    inFile.<span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出反序列化后的对象</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; p3.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; p3.<span class="built_in">getAge</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; p4.<span class="built_in">getName</span>() &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; p4.<span class="built_in">getAge</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个 <code>Person</code> 类来表示人员对象，然后重载了流操作符 <code>&lt;&lt;</code> 和 <code>&gt;&gt;</code> 来实现对象的序列化和反序列化。通过将对象写入文件，然后再从文件中读取并重新创建对象，我们实现了对象的序列化和反序列化过程。</p>
<hr>
<h2 id="Standard-Library-Containers-and-Iterators"><a href="#Standard-Library-Containers-and-Iterators" class="headerlink" title="Standard Library Containers and Iterators"></a>Standard Library Containers and Iterators</h2><blockquote>
<p>容器、迭代器和算法是C++标准库的核心组件。本章介绍了这些组件，并解释了它们在实现常见数据结构和处理算法中的作用。</p>
</blockquote>
<h3 id="顺序容器概述（Overview-of-the-Sequential-Containers）"><a href="#顺序容器概述（Overview-of-the-Sequential-Containers）" class="headerlink" title="顺序容器概述（Overview of the Sequential Containers）"></a>顺序容器概述（Overview of the Sequential Containers）</h3><div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>vector</code></td>
<td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢</td>
</tr>
<tr>
<td><code>deque</code></td>
<td>双端队列。支持快速随机访问。在头尾位置插入或删除速度很快</td>
</tr>
<tr>
<td><code>list</code></td>
<td>双向链表。只支持双向顺序访问。在任何位置插入或删除速度都很快</td>
</tr>
<tr>
<td><code>forward_list</code></td>
<td>单向链表。只支持单向顺序访问。在任何位置插入或删除速度都很快</td>
</tr>
<tr>
<td><code>array</code></td>
<td>固定大小数组。支持快速随机访问。不能添加或删除元素</td>
</tr>
<tr>
<td><code>string</code></td>
<td>类似<code>vector</code>，但用于保存字符。支持快速随机访问。在尾部插入或删除速度很快</td>
</tr>
</tbody>
</table>
</div>
<p><code>forward_list</code>和<code>array</code>是C++11新增类型。与内置数组相比，<code>array</code>更安全易用。<code>forward_list</code>没有<code>size</code>操作。</p>
<p>容器选择原则：</p>
<ul>
<li>除非有合适的理由选择其他容器，否则应该使用<code>vector</code>。</li>
<li>如果程序有很多小的元素，且空间的额外开销很重要，则不要使用<code>list</code>或<code>forward_list</code>。</li>
<li>如果程序要求随机访问容器元素，则应该使用<code>vector</code>或<code>deque</code>。</li>
<li>如果程序需要在容器头尾位置插入/删除元素，但不会在中间位置操作，则应该使用<code>deque</code>。</li>
<li>如果程序只有在读取输入时才需要在容器中间位置插入元素，之后需要随机访问元素。则：<ul>
<li>先确定是否真的需要在容器中间位置插入元素。当处理输入数据时，可以先向<code>vector</code>追加数据，再调用标准库的<code>sort</code>函数重排元素，从而避免在中间位置添加元素。</li>
<li>如果必须在中间位置插入元素，可以在输入阶段使用<code>list</code>。输入完成后将<code>list</code>中的内容拷贝到<code>vector</code>中。</li>
</ul>
</li>
<li>不确定应该使用哪种容器时，可以先只使用<code>vector</code>和<code>list</code>的公共操作：使用迭代器，不使用下标操作，避免随机访问。这样在必要时选择<code>vector</code>或<code>list</code>都很方便。</li>
</ul>
<h3 id="容器库概览（Container-Library-Overview）"><a href="#容器库概览（Container-Library-Overview）" class="headerlink" title="容器库概览（Container Library Overview）"></a>容器库概览（Container Library Overview）</h3><p>每个容器都定义在一个头文件中，文件名与类型名相同。容器均为模板类型。</p>
<h4 id="迭代器（Iterators）"><a href="#迭代器（Iterators）" class="headerlink" title="迭代器（Iterators）"></a>迭代器（Iterators）</h4><p><code>forward_list</code>类型不支持递减运算符<code>--</code>。</p>
<p>一个迭代器范围（iterator range）由一对迭代器表示。这两个迭代器通常被称为<code>begin</code>和<code>end</code>，分别指向同一个容器中的元素或尾后地址。<code>end</code>迭代器不会指向范围中的最后一个元素，而是指向尾元素之后的位置。这种元素范围被称为左闭合区间（left-inclusive interval），其标准数学描述为<code>[begin，end）</code>。迭代器<code>begin</code>和<code>end</code>必须指向相同的容器，<code>end</code>可以与<code>begin</code>指向相同的位置，但不能指向<code>begin</code>之前的位置（由程序员确保）。</p>
<p>假定<code>begin</code>和<code>end</code>构成一个合法的迭代器范围，则：</p>
<ul>
<li>如果<code>begin</code>等于<code>end</code>，则范围为空。</li>
<li>如果<code>begin</code>不等于<code>end</code>，则范围内至少包含一个元素，且<code>begin</code>指向该范围内的第一个元素。</li>
<li>可以递增<code>begin</code>若干次，令<code>begin</code>等于<code>end</code>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (begin != end)</span><br><span class="line">&#123;</span><br><span class="line">    *begin = val;   <span class="comment">// ok: range isn&#x27;t empty so begin denotes an element</span></span><br><span class="line">    ++begin;    <span class="comment">// advance the iterator to get the next element</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="容器类型成员（Container-Type-Members）"><a href="#容器类型成员（Container-Type-Members）" class="headerlink" title="容器类型成员（Container Type Members）"></a>容器类型成员（Container Type Members）</h4><p>通过类型别名，可以在不了解容器元素类型的情况下使用元素。如果需要元素类型，可以使用容器的<code>value_type</code>。如果需要元素类型的引用，可以使用<code>reference</code>或<code>const_reference</code>。</p>
<h4 id="begin和end成员（begin-and-end-Members）"><a href="#begin和end成员（begin-and-end-Members）" class="headerlink" title="begin和end成员（begin and end Members）"></a><code>begin</code>和<code>end</code>成员（<code>begin</code> and <code>end</code> Members）</h4><p><code>begin</code>和<code>end</code>操作生成指向容器中第一个元素和尾后地址的迭代器。其常见用途是形成一个包含容器中所有元素的迭代器范围。</p>
<p><code>begin</code>和<code>end</code>操作有多个版本：带<code>r</code>的版本返回反向迭代器。以<code>c</code>开头的版本（C++11新增）返回<code>const</code>迭代器。不以<code>c</code>开头的版本都是重载的，当对非常量对象调用这些成员时，返回普通迭代器，对<code>const</code>对象调用时，返回<code>const</code>迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; a = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> it1 = a.<span class="built_in">begin</span>();    <span class="comment">// list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = a.<span class="built_in">rbegin</span>();   <span class="comment">// list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.<span class="built_in">cbegin</span>();   <span class="comment">// list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it4 = a.<span class="built_in">crbegin</span>();  <span class="comment">// list&lt;string&gt;::const_reverse_iterator</span></span><br></pre></td></tr></table></figure>
<p>当<code>auto</code>与<code>begin</code>或<code>end</code>结合使用时，返回的迭代器类型依赖于容器类型。但调用以<code>c</code>开头的版本仍然可以获得<code>const</code>迭代器，与容器是否是常量无关。</p>
<p>当程序不需要写操作时，应该使用<code>cbegin</code>和<code>cend</code>。</p>
<h3 id="容器定义和初始化（Defining-and-Initializing-a-Container）"><a href="#容器定义和初始化（Defining-and-Initializing-a-Container）" class="headerlink" title="容器定义和初始化（Defining and Initializing a Container）"></a>容器定义和初始化（Defining and Initializing a Container）</h3><p>将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。</p>
<p>传递迭代器参数来拷贝一个范围时，不要求容器类型相同，而且新容器和原容器中的元素类型也可以不同，但是要能进行类型转换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each container has three elements, initialized from the given initializers</span></span><br><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; articles = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br><span class="line"><span class="function">list&lt;string&gt; <span class="title">list2</span><span class="params">(authors)</span></span>;        <span class="comment">// ok: types match</span></span><br><span class="line"><span class="function">deque&lt;string&gt; <span class="title">authList</span><span class="params">(authors)</span></span>;    <span class="comment">// error: container types don&#x27;t match</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">words</span><span class="params">(articles)</span></span>;     <span class="comment">// error: element types must match</span></span><br><span class="line"><span class="comment">// ok: converts const char* elements to string</span></span><br><span class="line"><span class="function">forward_list&lt;string&gt; <span class="title">words</span><span class="params">(articles.begin(), articles.end())</span></span>;</span><br></pre></td></tr></table></figure>
<p>C++11允许对容器进行列表初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// each container has three elements, initialized from the given initializers</span></span><br><span class="line">list&lt;string&gt; authors = &#123;<span class="string">&quot;Milton&quot;</span>, <span class="string">&quot;Shakespeare&quot;</span>, <span class="string">&quot;Austen&quot;</span>&#125;;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; articles = &#123;<span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>定义和使用<code>array</code>类型时，需要同时指定元素类型和容器大小。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 42&gt;      <span class="comment">// type is: array that holds 42 ints</span></span><br><span class="line">array&lt;string, 10&gt;   <span class="comment">// type is: array that holds 10 strings</span></span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt;::size_type i;   <span class="comment">// array type includes element type and size</span></span><br><span class="line">array&lt;<span class="type">int</span>&gt;::size_type j;       <span class="comment">// error: array&lt;int&gt; is not a type</span></span><br></pre></td></tr></table></figure>
<p>对<code>array</code>进行列表初始化时，初始值的数量不能大于<code>array</code>的大小。如果初始值的数量小于<code>array</code>的大小，则只初始化靠前的元素，剩余元素会被值初始化。如果元素类型是类类型，则该类需要一个默认构造函数。</p>
<p>可以对<code>array</code>进行拷贝或赋值操作，但要求二者的元素类型和大小都相同。</p>
<h3 id="赋值和swap（Assignment-and-swap）"><a href="#赋值和swap（Assignment-and-swap）" class="headerlink" title="赋值和swap（Assignment and swap）"></a>赋值和<code>swap</code>（Assignment and <code>swap</code>）</h3><p>赋值运算符两侧的运算对象必须类型相同。<code>assign</code>允许用不同但相容的类型赋值，或者用容器的子序列赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; names;</span><br><span class="line">vector&lt;<span class="type">const</span> <span class="type">char</span>*&gt; oldstyle;</span><br><span class="line">names = oldstyle;   <span class="comment">// error: container types don&#x27;t match</span></span><br><span class="line"><span class="comment">// ok: can convert from const char*to string</span></span><br><span class="line">names.<span class="built_in">assign</span>(oldstyle.<span class="built_in">cbegin</span>(), oldstyle.<span class="built_in">cend</span>());</span><br></pre></td></tr></table></figure>
<p>由于其旧元素被替换，因此传递给<code>assign</code>的迭代器不能指向调用<code>assign</code>的容器本身。</p>
<p><code>swap</code>交换两个相同类型容器的内容。除<code>array</code>外，<code>swap</code>不对任何元素进行拷贝、删除或插入操作，只交换两个容器的内部数据结构，因此可以保证快速完成。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec1</span><span class="params">(<span class="number">10</span>)</span></span>;   <span class="comment">// vector with ten elements</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">svec2</span><span class="params">(<span class="number">24</span>)</span></span>;   <span class="comment">// vector with 24 elements</span></span><br><span class="line"><span class="built_in">swap</span>(svec1, svec2);</span><br></pre></td></tr></table></figure>
<p>赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而<code>swap</code>操作交换容器内容，不会导致迭代器、引用和指针失效（<code>array</code>和<code>string</code>除外）。</p>
<p>对于<code>array</code>，<code>swap</code>会真正交换它们的元素。因此在<code>swap</code>操作后，指针、引用和迭代器所绑定的元素不变，但元素值已经被交换。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 3&gt; a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">array&lt;<span class="type">int</span>, 3&gt; b = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> p = a.<span class="built_in">cbegin</span>(), q = a.<span class="built_in">cend</span>();</span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">// 输出交换后的值，即4、5、6</span></span><br><span class="line"><span class="keyword">while</span> (p != q)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    ++p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>对于其他容器类型（除<code>string</code>），指针、引用和迭代器在<code>swap</code>操作后仍指向操作前的元素，但这些元素已经属于不同的容器了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; a = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; b = &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> p = a.<span class="built_in">cbegin</span>(), q = a.<span class="built_in">cend</span>();</span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="comment">// 输出交换前的值，即1、2、3</span></span><br><span class="line"><span class="keyword">while</span> (p != q)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; *p &lt;&lt; endl;</span><br><span class="line">    ++p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，即使在执行完 <code>a.swap(b)</code> 之后，<code>p</code> 和 <code>q</code> 仍然保留了交换前的值，因为它们是在 <code>a</code> 被交换前就已经初始化的，它们所指向的仍然是 <code>a</code> 的原始内存。</p>
<p>因此，输出仍然是原始的 <code>a</code> 的值：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>
<p><code>array</code>不支持<code>assign</code>，也不允许用花括号列表进行赋值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">array&lt;<span class="type">int</span>, 10&gt; a1 = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">array&lt;<span class="type">int</span>, 10&gt; a2 = &#123;<span class="number">0</span>&#125;;    <span class="comment">// elements all have value 0</span></span><br><span class="line">a1 = a2;    <span class="comment">// replaces elements in a1</span></span><br><span class="line">a2 = &#123;<span class="number">0</span>&#125;;   <span class="comment">// error: cannot assign to an array from a braced list</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码涉及了 <code>std::array</code> 的初始化和赋值操作。</p>
<ol>
<li><p><code>array&lt;int, 10&gt; a1 = &#123;0,1,2,3,4,5,6,7,8,9&#125;;</code></p>
<ul>
<li>这行代码创建了一个名为 <code>a1</code> 的 <code>std::array</code>，它包含了 10 个整数，初始化为 0 到 9。</li>
</ul>
</li>
<li><p><code>array&lt;int, 10&gt; a2 = &#123;0&#125;;</code></p>
<ul>
<li>这行代码创建了另一个名为 <code>a2</code> 的 <code>std::array</code>，它包含了 10 个整数，所有元素的值都被初始化为 0。注意，只提供了一个 0，但是因为 <code>std::array</code> 在初始化时会使用剩余的元素自动填充默认值，所以所有的元素都被初始化为 0。</li>
</ul>
</li>
<li><p><code>a1 = a2;</code></p>
<ul>
<li>这行代码将 <code>a2</code> 的值赋给了 <code>a1</code>，即用 <code>a2</code> 中的元素替换了 <code>a1</code> 中的元素。因为 <code>a1</code> 和 <code>a2</code> 都是相同类型和大小的 <code>std::array</code>，所以可以直接进行赋值操作。</li>
</ul>
</li>
<li><p><code>a2 = &#123;0&#125;;</code></p>
<ul>
<li>这行代码尝试将一个大括号初始化列表赋给 <code>a2</code>，但是这种赋值方式是不合法的。原因是对于 <code>std::array</code>，不能直接将大括号初始化列表赋值给它，必须通过逐个元素赋值或者通过另一个同类型的 <code>std::array</code> 进行赋值。因此，这行代码会导致编译错误。</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="容器大小操作（Container-Size-Operations）"><a href="#容器大小操作（Container-Size-Operations）" class="headerlink" title="容器大小操作（Container Size Operations）"></a>容器大小操作（Container Size Operations）</h3><p><code>size</code>成员返回容器中元素的数量；<code>empty</code>当<code>size</code>为0时返回<code>true</code>，否则返回<code>false</code>；<code>max_size</code>返回一个大于或等于该类型容器所能容纳的最大元素数量的值。<code>forward_list</code>支持<code>max_size</code>和<code>empty</code>，但不支持<code>size</code>。</p>
<h3 id="关系运算符（Relational-Operators）"><a href="#关系运算符（Relational-Operators）" class="headerlink" title="关系运算符（Relational Operators）"></a>关系运算符（Relational Operators）</h3><p>每个容器类型都支持相等运算符（<code>==</code>、<code>!=</code>）。除无序关联容器外，其他容器都支持关系运算符（<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>）。关系运算符两侧的容器类型和保存元素类型都必须相同。</p>
<p>两个容器的比较实际上是元素的逐对比较，其工作方式与<code>string</code>的关系运算符类似：</p>
<ul>
<li>如果两个容器大小相同且所有元素对应相等，则这两个容器相等。</li>
<li>如果两个容器大小不同，但较小容器中的每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。</li>
<li>如果两个容器都不是对方的前缀子序列，则两个容器的比较结果取决于第一个不等元素的比较结果。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v3 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4 = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span> &#125;;</span><br><span class="line">v1 &lt; v2     <span class="comment">// true; v1 and v2 differ at element [2]: v1[2] is less than v2[2]</span></span><br><span class="line">v1 &lt; v3     <span class="comment">// false; all elements are equal, but v3 has fewer of them;</span></span><br><span class="line">v1 == v4    <span class="comment">// true; each element is equal and v1 and v4 have the same size()</span></span><br><span class="line">v1 == v2    <span class="comment">// false; v2 has fewer elements than v1</span></span><br></pre></td></tr></table></figure>
<p>容器的相等运算符实际上是使用元素的<code>==</code>运算符实现的，而其他关系运算符则是使用元素的<code>&lt;</code>运算符。如果元素类型不支持所需运算符，则保存该元素的容器就不能使用相应的关系运算。</p>
<h3 id="顺序容器操作（Sequential-Container-Operations）"><a href="#顺序容器操作（Sequential-Container-Operations）" class="headerlink" title="顺序容器操作（Sequential Container Operations）"></a>顺序容器操作（Sequential Container Operations）</h3><h3 id="向顺序容器添加元素（Adding-Elements-to-a-Sequential-Container）"><a href="#向顺序容器添加元素（Adding-Elements-to-a-Sequential-Container）" class="headerlink" title="向顺序容器添加元素（Adding Elements to a Sequential Container）"></a>向顺序容器添加元素（Adding Elements to a Sequential Container）</h3><p>除<code>array</code>外，所有标准库容器都提供灵活的内存管理，在运行时可以动态添加或删除元素。</p>
<p><code>push_back</code>将一个元素追加到容器尾部，<code>push_front</code>将元素插入容器头部。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// read from standard input, putting each word onto the end of container</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    container.<span class="built_in">push_back</span>(word);</span><br></pre></td></tr></table></figure>
<p><code>insert</code>将元素插入到迭代器指定的位置之前。一些不支持<code>push_front</code>的容器可以使用<code>insert</code>将元素插入开始位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;</span><br><span class="line">list&lt;string&gt; slist;</span><br><span class="line"><span class="comment">// equivalent to calling slist.push_front(&quot;Hello!&quot;);</span></span><br><span class="line">slist.<span class="built_in">insert</span>(slist.<span class="built_in">begin</span>(), <span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line"><span class="comment">// no push_front on vector but we can insert before begin()</span></span><br><span class="line"><span class="comment">// warning: inserting anywhere but at the end of a vector might be slow</span></span><br><span class="line">svec.<span class="built_in">insert</span>(svec.<span class="built_in">begin</span>(), <span class="string">&quot;Hello!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>将元素插入到<code>vector</code>、<code>deque</code>或<code>string</code>的任何位置都是合法的，但可能会很耗时。</p>
<p>在新标准库中，接受元素个数或范围的<code>insert</code>版本返回指向第一个新增元素的迭代器，而旧版本中这些操作返回<code>void</code>。如果范围为空，不插入任何元素，<code>insert</code>会返回第一个参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">list&lt;string&gt; lst;</span><br><span class="line"><span class="keyword">auto</span> iter = lst.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    iter = lst.<span class="built_in">insert</span>(iter, word);  <span class="comment">// same as calling push_front</span></span><br></pre></td></tr></table></figure>
<p>新标准库增加了三个直接构造而不是拷贝元素的操作：<code>emplace_front</code>、<code>emplace_back</code>和<code>emplace</code>，其分别对应<code>push_front</code>、<code>push_back</code>和<code>insert</code>。当调用<code>push</code>或<code>insert</code>时，元素对象被拷贝到容器中。而调用<code>emplace</code>时，则是将参数传递给元素类型的构造函数，直接在容器的内存空间中构造元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// construct a Sales_data object at the end of c</span></span><br><span class="line"><span class="comment">// uses the three-argument Sales_data constructor</span></span><br><span class="line">c.<span class="built_in">emplace_back</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line"><span class="comment">// error: there is no version of push_back that takes three arguments</span></span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line"><span class="comment">// ok: we create a temporary Sales_data object to pass to push_back</span></span><br><span class="line">c.<span class="built_in">push_back</span>(<span class="built_in">Sales_data</span>(<span class="string">&quot;978-0590353403&quot;</span>, <span class="number">25</span>, <span class="number">15.99</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p> 这段代码涉及了使用 <code>push_back()</code> 和 <code>emplace_back()</code> 方法向容器中添加元素的不同方式。下面对每一部分进行解释：</p>
<ol>
<li><p><code>c.emplace_back(&quot;978-0590353403&quot;, 25, 15.99);</code></p>
<ul>
<li>这行代码使用 <code>emplace_back()</code> 方法向容器 <code>c</code> 的末尾添加一个元素。在这种情况下，使用了 <code>Sales_data</code> 类型的构造函数，该构造函数接受三个参数，分别是 ISBN 编号、售出册数和价格。<code>emplace_back()</code> 方法会在容器中直接构造一个 <code>Sales_data</code> 对象，而不是先创建一个临时对象然后再复制或移动到容器中。因此，它比 <code>push_back()</code> 方法更高效。</li>
</ul>
</li>
<li><p><code>c.push_back(&quot;978-0590353403&quot;, 25, 15.99);</code></p>
<ul>
<li>这行代码试图使用 <code>push_back()</code> 方法将一个具有三个参数的 <code>Sales_data</code> 对象添加到容器 <code>c</code> 的末尾。然而，<code>push_back()</code> 方法并不支持接受多个参数的情况，因此会导致编译错误。</li>
</ul>
</li>
<li><p><code>c.push_back(Sales_data(&quot;978-0590353403&quot;, 25, 15.99));</code></p>
<ul>
<li>这行代码使用 <code>push_back()</code> 方法向容器 <code>c</code> 的末尾添加一个元素。首先，创建了一个临时的 <code>Sales_data</code> 对象，然后将其作为参数传递给 <code>push_back()</code> 方法。这种方式虽然可以实现向容器中添加元素，但是需要额外的复制或移动操作，可能会影响性能。</li>
</ul>
</li>
</ol>
</blockquote>
<p>传递给<code>emplace</code>的参数必须与元素类型的构造函数相匹配。</p>
<p><code>forward_list</code>有特殊版本的<code>insert</code>和<code>emplace</code>操作，且不支持<code>push_back</code>和<code>emplace_back</code>。<code>vector</code>和<code>string</code>不支持<code>push_front</code>和<code>emplace_front</code>。</p>
<h3 id="访问元素（Accessing-Elements）"><a href="#访问元素（Accessing-Elements）" class="headerlink" title="访问元素（Accessing Elements）"></a>访问元素（Accessing Elements）</h3><p>每个顺序容器都有一个<code>front</code>成员函数，而除了<code>forward_list</code>之外的顺序容器还有一个<code>back</code>成员函数。这两个操作分别返回首元素和尾元素的引用。</p>
<p>在调用<code>front</code>和<code>back</code>之前，要确保容器非空。</p>
<p>在容器中访问元素的成员函数都返回引用类型。如果容器是<code>const</code>对象，则返回<code>const</code>引用，否则返回普通引用。</p>
<p>可以快速随机访问的容器（<code>string</code>、<code>vector</code>、<code>deque</code>和<code>array</code>）都提供下标运算符。保证下标有效是程序员的责任。如果希望确保下标合法，可以使用<code>at</code>成员函数。<code>at</code>类似下标运算，但如果下标越界，<code>at</code>会抛出<code>out_of_range</code>异常。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; svec;  <span class="comment">// empty vector</span></span><br><span class="line">cout &lt;&lt; svec[<span class="number">0</span>];      <span class="comment">// run-time error: there are no elements in svec!</span></span><br><span class="line">cout &lt;&lt; svec.<span class="built_in">at</span>(<span class="number">0</span>);   <span class="comment">// throws an out_of_range exception</span></span><br></pre></td></tr></table></figure>
<h3 id="删除元素（Erasing-Elements）"><a href="#删除元素（Erasing-Elements）" class="headerlink" title="删除元素（Erasing Elements）"></a>删除元素（Erasing Elements）</h3><p>删除<code>deque</code>中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。删除<code>vector</code>或<code>string</code>的元素后，指向删除点之后位置的迭代器、引用和指针也都会失效。</p>
<p>删除元素前，程序员必须确保目标元素存在。</p>
<p><code>pop_front</code>和<code>pop_back</code>函数分别删除首元素和尾元素。<code>vector</code>和<code>string</code>类型不支持<code>pop_front</code>，<code>forward_list</code>类型不支持<code>pop_back</code>。</p>
<p><code>erase</code>函数删除指定位置的元素。可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。两种形式的<code>erase</code>都返回指向删除元素（最后一个）之后位置的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// delete the range of elements between two iterators</span></span><br><span class="line"><span class="comment">// returns an iterator to the element just after the last removed element</span></span><br><span class="line">elem1 = slist.<span class="built_in">erase</span>(elem1, elem2);  <span class="comment">// after the call elem1 == elem2</span></span><br></pre></td></tr></table></figure>
<p><code>clear</code>函数删除容器内的所有元素。</p>
<h3 id="特殊的forward-list操作（Specialized-forward-list-Operations）"><a href="#特殊的forward-list操作（Specialized-forward-list-Operations）" class="headerlink" title="特殊的forward_list操作（Specialized forward_list Operations）"></a>特殊的<code>forward_list</code>操作（Specialized <code>forward_list</code> Operations）</h3><p>在<code>forward_list</code>中添加或删除元素的操作是通过改变给定元素之后的元素来完成的。</p>
<h3 id="改变容器大小（Resizing-a-Container）"><a href="#改变容器大小（Resizing-a-Container）" class="headerlink" title="改变容器大小（Resizing a Container）"></a>改变容器大小（Resizing a Container）</h3><p><code>resize</code>函数接受一个可选的元素值参数，用来初始化添加到容器中的元素，否则新元素进行值初始化。如果容器保存的是类类型元素，且<code>resize</code>向容器添加新元素，则必须提供初始值，或元素类型提供默认构造函数。</p>
<h3 id="容器操作可能使迭代器失效（Container-Operations-May-Invalidate-Iterators）"><a href="#容器操作可能使迭代器失效（Container-Operations-May-Invalidate-Iterators）" class="headerlink" title="容器操作可能使迭代器失效（Container Operations May Invalidate Iterators）"></a>容器操作可能使迭代器失效（Container Operations May Invalidate Iterators）</h3><p>向容器中添加或删除元素可能会使指向容器元素的指针、引用或迭代器失效。失效的指针、引用或迭代器不再表示任何元素，使用它们是一种严重的程序设计错误。</p>
<ul>
<li><p>向容器中添加元素后：</p>
<ul>
<li>如果容器是<code>vector</code>或<code>string</code>类型，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前元素的迭代器、指针和引用仍然有效，但指向插入位置之后元素的迭代器、指针和引用都会失效。</li>
<li>如果容器是<code>deque</code>类型，添加到除首尾之外的任何位置都会使迭代器、指针和引用失效。如果添加到首尾位置，则迭代器会失效，而指针和引用不会失效。</li>
<li>如果容器是<code>list</code>或<code>forward_list</code>类型，指向容器的迭代器、指针和引用仍然有效。</li>
</ul>
</li>
<li><p>从容器中删除元素后，指向被删除元素的迭代器、指针和引用失效：</p>
<ul>
<li>如果容器是<code>list</code>或<code>forward_list</code>类型，指向容器其他位置的迭代器、指针和引用仍然有效。</li>
<li>如果容器是<code>deque</code>类型，删除除首尾之外的任何元素都会使迭代器、指针和引用失效。如果删除尾元素，则尾后迭代器失效，其他迭代器、指针和引用不受影响。如果删除首元素，这些也不会受影响。</li>
<li>如果容器是<code>vector</code>或<code>string</code>类型，指向删除位置之前元素的迭代器、指针和引用仍然有效。但尾后迭代器总会失效。</li>
</ul>
</li>
</ul>
<p>必须保证在每次改变容器后都正确地重新定位迭代器。</p>
<p>不要保存<code>end</code>函数返回的迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// safer: recalculate end on each trip whenever the loop adds/erases elements</span></span><br><span class="line"><span class="keyword">while</span> (begin != v.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do some processing</span></span><br><span class="line">    ++begin;    <span class="comment">// advance begin because we want to insert after this element</span></span><br><span class="line">    begin = v.<span class="built_in">insert</span>(begin, <span class="number">42</span>);    <span class="comment">// insert the new value</span></span><br><span class="line">    ++begin;    <span class="comment">// advance begin past the element we just added</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="vector对象是如何增长的（How-a-vector-Grows）"><a href="#vector对象是如何增长的（How-a-vector-Grows）" class="headerlink" title="vector对象是如何增长的（How a vector Grows）"></a><code>vector</code>对象是如何增长的（How a <code>vector</code> Grows）</h3><p><code>vector</code>和<code>string</code>的实现通常会分配比新空间需求更大的内存空间，容器预留这些空间作为备用，可用来保存更多新元素。</p>
<p><code>capacity</code>函数返回容器在不扩充内存空间的情况下最多可以容纳的元素数量。<code>reserve</code>函数告知容器应该准备保存多少元素，它并不改变容器中元素的数量，仅影响容器预先分配的内存空间大小。</p>
<p>只有当需要的内存空间超过当前容量时，<code>reserve</code>才会真正改变容器容量，分配不小于需求大小的内存空间。当需求大小小于当前容量时，<code>reserve</code>并不会退回内存空间。因此在调用<code>reserve</code>之后，<code>capacity</code>会大于或等于传递给<code>reserve</code>的参数。</p>
<p>在C++11中可以使用<code>shrink_to_fit</code>函数来要求<code>deque</code>、<code>vector</code>和<code>string</code>退回不需要的内存空间（并不保证退回）。</p>
<h3 id="额外的string操作（Additional-string-Operations）"><a href="#额外的string操作（Additional-string-Operations）" class="headerlink" title="额外的string操作（Additional string Operations）"></a>额外的<code>string</code>操作（Additional string Operations）</h3><h3 id="构造string的其他方法（Other-Ways-to-Construct-strings）"><a href="#构造string的其他方法（Other-Ways-to-Construct-strings）" class="headerlink" title="构造string的其他方法（Other Ways to Construct strings）"></a>构造<code>string</code>的其他方法（Other Ways to Construct <code>string</code>s）</h3><p>从另一个<code>string</code>对象拷贝字符构造<code>string</code>时，如果提供的拷贝开始位置（可选）大于给定<code>string</code>的大小，则构造函数会抛出<code>out_of_range</code>异常。</p>
<p>如果传递给<code>substr</code>函数的开始位置超过<code>string</code>的大小，则函数会抛出<code>out_of_range</code>异常</p>
<h3 id="改变string的其他方法（Other-Ways-to-Change-a-string）"><a href="#改变string的其他方法（Other-Ways-to-Change-a-string）" class="headerlink" title="改变string的其他方法（Other Ways to Change a string）"></a>改变<code>string</code>的其他方法（Other Ways to Change a <code>string</code>）</h3><p><code>append</code>函数是在<code>string</code>末尾进行插入操作的简写形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;C++ Primer&quot;</span>)</span>, s2 </span>= s;     <span class="comment">// initialize s and s2 to &quot;C++ Primer&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(s.<span class="built_in">size</span>(), <span class="string">&quot; 4th Ed.&quot;</span>);     <span class="comment">// s == &quot;C++ Primer 4th Ed.&quot;</span></span><br><span class="line">s2.<span class="built_in">append</span>(<span class="string">&quot; 4th Ed.&quot;</span>);     <span class="comment">// equivalent: appends &quot; 4th Ed.&quot; to s2; s == s2</span></span><br></pre></td></tr></table></figure>
<p><code>replace</code>函数是调用<code>erase</code>和<code>insert</code>函数的简写形式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// equivalent way to replace &quot;4th&quot; by &quot;5th&quot;</span></span><br><span class="line">s.<span class="built_in">erase</span>(<span class="number">11</span>, <span class="number">3</span>);         <span class="comment">// s == &quot;C++ Primer Ed.&quot;</span></span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">11</span>, <span class="string">&quot;5th&quot;</span>);    <span class="comment">// s == &quot;C++ Primer 5th Ed.&quot;</span></span><br><span class="line"><span class="comment">// starting at position 11, erase three characters and then insert &quot;5th&quot;</span></span><br><span class="line">s2.<span class="built_in">replace</span>(<span class="number">11</span>, <span class="number">3</span>, <span class="string">&quot;5th&quot;</span>);   <span class="comment">// equivalent: s == s2</span></span><br></pre></td></tr></table></figure>
<h3 id="string搜索操作（string-Search-Operations）"><a href="#string搜索操作（string-Search-Operations）" class="headerlink" title="string搜索操作（string Search Operations）"></a><code>string</code>搜索操作（<code>string</code> Search Operations）</h3><p><code>string</code>的每个搜索操作都返回一个<code>string::size_type</code>值，表示匹配位置的下标。如果搜索失败，则返回一个名为<code>string::npos</code>的<code>static</code>成员。标准库将<code>npos</code>定义为<code>const string::size_type</code>类型，并初始化为-1。</p>
<p>不建议用<code>int</code>或其他带符号类型来保存<code>string</code>搜索函数的返回值。</p>
<h3 id="compare函数（The-compare-Functions）"><a href="#compare函数（The-compare-Functions）" class="headerlink" title="compare函数（The compare Functions）"></a><code>compare</code>函数（The <code>compare</code> Functions）</h3><p><code>string</code>类型提供了一组<code>compare</code>函数进行字符串比较操作，类似C标准库的<code>strcmp</code>函数。</p>
<h3 id="数值转换（Numeric-Conversions）"><a href="#数值转换（Numeric-Conversions）" class="headerlink" title="数值转换（Numeric Conversions）"></a>数值转换（Numeric Conversions）</h3><p>C++11增加了<code>string</code>和数值之间的转换函数。</p>
<p>进行数值转换时，<code>string</code>参数的第一个非空白字符必须是符号（<code>+</code>或<code>-</code>）或数字。它可以以<code>0x</code>或<code>0X</code>开头来表示十六进制数。对于转换目标是浮点值的函数，<code>string</code>参数也可以以小数点开头，并可以包含<code>e</code>或<code>E</code>来表示指数部分。</p>
<p>如果给定的<code>string</code>不能转换为一个数值，则转换函数会抛出<code>invalid_argument</code>异常。如果转换得到的数值无法用任何类型表示，则抛出<code>out_of_range</code>异常。</p>
<h3 id="容器适配器（Container-Adaptors）"><a href="#容器适配器（Container-Adaptors）" class="headerlink" title="容器适配器（Container Adaptors）"></a>容器适配器（Container Adaptors）</h3><p>标准库定义了<code>stack</code>、<code>queue</code>和<code>priority_queue</code>三种容器适配器。容器适配器可以改变已有容器的工作机制。</p>
<p>默认情况下，<code>stack</code>和<code>queue</code>是基于<code>deque</code>实现的，<code>priority_queue</code>是基于<code>vector</code>实现的。可以在创建适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// empty stack implemented on top of vector</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk;</span><br><span class="line"><span class="comment">// str_stk2 is implemented on top of vector and initially holds a copy of svec</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; <span class="built_in">str_stk2</span>(svec);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码展示了如何使用 <code>vector</code> 作为底层容器来实现一个栈（stack）。</p>
<ol>
<li><p><code>stack&lt;string, vector&lt;string&gt;&gt; str_stk;</code></p>
<ul>
<li>这行代码声明了一个名为 <code>str_stk</code> 的栈对象，它使用 <code>vector&lt;string&gt;</code> 作为底层容器。这意味着 <code>str_stk</code> 将使用 <code>vector</code> 来存储栈中的元素，以实现栈的基本功能。</li>
</ul>
</li>
<li><p><code>stack&lt;string, vector&lt;string&gt;&gt; str_stk2(svec);</code></p>
<ul>
<li>这行代码声明了另一个名为 <code>str_stk2</code> 的栈对象，并通过复制 <code>svec</code> 来初始化它。在这种情况下，<code>str_stk2</code> 中的元素与 <code>svec</code> 中的元素相同，因为它们是从同一份数据复制而来的。这种初始化方式可以用于创建一个已有容器的副本，作为新的栈的初始状态。</li>
</ul>
</li>
</ol>
</blockquote>
<p>所有适配器都要求容器具有添加和删除元素的能力，因此适配器不能构造在<code>array</code>上。适配器还要求容器具有添加、删除和访问尾元素的能力，因此也不能用<code>forward_list</code>构造适配器。</p>
<p>栈适配器<code>stack</code>定义在头文件<code>stack</code>中。队列适配器<code>queue</code>和<code>priority_queue</code>定义在头文件<code>queue</code>中。</p>
<p><code>queue</code>使用先进先出的存储和访问策略。进入队列的对象被放置到队尾，而离开队列的对象则从队首删除。</p>
<h3 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h3><p>关联容器支持高效的关键字查找和访问操作。2个主要的关联容器（associative-container）类型是<code>map</code>和<code>set</code>。</p>
<ul>
<li><code>map</code>中的元素是一些键值对（key-value）：关键字起索引作用，值表示与索引相关联的数据。</li>
<li><code>set</code>中每个元素只包含一个关键字，支持高效的关键字查询操作：检查一个给定关键字是否在<code>set</code>中。</li>
</ul>
<p>标准库提供了8个关联容器，它们之间的不同体现在三个方面：</p>
<ul>
<li>是<code>map</code>还是<code>set</code>类型。</li>
<li>是否允许保存重复的关键字。</li>
<li>是否按顺序保存元素。</li>
</ul>
<p>允许重复保存关键字的容器名字都包含单词<code>multi</code>；无序保存元素的容器名字都以单词<code>unordered</code>开头。</p>
<p>有序容器：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>map</code></td>
<td>保存键值对的关联数组</td>
</tr>
<tr>
<td><code>set</code></td>
<td>只保存关键字的容器</td>
</tr>
<tr>
<td><code>multimap</code></td>
<td>关键字可重复出现的<code>map</code></td>
</tr>
<tr>
<td><code>multiset</code></td>
<td>关键字可重复出现的<code>set</code></td>
</tr>
</tbody>
</table>
</div>
<p>无序容器：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>特性</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>unordered_map</code></td>
<td>用哈希函数管理的<code>map</code></td>
</tr>
<tr>
<td><code>unordered_set</code></td>
<td>用哈希函数管理的<code>set</code></td>
</tr>
<tr>
<td><code>unordered_multimap</code></td>
<td>关键字可重复出现的<code>unordered_map</code></td>
</tr>
<tr>
<td><code>unordered_multiset</code></td>
<td>关键字可重复出现的<code>unordered_set</code></td>
</tr>
</tbody>
</table>
</div>
<p><code>map</code>和<code>multimap</code>类型定义在头文件<code>map</code>中；<code>set</code>和<code>multiset</code>类型定义在头文件<code>set</code>中；无序容器定义在头文件<code>unordered_map</code>和<code>unordered_set</code>中。</p>
<h3 id="使用关联容器（Using-an-Associative-Container）"><a href="#使用关联容器（Using-an-Associative-Container）" class="headerlink" title="使用关联容器（Using an Associative Container）"></a>使用关联容器（Using an Associative Container）</h3><p><code>map</code>类型通常被称为关联数组（associative array）。</p>
<p>从<code>map</code>中提取一个元素时，会得到一个<code>pair</code>类型的对象。<code>pair</code>是一个模板类型，保存两个名为<code>first</code>和<code>second</code>的公有数据成员。<code>map</code>所使用的<code>pair</code>用<code>first</code>成员保存关键字，用<code>second</code>成员保存对应的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// count the number of times each word occurs in the input</span></span><br><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;     <span class="comment">// empty map from string to size_t</span></span><br><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; word)</span><br><span class="line">    ++word_count[word];     <span class="comment">// fetch and increment the counter for word</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;w : word_count)    <span class="comment">// for each element in the map</span></span><br><span class="line">    <span class="comment">// print the results</span></span><br><span class="line">    cout &lt;&lt; w.first &lt;&lt; <span class="string">&quot; occurs &quot;</span> &lt;&lt; w.second</span><br><span class="line">        &lt;&lt; ((w.second &gt; <span class="number">1</span>) ? <span class="string">&quot; times&quot;</span> : <span class="string">&quot; time&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p><code>set</code>类型的<code>find</code>成员返回一个迭代器。如果给定关键字在<code>set</code>中，则迭代器指向该关键字，否则返回的是尾后迭代器。</p>
<h3 id="关联容器概述（Overview-of-the-Associative-Containers）"><a href="#关联容器概述（Overview-of-the-Associative-Containers）" class="headerlink" title="关联容器概述（Overview of the Associative Containers）"></a>关联容器概述（Overview of the Associative Containers）</h3><h3 id="定义关联容器（Defining-an-Associative-Container）"><a href="#定义关联容器（Defining-an-Associative-Container）" class="headerlink" title="定义关联容器（Defining an Associative Container）"></a>定义关联容器（Defining an Associative Container）</h3><p>定义<code>map</code>时，必须指定关键字类型和值类型；定义<code>set</code>时，只需指定关键字类型。</p>
<p>初始化<code>map</code>时，提供的每个键值对用花括号<code>&#123;&#125;</code>包围。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">size_t</span>&gt; word_count;   <span class="comment">// empty</span></span><br><span class="line"><span class="comment">// list initialization</span></span><br><span class="line">set&lt;string&gt; exclude = &#123; <span class="string">&quot;the&quot;</span>, <span class="string">&quot;but&quot;</span>, <span class="string">&quot;and&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// three elements; authors maps last name to first</span></span><br><span class="line">map&lt;string, string&gt; authors =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="string">&quot;Joyce&quot;</span>, <span class="string">&quot;James&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Austen&quot;</span>, <span class="string">&quot;Jane&quot;</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;Dickens&quot;</span>, <span class="string">&quot;Charles&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>map</code>和<code>set</code>中的关键字必须唯一，<code>multimap</code>和<code>multiset</code>没有此限制。</p>
<p>对于有序容器——<code>map</code>、<code>multimap</code>、<code>set</code>和<code>multiset</code>，关键字类型必须定义元素比较的方法。默认情况下，标准库使用关键字类型的<code>&lt;</code>运算符来进行比较操作。</p>
<p>用来组织容器元素的操作的类型也是该容器类型的一部分。如果需要使用自定义的比较操作，则必须在定义关联容器类型时提供此操作的类型。操作类型在尖括号中紧跟着元素类型给出。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() &lt; rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bookstore can have several transactions with the same ISBN</span></span><br><span class="line"><span class="comment">// elements in bookstore will be in ISBN order</span></span><br><span class="line"><span class="function">multiset&lt;Sales_data, <span class="title">decltype</span><span class="params">(compareIsbn)</span>*&gt; <span class="title">bookstore</span><span class="params">(compareIsbn)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码定义了一个比较函数 <code>compareIsbn</code>，然后创建了一个 <code>multiset</code> 容器，用于存储 <code>Sales_data</code> 类型的对象。让我逐步解释：</p>
<ol>
<li><p><code>bool compareIsbn(const Sales_data &amp;lhs, const Sales_data &amp;rhs)</code>：<br>这是一个自定义的比较函数，用于比较两个 <code>Sales_data</code> 对象的 ISBN。<code>lhs</code> 和 <code>rhs</code> 是要比较的两个对象的引用。函数返回 <code>true</code> 表示 <code>lhs</code> 的 ISBN 小于 <code>rhs</code> 的 ISBN，否则返回 <code>false</code>。</p>
</li>
<li><p><code>multiset&lt;Sales_data, decltype(compareIsbn)*&gt; bookstore(compareIsbn);</code>：<br>这行代码创建了一个 <code>multiset</code> 容器，名为 <code>bookstore</code>，用于存储 <code>Sales_data</code> 类型的对象。<code>multiset</code> 是一个有序容器，它可以包含重复的元素，并且元素会按照指定的比较函数进行排序。</p>
<ul>
<li><p><code>&lt;Sales_data, decltype(compareIsbn)*&gt;</code> 指定了容器中存储的元素类型为 <code>Sales_data</code>，并且指定了比较函数的类型为 <code>decltype(compareIsbn)*</code>，即指向 <code>compareIsbn</code> 函数的指针。</p>
</li>
<li><p><code>bookstore(compareIsbn)</code> 创建了 <code>bookstore</code> 容器，并将 <code>compareIsbn</code> 函数作为参数传递给容器的构造函数，用于指定元素的排序规则。由于 <code>multiset</code> 容器要求指定一个比较函数来决定元素的顺序，因此需要将 <code>compareIsbn</code> 函数的地址传递给容器，以便容器内部能够调用该函数来进行元素的比较和排序。</p>
</li>
</ul>
</li>
</ol>
<p>因此，<code>bookstore</code> 是一个按照 <code>compareIsbn</code> 函数指定的排序规则进行排序的 <code>multiset</code> 容器，可以存储多个具有相同 ISBN 的 <code>Sales_data</code> 对象，并且这些对象将按照 ISBN 的顺序进行排列。</p>
</blockquote>
<h3 id="pair类型（The-pair-Type）"><a href="#pair类型（The-pair-Type）" class="headerlink" title="pair类型（The pair Type）"></a><code>pair</code>类型（The <code>pair</code> Type）</h3><p><code>pair</code>定义在头文件<code>utility</code>中。一个<code>pair</code>可以保存两个数据成员，分别命名为<code>first</code>和<code>second</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;string, string&gt; anon;        <span class="comment">// holds two strings</span></span><br><span class="line">pair&lt;string, <span class="type">size_t</span>&gt; word_count;  <span class="comment">// holds a string and an size_t</span></span><br><span class="line">pair&lt;string, vector&lt;<span class="type">int</span>&gt;&gt; line;   <span class="comment">// holds string and vector&lt;int&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>pair</code>的默认构造函数对数据成员进行值初始化。</p>
<p>在C++11中，如果函数需要返回<code>pair</code>，可以对返回值进行列表初始化。早期C++版本中必须显式构造返回值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">process</span><span class="params">(vector&lt;string&gt; &amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process v</span></span><br><span class="line">    <span class="keyword">if</span> (!v.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="comment">// list initialize</span></span><br><span class="line">        <span class="keyword">return</span> &#123; v.<span class="built_in">back</span>(), v.<span class="built_in">back</span>().<span class="built_in">size</span>() &#125;;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// explicitly constructed return value</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关联容器操作（Operations-on-Associative-Containers）"><a href="#关联容器操作（Operations-on-Associative-Containers）" class="headerlink" title="关联容器操作（Operations on Associative Containers）"></a>关联容器操作（Operations on Associative Containers）</h3><p>关联容器定义了类型别名来表示容器关键字和值的类型。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>key_type</code></td>
<td>容器的关键字类型</td>
</tr>
<tr>
<td><code>mapped_type</code></td>
<td><code>map</code>的值类型</td>
</tr>
<tr>
<td><code>value_type</code></td>
<td>对于<code>set</code>，与<code>key_type</code>相同 对于<code>map</code>，为<code>pair&lt;const key_type, mapped_type&gt;</code></td>
</tr>
</tbody>
</table>
</div>
<p>对于<code>set</code>类型，<code>key_type</code>和<code>value_type</code>是一样的。<code>set</code>中保存的值就是关键字。对于<code>map</code>类型，元素是键值对。即每个元素是一个<code>pair</code>对象，包含一个关键字和一个关联的值。由于元素关键字不能改变，因此<code>pair</code>的关键字部分是<code>const</code>的。另外，只有<code>map</code>类型（<code>unordered_map</code>、<code>unordered_multimap</code>、<code>multimap</code>、<code>map</code>）才定义了<code>mapped_type</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt;::value_type v1;        <span class="comment">// v1 is a string</span></span><br><span class="line">set&lt;string&gt;::key_type v2;          <span class="comment">// v2 is a string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::value_type v3;   <span class="comment">// v3 is a pair&lt;const string, int&gt;</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::key_type v4;     <span class="comment">// v4 is a string</span></span><br><span class="line">map&lt;string, <span class="type">int</span>&gt;::mapped_type v5;  <span class="comment">// v5 is an int</span></span><br></pre></td></tr></table></figure>
<h3 id="关联容器迭代器（Associative-Container-Iterators）"><a href="#关联容器迭代器（Associative-Container-Iterators）" class="headerlink" title="关联容器迭代器（Associative Container Iterators）"></a>关联容器迭代器（Associative Container Iterators）</h3><p>解引用关联容器迭代器时，会得到一个类型为容器的<code>value_type</code>的引用。对<code>map</code>而言，<code>value_type</code>是<code>pair</code>类型，其<code>first</code>成员保存<code>const</code>的关键字，<code>second</code>成员保存值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get an iterator to an element in word_count</span></span><br><span class="line"><span class="keyword">auto</span> map_it = word_count.<span class="built_in">begin</span>();</span><br><span class="line"><span class="comment">// *map_it is a reference to a pair&lt;const string, size_t&gt; object</span></span><br><span class="line">cout &lt;&lt; map_it-&gt;first;          <span class="comment">// prints the key for this element</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; map_it-&gt;second;  <span class="comment">// prints the value of the element</span></span><br><span class="line">map_it-&gt;first = <span class="string">&quot;new key&quot;</span>;      <span class="comment">// error: key is const</span></span><br><span class="line">++map_it-&gt;second;               <span class="comment">// ok: we can change the value through an iterator</span></span><br></pre></td></tr></table></figure>
<p>虽然<code>set</code>同时定义了<code>iterator</code>和<code>const_iterator</code>类型，但两种迭代器都只允许只读访问<code>set</code>中的元素。类似<code>map</code>，<code>set</code>中的关键字也是<code>const</code>的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; iset = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator set_it = iset.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">if</span> (set_it != iset.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line">    *set_it = <span class="number">42</span>;       <span class="comment">// error: keys in a set are read-only</span></span><br><span class="line">    cout &lt;&lt; *set_it &lt;&lt; endl;    <span class="comment">// ok: can read the key</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>map</code>和<code>set</code>都支持<code>begin</code>和<code>end</code>操作。使用迭代器遍历<code>map</code>、<code>multimap</code>、<code>set</code>或<code>multiset</code>时，迭代器按关键字升序遍历元素。</p>
<p>通常不对关联容器使用泛型算法。</p>
<h3 id="添加元素（Adding-Elements）"><a href="#添加元素（Adding-Elements）" class="headerlink" title="添加元素（Adding Elements）"></a>添加元素（Adding Elements）</h3><p>使用<code>insert</code>成员可以向关联容器中添加元素。向<code>map</code>和<code>set</code>中添加已存在的元素对容器没有影响。</p>
<p>通常情况下，对于想要添加到<code>map</code>中的数据，并没有现成的<code>pair</code>对象。可以直接在<code>insert</code>的参数列表中创建<code>pair</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// four ways to add word to word_count</span></span><br><span class="line">word_count.<span class="built_in">insert</span>(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">word_count.<span class="built_in">insert</span>(map&lt;string, <span class="type">size_t</span>&gt;::<span class="built_in">value_type</span>(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p><code>insert</code>或<code>emplace</code>的返回值依赖于容器类型和参数：</p>
<ul>
<li>对于不包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回一个<code>pair</code>，表示操作是否成功。<code>pair</code>的<code>first</code>成员是一个迭代器，指向具有给定关键字的元素；<code>second</code>成员是一个<code>bool</code>值。如果关键字已在容器中，则<code>insert</code>直接返回，<code>bool</code>值为<code>false</code>。如果关键字不存在，元素会被添加至容器中，<code>bool</code>值为<code>true</code>。</li>
<li>对于允许包含重复关键字的容器，添加单一元素的<code>insert</code>和<code>emplace</code>版本返回指向新元素的迭代器。</li>
</ul>
<h3 id="删除元素（Erasing-Elements）-1"><a href="#删除元素（Erasing-Elements）-1" class="headerlink" title="删除元素（Erasing Elements）"></a>删除元素（Erasing Elements）</h3><p>与顺序容器不同，关联容器提供了一个额外的<code>erase</code>操作。它接受一个<code>key_type</code>参数，删除所有匹配给定关键字的元素（如果存在），返回实际删除的元素数量。对于不包含重复关键字的容器，<code>erase</code>的返回值总是1或0。若返回值为0，则表示想要删除的元素并不在容器中。</p>
<h3 id="map的下标操作（Subscripting-a-map）"><a href="#map的下标操作（Subscripting-a-map）" class="headerlink" title="map的下标操作（Subscripting a map）"></a><code>map</code>的下标操作（Subscripting a <code>map</code>）</h3><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c[k]</code></td>
<td>返回关键字为<code>k</code>的元素；若<code>k</code>不存在，则向<code>c</code>中添加并进行值初始化</td>
</tr>
<tr>
<td><code>c.at(k)</code></td>
<td>返回关键字为<code>k</code>的元素；若<code>k</code>不存在，则抛出<code>out_of_range</code>异常</td>
</tr>
</tbody>
</table>
</div>
<p><code>map</code>下标运算符接受一个关键字，获取与此关键字相关联的值。如果关键字不在容器中，下标运算符会向容器中添加该关键字，并值初始化关联值。</p>
<p>由于下标运算符可能向容器中添加元素，所以只能对非<code>const</code>的<code>map</code>使用下标操作。</p>
<p>对<code>map</code>进行下标操作时，返回的是<code>mapped_type</code>类型的对象；解引用<code>map</code>迭代器时，返回的是<code>value_type</code>类型的对象。</p>
<h3 id="访问元素（Accessing-Elements）-1"><a href="#访问元素（Accessing-Elements）-1" class="headerlink" title="访问元素（Accessing Elements）"></a>访问元素（Accessing Elements）</h3><div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>c.find(k)</code></td>
<td>返回指向第一个关键字为<code>k</code>的元素的迭代器或尾后迭代器</td>
</tr>
<tr>
<td><code>c.count(k)</code></td>
<td>返回关键字为<code>k</code>的元素的数量</td>
</tr>
<tr>
<td><code>c.lower_bound(k)</code></td>
<td>返回指向第一个关键字不小于<code>k</code>的元素的迭代器</td>
</tr>
<tr>
<td><code>c.upper_bound(k)</code></td>
<td>返回指向第一个关键字大于<code>k</code>的元素的迭代器</td>
</tr>
<tr>
<td><code>c.equal_range(k)</code></td>
<td>返回一个迭代器<code>pair</code>，表示关键字为<code>k</code>的元素范围</td>
</tr>
</tbody>
</table>
</div>
<p>如果<code>multimap</code>或<code>multiset</code>中有多个元素具有相同关键字，则这些元素在容器中会相邻存储。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, string&gt; authors;</span><br><span class="line"><span class="comment">// adds the first element with the key Barth, John</span></span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Sot-Weed Factor&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// ok: adds the second element with the key Barth, John</span></span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Lost in the Funhouse&quot;</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">search_item</span><span class="params">(<span class="string">&quot;Alain de Botton&quot;</span>)</span></span>;      <span class="comment">// author we&#x27;ll look for</span></span><br><span class="line"><span class="keyword">auto</span> entries = authors.<span class="built_in">count</span>(search_item);  <span class="comment">// number of elements</span></span><br><span class="line"><span class="keyword">auto</span> iter = authors.<span class="built_in">find</span>(search_item);      <span class="comment">// first entry for this author</span></span><br><span class="line"><span class="comment">// loop through the number of entries there are for this author</span></span><br><span class="line"><span class="keyword">while</span>(entries)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; iter-&gt;second &lt;&lt; endl;   <span class="comment">// print each title</span></span><br><span class="line">    ++iter;      <span class="comment">// advance to the next title</span></span><br><span class="line">    --entries;   <span class="comment">// keep track of how many we&#x27;ve printed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码的目的是从 <code>multimap</code> 容器 <code>authors</code> 中查找特定作者的所有作品，并打印它们的标题。让我逐步解释：</p>
<ol>
<li><p>定义了一个 <code>multimap</code> 容器 <code>authors</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multimap&lt;string, string&gt; authors;</span><br></pre></td></tr></table></figure>
<p>这行代码创建了一个 <code>multimap</code> 容器，用于存储作者名和作品名的键值对。每个键（作者名）可以对应多个值（作品名）。</p>
</li>
<li><p>向容器中插入元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Sot-Weed Factor&quot;</span>&#125;);</span><br><span class="line">authors.<span class="built_in">insert</span>(&#123;<span class="string">&quot;Barth, John&quot;</span>, <span class="string">&quot;Lost in the Funhouse&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>这两行代码分别向 <code>authors</code> 容器中插入了两个具有相同键（”Barth, John”）的元素。因为 <code>multimap</code> 允许多个元素具有相同的键，所以这两个作品都会被插入。</p>
</li>
<li><p>定义要搜索的作者：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">search_item</span><span class="params">(<span class="string">&quot;Alain de Botton&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这行代码定义了要搜索的作者名称。在这个示例中，搜索的作者并不存在于 <code>authors</code> 容器中。</p>
</li>
<li><p>查找元素：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> entries = authors.<span class="built_in">count</span>(search_item);  <span class="comment">// number of elements</span></span><br><span class="line"><span class="keyword">auto</span> iter = authors.<span class="built_in">find</span>(search_item);      <span class="comment">// first entry for this author</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>authors.count(search_item)</code> 返回与搜索项匹配的元素数量。在这里，因为搜索项并不存在于容器中，所以 <code>entries</code> 被初始化为0。</li>
<li><code>authors.find(search_item)</code> 返回与搜索项匹配的第一个元素的迭代器。在这里，由于搜索项并不存在于容器中，<code>iter</code> 被初始化为指向容器末尾的迭代器（即 <code>authors.end()</code>）。</li>
</ul>
</li>
<li><p>输出作者作品：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(entries)</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; iter-&gt;second &lt;&lt; endl;   <span class="comment">// print each title</span></span><br><span class="line">    ++iter;      <span class="comment">// advance to the next title</span></span><br><span class="line">    --entries;   <span class="comment">// keep track of how many we&#x27;ve printed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一个循环，它的条件是 <code>entries</code> 不为0。但是，由于搜索项并不存在于容器中，所以循环体不会执行。因此，没有任何输出。</p>
</li>
</ol>
<p>综上所述，这段代码的作用是试图从 <code>multimap</code> 容器 <code>authors</code> 中查找指定作者的作品，并打印它们的标题。但由于搜索项并不存在于容器中，所以不会有任何输出。</p>
</blockquote>
<p><code>lower_bound</code>和<code>upper_bound</code>操作都接受一个关键字，返回一个迭代器。如果关键字在容器中，<code>lower_bound</code>返回的迭代器会指向第一个匹配给定关键字的元素，而<code>upper_bound</code>返回的迭代器则指向最后一个匹配元素之后的位置。如果关键字不在<code>multimap</code>中，则<code>lower_bound</code>和<code>upper_bound</code>会返回相等的迭代器，指向一个不影响排序的关键字插入位置。因此用相同的关键字调用<code>lower_bound</code>和<code>upper_bound</code>会得到一个迭代器范围，表示所有具有该关键字的元素范围。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definitions of authors and search_item as above</span></span><br><span class="line"><span class="comment">// beg and end denote the range of elements for this author</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> beg = authors.<span class="built_in">lower_bound</span>(search_item),</span><br><span class="line">        end = authors.<span class="built_in">upper_bound</span>(search_item);</span><br><span class="line">    beg != end; ++beg)</span><br><span class="line">    cout &lt;&lt; beg-&gt;second &lt;&lt; endl;    <span class="comment">// print each title</span></span><br></pre></td></tr></table></figure>
<p><code>lower_bound</code>和<code>upper_bound</code>有可能返回尾后迭代器。如果查找的元素具有容器中最大的关键字，则<code>upper_bound</code>返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则<code>lower_bound</code>也返回尾后迭代器。</p>
<p><code>equal_range</code>操作接受一个关键字，返回一个迭代器<code>pair</code>。若关键字存在，则第一个迭代器指向第一个匹配关键字的元素，第二个迭代器指向最后一个匹配元素之后的位置。若关键字不存在，则两个迭代器都指向一个不影响排序的关键字插入位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// definitions of authors and search_item as above</span></span><br><span class="line"><span class="comment">// pos holds iterators that denote the range of elements for this key</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> pos = authors.<span class="built_in">equal_range</span>(search_item);</span><br><span class="line">        pos.first != pos.second; ++pos.first)</span><br><span class="line">    cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl;  <span class="comment">// print each title</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码使用了 <code>equal_range</code> 函数来查找 <code>multimap</code> 容器中指定键的所有元素，并将它们的位置存储在迭代器对 <code>pos</code> 中。然后，通过循环遍历该范围，并输出每个匹配键的对应值。让我逐步解释：</p>
<ol>
<li><p><code>auto pos = authors.equal_range(search_item);</code>：<br>这行代码调用了 <code>equal_range</code> 函数，该函数会返回一个表示指定键在容器中的范围的迭代器对。<code>authors</code> 是一个 <code>multimap</code> 容器，<code>search_item</code> 是要查找的键值。<code>pos</code> 是一个自动类型的变量，用于存储返回的迭代器对。</p>
</li>
<li><p><code>pos.first != pos.second</code>：<br>这是一个循环条件，它检查迭代器对 <code>pos</code> 所表示的范围是否为空。如果范围不为空，则说明在容器中找到了与 <code>search_item</code> 匹配的元素。</p>
</li>
<li><p><code>++pos.first</code>：<br>在循环的每次迭代中，迭代器 <code>pos.first</code> 会向前移动，以便遍历匹配键的所有元素。</p>
</li>
<li><p><code>cout &lt;&lt; pos.first-&gt;second &lt;&lt; endl;</code>：<br>这行代码输出了匹配键的对应值。由于 <code>multimap</code> 容器可以包含多个具有相同键的元素，因此 <code>pos.first</code> 是一个迭代器，它指向范围内的当前元素。<code>pos.first-&gt;second</code> 访问了该元素的值部分，即容器中存储的第二个数据成员（假设作者与书名关联），并将其输出到标准输出流中。</p>
</li>
</ol>
<p>通过这种方式，该循环会逐个输出与指定键匹配的所有元素的对应值，直到范围中的所有元素都被遍历完毕。</p>
</blockquote>
<h3 id="无序容器（The-Unordered-Containers）"><a href="#无序容器（The-Unordered-Containers）" class="headerlink" title="无序容器（The Unordered Containers）"></a>无序容器（The Unordered Containers）</h3><p>新标准库定义了4个无序关联容器（unordered associative container），这些容器使用哈希函数（hash function）和关键字类型的<code>==</code>运算符组织元素。</p>
<p>无序容器和对应的有序容器通常可以相互替换。但是由于元素未按顺序存储，使用无序容器的程序输出一般会与有序容器的版本不同。</p>
<p>无序容器在存储上组织为一组桶，每个桶保存零或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。因此无序容器的性能依赖于哈希函数的质量和桶的数量及大小。</p>
<p>默认情况下，无序容器使用关键字类型的<code>==</code>运算符比较元素，还使用一个<code>hash&lt;key_type&gt;</code>类型的对象来生成每个元素的哈希值。标准库为内置类型和一些标准库类型提供了hash模板。因此可以直接定义关键字是这些类型的无序容器，而不能直接定义关键字类型为自定义类类型的无序容器，必须先提供对应的hash模板版本。</p>
<hr>
<h2 id="Standard-Library-Algorithms"><a href="#Standard-Library-Algorithms" class="headerlink" title="Standard Library Algorithms"></a>Standard Library Algorithms</h2><h3 id="概述（Overview）"><a href="#概述（Overview）" class="headerlink" title="概述（Overview）"></a>概述（Overview）</h3><p>大多数算法都定义在头文件<code>algorithm</code>中，此外标准库还在头文件<code>numeric</code>中定义了一组数值泛型算法。一般情况下，这些算法并不直接操作容器，而是遍历由两个迭代器指定的元素范围进行操作。</p>
<p><code>find</code>函数将范围中的每个元素与给定值进行比较，返回指向第一个等于给定值的元素的迭代器。如果无匹配元素，则返回其第二个参数来表示搜索失败。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val = <span class="number">42</span>;   <span class="comment">// value we&#x27;ll look for</span></span><br><span class="line"><span class="comment">// result will denote the element we want if it&#x27;s in vec, or vec.cend() if not</span></span><br><span class="line"><span class="keyword">auto</span> result = <span class="built_in">find</span>(vec.<span class="built_in">cbegin</span>(), vec.<span class="built_in">cend</span>(), val);</span><br><span class="line"><span class="comment">// report the result</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The value &quot;</span> &lt;&lt; val</span><br><span class="line">    &lt;&lt; (result == vec.<span class="built_in">cend</span>() ? <span class="string">&quot; is not present&quot;</span> : <span class="string">&quot; is present&quot;</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>迭代器参数令算法不依赖于特定容器，但依赖于元素类型操作。</p>
<p>泛型算法本身不会执行容器操作，它们只会运行于迭代器之上，执行迭代器操作。算法可能改变容器中元素的值，或者在容器内移动元素，但不会改变底层容器的大小（当算法操作插入迭代器时，迭代器可以向容器中添加元素，但算法自身不会进行这种操作）。</p>
<h3 id="初识泛型算法（A-First-Look-at-the-Algorithms）"><a href="#初识泛型算法（A-First-Look-at-the-Algorithms）" class="headerlink" title="初识泛型算法（A First Look at the Algorithms）"></a>初识泛型算法（A First Look at the Algorithms）</h3><h3 id="只读算法（Read-Only-Algorithms）"><a href="#只读算法（Read-Only-Algorithms）" class="headerlink" title="只读算法（Read-Only Algorithms）"></a>只读算法（Read-Only Algorithms）</h3><p><code>accumulate</code>函数（定义在头文件<code>numeric</code>中）用于计算一个序列的和。它接受三个参数，前两个参数指定需要求和的元素范围，第三个参数是和的初值（决定加法运算类型和返回值类型）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum the elements in vec starting the summation with the value 0</span></span><br><span class="line"><span class="type">int</span> sum = <span class="built_in">accumulate</span>(vec.<span class="built_in">cbegin</span>(), vec.<span class="built_in">cend</span>(), <span class="number">0</span>);</span><br><span class="line">string sum = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="built_in">string</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line"><span class="comment">// error: no + on const char*</span></span><br><span class="line">string sum = <span class="built_in">accumulate</span>(v.<span class="built_in">cbegin</span>(), v.<span class="built_in">cend</span>(), <span class="string">&quot;&quot;</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议在只读算法中使用<code>cbegin</code>和<code>cend</code>函数。</p>
</blockquote>
<p><code>equal</code>函数用于确定两个序列是否保存相同的值。它接受三个迭代器参数，前两个参数指定第一个序列范围，第三个参数指定第二个序列的首元素。<code>equal</code>函数假定第二个序列至少与第一个序列一样长。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// roster2 should have at least as many elements as roster1</span></span><br><span class="line"><span class="built_in">equal</span>(roster1.<span class="built_in">cbegin</span>(), roster1.<span class="built_in">cend</span>(), roster2.<span class="built_in">cbegin</span>());</span><br></pre></td></tr></table></figure>
<p>只接受单一迭代器表示第二个操作序列的算法都假定第二个序列至少与第一个序列一样长。</p>
<h3 id="写容器元素的算法（Algorithms-That-Write-Container-Elements）"><a href="#写容器元素的算法（Algorithms-That-Write-Container-Elements）" class="headerlink" title="写容器元素的算法（Algorithms That Write Container Elements）"></a>写容器元素的算法（Algorithms That Write Container Elements）</h3><p><code>fill</code>函数接受两个迭代器参数表示序列范围，还接受一个值作为第三个参数，它将给定值赋予范围内的每个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reset each element to 0</span></span><br><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><code>fill_n</code>函数接受单个迭代器参数、一个计数值和一个值，它将给定值赋予迭代器指向位置开始的指定个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reset all the elements of vec to 0</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>向目的位置迭代器写入数据的算法都假定目的位置足够大，能容纳要写入的元素。</p>
<p>插入迭代器（insert iterator）是一种向容器内添加元素的迭代器。通过插入迭代器赋值时，一个与赋值号右侧值相等的元素会被添加到容器中。</p>
<p><code>back_inserter</code>函数（定义在头文件<code>iterator</code>中）接受一个指向容器的引用，返回与该容器绑定的插入迭代器。通过此迭代器赋值时，赋值运算符会调用<code>push_back</code>将一个具有给定值的元素添加到容器中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;    <span class="comment">// empty vector</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">back_inserter</span>(vec);   <span class="comment">// assigning through it adds elements to vec</span></span><br><span class="line">*it = <span class="number">42</span>;   <span class="comment">// vec now has one element with value 42</span></span><br><span class="line"><span class="comment">// ok: back_inserter creates an insert iterator that adds elements to vec</span></span><br><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(vec), <span class="number">10</span>, <span class="number">0</span>);  <span class="comment">// appends ten elements to vec</span></span><br></pre></td></tr></table></figure>
<p><code>copy</code>函数接受三个迭代器参数，前两个参数指定输入序列，第三个参数指定目的序列的起始位置。它将输入序列中的元素拷贝到目的序列中，返回目的位置迭代器（递增后）的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a1[] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span> &#125;;</span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">sizeof</span>(a1) / <span class="built_in">sizeof</span>(*a1)];     <span class="comment">// a2 has the same size as a1</span></span><br><span class="line"><span class="comment">// ret points just past the last element copied into a2</span></span><br><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">copy</span>(<span class="built_in">begin</span>(a1), <span class="built_in">end</span>(a1), a2);    <span class="comment">// copy a1 into a2</span></span><br></pre></td></tr></table></figure>
<p><code>replace</code>函数接受四个参数，前两个迭代器参数指定输入序列，后两个参数指定要搜索的值和替换值。它将序列中所有等于第一个值的元素都替换为第二个值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// replace any element with the value 0 with 42</span></span><br><span class="line"><span class="built_in">replace</span>(ilst.<span class="built_in">begin</span>(), ilst.<span class="built_in">end</span>(), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>相对于<code>replace</code>，<code>replace_copy</code>函数可以保留原序列不变。它接受第三个迭代器参数，指定调整后序列的保存位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// use back_inserter to grow destination as needed</span></span><br><span class="line"><span class="built_in">replace_copy</span>(ilst.<span class="built_in">cbegin</span>(), ilst.<span class="built_in">cend</span>(), <span class="built_in">back_inserter</span>(ivec), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>很多算法都提供“copy”版本，这些版本不会将新元素放回输入序列，而是创建一个新序列保存结果。</p>
<h3 id="重排容器元素的算法（Algorithms-That-Reorder-Container-Elements）"><a href="#重排容器元素的算法（Algorithms-That-Reorder-Container-Elements）" class="headerlink" title="重排容器元素的算法（Algorithms That Reorder Container Elements）"></a>重排容器元素的算法（Algorithms That Reorder Container Elements）</h3><p><code>sort</code>函数接受两个迭代器参数，指定排序范围。它利用元素类型的<code>&lt;</code>运算符重新排列元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">elimDups</span><span class="params">(vector&lt;string&gt; &amp;words)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// sort words alphabetically so we can find the duplicates</span></span><br><span class="line">    <span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// unique reorders the input range so that each word appears once in the</span></span><br><span class="line">    <span class="comment">// front portion of the range and returns an iterator one past the unique range</span></span><br><span class="line">    <span class="keyword">auto</span> end_unique = <span class="built_in">unique</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// erase uses a vector operation to remove the nonunique elements</span></span><br><span class="line">    words.<span class="built_in">erase</span>(end_unique, words.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>unique</code>函数重排输入序列，消除相邻的重复项，返回指向不重复值范围末尾的迭代器。</p>
<h3 id="定制操作（Customizing-Operations）"><a href="#定制操作（Customizing-Operations）" class="headerlink" title="定制操作（Customizing Operations）"></a>定制操作（Customizing Operations）</h3><p>默认情况下，很多比较算法使用元素类型的<code>&lt;</code>或<code>==</code>运算符完成操作。可以为这些算法提供自定义操作来代替默认运算符。</p>
<h3 id="向算法传递函数（Passing-a-Function-to-an-Algorithm）"><a href="#向算法传递函数（Passing-a-Function-to-an-Algorithm）" class="headerlink" title="向算法传递函数（Passing a Function to an Algorithm）"></a>向算法传递函数（Passing a Function to an Algorithm）</h3><p>谓词（predicate）是一个可调用的表达式，其返回结果是一个能用作条件的值。标准库算法使用的谓词分为一元谓词（unary predicate，接受一个参数）和二元谓词（binary predicate，接受两个参数）。接受谓词参数的算法会对输入序列中的元素调用谓词，因此元素类型必须能转换为谓词的参数类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// comparison function to be used to sort by word length</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;s1, <span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort on word length, shortest to longest</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br></pre></td></tr></table></figure>
<h3 id="lambda表达式（Lambda-Expressions）"><a href="#lambda表达式（Lambda-Expressions）" class="headerlink" title="lambda表达式（Lambda Expressions）"></a>lambda表达式（Lambda Expressions）</h3><p><code>find_if</code>函数接受两个迭代器参数和一个谓词参数。迭代器参数用于指定序列范围，之后对序列中的每个元素调用给定谓词，并返回第一个使谓词返回非0值的元素。如果不存在，则返回尾迭代器。</p>
<p>对于一个对象或表达式，如果可以对其使用调用运算符<code>()</code>，则称它为可调用对象（callable object）。可以向算法传递任何类别的可调用对象。</p>
<p>一个<code>lambda</code>表达式表示一个可调用的代码单元，类似未命名的内联函数，但可以定义在函数内部。其形式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list] (parameter list) -&gt; <span class="keyword">return</span> type &#123; function body &#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>capture list</code>（捕获列表）是一个由<code>lambda</code>所在函数定义的局部变量的列表（通常为空）。<code>return type</code>、<code>parameter list</code>和<code>function body</code>与普通函数一样，分别表示返回类型、参数列表和函数体。但与普通函数不同，<code>lambda</code>必须使用尾置返回类型，且不能有默认实参。</p>
<p>定义<code>lambda</code>时可以省略参数列表和返回类型，但必须包含捕获列表和函数体。省略参数列表等价于指定空参数列表。省略返回类型时，若函数体只是一个<code>return</code>语句，则返回类型由返回表达式的类型推断而来。否则返回类型为<code>void</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br><span class="line">cout &lt;&lt; <span class="built_in">f</span>() &lt;&lt; endl;    <span class="comment">// prints 42</span></span><br></pre></td></tr></table></figure>
<p><code>lambda</code>可以使用其所在函数的局部变量，但必须先将其包含在捕获列表中。捕获列表只能用于局部非<code>static</code>变量，<code>lambda</code>可以直接使用局部<code>static</code>变量和其所在函数之外声明的名字。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get an iterator to the first element whose size() is &gt;= sz</span></span><br><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">                    [sz](<span class="type">const</span> string &amp;a) &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>解释一下：</p>
<p>这段代码使用了STL（标准模板库）中的<code>find_if</code>算法来查找满足特定条件的元素。让我们逐步解释每个部分的功能：</p>
<ol>
<li><p><code>auto wc = find_if(words.begin(), words.end(), [sz](const string &amp;a) &#123; return a.size() &gt;= sz; &#125;);</code>：这一行使用了<code>find_if</code>算法，它在指定范围内查找第一个满足特定条件的元素。具体来说：</p>
<ul>
<li><p><code>words.begin()</code>和<code>words.end()</code>指定了查找范围，即从<code>words</code>向量的起始位置到末尾位置。</p>
</li>
<li><p><code>[sz](const string &amp;a) &#123; return a.size() &gt;= sz; &#125;</code>是一个lambda表达式，它定义了查找条件。lambda表达式的形式是<code>[capture list](parameter list) &#123; function body &#125;</code>，在这里：</p>
<ul>
<li><p><code>[sz]</code>是捕获列表，它捕获了外部变量<code>sz</code>，使lambda表达式可以访问并使用它。</p>
</li>
<li><p><code>(const string &amp;a)</code>是参数列表，它指定了lambda表达式的参数，这里是一个const引用到字符串。</p>
</li>
<li><p><code>&#123; return a.size() &gt;= sz; &#125;</code>是函数体，它定义了查找条件。这里，lambda表达式返回一个布尔值，即判断字符串<code>a</code>的大小是否大于等于<code>sz</code>。如果是，则返回<code>true</code>，表示找到了满足条件的元素。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>auto wc = ...;</code>：使用<code>auto</code>关键字自动推导出迭代器的类型。<code>wc</code>是一个迭代器，它指向第一个满足条件的元素。</p>
</li>
</ol>
<p>综上所述，这段代码的功能是查找在<code>words</code>向量中，第一个满足长度大于等于<code>sz</code>的字符串，并将指向该字符串的迭代器存储在<code>wc</code>中。</p>
</blockquote>
<p><code>for_each</code>函数接受一个输入序列和一个可调用对象，它对输入序列中的每个元素调用此对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print words of the given size or longer, each one followed by a space</span></span><br><span class="line">for_each(wc, words.<span class="built_in">end</span>(),</span><br><span class="line">            [] (<span class="type">const</span> string &amp;s) &#123; cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>; &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="lambda捕获和返回（Lambda-Captures-and-Returns）"><a href="#lambda捕获和返回（Lambda-Captures-and-Returns）" class="headerlink" title="lambda捕获和返回（Lambda Captures and Returns）"></a>lambda捕获和返回（Lambda Captures and Returns）</h3><p>被<code>lambda</code>捕获的变量的值是在<code>lambda</code>创建时拷贝，而不是调用时拷贝。在<code>lambda</code>创建后修改局部变量不会影响<code>lambda</code>内对应的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> v1 = <span class="number">42</span>; <span class="comment">// local variable</span></span><br><span class="line"><span class="comment">// copies v1 into the callable object named f</span></span><br><span class="line"><span class="keyword">auto</span> f = [v1] &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>();   <span class="comment">// j is 42; f stored a copy of v1 when we created it</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码使用了 C++11 中的 lambda 表达式来创建了一个可调用对象，并且捕获了一个局部变量 <code>v1</code>。让我们一步步解释代码的功能：</p>
<ol>
<li><p><code>size_t v1 = 42;</code>: 这行代码声明并初始化了一个名为 <code>v1</code> 的本地变量，其值为 <code>42</code>。</p>
</li>
<li><p><code>auto f = [v1] &#123; return v1; &#125;;</code>: 这行代码定义了一个 lambda 表达式，并将其赋值给变量 <code>f</code>。 lambda 表达式的形式为 <code>[capture-list] (parameters) &#123; body &#125;</code>，在这里：</p>
<ul>
<li><p><code>[v1]</code> 是捕获列表，它允许 lambda 表达式访问在 lambda 函数体内部使用的外部变量。<code>[v1]</code> 捕获了变量 <code>v1</code>，并在 lambda 函数体内部使用它。</p>
</li>
<li><p><code>&#123; return v1; &#125;</code> 是 lambda 函数体，它包含了 lambda 表达式要执行的操作。在这里，lambda 函数体返回捕获的变量 <code>v1</code> 的值。</p>
</li>
</ul>
</li>
<li><p><code>v1 = 0;</code>: 这行代码将变量 <code>v1</code> 的值更改为 <code>0</code>。</p>
</li>
<li><p><code>auto j = f();</code>: 这行代码调用了 lambda 表达式，并将其返回值赋值给变量 <code>j</code>。由于 lambda 表达式 <code>[v1] &#123; return v1; &#125;</code> 捕获了变量 <code>v1</code> 的值（在创建时进行了捕获），即使在调用 lambda 表达式时 <code>v1</code> 的值已经被修改为 <code>0</code>，lambda 表达式仍然返回了捕获时的值，也就是 <code>42</code>。因此，变量 <code>j</code> 的值为 <code>42</code>。</p>
</li>
</ol>
</blockquote>
<p><code>lambda</code>可以以引用方式捕获变量，但必须保证<code>lambda</code>执行时变量存在。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> v1 = <span class="number">42</span>; <span class="comment">// local variable</span></span><br><span class="line"><span class="comment">// the object f2 contains a reference to v1</span></span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;v1] &#123; <span class="keyword">return</span> v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f2</span>();  <span class="comment">// j is 0; f2 refers to v1; it doesn&#x27;t store it</span></span><br></pre></td></tr></table></figure>
<p>可以让编译器根据<code>lambda</code>代码隐式捕获函数变量，方法是在捕获列表中写一个<code>&amp;</code>或<code>=</code>符号。<code>&amp;</code>为引用捕获，<code>=</code>为值捕获。</p>
<p>可以混合使用显式捕获和隐式捕获。混合使用时，捕获列表中的第一个元素必须是<code>&amp;</code>或<code>=</code>符号，用于指定默认捕获方式。显式捕获的变量必须使用与隐式捕获不同的方式。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os implicitly captured by reference; c explicitly captured by value</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">            [&amp;, c] (<span class="type">const</span> string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line"><span class="comment">// os explicitly captured by reference; c implicitly captured by value</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">            [=, &amp;os] (<span class="type">const</span> string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这两段代码是使用 lambda 表达式结合 STL 中的 <code>for_each</code> 算法来对 <code>words</code> 容器中的元素进行处理。它们展示了 lambda 表达式中捕获变量的不同方式，通过引用捕获和值捕获的不同组合。</p>
<p>第一段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os implicitly captured by reference; c explicitly captured by value</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">         [&amp;, c] (<span class="type">const</span> string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码使用了 <code>[&amp;, c]</code> 的捕获列表。其中 <code>&amp;</code> 表示以引用方式捕获外部作用域的变量，而 <code>c</code> 则表示以值的方式捕获。这意味着 <code>os</code> 变量会被隐式以引用方式捕获，而 <code>c</code> 则被显式以值的方式捕获。在 lambda 函数体中，<code>os</code> 是以引用方式捕获的，而 <code>c</code> 则是以值的方式捕获的。</p>
<p>第二段代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// os explicitly captured by reference; c implicitly captured by value</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">         [=, &amp;os] (<span class="type">const</span> string &amp;s) &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码使用了 <code>[=, &amp;os]</code> 的捕获列表。其中 <code>=</code> 表示以值的方式捕获所有外部作用域的变量，而 <code>&amp;os</code> 则表示以引用的方式捕获 <code>os</code> 变量。这意味着 <code>os</code> 变量会被显式以引用方式捕获，而 <code>c</code> 则会被隐式以值的方式捕获。在 lambda 函数体中，<code>os</code> 是以引用方式捕获的，而 <code>c</code> 则是以值的方式捕获的。</p>
<p>总的来说，两段代码都使用了相同的 <code>for_each</code> 算法来遍历 <code>words</code> 容器中的元素，并对每个元素执行相同的操作，即将每个字符串及变量 <code>c</code> 的值输出到输出流 <code>os</code> 中。唯一的区别在于，它们对于变量 <code>os</code> 和 <code>c</code> 的捕获方式不同。</p>
</blockquote>
<p>默认情况下，对于值方式捕获的变量，<code>lambda</code>不能修改其值。如果希望修改，就必须在参数列表后添加关键字<code>mutable</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> v1 = <span class="number">42</span>; <span class="comment">// local variable</span></span><br><span class="line"><span class="comment">// f can change the value of the variables it captures</span></span><br><span class="line"><span class="keyword">auto</span> f = [v1] () <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> ++v1; &#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> j = <span class="built_in">f</span>();   <span class="comment">// j is 43</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对于引用方式捕获的变量，<code>lambda</code>是否可以修改依赖于此引用指向的是否是<code>const</code>类型。</p>
</blockquote>
<p><code>transform</code>函数接受三个迭代器参数和一个可调用对象。前两个迭代器参数指定输入序列，第三个迭代器参数表示目的位置。它对输入序列中的每个元素调用可调用对象，并将结果写入目的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">transform</span>(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(),</span><br><span class="line">            [](<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123; <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i; &#125;);</span><br></pre></td></tr></table></figure>
<p>为<code>lambda</code>定义返回类型时，必须使用尾置返回类型。</p>
<h3 id="参数绑定（Binding-Arguments）"><a href="#参数绑定（Binding-Arguments）" class="headerlink" title="参数绑定（Binding Arguments）"></a>参数绑定（Binding Arguments）</h3><p><code>bind</code>函数定义在头文件<code>functional</code>中，相当于一个函数适配器，它接受一个可调用对象，生成一个新的可调用对象来适配原对象的参数列表。一般形式如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = <span class="built_in">bind</span>(callable, arg_list);</span><br></pre></td></tr></table></figure>
<p>其中，<code>newCallable</code>本身是一个可调用对象，<code>arg_list</code>是一个以逗号分隔的参数列表，对应给定的<code>callable</code>的参数。之后调用<code>newCallable</code>时，<code>newCallable</code>会再调用<code>callable</code>，并传递给它<code>arg_list</code>中的参数。<code>arg_list</code>中可能包含形如<code>_n</code>的名字，其中<code>n</code>是一个整数。这些参数是占位符，表示<code>newCallable</code>的参数，它们占据了传递给<code>newCallable</code>的参数的位置。数值<code>n</code>表示生成的可调用对象中参数的位置：<code>_1</code>为<code>newCallable</code>的第一个参数，<code>_2</code>为<code>newCallable</code>的第二个参数，依次类推。这些名字都定义在命名空间<code>placeholders</code>中，它又定义在命名空间<code>std</code>中，因此使用时应该进行双重限定。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> std::placeholders::_1;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check_size</span><span class="params">(<span class="type">const</span> string &amp;s, string::size_type sz)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// check6 is a callable object that takes one argument of type string</span></span><br><span class="line"><span class="comment">// and calls check_size on its given string and the value 6</span></span><br><span class="line"><span class="keyword">auto</span> check6 = <span class="built_in">bind</span>(check_size, _1, <span class="number">6</span>);</span><br><span class="line">string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="type">bool</span> b1 = <span class="built_in">check6</span>(s);    <span class="comment">// check6(s) calls check_size(s, 6)</span></span><br></pre></td></tr></table></figure>
<p><code>bind</code>函数可以调整给定可调用对象中的参数顺序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sort on word length, shortest to longest</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), isShorter);</span><br><span class="line"><span class="comment">// sort on word length, longest to shortest</span></span><br><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(isShorter, _2, _1));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码演示了如何使用 C++ 的 <code>sort</code> 算法对一个字符串向量 <code>words</code> 进行排序，以字符串的长度作为排序的标准。然而，这里使用了两种不同的排序方式，并且利用了函数对象和函数适配器。让我们逐步解释：</p>
<ol>
<li><p><code>sort(words.begin(), words.end(), isShorter);</code>：<br>这行代码使用了 <code>sort</code> 算法来对字符串向量 <code>words</code> 进行排序。<code>words.begin()</code> 和 <code>words.end()</code> 指定了排序的范围，即从 <code>words</code> 的起始位置到末尾位置。排序的方式由第三个参数 <code>isShorter</code> 指定。这里 <code>isShorter</code> 是一个自定义的函数对象，它定义了字符串长度的比较规则，即按照字符串长度从短到长的顺序进行排序。</p>
</li>
<li><p><code>sort(words.begin(), words.end(), bind(isShorter, _2, _1));</code>：<br>这行代码也使用了 <code>sort</code> 算法来对字符串向量 <code>words</code> 进行排序。<code>words.begin()</code> 和 <code>words.end()</code> 仍然指定了排序的范围。不同之处在于第三个参数，这里使用了 <code>bind</code> 函数适配器。<code>bind</code> 函数适配器可以用来修改函数的参数顺序。在这里，<code>bind(isShorter, _2, _1)</code> 将 <code>isShorter</code> 函数对象的参数顺序进行了调换。具体来说，它将 <code>isShorter</code> 的第一个参数 <code>_1</code> 绑定到了 <code>isShorter</code> 的第二个参数，将 <code>isShorter</code> 的第二个参数 <code>_2</code> 绑定到了 <code>isShorter</code> 的第一个参数。这意味着排序将按照字符串长度从长到短的顺序进行，因为在比较时，先比较的是第二个字符串的长度（即 <code>_2</code>），再比较第一个字符串的长度（即 <code>_1</code>）。</p>
</li>
</ol>
<p>综上所述，这段代码展示了如何使用不同的比较函数对象来对字符串向量进行排序，并且展示了如何使用 <code>bind</code> 函数适配器来修改函数的参数顺序。</p>
</blockquote>
<p>默认情况下，<code>bind</code>函数的非占位符参数被拷贝到<code>bind</code>返回的可调用对象中。但有些类型不支持拷贝操作。</p>
<p>如果希望传递给<code>bind</code>一个对象而又不拷贝它，则必须使用标准库的<code>ref</code>函数。<code>ref</code>函数返回一个对象，包含给定的引用，此对象是可以拷贝的。<code>cref</code>函数生成保存<code>const</code>引用的类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="type">const</span> string &amp;s, <span class="type">char</span> c)</span></span>;</span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(print, <span class="built_in">ref</span>(os), _1, <span class="string">&#x27; &#x27;</span>));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码使用了 <code>for_each</code> 算法，结合 <code>bind</code> 函数适配器，来对字符串向量 <code>words</code> 中的每个字符串调用 <code>print</code> 函数进行处理。让我们逐步解释：</p>
<ol>
<li><p><code>ostream &amp;print(ostream &amp;os, const string &amp;s, char c);</code>：<br>这是一个名为 <code>print</code> 的函数声明，它接受一个输出流 <code>os</code>、一个字符串 <code>s</code> 和一个字符 <code>c</code> 作为参数，并返回一个输出流引用。这个函数的功能可能是将字符串 <code>s</code> 输出到输出流 <code>os</code> 中，并在其末尾添加字符 <code>c</code>。</p>
</li>
<li><p><code>for_each(words.begin(), words.end(), bind(print, ref(os), _1, &#39; &#39;));</code>：<br>这行代码使用了 <code>for_each</code> 算法，它遍历了字符串向量 <code>words</code> 中的每个字符串，并对每个字符串调用 <code>print</code> 函数进行处理。在这里，<code>bind</code> 函数适配器用来绑定 <code>print</code> 函数的参数。具体来说：</p>
<ul>
<li><p><code>words.begin()</code> 和 <code>words.end()</code> 指定了需要遍历的范围，即从 <code>words</code> 的起始位置到末尾位置。</p>
</li>
<li><p><code>bind(print, ref(os), _1, &#39; &#39;)</code> 将 <code>print</code> 函数与参数绑定，创建了一个函数对象。这里：</p>
<ul>
<li><code>print</code> 是要绑定的函数。</li>
<li><code>ref(os)</code> 用来将输出流 <code>os</code> 以引用的方式传递给 <code>print</code> 函数，因为通常输出流需要以引用方式传递。</li>
<li><code>_1</code> 是一个占位符，表示绑定的函数对象将接受一个参数，该参数将在调用时传递给 <code>print</code> 函数的第二个参数 <code>s</code>。<code>_1</code> 与 <code>for_each</code> 算法中遍历的每个字符串 <code>s</code> 相对应。</li>
<li><code>&#39; &#39;</code> 是要绑定的函数对象的最后一个参数，表示将空格字符添加到每个字符串的末尾。</li>
</ul>
</li>
</ul>
<p>因此，<code>for_each</code> 算法会遍历 <code>words</code> 中的每个字符串，并对每个字符串调用 <code>print</code> 函数，将其输出到输出流 <code>os</code> 中，并在末尾添加一个空格字符。</p>
</li>
</ol>
<p>综上所述，这段代码展示了如何使用 <code>for_each</code> 算法和 <code>bind</code> 函数适配器来对字符串向量中的每个元素调用自定义函数进行处理，并根据需要绑定函数的参数。</p>
</blockquote>
<h3 id="再探迭代器（Revisiting-Iterators）"><a href="#再探迭代器（Revisiting-Iterators）" class="headerlink" title="再探迭代器（Revisiting Iterators）"></a>再探迭代器（Revisiting Iterators）</h3><p>除了为每种容器定义的迭代器之外，标准库还在头文件<code>iterator</code>中定义了另外几种迭代器。</p>
<ul>
<li>插入迭代器（insert iterator）：该类型迭代器被绑定到容器对象上，可用来向容器中插入元素。</li>
<li>流迭代器（stream iterator）：该类型迭代器被绑定到输入或输出流上，可用来遍历所关联的IO流。</li>
<li>反向迭代器（reverse iterator）：该类型迭代器向后而不是向前移动。除了<code>forward_list</code>之外的标准库容器都有反向迭代器。</li>
<li>移动迭代器（move iterator）：该类型迭代器用来移动容器元素。</li>
</ul>
<h3 id="插入迭代器（Insert-Iterators）"><a href="#插入迭代器（Insert-Iterators）" class="headerlink" title="插入迭代器（Insert Iterators）"></a>插入迭代器（Insert Iterators）</h3><p>插入器是一种迭代器适配器，它接受一个容器参数，生成一个插入迭代器。通过插入迭代器赋值时，该迭代器调用容器操作向给定容器的指定位置插入一个元素。</p>
<p>插入器有三种类型，区别在于元素插入的位置：</p>
<ul>
<li><code>back_inserter</code>：创建一个调用<code>push_back</code>操作的迭代器。</li>
<li><code>front_inserter</code>：创建一个调用<code>push_front</code>操作的迭代器。</li>
<li><code>inserter</code>：创建一个调用<code>insert</code>操作的迭代器。此函数接受第二个参数，该参数必须是一个指向给定容器的迭代器，元素会被插入到该参数指向的元素之前。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span> &#125;;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst2, lst3;   <span class="comment">// empty lists</span></span><br><span class="line"><span class="comment">// after copy completes, lst2 contains 4 3 2 1</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>(), <span class="built_in">front_inserter</span>(lst2));</span><br><span class="line"><span class="comment">// after copy completes, lst3 contains 1 2 3 4</span></span><br><span class="line"><span class="built_in">copy</span>(lst.<span class="built_in">cbegin</span>(), lst.<span class="built_in">cend</span>(), <span class="built_in">inserter</span>(lst3, lst3.<span class="built_in">begin</span>()));</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码使用了STL算法 <code>copy</code> 以及插入迭代器 <code>front_inserter</code> 和 <code>inserter</code> 来将一个列表 <code>lst</code> 中的元素复制到另外两个列表 <code>lst2</code> 和 <code>lst3</code> 中。让我们逐步解释这段代码的功能：</p>
<ol>
<li><p><code>list&lt;int&gt; lst = &#123; 1,2,3,4 &#125;;</code>：<br>这行代码创建了一个名为 <code>lst</code> 的列表，并初始化它为包含 1、2、3、4 这四个整数的列表。</p>
</li>
<li><p><code>list&lt;int&gt; lst2, lst3;</code>：<br>这行代码创建了两个名为 <code>lst2</code> 和 <code>lst3</code> 的空列表。</p>
</li>
<li><p><code>copy(lst.cbegin(), lst.cend(), front_inserter(lst2));</code>：<br>这行代码使用 <code>copy</code> 算法，将列表 <code>lst</code> 中的元素复制到列表 <code>lst2</code> 中。<code>front_inserter(lst2)</code> 是一个插入迭代器，它会将复制的元素插入到目标列表 <code>lst2</code> 的前面。因此，复制完成后，<code>lst2</code> 中的元素顺序是 4、3、2、1。</p>
</li>
<li><p><code>copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));</code>：<br>这行代码也使用 <code>copy</code> 算法，将列表 <code>lst</code> 中的元素复制到列表 <code>lst3</code> 中。<code>inserter(lst3, lst3.begin())</code> 是另一种插入迭代器，它会将复制的元素插入到目标列表 <code>lst3</code> 中的指定位置，即 <code>lst3.begin()</code> 所指示的位置。由于是从列表的开始处插入，因此复制完成后，<code>lst3</code> 中的元素顺序是 1、2、3、4。</p>
</li>
</ol>
<p>综上所述，这段代码展示了如何使用插入迭代器 <code>front_inserter</code> 和 <code>inserter</code> 将列表中的元素复制到另一个列表中，并控制复制后元素在目标列表中的顺序。</p>
</blockquote>
<h3 id="iostream迭代器（iostream-Iterators）"><a href="#iostream迭代器（iostream-Iterators）" class="headerlink" title="iostream迭代器（iostream Iterators）"></a><code>iostream</code>迭代器（<code>iostream</code> Iterators）</h3><p><code>istream_iterator</code>从输入流读取数据，<code>ostream_iterator</code>向输出流写入数据。这些迭代器将流当作特定类型的元素序列处理。</p>
<p>创建流迭代器时，必须指定迭代器读写的对象类型。<code>istream_iterator</code>使用<code>&gt;&gt;</code>来读取流，因此<code>istream_iterator</code>要读取的类型必须定义了<code>&gt;&gt;</code>运算符。创建<code>istream_iterator</code>时，可以将其绑定到一个流。如果默认初始化，则创建的是尾后迭代器。</p>
<h3 id="iostream迭代器（iostream-Iterators）-1"><a href="#iostream迭代器（iostream-Iterators）-1" class="headerlink" title="iostream迭代器（iostream Iterators）"></a><code>iostream</code>迭代器（<code>iostream</code> Iterators）</h3><p><code>istream_iterator</code>从输入流读取数据，<code>ostream_iterator</code>向输出流写入数据。这些迭代器将流当作特定类型的元素序列处理。</p>
<p>创建流迭代器时，必须指定迭代器读写的对象类型。<code>istream_iterator</code>使用<code>&gt;&gt;</code>来读取流，因此<code>istream_iterator</code>要读取的类型必须定义了<code>&gt;&gt;</code>运算符。创建<code>istream_iterator</code>时，可以将其绑定到一个流。如果默认初始化，则创建的是尾后迭代器。</p>
<blockquote>
<p>这段代码涉及到了 C++ 中的输入流迭代器 <code>istream_iterator</code> 的使用，以及如何从不同的输入源（标准输入流 <code>cin</code> 和文件流 <code>ifstream</code>）中读取数据。让我们一步步来解释：</p>
<ol>
<li><p><code>istream_iterator&lt;int&gt; int_it(cin);</code>：<br>这行代码创建了一个名为 <code>int_it</code> 的 <code>istream_iterator</code> 对象，它被初始化为从标准输入流 <code>cin</code> 中读取整数。这意味着它将从标准输入中读取用户输入的整数数据，并将其作为迭代器进行处理。</p>
</li>
<li><p><code>istream_iterator&lt;int&gt; int_eof;</code>：<br>这行代码创建了一个名为 <code>int_eof</code> 的 <code>istream_iterator</code> 对象，它被初始化为默认的“结束迭代器”值。结束迭代器用于指示输入流的末尾，通常用于在循环中检查迭代器是否已经到达了流的末尾。</p>
</li>
<li><p><code>ifstream in(&quot;afile&quot;);</code>：<br>这行代码创建了一个名为 <code>in</code> 的文件流对象，并打开了名为 <code>&quot;afile&quot;</code> 的文件。<code>ifstream</code> 类是 C++ 中用于从文件中读取数据的输入流类。</p>
</li>
<li><p><code>istream_iterator&lt;string&gt; str_it(in);</code>：<br>这行代码创建了一个名为 <code>str_it</code> 的 <code>istream_iterator</code> 对象，它被初始化为从文件流 <code>in</code> 中读取字符串。这意味着它将从文件 <code>&quot;afile&quot;</code> 中读取字符串数据，并将其作为迭代器进行处理。</p>
</li>
</ol>
<p>综上所述，这段代码展示了如何使用 <code>istream_iterator</code> 类从标准输入流和文件流中读取数据，并将其用作迭代器以便于在程序中进行处理。</p>
</blockquote>
<p>对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或IO错误，迭代器的值就与尾后迭代器相等。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span></span>;     <span class="comment">// read ints from cin</span></span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; eof;      <span class="comment">// istream &#x27;&#x27;end&#x27;&#x27; iterator</span></span><br><span class="line"><span class="keyword">while</span> (in_iter != eof)      <span class="comment">// while there&#x27;s valid input to read</span></span><br><span class="line">    <span class="comment">// postfix increment reads the stream and returns the old value of the iterator</span></span><br><span class="line">    <span class="comment">// we dereference that iterator to get the previous value read from the stream</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(*in_iter++);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码使用了输入流迭代器 <code>istream_iterator</code> 从标准输入流 <code>cin</code> 中读取整数，并将其存储到一个向量 <code>vec</code> 中。让我逐步解释：</p>
<ol>
<li><p><code>istream_iterator&lt;int&gt; in_iter(cin);</code>：<br>这行代码创建了一个名为 <code>in_iter</code> 的 <code>istream_iterator</code> 对象，它被初始化为从标准输入流 <code>cin</code> 中读取整数。这意味着 <code>in_iter</code> 将从标准输入中读取用户输入的整数数据，并将其作为迭代器进行处理。</p>
</li>
<li><p><code>istream_iterator&lt;int&gt; eof;</code>：<br>这行代码创建了一个名为 <code>eof</code> 的 <code>istream_iterator</code> 对象。在这种情况下，没有提供流作为参数，因此 <code>eof</code> 被初始化为默认的“结束迭代器”值。结束迭代器用于指示输入流的末尾，通常用于在循环中检查迭代器是否已经到达了流的末尾。</p>
</li>
<li><p><code>while (in_iter != eof)</code>：<br>这是一个 <code>while</code> 循环，它的条件是迭代器 <code>in_iter</code> 不等于结束迭代器 <code>eof</code>。这个条件保证了只要输入流中还有有效的输入，就会继续执行循环。</p>
</li>
<li><p><code>vec.push_back(*in_iter++);</code>：<br>在循环体内部，这行代码执行了以下操作：</p>
<ul>
<li><p><code>*in_iter</code> 解引用迭代器 <code>in_iter</code>，获取迭代器当前指向的元素（即从输入流读取的整数）。</p>
</li>
<li><p><code>vec.push_back(...)</code> 将解引用后的值添加到向量 <code>vec</code> 的末尾。</p>
</li>
<li><p><code>in_iter++</code> 是迭代器的后置递增操作符，它将迭代器向前移动一个位置，指向下一个输入流中的元素。注意，这里是后置递增，因此 <code>*in_iter</code> 返回的是旧的迭代器指向的元素，然后迭代器再自增，指向下一个位置。</p>
</li>
</ul>
</li>
</ol>
<p>综上所述，这段代码会持续从标准输入流中读取整数，直到输入流中没有更多的有效数据为止，然后将读取的整数存储到向量 <code>vec</code> 中。</p>
</blockquote>
<p>可以直接使用流迭代器构造容器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">in_iter</span><span class="params">(cin)</span>, eof</span>;    <span class="comment">// read ints from cin</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>;      <span class="comment">// construct vec from an iterator range</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><p><code>istream_iterator&lt;int&gt; in_iter(cin), eof;</code>：<br>这行代码创建了两个 <code>istream_iterator</code> 对象。第一个对象是 <code>in_iter</code>，它被初始化为从标准输入流 <code>cin</code> 中读取整数。第二个对象是 <code>eof</code>，它是一个默认构造的 <code>istream_iterator</code>，没有指定输入流作为参数。因此，<code>eof</code> 被初始化为默认的“结束迭代器”值。结束迭代器用于指示输入流的末尾，通常用于在循环中检查迭代器是否已经到达了流的末尾。</p>
</li>
<li><p><code>vector&lt;int&gt; vec(in_iter, eof);</code>：<br>这行代码创建了一个名为 <code>vec</code> 的向量，并通过迭代器范围构造函数来初始化它。这个范围从 <code>in_iter</code> 到 <code>eof</code>，即从标准输入流中读取的整数序列的起始迭代器到结束迭代器。向量 <code>vec</code> 会包含从输入流中读取的所有整数。</p>
</li>
</ol>
<p>综上所述，这段代码的作用是从标准输入流 <code>cin</code> 中读取整数，然后将这些整数存储到向量 <code>vec</code> 中。</p>
</blockquote>
<p>将<code>istream_iterator</code>绑定到一个流时，标准库并不保证迭代器立即从流读取数据。但可以保证在第一次解引用迭代器之前，从流中读取数据的操作已经完成了。</p>
<p>定义<code>ostream_iterator</code>对象时，必须将其绑定到一个指定的流。不允许定义空的或者表示尾后位置的<code>ostream_iterator</code>。</p>
<p><code>*</code>和<code>++</code>运算符实际上不会对<code>ostream_iterator</code>对象做任何操作。但是建议代码写法与其他迭代器保持一致。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">out_iter</span><span class="params">(cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec)</span><br><span class="line">    *out_iter++ = e;    <span class="comment">// the assignment writes this element to cout</span></span><br><span class="line">cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以为任何定义了<code>&lt;&lt;</code>运算符的类型创建<code>istream_iterator</code>对象，为定义了<code>&gt;&gt;</code>运算符的类型创建<code>ostream_iterator</code>对象。</p>
</blockquote>
<h3 id="反向迭代器（Reverse-Iterators）"><a href="#反向迭代器（Reverse-Iterators）" class="headerlink" title="反向迭代器（Reverse Iterators）"></a>反向迭代器（Reverse Iterators）</h3><p>递增反向迭代器会移动到前一个元素，递减会移动到后一个元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());   <span class="comment">// sorts vec in &quot;normal&quot; order</span></span><br><span class="line"><span class="comment">// sorts in reverse: puts the smallest element at the end of vec</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">rbegin</span>(), vec.<span class="built_in">rend</span>());</span><br></pre></td></tr></table></figure>
<p>不能从<code>forward_list</code>或流迭代器创建反向迭代器。</p>
<p>调用反向迭代器的<code>base</code>函数可以获得其对应的普通迭代器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// find the last element in a comma-separated list</span></span><br><span class="line"><span class="keyword">auto</span> rcomma = <span class="built_in">find</span>(line.<span class="built_in">crbegin</span>(), line.<span class="built_in">crend</span>(), <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line"><span class="comment">// WRONG: will generate the word in reverse order</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">string</span>(line.<span class="built_in">crbegin</span>(), rcomma) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// ok: get a forward iterator and read to the end of line</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">string</span>(rcomma.<span class="built_in">base</span>(), line.<span class="built_in">cend</span>()) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>反向迭代器的目的是表示元素范围，而这些范围是不对称的。用普通迭代器初始化反向迭代器，或者给反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同元素。</p>
<p>这段代码是在处理一个逗号分隔的字符串时，使用了反向迭代器来找到最后一个逗号，并根据其位置来拆分字符串。让我们逐步解释代码的功能：</p>
<ol>
<li><p><code>auto rcomma = find(line.crbegin(), line.crend(), &#39;,&#39;);</code>：<br>这行代码使用了 <code>find</code> 算法，通过反向迭代器在字符串 <code>line</code> 中查找最后一个逗号的位置。<code>line.crbegin()</code> 返回 <code>line</code> 字符串的反向起始迭代器，而 <code>line.crend()</code> 返回 <code>line</code> 字符串的反向结束迭代器。这样，<code>find</code> 将从字符串的末尾开始搜索，直到找到第一个逗号。</p>
</li>
<li><p><code>cout &lt;&lt; string(line.crbegin(), rcomma) &lt;&lt; endl;</code>：<br>这行代码尝试使用从字符串末尾到最后一个逗号之间的字符来构造一个新的字符串。但是，它使用了 <code>string</code> 构造函数，将反向迭代器作为参数传递，这会导致构造的字符串是反向的，即以逆序的方式输出。</p>
</li>
<li><p><code>cout &lt;&lt; string(rcomma.base(), line.cend()) &lt;&lt; endl;</code>：<br>这行代码则采取了不同的方法。它使用了 <code>base()</code> 函数来获取反向迭代器的正向迭代器，然后使用这两个正向迭代器来构造一个新的字符串，从逗号的下一个位置直到字符串的末尾。因此，它能够正确地输出从逗号后面到字符串末尾的内容。</p>
</li>
</ol>
<p>综上所述，第二行代码由于使用了反向迭代器构造字符串，导致了字符串逆序输出的问题，而第三行代码则通过转换为正向迭代器来解决了这个问题，正确地输出了所需的字符串片段。</p>
</blockquote>
<h3 id="泛型算法结构（Structure-of-Generic-Algorithms）"><a href="#泛型算法结构（Structure-of-Generic-Algorithms）" class="headerlink" title="泛型算法结构（Structure of Generic Algorithms）"></a>泛型算法结构（Structure of Generic Algorithms）</h3><h3 id="五类迭代器（The-Five-Iterator-Categories）"><a href="#五类迭代器（The-Five-Iterator-Categories）" class="headerlink" title="五类迭代器（The Five Iterator Categories）"></a>五类迭代器（The Five Iterator Categories）</h3><p>C++标准指定了泛型和数值算法的每个迭代器参数的最小类别。对于迭代器实参来说，其能力必须大于或等于规定的最小类别。向算法传递更低级的迭代器参数会产生错误（大部分编译器不会提示错误）。</p>
<p>迭代器类别：</p>
<ul>
<li>输入迭代器（input iterator）：可以读取序列中的元素，只能用于单遍扫描算法。必须支持以下操作：<ul>
<li>用于比较两个迭代器相等性的相等<code>==</code>和不等运算符<code>!=</code>。</li>
<li>用于推进迭代器位置的前置和后置递增运算符<code>++</code>。</li>
<li>用于读取元素的解引用运算符<code>*</code>；解引用只能出现在赋值运算符右侧。</li>
<li>用于读取元素的箭头运算符<code>-&gt;</code>。</li>
</ul>
</li>
<li>输出迭代器（output iterator）：可以读写序列中的元素，只能用于单遍扫描算法，通常指向目的位置。必须支持以下操作：<ul>
<li>用于推进迭代器位置的前置和后置递增运算符<code>++</code>。</li>
<li>用于读取元素的解引用运算符<code>*</code>；解引用只能出现在赋值运算符左侧（向已经解引用的输出迭代器赋值，等价于将值写入其指向的元素）。</li>
</ul>
</li>
<li>前向迭代器（forward iterator）：可以读写序列中的元素。只能在序列中沿一个方向移动。支持所有输入和输出迭代器的操作，而且可以多次读写同一个元素。因此可以使用前向迭代器对序列进行多遍扫描。</li>
<li>双向迭代器（bidirectional iterator）：可以正向/反向读写序列中的元素。除了支持所有前向迭代器的操作之外，还支持前置和后置递减运算符<code>--</code>。除<code>forward_list</code>之外的其他标准库容器都提供符合双向迭代器要求的迭代器。</li>
<li>随机访问迭代器（random-access iterator）：可以在常量时间内访问序列中的任何元素。除了支持所有双向迭代器的操作之外，还必须支持以下操作：<ul>
<li>用于比较两个迭代器相对位置的关系运算符<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>。</li>
<li>迭代器和一个整数值的加减法运算<code>+</code>、<code>+=</code>、<code>-</code>、<code>-=</code>，计算结果是迭代器在序列中前进或后退给定整数个元素后的位置。</li>
<li>用于两个迭代器上的减法运算符<code>-</code>，计算得到两个迭代器的距离。</li>
<li>下标运算符<code>[]</code>。</li>
</ul>
</li>
</ul>
<h3 id="算法形参模式（Algorithm-Parameter-Patterns）"><a href="#算法形参模式（Algorithm-Parameter-Patterns）" class="headerlink" title="算法形参模式（Algorithm Parameter Patterns）"></a>算法形参模式（Algorithm Parameter Patterns）</h3><p>大多数算法的形参模式是以下四种形式之一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alg</span>(beg, end, other args);</span><br><span class="line"><span class="built_in">alg</span>(beg, end, dest, other args);</span><br><span class="line"><span class="built_in">alg</span>(beg, end, beg2, other args);</span><br><span class="line"><span class="built_in">alg</span>(beg, end, beg2, end2, other args);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个描述指的是STL（标准模板库）中的算法通常采用的四种参数模式。让我们逐一解释这些参数模式：</p>
<ol>
<li><p><code>alg(beg, end, other args);</code>：<br>这种模式是最常见的，其中 <code>alg</code> 是算法的名称，<code>beg</code> 和 <code>end</code> 表示一个范围，通常是指定容器的起始迭代器和结束迭代器。算法将在此范围内操作。<code>other args</code> 表示其他可能需要传递给算法的参数。</p>
</li>
<li><p><code>alg(beg, end, dest, other args);</code>：<br>在这种情况下，除了传递输入范围的起始和结束迭代器外，还传递了目标容器的起始迭代器 <code>dest</code>。算法将结果存储到目标容器中，而不是修改输入范围。<code>other args</code> 表示其他可能需要传递给算法的参数。</p>
</li>
<li><p><code>alg(beg, end, beg2, other args);</code>：<br>在这种情况下，除了传递了输入范围的起始和结束迭代器外，还传递了第二个范围的起始迭代器 <code>beg2</code>。某些算法需要使用两个范围进行操作，例如合并两个有序序列。<code>other args</code> 表示其他可能需要传递给算法的参数。</p>
</li>
<li><p><code>alg(beg, end, beg2, end2, other args);</code>：<br>这种模式类似于第三种模式，不同之处在于它还传递了第二个范围的结束迭代器 <code>end2</code>。这种模式通常用于需要操作两个范围的算法，例如交集、并集等。<code>other args</code> 表示其他可能需要传递给算法的参数。</p>
</li>
</ol>
<p>这些参数模式提供了一种通用的方式来在STL中调用算法，并且能够适应不同的情况和需求。</p>
</blockquote>
<h3 id="算法命名规范（Algorithm-Naming-Conventions）"><a href="#算法命名规范（Algorithm-Naming-Conventions）" class="headerlink" title="算法命名规范（Algorithm Naming Conventions）"></a>算法命名规范（Algorithm Naming Conventions）</h3><p>接受谓词参数的算法都有附加的<code>_if</code>后缀。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg, end, val);       <span class="comment">// find the first instance of val in the input range</span></span><br><span class="line"><span class="built_in">find_if</span>(beg, end, pred);   <span class="comment">// find the first instance for which pred is true</span></span><br></pre></td></tr></table></figure>
<p>将执行结果写入额外目的空间的算法都有<code>_copy</code>后缀。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(beg, end);              <span class="comment">// reverse the elements in the input range</span></span><br><span class="line"><span class="built_in">reverse_copy</span>(beg, end, dest);   <span class="comment">// copy elements in reverse order into dest</span></span><br></pre></td></tr></table></figure>
<p>一些算法同时提供<code>_copy</code>和<code>_if</code>版本。</p>
<h3 id="特定容器算法（Container-Specific-Algorithms）"><a href="#特定容器算法（Container-Specific-Algorithms）" class="headerlink" title="特定容器算法（Container-Specific Algorithms）"></a>特定容器算法（Container-Specific Algorithms）</h3><p>对于<code>list</code>和<code>forward_list</code>类型，应该优先使用成员函数版本的算法，而非通用算法。</p>
<p>链表特有版本的算法操作会改变底层容器。</p>
<hr>
<h2 id="Exception-Handling-A-Deeper-Look"><a href="#Exception-Handling-A-Deeper-Look" class="headerlink" title="Exception Handling: A Deeper Look"></a>Exception Handling: A Deeper Look</h2><blockquote>
<p>异常是程序执行过程中出现问题的指示。异常处理使您能够创建能够解决（或处理）异常的应用程序。在许多情况下，这使得程序能够继续执行，就好像没有遇到任何问题一样。</p>
</blockquote>
<p>异常处理是程序中一种重要的技术，它可以帮助我们在程序运行过程中处理各种错误和异常情况，使程序更加健壮。</p>
<ol>
<li><p><strong>异常类定义</strong>：</p>
<ul>
<li>提供的代码定义了一个自定义的异常类，名为 <code>DivideByZeroException</code>，它是从 <code>std::runtime_error</code> 类派生而来的。</li>
<li>这个异常类表示了试图进行除以零操作的情况。</li>
<li>该类通常包含一个构造函数，用于初始化基类 <code>runtime_error</code> 并传递错误消息。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DivideByZeroException.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DivideByZeroException</span> : <span class="keyword">public</span> std::runtime_error &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">DivideByZeroException</span>() : std::<span class="built_in">runtime_error</span>(<span class="string">&quot;试图除以零&quot;</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数定义</strong>：</p>
<ul>
<li>定义了一个名为 <code>quotient</code> 的函数，用于执行除法操作，并处理除以零的可能性。</li>
<li>这个函数接受两个整数参数，并返回一个双精度浮点数结果。</li>
<li>在执行除法之前，函数会检查分母是否为零，如果是，则抛出一个 <code>DivideByZeroException</code> 异常。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fig17_02.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DivideByZeroException.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">quotient</span><span class="params">(<span class="type">int</span> numerator, <span class="type">int</span> denominator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (denominator == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">DivideByZeroException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(numerator) / denominator;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>主函数中的异常处理</strong>：</p>
<ul>
<li>主函数通过在 <code>try</code> 块中调用 <code>quotient</code> 函数来演示异常处理。</li>
<li>如果发生异常（即除以零），它将被一个专门设计用于处理 <code>DivideByZeroException</code> 的 <code>catch</code> 块捕获。</li>
<li><code>catch</code> 块打印出错信息并提示用户输入新的值。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> num1, num2;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入两个整数：&quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">double</span> result = <span class="built_in">quotient</span>(num1, num2);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;商是：&quot;</span> &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> DivideByZeroException&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;错误：&quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;请重新输入非零的分母。&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>在 C++ 中，<code>e.what()</code> 是异常类的一个成员函数，通常用于返回异常对象的错误消息。在标准异常类 <code>std::exception</code> 中，<code>what()</code> 函数返回一个 C 风格的字符串，该字符串包含了关于异常的描述信息。</p>
<p>在给定的例子中，<code>e.what()</code> 是在 <code>DivideByZeroException</code> 类中调用的，它继承自 <code>std::runtime_error</code>，而后者又继承自 <code>std::exception</code>。因此，<code>e.what()</code> 返回的是 <code>DivideByZeroException</code> 对象中存储的错误消息字符串。</p>
<p>在异常处理中，通常会使用 <code>e.what()</code> 来获取异常的描述信息，并在处理异常的代码块中使用该信息进行适当的处理或输出。</p>
</blockquote>
<ol>
<li><strong>控制流</strong>：<ul>
<li>如果在 <code>try</code> 块中没有发生异常，那么其中的语句将正常执行。</li>
<li>如果发生异常，则控制转移到相应的 <code>catch</code> 块。</li>
<li>处理完异常后，控制流将恢复到最后一个 <code>catch</code> 块后面的语句。</li>
<li>如果没有找到匹配的 <code>catch</code> 块，程序可能会终止，或者尝试在调用函数中找到包含的 <code>try</code> 块（栈展开）。</li>
</ul>
</li>
</ol>
<h3 id="1-资源管理和异常处理："><a href="#1-资源管理和异常处理：" class="headerlink" title="1. 资源管理和异常处理："></a>1. <strong>资源管理和异常处理</strong>：</h3><ul>
<li>当函数使用资源（如文件）时，可能希望在异常发生时释放资源（如关闭文件）。</li>
<li>异常处理程序在接收到异常时，可以释放资源，然后通过 <code>throw;</code> 语句重新抛出异常，通知调用者发生了异常。</li>
<li>无论处理程序是否能够处理异常，都可以通过重新抛出异常进行进一步处理。</li>
<li>下一个封闭的 try 块会检测重新抛出的异常，然后尝试处理该异常的 catch 处理程序列在该封闭 try 块之后。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Assume opening a file</span></span><br><span class="line">    <span class="comment">// If an exception occurs during file processing, we want to close the file</span></span><br><span class="line">    <span class="comment">// before rethrowing the exception</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Processing resource...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Exception occurred during resource processing&quot;</span>);</span><br><span class="line">    <span class="comment">// Assume closing the file</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">processResource</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (...) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught exception in main&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// Rethrow the exception for further processing</span></span><br><span class="line">        <span class="keyword">throw</span>; <span class="comment">// Rethrow the same exception</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>processResource</code> 函数模拟了使用资源（例如文件）的过程。如果在处理资源期间发生异常，我们希望在重新抛出异常之前释放资源。<code>main</code> 函数中的异常处理程序捕获异常，并重新抛出相同的异常以进行进一步处理。</p>
<h3 id="栈展开"><a href="#栈展开" class="headerlink" title="栈展开"></a>栈展开</h3><ol>
<li><p><strong>异常抛出和捕获机制</strong>：</p>
<ul>
<li>当在程序执行过程中抛出异常时，程序会尝试在当前作用域内的 <code>try...catch</code> 块中捕获该异常。</li>
<li>如果没有合适的 <code>try...catch</code> 块来捕获异常，异常会沿着调用栈向上传播，直到遇到能够处理异常的 <code>try...catch</code> 块或者直到达到程序的入口点。</li>
<li>如果在传播过程中遇到了没有被捕获的异常，程序将终止。</li>
</ul>
</li>
<li><p><strong>栈展开</strong>：</p>
<ul>
<li>当异常在一个函数中抛出但未在该函数内被捕获时，会触发栈展开过程。</li>
<li>栈展开意味着异常发生的函数会被“展开”，即函数的执行被中断，函数内的局部变量被销毁，控制权返回到调用该函数的语句处。</li>
<li>然后，程序会尝试在调用函数的上一级作用域中捕获异常，即沿着调用栈向上继续查找 <code>try...catch</code> 块。</li>
<li>如果在调用栈的某个级别找到了合适的 <code>try...catch</code> 块，异常将被捕获并相应处理；否则，栈展开会继续，直到达到程序的入口点或者直到异常被捕获。</li>
</ul>
</li>
</ol>
<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">thirdFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside thirdFunction&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Exception thrown from thirdFunction&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">secondFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside secondFunction&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">thirdFunction</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">firstFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Inside firstFunction&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="built_in">secondFunction</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Inside main&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">firstFunction</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught exception in main: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们有四个函数：<code>main</code>、<code>firstFunction</code>、<code>secondFunction</code> 和 <code>thirdFunction</code>。每个函数都会打印一条消息，以便我们可以了解程序的执行流程。同时，在 <code>thirdFunction</code> 中会抛出一个 <code>std::runtime_error</code> 异常。</p>
<p>当我们运行这段代码时，会发生以下事情：</p>
<ol>
<li><code>main</code> 函数开始执行，打印 “Inside main”。</li>
<li><code>main</code> 调用 <code>firstFunction</code>。</li>
<li><code>firstFunction</code> 打印 “Inside firstFunction”，然后调用 <code>secondFunction</code>。</li>
<li><code>secondFunction</code> 打印 “Inside secondFunction”，然后调用 <code>thirdFunction</code>。</li>
<li><code>thirdFunction</code> 打印 “Inside thirdFunction”，然后抛出一个异常。</li>
<li>异常被抛出，当前函数 <code>thirdFunction</code> 结束执行，它的局部变量被销毁，控制权返回到调用它的函数 <code>secondFunction</code>。</li>
<li><code>secondFunction</code> 没有捕获异常，因此终止执行，它的局部变量被销毁，控制权返回到调用它的函数 <code>firstFunction</code>。</li>
<li><code>firstFunction</code> 没有捕获异常，因此终止执行，它的局部变量被销毁，控制权返回到 <code>main</code> 函数。</li>
<li><code>main</code> 函数的异常处理程序捕获了异常，并打印出错误消息，程序继续执行。</li>
</ol>
<p>因此，程序的打印输出将会是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Inside main</span><br><span class="line">Inside firstFunction</span><br><span class="line">Inside secondFunction</span><br><span class="line">Inside thirdFunction</span><br><span class="line">Caught exception in main: Exception thrown from thirdFunction</span><br></pre></td></tr></table></figure>
<ol>
<li><p><strong>异常处理与软件元素交互</strong>：</p>
<ul>
<li>在一个程序中，各种软件元素（如成员函数、构造函数、析构函数和类）相互交互，执行各种操作。</li>
<li>当这些软件元素执行过程中遇到问题时，它们可能会使用异常来通知程序发生了异常情况，这种情况可能需要程序进行处理。</li>
</ul>
</li>
<li><p><strong>自定义错误处理</strong>：</p>
<ul>
<li>异常处理机制使得程序可以实现自定义的错误处理逻辑。</li>
<li>每个应用程序可能对异常情况的处理方式不同，因此程序员可以根据具体需求编写适合自己应用程序的异常处理代码。</li>
</ul>
</li>
<li><p><strong>预定义组件和应用程序特定组件的交互</strong>：</p>
<ul>
<li>复杂的应用程序通常由预定义的通用组件和特定于应用程序的组件构成。</li>
<li>当预定义组件遇到问题时，它们需要一种机制来通知应用程序特定组件，以便应用程序可以采取适当的行动。</li>
</ul>
</li>
<li><p><strong>C++11中的异常规范说明</strong>：</p>
<ul>
<li>从C++11开始，如果一个函数不会抛出任何异常，并且不会调用任何会抛出异常的函数，应该明确声明该函数不会抛出异常。</li>
<li>这样做可以向客户端程序员明确表示，他们不需要在调用该函数的地方使用try块来捕获异常。</li>
<li>在函数的参数列表后面加上<code>noexcept</code>关键字，表示该函数不会抛出异常。</li>
<li>如果声明了<code>noexcept</code>的函数调用了另一个会抛出异常或执行<code>throw</code>语句的函数，程序将终止。</li>
</ul>
</li>
</ol>
<h3 id="Constructors-Destructors-and-Exception-Handling"><a href="#Constructors-Destructors-and-Exception-Handling" class="headerlink" title="Constructors, Destructors and Exception Handling"></a>Constructors, Destructors and Exception Handling</h3><p>当在构造函数中检测到错误时，对象的构造函数应该如何响应？因为构造函数无法返回值来指示错误，我们必须选择另一种方式来指示对象未正确构造。</p>
<p>一种方案是返回未正确构造的对象，并希望任何使用它的人会进行适当的测试，以确定它处于不一致状态。另一种方案是在构造函数之外设置某些变量。</p>
<p><strong>首选的替代方案是要求构造函数抛出一个包含错误信息的异常，从而为程序提供处理失败的机会。</strong></p>
<p>在构造函数抛出异常之前，会调用构造已完成的任何成员对象的析构函数作为正在构造的对象的一部分。在try块中，会在捕获异常之前调用每个自动对象的析构函数。确保在异常处理程序开始执行时，堆栈展开已经完成。如果由于堆栈展开而调用的析构函数抛出异常，则程序将终止。这已被关联到各种安全攻击。</p>
<p>如果一个对象有成员对象，并且如果在外部对象完全构造之前抛出异常，则将执行已构造的成员对象的析构函数。</p>
<p>如果在异常发生时部分构造了对象数组，则仅调用数组中已构造对象的析构函数。</p>
<p><strong>初始化局部对象以获取资源</strong></p>
<p>异常可能会阻止通常释放资源（如内存或文件）的代码操作，从而导致资源泄漏，阻止其他程序获取资源。解决这个问题的一种技术是初始化局部对象以获取资源。当异常发生时，该对象的析构函数将被调用，并且可以释放资源。</p>
<p>让我们通过一个代码示例来说明这些概念：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Resource</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Resource</span>() &#123;</span><br><span class="line">        <span class="comment">// Simulate resource acquisition</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource acquired&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Resource</span>() &#123;</span><br><span class="line">        <span class="comment">// Simulate resource release</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Resource released&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Resource res;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        <span class="comment">// Simulate constructor error</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Constructor error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MyClass obj; <span class="comment">// Constructor of MyClass throws exception</span></span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::runtime_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// Resource will be automatically released here due to destructor call</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，<code>MyClass</code> 的构造函数抛出了一个 <code>std::runtime_error</code> 异常，模拟了构造函数中的错误情况。当异常抛出时，<code>Resource</code> 类中的析构函数被调用，模拟了资源的释放过程。这样，即使在构造函数中发生了异常，资源也能够得到正确释放，从而避免了资源泄漏。</p>
<h3 id="Exceptions-and-Inheritance"><a href="#Exceptions-and-Inheritance" class="headerlink" title="Exceptions and Inheritance"></a>Exceptions and Inheritance</h3><p>在C++中，可以从一个共同的基类派生多个异常类，这些异常类可能用于不同的错误情况。通过使用继承，我们可以实现对相关异常的多态处理。让我们深入剖析这个概念，并提供一个代码示例来说明。</p>
<p>考虑以下的异常类继承关系：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类异常</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseException</span> : <span class="keyword">public</span> std::exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Base Exception&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生异常类1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedException1</span> : <span class="keyword">public</span> BaseException &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Derived Exception 1&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生异常类2</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DerivedException2</span> : <span class="keyword">public</span> BaseException &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">char</span>* <span class="title">what</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">noexcept</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Derived Exception 2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟抛出 DerivedException1 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">DerivedException1</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> BaseException&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught Base Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 模拟抛出 DerivedException2 异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">DerivedException2</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> BaseException&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Caught Base Exception: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们定义了一个基类异常 <code>BaseException</code>，然后派生了两个异常类 <code>DerivedException1</code> 和 <code>DerivedException2</code>。这两个派生类覆盖了 <code>what()</code> 函数以提供自己的异常信息。</p>
<p>在 <code>main()</code> 函数中，我们模拟了抛出这两种异常，并使用基类异常的引用来捕获它们。由于派生类是从基类继承的，因此基类异常的引用可以捕获任何派生异常的对象。</p>
<p>这种方式允许我们在处理异常时采用多态的方式，即使我们在 <code>catch</code> 块中使用基类异常的引用，我们仍然可以捕获并处理所有相关的派生异常。</p>
<h3 id="Processing-new-Failures"><a href="#Processing-new-Failures" class="headerlink" title="Processing new Failures"></a>Processing new Failures</h3><p>两种处理失败的方式：通过抛出 <code>bad_alloc</code> 异常和通过设置 <code>set_new_handler</code> 函数。</p>
<ol>
<li><strong>new 抛出 bad_alloc 异常</strong>：<ul>
<li>当内存分配失败时，<code>operator new</code> 可能会抛出 <code>bad_alloc</code> 异常，通常发生在内存不足的情况下。</li>
<li>通过 <code>try-catch</code> 机制捕获异常并处理。</li>
<li>下面是一个示例，其中使用 <code>try-catch</code> 来捕获 <code>bad_alloc</code> 异常：</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">            <span class="type">double</span> *ptr = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">50000000</span>];</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Iteration &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">delete</span>[] ptr; <span class="comment">// Release memory</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::bad_alloc&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Exception occurred: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>new 返回 nullptr</strong>：<ul>
<li>C++标准允许使用一个老版本的 <code>new</code>，它在内存分配失败时返回 <code>nullptr</code>。</li>
<li>可以使用 <code>nothrow</code> 参数来使用此版本的 <code>new</code>，如下所示：</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> *ptr = <span class="built_in">new</span> (std::nothrow) <span class="type">double</span>[<span class="number">50000000</span>];</span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Memory allocation successful&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr; <span class="comment">// Release memory</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>使用 <code>set_new_handler</code> 函数处理失败</strong>：<ul>
<li><code>set_new_handler</code> 函数用于设置一个新的内存分配失败处理函数。</li>
<li>如果内存分配失败，而已经注册了新的处理函数，则该处理函数会被调用。</li>
<li>下面是一个示例：</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">customNewHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Memory allocation failed&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::<span class="built_in">abort</span>(); <span class="comment">// Terminate program</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">set_new_handler</span>(customNewHandler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; ++i) &#123;</span><br><span class="line">        <span class="type">double</span> *ptr = <span class="keyword">new</span> <span class="type">double</span>[<span class="number">50000000</span>];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Iteration &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; successful&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">delete</span>[] ptr; <span class="comment">// Release memory</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a><code>unique_ptr</code></h3><p> C++11 中的 <code>unique_ptr</code> 类模板，它是用于管理动态分配内存的智能指针。</p>
<ol>
<li><strong><code>unique_ptr</code> 的基本使用</strong>：<ul>
<li><code>unique_ptr</code> 是一个智能指针，用于管理动态分配的内存。</li>
<li>当 <code>unique_ptr</code> 对象被销毁时（例如，当其超出作用域时），它会自动调用 <code>delete</code> 操作来释放其指向的内存。</li>
<li>可以通过 <code>*</code> 和 <code>-&gt;</code> 运算符来访问 <code>unique_ptr</code> 指向的对象，就像使用原始指针一样。</li>
</ul>
</li>
</ol>
<p>下面是一个示例，演示了如何使用 <code>unique_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Integer</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Integer</span>(<span class="type">int</span> val) : <span class="built_in">value</span>(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Value: &quot;</span> &lt;&lt; value &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;Integer&gt; <span class="title">ptrToInteger</span><span class="params">(<span class="keyword">new</span> Integer(<span class="number">42</span>))</span></span>;</span><br><span class="line">    ptrToInteger-&gt;<span class="built_in">display</span>(); <span class="comment">// Access object via unique_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No need to manually delete ptrToInteger</span></span><br><span class="line">    <span class="comment">// When ptrToInteger goes out of scope, its destructor will automatically release the memory</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个示例中，我们使用 <code>unique_ptr</code> 来管理动态分配的 <code>Integer</code> 对象。当 <code>ptrToInteger</code> 超出作用域时，它的析构函数会自动释放内存。</p>
<ol>
<li><strong><code>unique_ptr</code> 管理动态数组</strong>：<ul>
<li><code>unique_ptr</code> 还可以用于管理动态分配的数组。</li>
<li>当 <code>unique_ptr</code> 管理一个数组时，它会使用 <code>delete []</code> 来释放内存，确保每个数组元素都会调用析构函数。</li>
<li><code>unique_ptr</code> 提供了重载的 <code>[]</code> 运算符，以便访问数组的元素。</li>
</ul>
</li>
</ol>
<p>下面是一个示例，演示了如何使用 <code>unique_ptr</code> 来管理动态数组：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::unique_ptr&lt;std::string[]&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> std::string[<span class="number">10</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">    ptr[<span class="number">2</span>] = <span class="string">&quot;hello&quot;</span>; <span class="comment">// Assign value to array element</span></span><br><span class="line">    std::cout &lt;&lt; ptr[<span class="number">2</span>] &lt;&lt; std::endl; <span class="comment">// Access array element</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// No need to manually delete ptr</span></span><br><span class="line">    <span class="comment">// When ptr goes out of scope, its destructor will automatically release the memory</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h3><p> C++ 标准库中的异常类，包括 <code>runtime_error</code> 和 <code>logic_error</code>，它们各自派生了一系列的异常类，用于指示程序执行过程中可能发生的错误。</p>
<ol>
<li><strong>logic_error 类及其派生类</strong>：<ul>
<li><code>logic_error</code> 类是一系列表示程序逻辑错误的标准异常类的基类。</li>
<li>例如，<code>invalid_argument</code> 类表示函数接收到了无效的参数，通常是因为调用者传递了不合法的参数。</li>
<li>另外，<code>length_error</code> 类表示对象的长度超出了允许的最大大小，<code>out_of_range</code> 类表示值超出了允许的范围。</li>
<li>下面是一个示例，演示了如何使用 <code>invalid_argument</code> 异常类：</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">processInput</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(<span class="string">&quot;Value must be non-negative&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Process the input value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">processInput</span>(<span class="number">-5</span>);</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::invalid_argument&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Invalid argument: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><strong>runtime_error 类及其派生类</strong>：<ul>
<li><code>runtime_error</code> 类是一系列表示程序执行时错误的标准异常类的基类。</li>
<li>例如，<code>overflow_error</code> 类表示算术运算溢出，而 <code>underflow_error</code> 类表示算术运算下溢。</li>
<li>下面是一个示例，演示了如何使用 <code>overflow_error</code> 异常类：</li>
</ul>
</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performArithmeticOperation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Simulating an arithmetic overflow</span></span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">overflow_error</span>(<span class="string">&quot;Arithmetic overflow occurred&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">performArithmeticOperation</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> std::overflow_error&amp; e) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Overflow error: &quot;</span> &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Introduction-to-Custom-Templates"><a href="#Introduction-to-Custom-Templates" class="headerlink" title="Introduction to Custom Templates"></a>Introduction to Custom Templates</h2><h3 id="模板的声明"><a href="#模板的声明" class="headerlink" title="模板的声明"></a>模板的声明</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="function"><span class="type">int</span> <span class="title">compare</span> <span class="params">(T t1, T t2)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">class</span> <span class="title class_">compare</span>;</span><br></pre></td></tr></table></figure>
<h3 id="定义一个模板函数"><a href="#定义一个模板函数" class="headerlink" title="定义一个模板函数"></a>定义一个模板函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">compare</span><span class="params">(T &amp; t1, T &amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1 &gt; t2) </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(t1 == t2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(t1 &lt; t2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义一个模板类"><a href="#定义一个模板类" class="headerlink" title="定义一个模板类"></a>定义一个模板类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">compare</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T _val;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">compare</span><span class="params">(T &amp; val)</span> : _val(val) &#123;</span> &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">compare</span><span class="params">(T &amp;&amp; val)</span> : _val(val) &#123;</span> &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(T &amp; t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _val == t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>模板定义并不是真正的定义了一个函数或者类，而是编译器根据程序员缩写的模板和形参来自己写出一个对应版本的定义，这个过程叫做模板实例化。编译器成成的版本通常被称为模板的实例。编译器为程序员生成对应版本的具体过程。类似宏替换。</p>
<p>模板类在没有调用之前是不会生成代码的。</p>
<p>由于编译器并不会直接编译模板本身，所以模板的定义通常放在头文件中。</p>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123; </span><br><span class="line">  <span class="keyword">private</span>: </span><br><span class="line">    vector&lt;T&gt; elems;     <span class="comment">// 元素 </span></span><br><span class="line"> </span><br><span class="line">  <span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T <span class="type">const</span>&amp;)</span></span>;  <span class="comment">// 入栈</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;               <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> <span class="type">const</span></span>;            <span class="comment">// 返回栈顶元素</span></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="type">const</span></span>&#123;       <span class="comment">// 如果为空则返回真。</span></span><br><span class="line">        <span class="keyword">return</span> elems.<span class="built_in">empty</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span> (T <span class="type">const</span>&amp; elem) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="comment">// 追加传入元素的副本</span></span><br><span class="line">    elems.<span class="built_in">push_back</span>(elem);    </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span> () </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::pop(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后一个元素</span></span><br><span class="line">    elems.<span class="built_in">pop_back</span>();         </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">T Stack&lt;T&gt;::<span class="built_in">top</span> () <span class="type">const</span> </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (elems.<span class="built_in">empty</span>()) &#123; </span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">out_of_range</span>(<span class="string">&quot;Stack&lt;&gt;::top(): empty stack&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回最后一个元素的副本 </span></span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">back</span>();      </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">        Stack&lt;<span class="type">int</span>&gt;         intStack;  <span class="comment">// int 类型的栈 </span></span><br><span class="line">        Stack&lt;string&gt; stringStack;    <span class="comment">// string 类型的栈 </span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 int 类型的栈 </span></span><br><span class="line">        intStack.<span class="built_in">push</span>(<span class="number">7</span>); </span><br><span class="line">        cout &lt;&lt; intStack.<span class="built_in">top</span>() &lt;&lt;endl; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 操作 string 类型的栈 </span></span><br><span class="line">        stringStack.<span class="built_in">push</span>(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line">        cout &lt;&lt; stringStack.<span class="built_in">top</span>() &lt;&lt; std::endl; </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">        stringStack.<span class="built_in">pop</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="built_in">catch</span> (exception <span class="type">const</span>&amp; ex) &#123; </span><br><span class="line">        cerr &lt;&lt; <span class="string">&quot;Exception: &quot;</span> &lt;&lt; ex.<span class="built_in">what</span>() &lt;&lt;endl; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.totorocatcat.top/">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/2024/06/08/C-ppt%E5%A4%8D%E4%B9%A0/">http://totorocatcat.top/2024/06/08/C-ppt%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%89%E8%B6%A3/">有趣</a></div><div class="post_share"><div class="social-share" data-image="https://p4.qhimg.com/bdr/__85/t01d5b63058c5beaba1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/07/02/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B95/" title="牛客小白月赛95"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p4.qhimg.com/bdr/__85/t01f3f121122fcba272.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">牛客小白月赛95</div></div></a></div><div class="next-post pull-right"><a href="/2024/06/03/C-%E7%BB%83%E4%B9%A0%E9%A2%983/" title="C++练习题3"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/%E5%9B%BE%E5%8C%85webp/%E5%8A%A8%E6%BC%AB%E7%BB%BC%E5%90%881/73207-106.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++练习题3</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/01/C-%E5%85%AB%E8%82%A1/" title="C++八股"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.likepoems.com/resource/pc/b702fcf4480034312d58d6f56e30d7624.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-01</div><div class="title">C++八股</div></div></a></div><div><a href="/2024/06/03/C-%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%882%EF%BC%89/" title="C++练习题2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.51/img_513_1920x1080_72_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-03</div><div class="title">C++练习题2</div></div></a></div><div><a href="/2024/05/31/C-%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95-1/" title="C++期末考试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/%E5%9B%BE%E5%8C%85webp/%E5%8A%A8%E6%BC%AB%E7%BB%BC%E5%90%881/86815-106.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-31</div><div class="title">C++期末考试</div></div></a></div><div><a href="/2024/05/31/C-%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/" title="C++期末考试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.likepoems.com/resource/pc/68e21cc80a435c28fdf4c47e4652ebc17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-31</div><div class="title">C++期末考试</div></div></a></div><div><a href="/2024/06/03/C-%E7%BB%83%E4%B9%A0%E9%A2%983/" title="C++练习题3"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/%E5%9B%BE%E5%8C%85webp/%E5%8A%A8%E6%BC%AB%E7%BB%BC%E5%90%881/73207-106.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-03</div><div class="title">C++练习题3</div></div></a></div><div><a href="/2024/06/02/C-%E9%80%89%E6%8B%A9%E9%A2%98%E5%8A%A0%E8%AE%AD/" title="C++选择题加训"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.37/img_371_3840x2160_72_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-02</div><div class="title">C++选择题加训</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description">敲代码的SCUT学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">707</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#C-PPT"><span class="toc-number">1.</span> <span class="toc-text">C++PPT</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-to-C"><span class="toc-number">1.1.</span> <span class="toc-text">Introduction to C++</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Importance-of-C"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">Importance of C++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Computing-Power"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">Computing Power</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Software-Development"><span class="toc-number">1.1.0.3.</span> <span class="toc-text">Software Development</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Computer-Organization"><span class="toc-number">1.1.0.4.</span> <span class="toc-text">Computer Organization</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Programming-Languages"><span class="toc-number">1.1.0.5.</span> <span class="toc-text">Programming Languages</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Evolution-of-C"><span class="toc-number">1.1.0.6.</span> <span class="toc-text">Evolution of C++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-Standard-Library"><span class="toc-number">1.1.0.7.</span> <span class="toc-text">C++ Standard Library</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-Oriented-Programming-Concepts"><span class="toc-number">1.1.0.8.</span> <span class="toc-text">Object-Oriented Programming Concepts</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Programming-Phases-in-C"><span class="toc-number">1.1.0.9.</span> <span class="toc-text">Programming Phases in C++</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Integrated-Development-Environments-IDEs"><span class="toc-number">1.1.0.10.</span> <span class="toc-text">Integrated Development Environments (IDEs)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Challenges"><span class="toc-number">1.1.0.11.</span> <span class="toc-text">Challenges</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Key-Takeaways"><span class="toc-number">1.1.1.</span> <span class="toc-text">Key Takeaways</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-Programming-Basics-Key-Concepts-from-the-Presentation"><span class="toc-number">1.2.</span> <span class="toc-text">C++ Programming Basics: Key Concepts from the Presentation</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Comments"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">Comments</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Preprocessing-Directives"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">Preprocessing Directives</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Whitespace"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">Whitespace</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#The-main-Function"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">The main Function</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Basic-Syntax"><span class="toc-number">1.2.0.5.</span> <span class="toc-text">Basic Syntax</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.0.6.</span> <span class="toc-text">基本语法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Input-and-Output"><span class="toc-number">1.2.0.7.</span> <span class="toc-text">Input and Output</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Variables-and-Data-Types"><span class="toc-number">1.2.0.8.</span> <span class="toc-text">Variables and Data Types</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Arithmetic-Operations"><span class="toc-number">1.2.0.9.</span> <span class="toc-text">Arithmetic Operations</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Control-Structures"><span class="toc-number">1.2.0.10.</span> <span class="toc-text">Control Structures</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Example-Programs"><span class="toc-number">1.2.0.11.</span> <span class="toc-text">Example Programs</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Additional-Concepts"><span class="toc-number">1.2.0.12.</span> <span class="toc-text">Additional Concepts</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-to-Classes-Objects"><span class="toc-number">1.3.</span> <span class="toc-text">Introduction to Classes Objects</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Control-Statements"><span class="toc-number">2.</span> <span class="toc-text">Control Statements</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Logic-Operations"><span class="toc-number">2.1.</span> <span class="toc-text">Logic Operations</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Functions-and-an-Introduction-to-Recursion"><span class="toc-number">2.2.</span> <span class="toc-text">Functions and an  Introduction to Recursion</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.2.1.</span> <span class="toc-text">C++ 中的枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9E%9A%E4%B8%BE"><span class="toc-number">2.2.2.</span> <span class="toc-text">基本枚举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%9E%9A%E4%B8%BE%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.3.</span> <span class="toc-text">基本枚举示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E4%BA%88%E8%87%AA%E5%AE%9A%E4%B9%89%E5%80%BC"><span class="toc-number">2.2.4.</span> <span class="toc-text">赋予自定义值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9E%9A%E4%B8%BE%EF%BC%88C-11%EF%BC%89"><span class="toc-number">2.2.5.</span> <span class="toc-text">作用域枚举（C++11）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9E%9A%E4%B8%BE%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.6.</span> <span class="toc-text">作用域枚举示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E5%AE%9A%E6%9E%9A%E4%B8%BE%E5%B8%B8%E9%87%8F%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.7.</span> <span class="toc-text">指定枚举常量的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%8C%87%E5%AE%9A%E7%B1%BB%E5%9E%8B%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9E%9A%E4%B8%BE%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.8.</span> <span class="toc-text">带指定类型的作用域枚举示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.9.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E6%9C%89%E6%B7%B7%E5%90%88%E7%B1%BB%E5%9E%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.2.10.</span> <span class="toc-text">带有混合类型表达式的枚举示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E7%9A%84%E5%BC%95%E6%93%8E%E5%92%8C%E5%88%86%E5%B8%83"><span class="toc-number">2.2.11.</span> <span class="toc-text">随机数生成的引擎和分布</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">2.2.12.</span> <span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A"><span class="toc-number">2.2.13.</span> <span class="toc-text">代码解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E9%93%BE%E6%8E%A5"><span class="toc-number">2.2.14.</span> <span class="toc-text">C++中的存储持续时间、作用域和链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%EF%BC%88Storage-Duration%EF%BC%89"><span class="toc-number">2.2.15.</span> <span class="toc-text">存储持续时间（Storage Duration）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E8%87%AA%E5%8A%A8%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%EF%BC%88Local-Variables-and-Automatic-Storage-Duration%EF%BC%89"><span class="toc-number">2.2.15.1.</span> <span class="toc-text">局部变量和自动存储持续时间（Local Variables and Automatic Storage Duration）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-1"><span class="toc-number">2.2.15.1.1.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%8F%98%E9%87%8F%EF%BC%88Register-Variables%EF%BC%89"><span class="toc-number">2.2.15.2.</span> <span class="toc-text">寄存器变量（Register Variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-2"><span class="toc-number">2.2.15.2.1.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%EF%BC%88Static-Storage-Duration%EF%BC%89"><span class="toc-number">2.2.15.3.</span> <span class="toc-text">静态存储持续时间（Static Storage Duration）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B7%E6%9C%89%E9%9D%99%E6%80%81%E5%AD%98%E5%82%A8%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6%EF%BC%88Identifiers-with-Static-Storage-Duration%EF%BC%89"><span class="toc-number">2.2.15.3.1.</span> <span class="toc-text">具有静态存储持续时间的标识符（Identifiers with Static Storage Duration）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%EF%BC%88static-Local-Variables%EF%BC%89"><span class="toc-number">2.2.15.4.</span> <span class="toc-text">静态局部变量（static Local Variables）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-3"><span class="toc-number">2.2.15.4.1.</span> <span class="toc-text">示例代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Scope%EF%BC%89"><span class="toc-number">2.2.16.</span> <span class="toc-text">作用域（Scope）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%97%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Block-Scope%EF%BC%89"><span class="toc-number">2.2.17.</span> <span class="toc-text">块作用域（Block Scope）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-4"><span class="toc-number">2.2.17.1.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Function-Scope%EF%BC%89"><span class="toc-number">2.2.18.</span> <span class="toc-text">函数作用域（Function Scope）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-5"><span class="toc-number">2.2.18.1.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Global-Namespace-Scope%EF%BC%89"><span class="toc-number">2.2.19.</span> <span class="toc-text">全局命名空间作用域（Global Namespace Scope）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-6"><span class="toc-number">2.2.19.1.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%8E%9F%E5%9E%8B%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88Function-Prototype-Scope%EF%BC%89"><span class="toc-number">2.2.20.</span> <span class="toc-text">函数原型作用域（Function-Prototype Scope）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-7"><span class="toc-number">2.2.20.1.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%BC%94%E7%A4%BA"><span class="toc-number">2.2.21.</span> <span class="toc-text">作用域演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-1"><span class="toc-number">2.2.22.</span> <span class="toc-text">代码解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%EF%BC%88Linkage%EF%BC%89"><span class="toc-number">2.2.23.</span> <span class="toc-text">链接（Linkage）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%85%B7%E4%BD%93%E8%A7%A3%E9%87%8A"><span class="toc-number">2.2.24.</span> <span class="toc-text">链接类型的具体解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E9%93%BE%E6%8E%A5%EF%BC%88No-Linkage%EF%BC%89"><span class="toc-number">2.2.24.1.</span> <span class="toc-text">无链接（No Linkage）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5%EF%BC%88Internal-Linkage%EF%BC%89"><span class="toc-number">2.2.24.2.</span> <span class="toc-text">内部链接（Internal Linkage）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E9%93%BE%E6%8E%A5%EF%BC%88External-Linkage%EF%BC%89"><span class="toc-number">2.2.24.3.</span> <span class="toc-text">外部链接（External Linkage）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">2.2.25.</span> <span class="toc-text">链接类型的总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%A7%A3C-%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88"><span class="toc-number">2.2.26.</span> <span class="toc-text">理解C++中的函数调用机制：函数调用栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E6%A0%88%EF%BC%88Function-Call-Stack%EF%BC%89"><span class="toc-number">2.2.27.</span> <span class="toc-text">函数调用栈（Function-Call Stack）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%B8%A7%EF%BC%88Stack-Frames%EF%BC%89"><span class="toc-number">2.2.27.1.</span> <span class="toc-text">栈帧（Stack Frames）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8F%98%E9%87%8F%E5%92%8C%E6%A0%88%E5%B8%A7%EF%BC%88Automatic-Variables-and-Stack-Frames%EF%BC%89"><span class="toc-number">2.2.27.2.</span> <span class="toc-text">自动变量和栈帧（Automatic Variables and Stack Frames）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E6%BA%A2%E5%87%BA%EF%BC%88Stack-Overflow%EF%BC%89"><span class="toc-number">2.2.27.3.</span> <span class="toc-text">栈溢出（Stack Overflow）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%E5%92%8C%E8%A7%A3%E9%87%8A"><span class="toc-number">2.2.28.</span> <span class="toc-text">示例代码和解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-2"><span class="toc-number">2.2.28.1.</span> <span class="toc-text">代码解释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E5%87%BD%E6%95%B0%E4%B8%8E%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.29.</span> <span class="toc-text">C++ 函数与参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E5%8F%82%E6%95%B0%E5%88%97%E8%A1%A8"><span class="toc-number">2.2.29.1.</span> <span class="toc-text">空参数列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.29.2.</span> <span class="toc-text">内联函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.29.3.</span> <span class="toc-text">向函数传递参数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%86%85%E4%BD%9C%E4%B8%BA%E5%88%AB%E5%90%8D%E7%9A%84%E5%BC%95%E7%94%A8"><span class="toc-number">2.2.30.</span> <span class="toc-text">函数内作为别名的引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%BC%95%E7%94%A8"><span class="toc-number">2.2.31.</span> <span class="toc-text">从函数返回引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.2.32.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.33.</span> <span class="toc-text">默认参数和作用域解析运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.33.1.</span> <span class="toc-text">默认参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-number">2.2.33.1.1.</span> <span class="toc-text">使用默认参数的规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%AE%A1%E7%AE%97%E7%9B%92%E5%AD%90%E7%9A%84%E4%BD%93%E7%A7%AF"><span class="toc-number">2.2.33.1.2.</span> <span class="toc-text">示例：计算盒子的体积</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%A3%E6%9E%90%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.2.33.2.</span> <span class="toc-text">作用域解析运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-%E8%AE%BF%E9%97%AE%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">2.2.33.2.1.</span> <span class="toc-text">使用 :: 访问全局变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%90%8C%E5%90%8D"><span class="toc-number">2.2.33.2.2.</span> <span class="toc-text">示例：局部变量和全局变量同名</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">2.2.34.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">2.2.35.</span> <span class="toc-text">函数重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.35.1.</span> <span class="toc-text">如何区分重载函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E8%AE%A1%E7%AE%97%E5%B9%B3%E6%96%B9"><span class="toc-number">2.2.35.2.</span> <span class="toc-text">示例：使用函数重载计算平方</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">2.2.36.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.2.37.</span> <span class="toc-text">函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.2.37.1.</span> <span class="toc-text">定义函数模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%BD%AE%EF%BC%88%E8%BF%99%E4%B8%AA%E4%B9%9F%E6%98%AF%E4%B8%80%E4%B8%AA%E6%9C%AA%E7%9F%A5%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%89"><span class="toc-number">2.2.37.2.</span> <span class="toc-text">返回类型后置（这个也是一个未知知识点）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">2.2.37.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">2.2.38.</span> <span class="toc-text">递归的特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B6%E4%B9%98%E7%9A%84%E9%80%92%E5%BD%92%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">2.2.39.</span> <span class="toc-text">阶乘的递归定义：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A"><span class="toc-number">2.2.40.</span> <span class="toc-text">示例代码：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Class-Templates-array-and-vector-Catching-Exceptions"><span class="toc-number">2.3.</span> <span class="toc-text">Class Templates array and vector; Catching Exceptions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Astd-array"><span class="toc-number">2.3.1.</span> <span class="toc-text">数据结构：std::array</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">定义和声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.1.3.</span> <span class="toc-text">常用操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-8"><span class="toc-number">2.3.1.4.</span> <span class="toc-text">示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E6%95%B0%E7%BB%84%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.3.2.</span> <span class="toc-text">静态局部数组的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-9"><span class="toc-number">2.3.3.</span> <span class="toc-text">示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1-%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E6%95%B0%E7%BB%84%E7%9A%84%E9%9B%B6%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.3.3.1.</span> <span class="toc-text">示例 1: 静态局部数组的零初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2-%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E6%95%B0%E7%BB%84%E7%9A%84%E6%98%BE%E5%BC%8F%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.3.3.2.</span> <span class="toc-text">示例 2: 静态局部数组的显式初始化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3-%E9%9D%99%E6%80%81%E5%B1%80%E9%83%A8%E6%95%B0%E7%BB%84%E7%9A%84%E5%80%BC%E4%BF%9D%E6%8C%81"><span class="toc-number">2.3.3.3.</span> <span class="toc-text">示例 3: 静态局部数组的值保持</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E5%9F%BA%E4%BA%8E%E8%8C%83%E5%9B%B4%E7%9A%84for%E8%AF%AD%E5%8F%A5%E5%92%8C%E6%95%B0%E7%BB%84%E5%A4%84%E7%90%86-Range-Based-for-Statement"><span class="toc-number">2.3.4.</span> <span class="toc-text">范围基于范围的for语句和数组处理(Range-Based for Statement )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">2.3.4.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-10"><span class="toc-number">2.3.4.2.</span> <span class="toc-text">示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4%E5%9F%BA%E4%BA%8Efor%E8%AF%AD%E5%8F%A5%E6%98%BE%E7%A4%BA%E6%95%B0%E7%BB%84%E5%86%85%E5%AE%B9"><span class="toc-number">2.3.4.2.1.</span> <span class="toc-text">示例 1：使用范围基于for语句显示数组内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4%E5%9F%BA%E4%BA%8Efor%E8%AF%AD%E5%8F%A5%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E5%86%85%E5%AE%B9"><span class="toc-number">2.3.4.2.2.</span> <span class="toc-text">示例 2：使用范围基于for语句修改数组内容</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3%EF%BC%9A%E4%BD%BF%E7%94%A8%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.4.2.3.</span> <span class="toc-text">示例 3：使用下标访问数组元素</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">2.3.5.</span> <span class="toc-text">静态数据成员</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-1"><span class="toc-number">2.3.5.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-11"><span class="toc-number">2.3.5.2.</span> <span class="toc-text">示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1%EF%BC%9A%E9%9D%99%E6%80%81%E5%B8%B8%E9%87%8F%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">2.3.5.2.1.</span> <span class="toc-text">示例 1：静态常量数据成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2%EF%BC%9A%E5%85%AC%E5%85%B1%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE"><span class="toc-number">2.3.5.2.2.</span> <span class="toc-text">示例 2：公共静态数据成员的访问</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">2.3.6.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8C-%E6%A0%87%E5%87%86%E5%BA%93%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">2.3.7.</span> <span class="toc-text">使用C++标准库进行排序和二分查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-2"><span class="toc-number">2.3.7.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-12"><span class="toc-number">2.3.7.2.</span> <span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA"><span class="toc-number">2.3.7.3.</span> <span class="toc-text">输出</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA%E8%A1%A8%E6%A0%BC%E6%95%B0%E6%8D%AE"><span class="toc-number">2.3.8.</span> <span class="toc-text">使用二维数组表示表格数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-3"><span class="toc-number">2.3.8.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-13"><span class="toc-number">2.3.8.2.</span> <span class="toc-text">示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-array-%E6%A8%A1%E6%9D%BF%E5%88%9D%E5%A7%8B%E5%8C%96%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.8.2.1.</span> <span class="toc-text">使用 array 模板初始化二维数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A"><span class="toc-number">2.3.8.3.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.3.8.4.</span> <span class="toc-text">进一步的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81%EF%BC%9A%E5%AD%98%E5%82%A8%E5%AD%A6%E7%94%9F%E6%88%90%E7%BB%A9%E7%9A%84%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.8.4.1.</span> <span class="toc-text">示例代码：存储学生成绩的二维数组</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-1"><span class="toc-number">2.3.8.5.</span> <span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%A0%87%E5%87%86%E5%BA%93%E6%A8%A1%E6%9D%BF%E7%B1%BB-vector"><span class="toc-number">2.3.9.</span> <span class="toc-text">C++ 标准库模板类 vector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9F%A5%E8%AF%86%E7%82%B9-4"><span class="toc-number">2.3.9.1.</span> <span class="toc-text">知识点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-14"><span class="toc-number">2.3.9.2.</span> <span class="toc-text">示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-vector-%E7%9A%84%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">2.3.9.2.1.</span> <span class="toc-text">使用 vector 的示例代码</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-2"><span class="toc-number">2.3.9.3.</span> <span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">2.3.10.</span> <span class="toc-text">指针的基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%8C%87%E9%92%88%E7%AE%80%E4%BB%8B"><span class="toc-number">2.3.10.1.</span> <span class="toc-text">1. 指针简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88"><span class="toc-number">2.3.10.2.</span> <span class="toc-text">2. 何时使用指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%97%B4%E6%8E%A5%E5%BC%95%E7%94%A8%EF%BC%88Indirection%EF%BC%89"><span class="toc-number">2.3.10.3.</span> <span class="toc-text">3. 间接引用（Indirection）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%A9%BA%E6%8C%87%E9%92%88%EF%BC%88Null-Pointers%EF%BC%89"><span class="toc-number">2.3.10.4.</span> <span class="toc-text">4. 空指针（Null Pointers）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-amp-%EF%BC%89"><span class="toc-number">2.3.10.5.</span> <span class="toc-text">5. 地址运算符（&amp;）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-15"><span class="toc-number">2.3.11.</span> <span class="toc-text">示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%9F%BA%E7%A1%80%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.11.1.</span> <span class="toc-text">指针基础示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E6%8C%87%E9%92%88%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.11.2.</span> <span class="toc-text">空指针示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%B8%8E%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.11.3.</span> <span class="toc-text">指针与数组的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-3"><span class="toc-number">2.3.12.</span> <span class="toc-text">解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%9C%B0%E5%9D%80%E8%BF%90%E7%AE%97%E7%AC%A6%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.13.</span> <span class="toc-text">指针和地址运算符示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.13.1.</span> <span class="toc-text">间接引用运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.3.13.2.</span> <span class="toc-text">示例程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A-4"><span class="toc-number">2.3.13.3.</span> <span class="toc-text">解释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%BC%A0%E9%80%92%E7%9A%84%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92"><span class="toc-number">2.3.14.</span> <span class="toc-text">指针传递的引用传递</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%95%E8%A8%80"><span class="toc-number">2.3.14.1.</span> <span class="toc-text">1. 引言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.14.2.</span> <span class="toc-text">2. 引用传递示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">2.3.14.3.</span> <span class="toc-text">3. 示例代码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.15.</span> <span class="toc-text">内置数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A3%B0%E6%98%8E%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.15.1.</span> <span class="toc-text">1. 声明内置数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0"><span class="toc-number">2.3.15.2.</span> <span class="toc-text">2. 访问内置数组的元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%9D%E5%A7%8B%E5%8C%96%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84"><span class="toc-number">2.3.15.3.</span> <span class="toc-text">3. 初始化内置数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">2.3.15.4.</span> <span class="toc-text">4. 内置数组的参数传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%A3%B0%E6%98%8E%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84%E5%8F%82%E6%95%B0"><span class="toc-number">2.3.15.5.</span> <span class="toc-text">5. 声明内置数组参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-C-11%EF%BC%9A%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0-begin-%E5%92%8C-end"><span class="toc-number">2.3.15.6.</span> <span class="toc-text">6. C++11：标准库函数 begin 和 end</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">2.3.15.7.</span> <span class="toc-text">7. 内置数组的局限性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E6%9D%83%E9%99%90%E5%8E%9F%E5%88%99"><span class="toc-number">2.3.16.</span> <span class="toc-text">最小权限原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E5%87%BD%E6%95%B0%E4%BC%A0%E9%80%92%E6%8C%87%E9%92%88%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.3.17.</span> <span class="toc-text">向函数传递指针的四种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E6%BC%94%E7%A4%BA"><span class="toc-number">2.3.18.</span> <span class="toc-text">示例演示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sizeof-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.3.19.</span> <span class="toc-text">sizeof 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84%E7%9A%84%E5%85%83%E7%B4%A0%E6%95%B0%E9%87%8F"><span class="toc-number">2.3.20.</span> <span class="toc-text">计算内置数组的元素数量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-16"><span class="toc-number">2.3.21.</span> <span class="toc-text">示例代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%BE%93%E5%87%BA"><span class="toc-number">2.3.22.</span> <span class="toc-text">示例输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.3.23.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97"><span class="toc-number">2.3.24.</span> <span class="toc-text">指针算术运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">2.3.25.</span> <span class="toc-text">示例说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E5%92%8Cvoid-%E6%8C%87%E9%92%88"><span class="toc-number">2.3.26.</span> <span class="toc-text">指针赋值和void*指针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC"><span class="toc-number">2.3.26.1.</span> <span class="toc-text">指针赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.3.26.2.</span> <span class="toc-text">强制转换操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E5%90%91void%E7%9A%84%E6%8C%87%E9%92%88"><span class="toc-number">2.3.26.3.</span> <span class="toc-text">指向void的指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%AF%B4%E6%98%8E-1"><span class="toc-number">2.3.26.4.</span> <span class="toc-text">示例说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-1"><span class="toc-number">2.3.27.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E7%9A%84%E6%9B%B4%E5%A4%9A%E8%80%83%E8%99%91"><span class="toc-number">2.3.28.</span> <span class="toc-text">指针赋值的更多考虑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">2.3.28.1.</span> <span class="toc-text">指针赋值的安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E8%B5%8B%E5%80%BC%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="toc-number">2.3.28.2.</span> <span class="toc-text">指针赋值的语义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#void-%E6%8C%87%E9%92%88%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%94%A8%E9%80%94"><span class="toc-number">2.3.29.</span> <span class="toc-text">void*指针的更多用途</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">2.3.29.1.</span> <span class="toc-text">泛型编程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%AF%94%E8%BE%83"><span class="toc-number">2.3.30.</span> <span class="toc-text">指针比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.3.31.</span> <span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-2"><span class="toc-number">2.3.32.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82"><span class="toc-number">2.3.33.</span> <span class="toc-text">C字符串。</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Classes-A-Deeper-Look-Throwing-Exceptions"><span class="toc-number">2.4.</span> <span class="toc-text">Classes: A Deeper Look; Throwing Exceptions</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E5%A4%B4%E6%96%87%E4%BB%B6%E8%A2%AB%E9%87%8D%E5%A4%8D%E5%8C%85%E5%90%AB"><span class="toc-number">2.4.1.</span> <span class="toc-text">防止头文件被重复包含</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%A4%96%E9%83%A8%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%EF%BC%9B%E7%B1%BB%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">2.4.2.</span> <span class="toc-text">定义类外部的成员函数；类作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.4.3.</span> <span class="toc-text">对象大小</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Class-Scope-and-Block-Scope"><span class="toc-number">2.4.4.</span> <span class="toc-text">Class Scope and Block Scope:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Dot-and-Arrow-gt-Member-Selection-Operators"><span class="toc-number">2.4.5.</span> <span class="toc-text">Dot (.) and Arrow (-&gt;) Member Selection Operators:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Accessing-public-Class-Members-Through-Objects-References-and-Pointers"><span class="toc-number">2.4.6.</span> <span class="toc-text">Accessing public Class Members Through Objects, References and Pointers:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Access-Functions"><span class="toc-number">2.4.7.</span> <span class="toc-text">Access Functions:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Utility-Functions"><span class="toc-number">2.4.8.</span> <span class="toc-text">Utility Functions:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">2.4.9.</span> <span class="toc-text">访问函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">2.4.10.</span> <span class="toc-text">实用函数：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0-1"><span class="toc-number">2.4.11.</span> <span class="toc-text">默认参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%EF%BC%9A"><span class="toc-number">2.4.12.</span> <span class="toc-text">列表初始化器：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E7%9A%84%E8%B5%8B%E5%80%BC%E6%93%8D%E4%BD%9C%E5%92%8C%E6%8B%B7%E8%B4%9D%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">2.4.13.</span> <span class="toc-text">关于对象之间的赋值操作和拷贝问题：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Const"><span class="toc-number">2.4.14.</span> <span class="toc-text">Const</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%85%E8%B0%88%E4%B8%80%E4%B8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BB%BA%E8%AE%AE%E5%A4%9A%E7%94%A8%E7%BB%84%E5%90%88%E5%B0%91%E7%94%A8%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="toc-number">2.4.15.</span> <span class="toc-text">浅谈一下设计模式中为什么建议多用组合少用继承：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.4.16.</span> <span class="toc-text">友元函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">2.4.17.</span> <span class="toc-text">this指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static-Class-Members"><span class="toc-number">2.4.18.</span> <span class="toc-text">static Class Members</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Operator-Overloading-Class-string"><span class="toc-number">2.5.</span> <span class="toc-text">Operator Overloading; Class string</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Estring%E7%9A%84%E4%B8%80%E4%BA%9B%E9%87%8D%E8%BD%BD"><span class="toc-number">2.5.1.</span> <span class="toc-text">关于string的一些重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD"><span class="toc-number">2.5.2.</span> <span class="toc-text">重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.5.3.</span> <span class="toc-text">一元运算符重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%8F%96%E5%8F%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="toc-number">2.5.4.</span> <span class="toc-text">非成员函数重载取反运算符：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD%E5%8F%96%E5%8F%8D%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%9A"><span class="toc-number">2.5.5.</span> <span class="toc-text">成员函数重载取反运算符：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%89%8D%E7%BC%80%E5%92%8C%E5%90%8E%E7%BC%80%E7%9A%84%E9%80%92%E5%A2%9E%E5%92%8C%E9%80%92%E5%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">2.5.6.</span> <span class="toc-text">重载前缀和后缀的递增和递减运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%89%8D%E7%BC%80%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6-i-%EF%BC%9A"><span class="toc-number">2.5.7.</span> <span class="toc-text">重载前缀递增运算符 (++i)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%90%8E%E7%BC%80%E9%80%92%E5%A2%9E%E8%BF%90%E7%AE%97%E7%AC%A6-i-%EF%BC%9A"><span class="toc-number">2.5.8.</span> <span class="toc-text">重载后缀递增运算符 (i++)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E9%94%99%EF%BC%9A"><span class="toc-number">2.5.9.</span> <span class="toc-text">为什么会出错：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">2.5.10.</span> <span class="toc-text">示例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9A"><span class="toc-number">2.5.11.</span> <span class="toc-text">如何避免：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-new-%E5%88%86%E9%85%8D%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%EF%BC%9A"><span class="toc-number">2.5.12.</span> <span class="toc-text">使用 new 分配动态内存：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-delete-%E9%87%8A%E6%94%BE%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%EF%BC%9A"><span class="toc-number">2.5.13.</span> <span class="toc-text">使用 delete 释放动态内存：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E6%95%B0%E7%BB%84%EF%BC%9A"><span class="toc-number">2.5.14.</span> <span class="toc-text">动态分配数组：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-delete-%E9%87%8A%E6%94%BE%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D%E7%9A%84%E6%95%B0%E7%BB%84%EF%BC%9A"><span class="toc-number">2.5.15.</span> <span class="toc-text">使用 delete[] 释放动态分配的数组：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-11-%E4%B8%AD%E7%9A%84-unique-ptr%EF%BC%9A"><span class="toc-number">2.5.16.</span> <span class="toc-text">C++11 中的 unique_ptr：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Array%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.5.17.</span> <span class="toc-text">Array类的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%A7%A3%E9%87%8A-3"><span class="toc-number">2.5.18.</span> <span class="toc-text">代码解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E4%B8%8E%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%E8%AF%A6%E7%BB%86%E7%AC%94%E8%AE%B0"><span class="toc-number">2.5.19.</span> <span class="toc-text">类型转换与转换运算符详细笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.5.19.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.19.2.</span> <span class="toc-text">转换构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Cast-Operators%EF%BC%89"><span class="toc-number">2.5.19.3.</span> <span class="toc-text">转换运算符（Cast Operators）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E8%BD%AC%E6%8D%A2%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E9%9A%90%E5%BC%8F%E8%B0%83%E7%94%A8"><span class="toc-number">2.5.19.4.</span> <span class="toc-text">转换构造函数与转换运算符的隐式调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">2.5.20.</span> <span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.5.20.1.</span> <span class="toc-text">详细示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%8F%AF%E8%83%BD%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.21.</span> <span class="toc-text">隐式转换可能引发的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%AF%BC%E8%87%B4%E7%9A%84%E7%BC%96%E8%AF%91%E9%94%99%E8%AF%AF"><span class="toc-number">2.5.21.1.</span> <span class="toc-text">隐式转换导致的编译错误</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%AF%BC%E8%87%B4%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E9%80%BB%E8%BE%91%E9%94%99%E8%AF%AF"><span class="toc-number">2.5.21.2.</span> <span class="toc-text">隐式转换导致的运行时逻辑错误</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E9%97%AE%E9%A2%98%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.22.</span> <span class="toc-text">避免隐式转换问题的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-6"><span class="toc-number">2.5.23.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88%EF%BC%89"><span class="toc-number">2.5.24.</span> <span class="toc-text">重载函数调用运算符（）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%A5%E9%80%89%E5%8F%96%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">2.5.24.1.</span> <span class="toc-text">示例：重载函数调用运算符以选取子字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">2.5.24.1.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">2.5.24.1.2.</span> <span class="toc-text">使用：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BB%A5%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%8B%E6%A0%87%E8%AE%BF%E9%97%AE"><span class="toc-number">2.5.24.2.</span> <span class="toc-text">示例：重载函数调用运算符以实现二维数组的下标访问</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A-1"><span class="toc-number">2.5.24.2.1.</span> <span class="toc-text">定义：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%EF%BC%9A-1"><span class="toc-number">2.5.24.2.2.</span> <span class="toc-text">使用：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-Oriented-Programming-Inheritance"><span class="toc-number">2.6.</span> <span class="toc-text">Object-Oriented Programming: Inheritance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%85%B3%E7%B3%BB"><span class="toc-number">2.6.1.</span> <span class="toc-text">继承与关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#is-a-%E5%92%8C-has-a-%E5%85%B3%E7%B3%BB"><span class="toc-number">2.6.1.1.</span> <span class="toc-text">is-a 和 has-a 关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.6.2.</span> <span class="toc-text">继承的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.6.3.</span> <span class="toc-text">C++ 中的继承类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">2.6.4.</span> <span class="toc-text">继承的层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.6.4.1.</span> <span class="toc-text">继承关系示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9B%BE%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.6.5.</span> <span class="toc-text">类图示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%91%98%E5%B7%A5%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB"><span class="toc-number">2.6.6.</span> <span class="toc-text">示例：员工类的继承关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8F%97%E4%BF%9D%E6%8A%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">2.6.7.</span> <span class="toc-text">使用受保护数据的注意事项：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%EF%BC%9A"><span class="toc-number">2.6.8.</span> <span class="toc-text">派生类对象的构造和析构过程：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">2.6.8.1.</span> <span class="toc-text">代码示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-11%E4%B8%AD%E7%9A%84%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%BB%A7%E6%89%BF%EF%BC%9A"><span class="toc-number">2.6.9.</span> <span class="toc-text">C++11中的基类构造函数继承：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">2.6.10.</span> <span class="toc-text">继承的作用：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object-Oriented-Programming-Polymorphism"><span class="toc-number">2.7.</span> <span class="toc-text">Object-Oriented Programming: Polymorphism</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">2.7.0.1.</span> <span class="toc-text">优点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8"><span class="toc-number">2.7.1.</span> <span class="toc-text">虚函数表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-typeid-%E8%BF%90%E7%AE%97%E7%AC%A6%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF%EF%BC%9A"><span class="toc-number">2.7.2.</span> <span class="toc-text">使用 typeid 运算符获取对象的类型信息：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-dynamic-cast-%E8%BF%90%E7%AE%97%E7%AC%A6%E8%BF%9B%E8%A1%8C%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">2.7.3.</span> <span class="toc-text">使用 dynamic_cast 运算符进行动态类型转换：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream-Input-Output"><span class="toc-number">2.8.</span> <span class="toc-text">Stream Input&#x2F;Output</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#C-iostream%E5%BA%93%E6%A6%82%E8%BF%B0"><span class="toc-number">2.8.1.</span> <span class="toc-text">C++ iostream库概述:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%92%8C%E6%9C%AA%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">2.8.2.</span> <span class="toc-text">C++中的格式化和未格式化输入功能：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD-istream-%E7%B1%BB%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0-ignore%E3%80%81putback-%E5%92%8C-peek%EF%BC%9A"><span class="toc-number">2.8.3.</span> <span class="toc-text">C++ 中 istream 类的成员函数 ignore、putback 和 peek：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ignore-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.4.</span> <span class="toc-text">ignore 成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#putback-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.5.</span> <span class="toc-text">putback 成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#peek-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.6.</span> <span class="toc-text">peek 成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.8.7.</span> <span class="toc-text">综合示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E5%AE%89%E5%85%A8I-O%E6%A6%82%E8%BF%B0"><span class="toc-number">2.8.8.</span> <span class="toc-text">类型安全I&#x2F;O概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E7%9A%84-lt-lt-%E5%92%8C-gt-gt-%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.8.9.</span> <span class="toc-text">重载的 &lt;&lt; 和 &gt;&gt; 操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#I-O%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">2.8.10.</span> <span class="toc-text">I&#x2F;O错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81-17"><span class="toc-number">2.8.11.</span> <span class="toc-text">示例代码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD%E6%93%8D%E4%BD%9C%E7%AC%A6%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.8.11.1.</span> <span class="toc-text">重载操作符示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E9%94%99%E8%AF%AF%E4%BD%8D%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.8.11.2.</span> <span class="toc-text">测试错误位示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%86%85%E5%AE%B9%EF%BC%9AI-O%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">2.8.12.</span> <span class="toc-text">扩展内容：I&#x2F;O状态管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E9%94%99%E8%AF%AF%E7%8A%B6%E6%80%81"><span class="toc-number">2.8.12.1.</span> <span class="toc-text">清除错误状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%BD%E7%95%A5%E9%94%99%E8%AF%AF%E8%BE%93%E5%85%A5"><span class="toc-number">2.8.12.2.</span> <span class="toc-text">忽略错误输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E4%BD%8D%E8%BE%93%E5%85%A5%E6%B5%81"><span class="toc-number">2.8.12.3.</span> <span class="toc-text">复位输入流</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E9%9D%9E%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA"><span class="toc-number">2.8.13.</span> <span class="toc-text">C++中的非格式化输入&#x2F;输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.14.</span> <span class="toc-text">主要成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#read-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.14.1.</span> <span class="toc-text">read 成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#write-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.14.2.</span> <span class="toc-text">write 成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gcount-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.8.14.3.</span> <span class="toc-text">gcount 成员函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">2.8.15.</span> <span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%86%85%E5%AE%B9%EF%BC%9A%E9%9D%9E%E6%A0%BC%E5%BC%8F%E5%8C%96I-O%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.8.16.</span> <span class="toc-text">扩展内容：非格式化I&#x2F;O的应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%84%E7%90%86%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6"><span class="toc-number">2.8.16.1.</span> <span class="toc-text">1. 处理二进制文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8F%90%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-number">2.8.16.2.</span> <span class="toc-text">2. 提高性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%AD%98%E5%82%A8%E5%92%8C%E4%BC%A0%E8%BE%93%E5%8E%9F%E5%A7%8B%E6%95%B0%E6%8D%AE"><span class="toc-number">2.8.16.3.</span> <span class="toc-text">3. 存储和传输原始数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E5%92%8C%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86"><span class="toc-number">2.8.17.</span> <span class="toc-text">错误处理和状态管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%8F%8A%E5%85%B6%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%BB%BB%E5%8A%A1"><span class="toc-number">2.8.18.</span> <span class="toc-text">C++ 流操作符及其格式化任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E5%AD%97%E7%9A%84%E5%9F%BA%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.8.18.1.</span> <span class="toc-text">1. 数字的基数设置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6"><span class="toc-number">2.8.18.2.</span> <span class="toc-text">2. 设置浮点数精度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%AE%BE%E7%BD%AE%E5%AD%97%E6%AE%B5%E5%AE%BD%E5%BA%A6"><span class="toc-number">2.8.18.3.</span> <span class="toc-text">3. 设置字段宽度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B5%81%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.8.18.4.</span> <span class="toc-text">4. 自定义流操作符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%86%85%E5%AE%B9"><span class="toc-number">2.8.19.</span> <span class="toc-text">扩展内容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AE%E5%A1%AB%E5%85%85%E5%AD%97%E7%AC%A6"><span class="toc-number">2.8.19.1.</span> <span class="toc-text">1. 设置填充字符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%B7%E6%96%B0%E6%B5%81"><span class="toc-number">2.8.19.2.</span> <span class="toc-text">2. 刷新流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%8F%92%E5%85%A5%E6%8D%A2%E8%A1%8C%E7%AC%A6%E5%92%8C%E8%B7%B3%E8%BF%87%E7%A9%BA%E7%99%BD%E5%AD%97%E7%AC%A6"><span class="toc-number">2.8.19.3.</span> <span class="toc-text">3. 插入换行符和跳过空白字符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%B5%81%E6%93%8D%E7%BA%B5%E5%99%A8"><span class="toc-number">2.8.20.</span> <span class="toc-text">C++ 流操纵器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%98%E6%80%A7%E6%B5%81%E6%93%8D%E7%BA%B5%E5%99%A8"><span class="toc-number">2.8.20.1.</span> <span class="toc-text">粘性流操纵器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%B2%98%E6%80%A7%E6%B5%81%E6%93%8D%E7%BA%B5%E5%99%A8"><span class="toc-number">2.8.20.2.</span> <span class="toc-text">非粘性流操纵器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">2.8.21.</span> <span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">2.8.22.</span> <span class="toc-text">分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E6%B5%81%E6%93%8D%E7%BA%B5%E5%99%A8%E7%B1%BB%E5%88%AB"><span class="toc-number">2.8.23.</span> <span class="toc-text">C++ 流操纵器类别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%B5%81%E6%93%8D%E7%BA%B5%E5%99%A8"><span class="toc-number">2.8.23.1.</span> <span class="toc-text">常见的流操纵器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">2.8.23.2.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#boolalpha%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.8.24.</span> <span class="toc-text">boolalpha的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">2.8.25.</span> <span class="toc-text">解释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%84%E5%8A%A0%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">2.8.26.</span> <span class="toc-text">附加说明：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B5%81%E7%8A%B6%E6%80%81"><span class="toc-number">2.9.</span> <span class="toc-text">处理流状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%8A%B6%E6%80%81%E4%BD%8D"><span class="toc-number">2.9.1.</span> <span class="toc-text">流状态位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E4%BA%8E%E6%B5%8B%E8%AF%95%E7%8A%B6%E6%80%81%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.9.2.</span> <span class="toc-text">用于测试状态的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%8A%B6%E6%80%81%E6%B5%8B%E8%AF%95%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.9.3.</span> <span class="toc-text">流状态测试的成员函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.9.4.</span> <span class="toc-text">在文件处理中的使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA%E6%B5%81"><span class="toc-number">2.10.</span> <span class="toc-text">同步输入和输出流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8cin-tie"><span class="toc-number">2.10.1.</span> <span class="toc-text">使用cin.tie()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E7%94%A8%E6%B3%95"><span class="toc-number">2.10.2.</span> <span class="toc-text">示例用法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%92%8C%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">2.10.3.</span> <span class="toc-text">缓冲和绑定机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E7%BC%93%E5%86%B2"><span class="toc-number">2.10.4.</span> <span class="toc-text">输出缓冲</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%8F%90%E9%AB%98-I-O-%E6%93%8D%E4%BD%9C%E6%95%88%E7%8E%87"><span class="toc-number">2.10.5.</span> <span class="toc-text">1. 提高 I&#x2F;O 操作效率</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">2.10.5.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%87%8F%E5%B0%91%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%AC%A1%E6%95%B0"><span class="toc-number">2.10.6.</span> <span class="toc-text">2. 减少系统调用次数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-2"><span class="toc-number">2.10.6.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%8E%A7%E5%88%B6%E8%BE%93%E5%87%BA%E8%A1%8C%E4%B8%BA"><span class="toc-number">2.10.7.</span> <span class="toc-text">3. 控制输出行为</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%EF%BC%9A-3"><span class="toc-number">2.10.7.1.</span> <span class="toc-text">示例：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%8F%90%E9%AB%98%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%80%A7%E8%83%BD"><span class="toc-number">2.10.8.</span> <span class="toc-text">4. 提高多线程程序的性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8F%90%E4%BE%9B%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%B4%E6%97%B6%E5%AD%98%E5%82%A8"><span class="toc-number">2.10.9.</span> <span class="toc-text">5. 提供数据的临时存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-7"><span class="toc-number">2.10.10.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6"><span class="toc-number">2.10.11.</span> <span class="toc-text">绑定机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-4"><span class="toc-number">2.10.12.</span> <span class="toc-text">代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-How-to-Program"><span class="toc-number">2.11.</span> <span class="toc-text">C++ How to Program</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">2.12.</span> <span class="toc-text">文件处理基础概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%A4%84%E7%90%86%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">2.12.1.</span> <span class="toc-text">文件处理类模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lt-fstream-gt-%E5%BA%93%E6%8F%90%E4%BE%9B%E4%BA%86%E8%BF%99%E4%BA%9B%E6%A8%A1%E6%9D%BF%E7%89%B9%E5%8C%96%E7%9A%84-typedef-%E5%88%AB%E5%90%8D%E3%80%82"><span class="toc-number">2.12.2.</span> <span class="toc-text">&lt;fstream&gt; 库提供了这些模板特化的 typedef 别名。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E4%BA%9B%E6%A8%A1%E6%9D%BF%E7%BB%A7%E6%89%BF%E8%87%AA%E7%B1%BB%E6%A8%A1%E6%9D%BF-basic-istream%E3%80%81basic-ostream-%E5%92%8C-basic-iostream%E3%80%82"><span class="toc-number">2.12.3.</span> <span class="toc-text">这些模板继承自类模板 basic_istream、basic_ostream 和 basic_iostream。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B-5"><span class="toc-number">2.12.4.</span> <span class="toc-text">代码示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#C-%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">2.12.5.</span> <span class="toc-text">C++ 中的文件结构：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%AD%A5%E9%AA%A4%EF%BC%9F"><span class="toc-number">2.12.6.</span> <span class="toc-text">读文件的基本步骤？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.12.7.</span> <span class="toc-text">不可修改的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F%E5%8C%96%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.12.8.</span> <span class="toc-text">格式化输入&#x2F;输出模型的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.12.9.</span> <span class="toc-text">随机访问文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E9%A3%8E%E6%A0%BC"><span class="toc-number">2.12.10.</span> <span class="toc-text">面向对象的输入&#x2F;输出风格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.12.11.</span> <span class="toc-text">对象序列化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%B3%BB%E5%88%97%E5%8C%96%EF%BC%9F"><span class="toc-number">2.12.12.</span> <span class="toc-text">如何系列化？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Standard-Library-Containers-and-Iterators"><span class="toc-number">2.13.</span> <span class="toc-text">Standard Library Containers and Iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0%EF%BC%88Overview-of-the-Sequential-Containers%EF%BC%89"><span class="toc-number">2.13.1.</span> <span class="toc-text">顺序容器概述（Overview of the Sequential Containers）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%BA%93%E6%A6%82%E8%A7%88%EF%BC%88Container-Library-Overview%EF%BC%89"><span class="toc-number">2.13.2.</span> <span class="toc-text">容器库概览（Container Library Overview）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88Iterators%EF%BC%89"><span class="toc-number">2.13.2.1.</span> <span class="toc-text">迭代器（Iterators）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%B1%BB%E5%9E%8B%E6%88%90%E5%91%98%EF%BC%88Container-Type-Members%EF%BC%89"><span class="toc-number">2.13.2.2.</span> <span class="toc-text">容器类型成员（Container Type Members）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#begin%E5%92%8Cend%E6%88%90%E5%91%98%EF%BC%88begin-and-end-Members%EF%BC%89"><span class="toc-number">2.13.2.3.</span> <span class="toc-text">begin和end成员（begin and end Members）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%9A%E4%B9%89%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%88Defining-and-Initializing-a-Container%EF%BC%89"><span class="toc-number">2.13.3.</span> <span class="toc-text">容器定义和初始化（Defining and Initializing a Container）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%92%8Cswap%EF%BC%88Assignment-and-swap%EF%BC%89"><span class="toc-number">2.13.4.</span> <span class="toc-text">赋值和swap（Assignment and swap）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F%E6%93%8D%E4%BD%9C%EF%BC%88Container-Size-Operations%EF%BC%89"><span class="toc-number">2.13.5.</span> <span class="toc-text">容器大小操作（Container Size Operations）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88Relational-Operators%EF%BC%89"><span class="toc-number">2.13.6.</span> <span class="toc-text">关系运算符（Relational Operators）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%EF%BC%88Sequential-Container-Operations%EF%BC%89"><span class="toc-number">2.13.7.</span> <span class="toc-text">顺序容器操作（Sequential Container Operations）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%88Adding-Elements-to-a-Sequential-Container%EF%BC%89"><span class="toc-number">2.13.8.</span> <span class="toc-text">向顺序容器添加元素（Adding Elements to a Sequential Container）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0%EF%BC%88Accessing-Elements%EF%BC%89"><span class="toc-number">2.13.9.</span> <span class="toc-text">访问元素（Accessing Elements）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88Erasing-Elements%EF%BC%89"><span class="toc-number">2.13.10.</span> <span class="toc-text">删除元素（Erasing Elements）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84forward-list%E6%93%8D%E4%BD%9C%EF%BC%88Specialized-forward-list-Operations%EF%BC%89"><span class="toc-number">2.13.11.</span> <span class="toc-text">特殊的forward_list操作（Specialized forward_list Operations）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F%EF%BC%88Resizing-a-Container%EF%BC%89"><span class="toc-number">2.13.12.</span> <span class="toc-text">改变容器大小（Resizing a Container）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%E5%8F%AF%E8%83%BD%E4%BD%BF%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88%EF%BC%88Container-Operations-May-Invalidate-Iterators%EF%BC%89"><span class="toc-number">2.13.13.</span> <span class="toc-text">容器操作可能使迭代器失效（Container Operations May Invalidate Iterators）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector%E5%AF%B9%E8%B1%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%A2%9E%E9%95%BF%E7%9A%84%EF%BC%88How-a-vector-Grows%EF%BC%89"><span class="toc-number">2.13.14.</span> <span class="toc-text">vector对象是如何增长的（How a vector Grows）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%9D%E5%A4%96%E7%9A%84string%E6%93%8D%E4%BD%9C%EF%BC%88Additional-string-Operations%EF%BC%89"><span class="toc-number">2.13.15.</span> <span class="toc-text">额外的string操作（Additional string Operations）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0string%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%EF%BC%88Other-Ways-to-Construct-strings%EF%BC%89"><span class="toc-number">2.13.16.</span> <span class="toc-text">构造string的其他方法（Other Ways to Construct strings）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%B9%E5%8F%98string%E7%9A%84%E5%85%B6%E4%BB%96%E6%96%B9%E6%B3%95%EF%BC%88Other-Ways-to-Change-a-string%EF%BC%89"><span class="toc-number">2.13.17.</span> <span class="toc-text">改变string的其他方法（Other Ways to Change a string）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#string%E6%90%9C%E7%B4%A2%E6%93%8D%E4%BD%9C%EF%BC%88string-Search-Operations%EF%BC%89"><span class="toc-number">2.13.18.</span> <span class="toc-text">string搜索操作（string Search Operations）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#compare%E5%87%BD%E6%95%B0%EF%BC%88The-compare-Functions%EF%BC%89"><span class="toc-number">2.13.19.</span> <span class="toc-text">compare函数（The compare Functions）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E5%80%BC%E8%BD%AC%E6%8D%A2%EF%BC%88Numeric-Conversions%EF%BC%89"><span class="toc-number">2.13.20.</span> <span class="toc-text">数值转换（Numeric Conversions）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E9%80%82%E9%85%8D%E5%99%A8%EF%BC%88Container-Adaptors%EF%BC%89"><span class="toc-number">2.13.21.</span> <span class="toc-text">容器适配器（Container Adaptors）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="toc-number">2.13.22.</span> <span class="toc-text">关联容器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%EF%BC%88Using-an-Associative-Container%EF%BC%89"><span class="toc-number">2.13.23.</span> <span class="toc-text">使用关联容器（Using an Associative Container）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0%EF%BC%88Overview-of-the-Associative-Containers%EF%BC%89"><span class="toc-number">2.13.24.</span> <span class="toc-text">关联容器概述（Overview of the Associative Containers）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%EF%BC%88Defining-an-Associative-Container%EF%BC%89"><span class="toc-number">2.13.25.</span> <span class="toc-text">定义关联容器（Defining an Associative Container）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pair%E7%B1%BB%E5%9E%8B%EF%BC%88The-pair-Type%EF%BC%89"><span class="toc-number">2.13.26.</span> <span class="toc-text">pair类型（The pair Type）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C%EF%BC%88Operations-on-Associative-Containers%EF%BC%89"><span class="toc-number">2.13.27.</span> <span class="toc-text">关联容器操作（Operations on Associative Containers）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88Associative-Container-Iterators%EF%BC%89"><span class="toc-number">2.13.28.</span> <span class="toc-text">关联容器迭代器（Associative Container Iterators）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0%EF%BC%88Adding-Elements%EF%BC%89"><span class="toc-number">2.13.29.</span> <span class="toc-text">添加元素（Adding Elements）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0%EF%BC%88Erasing-Elements%EF%BC%89-1"><span class="toc-number">2.13.30.</span> <span class="toc-text">删除元素（Erasing Elements）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#map%E7%9A%84%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C%EF%BC%88Subscripting-a-map%EF%BC%89"><span class="toc-number">2.13.31.</span> <span class="toc-text">map的下标操作（Subscripting a map）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E5%85%83%E7%B4%A0%EF%BC%88Accessing-Elements%EF%BC%89-1"><span class="toc-number">2.13.32.</span> <span class="toc-text">访问元素（Accessing Elements）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8%EF%BC%88The-Unordered-Containers%EF%BC%89"><span class="toc-number">2.13.33.</span> <span class="toc-text">无序容器（The Unordered Containers）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Standard-Library-Algorithms"><span class="toc-number">2.14.</span> <span class="toc-text">Standard Library Algorithms</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%88Overview%EF%BC%89"><span class="toc-number">2.14.1.</span> <span class="toc-text">概述（Overview）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E8%AF%86%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%EF%BC%88A-First-Look-at-the-Algorithms%EF%BC%89"><span class="toc-number">2.14.2.</span> <span class="toc-text">初识泛型算法（A First Look at the Algorithms）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E7%AE%97%E6%B3%95%EF%BC%88Read-Only-Algorithms%EF%BC%89"><span class="toc-number">2.14.3.</span> <span class="toc-text">只读算法（Read-Only Algorithms）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%88Algorithms-That-Write-Container-Elements%EF%BC%89"><span class="toc-number">2.14.4.</span> <span class="toc-text">写容器元素的算法（Algorithms That Write Container Elements）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%88Algorithms-That-Reorder-Container-Elements%EF%BC%89"><span class="toc-number">2.14.5.</span> <span class="toc-text">重排容器元素的算法（Algorithms That Reorder Container Elements）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C%EF%BC%88Customizing-Operations%EF%BC%89"><span class="toc-number">2.14.6.</span> <span class="toc-text">定制操作（Customizing Operations）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E7%AE%97%E6%B3%95%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0%EF%BC%88Passing-a-Function-to-an-Algorithm%EF%BC%89"><span class="toc-number">2.14.7.</span> <span class="toc-text">向算法传递函数（Passing a Function to an Algorithm）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88Lambda-Expressions%EF%BC%89"><span class="toc-number">2.14.8.</span> <span class="toc-text">lambda表达式（Lambda Expressions）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lambda%E6%8D%95%E8%8E%B7%E5%92%8C%E8%BF%94%E5%9B%9E%EF%BC%88Lambda-Captures-and-Returns%EF%BC%89"><span class="toc-number">2.14.9.</span> <span class="toc-text">lambda捕获和返回（Lambda Captures and Returns）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A%EF%BC%88Binding-Arguments%EF%BC%89"><span class="toc-number">2.14.10.</span> <span class="toc-text">参数绑定（Binding Arguments）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88Revisiting-Iterators%EF%BC%89"><span class="toc-number">2.14.11.</span> <span class="toc-text">再探迭代器（Revisiting Iterators）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88Insert-Iterators%EF%BC%89"><span class="toc-number">2.14.12.</span> <span class="toc-text">插入迭代器（Insert Iterators）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iostream%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88iostream-Iterators%EF%BC%89"><span class="toc-number">2.14.13.</span> <span class="toc-text">iostream迭代器（iostream Iterators）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iostream%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88iostream-Iterators%EF%BC%89-1"><span class="toc-number">2.14.14.</span> <span class="toc-text">iostream迭代器（iostream Iterators）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88Reverse-Iterators%EF%BC%89"><span class="toc-number">2.14.15.</span> <span class="toc-text">反向迭代器（Reverse Iterators）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84%EF%BC%88Structure-of-Generic-Algorithms%EF%BC%89"><span class="toc-number">2.14.16.</span> <span class="toc-text">泛型算法结构（Structure of Generic Algorithms）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%B1%BB%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%88The-Five-Iterator-Categories%EF%BC%89"><span class="toc-number">2.14.17.</span> <span class="toc-text">五类迭代器（The Five Iterator Categories）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%BD%A2%E5%8F%82%E6%A8%A1%E5%BC%8F%EF%BC%88Algorithm-Parameter-Patterns%EF%BC%89"><span class="toc-number">2.14.18.</span> <span class="toc-text">算法形参模式（Algorithm Parameter Patterns）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%EF%BC%88Algorithm-Naming-Conventions%EF%BC%89"><span class="toc-number">2.14.19.</span> <span class="toc-text">算法命名规范（Algorithm Naming Conventions）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95%EF%BC%88Container-Specific-Algorithms%EF%BC%89"><span class="toc-number">2.14.20.</span> <span class="toc-text">特定容器算法（Container-Specific Algorithms）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Exception-Handling-A-Deeper-Look"><span class="toc-number">2.15.</span> <span class="toc-text">Exception Handling: A Deeper Look</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%92%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-number">2.15.1.</span> <span class="toc-text">1. 资源管理和异常处理：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%B1%95%E5%BC%80"><span class="toc-number">2.15.2.</span> <span class="toc-text">栈展开</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Constructors-Destructors-and-Exception-Handling"><span class="toc-number">2.15.3.</span> <span class="toc-text">Constructors, Destructors and Exception Handling</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Exceptions-and-Inheritance"><span class="toc-number">2.15.4.</span> <span class="toc-text">Exceptions and Inheritance</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Processing-new-Failures"><span class="toc-number">2.15.5.</span> <span class="toc-text">Processing new Failures</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr"><span class="toc-number">2.15.6.</span> <span class="toc-text">unique_ptr</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">2.15.7.</span> <span class="toc-text">异常类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction-to-Custom-Templates"><span class="toc-number">2.16.</span> <span class="toc-text">Introduction to Custom Templates</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">2.16.1.</span> <span class="toc-text">模板的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0"><span class="toc-number">2.16.2.</span> <span class="toc-text">定义一个模板函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">2.16.3.</span> <span class="toc-text">定义一个模板类</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/20/lec94/" title="Lec9 Graph Algorithms(4)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/d4f507db4948b6927219f40a357b26b.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lec9 Graph Algorithms(4)"/></a><div class="content"><a class="title" href="/2024/11/20/lec94/" title="Lec9 Graph Algorithms(4)">Lec9 Graph Algorithms(4)</a><time datetime="2024-11-20T09:21:14.000Z" title="发表于 2024-11-20 17:21:14">2024-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/20/lec93/" title="Lec9 Graph Algorithms(3)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/5fde7714def1c49ec9fb4ab3e8ff4f7.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lec9 Graph Algorithms(3)"/></a><div class="content"><a class="title" href="/2024/11/20/lec93/" title="Lec9 Graph Algorithms(3)">Lec9 Graph Algorithms(3)</a><time datetime="2024-11-20T08:41:52.000Z" title="发表于 2024-11-20 16:41:52">2024-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/20/lec912/" title="Lec9 Graph Algorithms(2)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/56a71ed278c8b437596f43cb5fcfb38.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lec9 Graph Algorithms(2)"/></a><div class="content"><a class="title" href="/2024/11/20/lec912/" title="Lec9 Graph Algorithms(2)">Lec9 Graph Algorithms(2)</a><time datetime="2024-11-20T08:00:30.000Z" title="发表于 2024-11-20 16:00:30">2024-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/20/lec91/" title="Lec9 Graph Algorithms(1)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/383b7bff62aee5037609cfe75dfbd42.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lec9 Graph Algorithms(1)"/></a><div class="content"><a class="title" href="/2024/11/20/lec91/" title="Lec9 Graph Algorithms(1)">Lec9 Graph Algorithms(1)</a><time datetime="2024-11-20T07:10:58.000Z" title="发表于 2024-11-20 15:10:58">2024-11-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/20/lec8/" title="Lec8 Disjoint Set Class"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/03d57a9d59bc68710938fa9e1e6a860.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Lec8 Disjoint Set Class"/></a><div class="content"><a class="title" href="/2024/11/20/lec8/" title="Lec8 Disjoint Set Class">Lec8 Disjoint Set Class</a><time datetime="2024-11-20T07:01:23.000Z" title="发表于 2024-11-20 15:01:23">2024-11-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HT1PalaKkPaG1UqAXBhJXIu8-gzGzoHsz',
      appKey: 'iT0TnVVAwf9zuZ7NqwclQItY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="1" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="只此无为身，且前行,忘记过去的人注定重蹈覆辙,我是我，我靠自己站立，我会做好自身,如果我睡大觉，谁给我摘月亮呢,假期和朋友，是人生中顶好的两样东西啊。,去爱，去失去，要不负相遇,没什么想不想通的，只是固执而已,我们深爱星辰，乃至不惧夜的黑,吃，喝，享受幸福，接受奇迹,浊水若长流，自清澄,雅俗共赏,总会有什么也不想的幸福时刻吧,时间顺流而下，生活逆流而上,悟已往之不谏，知来者之可追,希望你的小世界里,山花烂漫,茶酒俱全,安宁清淡,明朗欢愉" data-fontsize="20px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4b31456c6f0f4489f99177f89e936de7286431045.png@1256w_708h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt="">诗录</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/51d37eba99d243607ddedfff6e91568f617436609.jpg@1256w_1884h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">TotoroのPlan</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS61B/&quot;);" href="javascript:void(0);">CS61B</a><span class="categoryBar-list-count">76</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS70の旅/&quot;);" href="javascript:void(0);">CS70の旅</a><span class="categoryBar-list-count">25</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/期末の旅/&quot;);" href="javascript:void(0);">期末の旅</a><span class="categoryBar-list-count">59</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACMの旅/&quot;);" href="javascript:void(0);">ACMの旅</a><span class="categoryBar-list-count">68</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/区域赛の旅/&quot;);" href="javascript:void(0);">区域赛の旅</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数学建模/&quot;);" href="javascript:void(0);">数学建模</a><span class="categoryBar-list-count">31</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Codeforcesの旅/&quot;);" href="javascript:void(0);">Codeforcesの旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题计划/&quot;);" href="javascript:void(0);">刷题计划</a><span class="categoryBar-list-count">40</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/牛客の旅/&quot;);" href="javascript:void(0);">牛客の旅</a><span class="categoryBar-list-count">65</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/前端の旅/&quot;);" href="javascript:void(0);">前端の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构/&quot;);" href="javascript:void(0);">数据结构</a><span class="categoryBar-list-count">47</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_24.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Atcoderの旅/&quot;);" href="javascript:void(0);">Atcoderの旅</a><span class="categoryBar-list-count">53</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_25.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-の旅/&quot;);" href="javascript:void(0);">C++の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_26.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CSAPPの旅/&quot;);" href="javascript:void(0);">CSAPPの旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_27.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS知识/&quot;);" href="javascript:void(0);">CS知识</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_28.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程基础/&quot;);" href="javascript:void(0);">编程基础</a><span class="categoryBar-list-count">22</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_29.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/离散数学/&quot;);" href="javascript:void(0);">离散数学</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_30.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JAVAの旅/&quot;);" href="javascript:void(0);">JAVAの旅</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_31.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MIT-6-031-Software-Construction/&quot;);" href="javascript:void(0);">MIT 6.031:Software Construction</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_32.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS-110L/&quot;);" href="javascript:void(0);">CS 110L</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_33.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/灵魂の旅/&quot;);" href="javascript:void(0);">灵魂の旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_34.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/个人安排/&quot;);" href="javascript:void(0);">个人安排</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_35.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂项/&quot;);" href="javascript:void(0);">杂项</a><span class="categoryBar-list-count">11</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_36.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文学/&quot;);" href="javascript:void(0);">文学</a><span class="categoryBar-list-count">49</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_37.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/力扣の旅/&quot;);" href="javascript:void(0);">力扣の旅</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_38.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/千里十二行/&quot;);" href="javascript:void(0);">千里十二行</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_39.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/🗡指offer/&quot;);" href="javascript:void(0);">🗡指offer</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/少年游/&quot;);" href="javascript:void(0);">少年游</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_41.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法提高课/&quot;);" href="javascript:void(0);">算法提高课</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_42.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/汇编の旅/&quot;);" href="javascript:void(0);">汇编の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_43.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-实训/&quot;);" href="javascript:void(0);">C++实训</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>