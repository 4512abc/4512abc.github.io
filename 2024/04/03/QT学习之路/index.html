<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>QT学习之路 | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这是实训的必经（）之路，含着泪也要吃下去 【千锋教育2023新版Qt基础教程，Qt高级开发视频教程完整版】https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1xu4y1F7K3?p&#x3D;70&amp;vd_source&#x3D;df0626874cc0b0a110157982c80797c4 Qt概述1.1 什么是QtQt是一个跨平台的C++图形用户界面应用程序框架。它为应用程序开发者提">
<meta property="og:type" content="article">
<meta property="og:title" content="QT学习之路">
<meta property="og:url" content="http://totorocatcat.top/2024/04/03/QT%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="这是实训的必经（）之路，含着泪也要吃下去 【千锋教育2023新版Qt基础教程，Qt高级开发视频教程完整版】https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1xu4y1F7K3?p&#x3D;70&amp;vd_source&#x3D;df0626874cc0b0a110157982c80797c4 Qt概述1.1 什么是QtQt是一个跨平台的C++图形用户界面应用程序框架。它为应用程序开发者提">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.12/img_122_808x1400_350.011993408203_null_normal.jpg">
<meta property="article:published_time" content="2024-04-03T15:03:11.000Z">
<meta property="article:modified_time" content="2024-06-06T16:20:45.425Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.12/img_122_808x1400_350.011993408203_null_normal.jpg"><link rel="shortcut icon" href="https://source.fomal.cc/img/default_cover_227.webp"><link rel="canonical" href="http://totorocatcat.top/2024/04/03/QT%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":765,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'QT学习之路',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-06-07 00:20:45'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">471</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://npm.elemecdn.com/ushio-api-img-moe@5.0.12/img_122_808x1400_350.011993408203_null_normal.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">QT学习之路</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-03T15:03:11.000Z" title="发表于 2024-04-03 23:03:11">2024-04-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-06-06T16:20:45.425Z" title="更新于 2024-06-07 00:20:45">2024-06-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">17.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>61分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="QT学习之路"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1433418985&auto=1&height=66"></iframe>


<p>这是实训的必经（）之路，含着泪也要吃下去</p>
<p>【千锋教育2023新版Qt基础教程，Qt高级开发视频教程完整版】<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1xu4y1F7K3?p=70&amp;vd_source=df0626874cc0b0a110157982c80797c4">https://www.bilibili.com/video/BV1xu4y1F7K3?p=70&amp;vd_source=df0626874cc0b0a110157982c80797c4</a></p>
<h1 id="Qt概述"><a href="#Qt概述" class="headerlink" title="Qt概述"></a>Qt概述</h1><h2 id="1-1-什么是Qt"><a href="#1-1-什么是Qt" class="headerlink" title="1.1 什么是Qt"></a>1.1 什么是Qt</h2><p>Qt是一个<strong>跨平台</strong>的C++<strong>图形用户界面应用程序框架</strong>。它为应用程序开发者提供建立艺术级图形界面所需的所有功能。它是完全面向对象的，很容易扩展，并且允许真正的组件编程。</p>
<h2 id="1-2-Qt的发展史"><a href="#1-2-Qt的发展史" class="headerlink" title="1.2 Qt的发展史"></a>1.2 Qt的发展史</h2><p>1991年 Qt最早由奇趣科技开发</p>
<p>1996年 进入商业领域，它也是目前流行的Linux桌面环境KDE的基础</p>
<p>2008年 奇趣科技被诺基亚公司收购，Qt称为诺基亚旗下的编程语言</p>
<p>2012年 Qt又被Digia公司收购</p>
<p>2014年4月 跨平台的集成开发环境Qt Creator3.1.0发布，同年5月20日配发了Qt5.3正式版，至此Qt实现了对iOS、Android、WP等各平台的全面支持。</p>
<p>当前Qt最新版本为 5.5.0</p>
<h2 id="1-3-支持的平台"><a href="#1-3-支持的平台" class="headerlink" title="1.3 支持的平台"></a>1.3 支持的平台</h2><p>l Windows – XP、Vista、Win7、Win8、Win2008、Win10</p>
<p>l Uinux/X11 – Linux、Sun Solaris、HP-UX、Compaq Tru64 UNIX、IBM AIX、SGI IRIX、FreeBSD、BSD/OS、和其他很多X11平台</p>
<p>l Macintosh – Mac OS X</p>
<p>l Embedded – 有帧缓冲支持的嵌入式Linux平台，Windows CE</p>
<h2 id="1-4-Qt版本"><a href="#1-4-Qt版本" class="headerlink" title="1.4 Qt版本"></a>1.4 Qt版本</h2><p>Qt按照不同的版本发行，分为商业版和开源版</p>
<p>l 商业版</p>
<p>为商业软件提供开发，他们提供传统商业软件发行版，并且提供在商业有效期内的免费升级和技术支持服务。</p>
<p>l 开源的LGPL版本：</p>
<p>为了开发自有而设计的开放源码软件，它提供了和商业版本同样的功能，在GNU通用公共许可下，它是免费的。</p>
<h2 id="1-5Qt的优点"><a href="#1-5Qt的优点" class="headerlink" title="1.5Qt的优点"></a>1.5Qt的优点</h2><ul>
<li>l 跨平台，几乎支持所有的平台</li>
<li>l 接口简单，容易上手，学习QT框架对学习其他框架有参考意义。</li>
<li>l 一定程度上简化了内存回收机制</li>
<li>l 开发效率高，能够快速的构建应用程序。</li>
<li>l 有很好的社区氛围，市场份额在缓慢上升。</li>
<li>l 可以进行嵌入式开发。</li>
</ul>
<h1 id="创建Qt项目"><a href="#创建Qt项目" class="headerlink" title="创建Qt项目"></a>创建Qt项目</h1><h2 id="2-1-使用向导创建"><a href="#2-1-使用向导创建" class="headerlink" title="2.1 使用向导创建"></a>2.1 使用向导创建</h2><p>打开Qt Creator 界面选择 New Project或者选择菜单栏 【文件】-【新建文件或项目】菜单项</p>
<p>弹出New Project对话框，选择Qt Widgets Application，</p>
<p>选择【Choose】按钮，弹出如下对话框</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/clip_image006.jpg" alt="img"></p>
<p>设置项目名称和路径，按照向导进行下一步，</p>
<p>选择编译套件</p>
<p>向导会默认添加一个继承自CMainWindow的类，可以在此修改类的名字和基类。继续下一步</p>
<p>即可创建出一个Qt桌面程序。</p>
<h2 id="2-2-手动创建"><a href="#2-2-手动创建" class="headerlink" title="2.2 手动创建"></a>2.2 手动创建</h2><p>添加一个空项目</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/clip_image014.jpg" alt="img"></p>
<p>选择【choose】进行下一步。设置项目名称和路径 —&gt; 选择编译套件 —&gt; 修改类信息 —&gt; 完成（步骤同上），生成一个空项目。在空项目中添加文件：在项目名称上单击鼠标右键弹出右键菜单，选择【添加新文件】</p>
<p>弹出新建文件对话框</p>
<p>在此对话框中选择要添加的类或者文件，根据向导完成文件的添加。</p>
<h2 id="2-3-pro文件"><a href="#2-3-pro文件" class="headerlink" title="2.3 .pro文件"></a>2.3 .pro文件</h2><p>在使用Qt向导生成的应用程序.pro文件格式如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">QT  += core gui   <span class="comment">//模块的名字</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">greaterThan</span>(QT_MAJOR_VERSION, <span class="number">4</span>): QT += widgets</span><br><span class="line"></span><br><span class="line">TARGET = test  <span class="comment">//应用程序名</span></span><br><span class="line"></span><br><span class="line">TEMPLATE = app <span class="comment">//生成的makefile的模板类型</span></span><br><span class="line">        <span class="comment">//源文件</span></span><br><span class="line"> SOURCES += main.cpp\mainwindow.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件</span></span><br><span class="line"> HEADERS  += mainwindow.h</span><br><span class="line"><span class="comment">//窗口设计文件</span></span><br><span class="line">FORMS    += mainwindow.ui</span><br></pre></td></tr></table></figure>
<p><strong>.pro</strong>就是工程文件(project)，它是qmake自动生成的用于生产makefile的配置文件。.pro文件的写法如下：</p>
<blockquote>
<p>l 注释</p>
<p>从“#”开始，到这一行结束。</p>
<p>l 模板变量告诉qmake为这个应用程序生成哪种makefile。下面是可供使用的选择：<strong>TEMPLATE</strong> = app</p>
<ul>
<li>n app -建立一个应用程序的makefile。这是默认值，所以如果模板没有被指定，这个将被使用。</li>
<li>n lib - 建立一个库的makefile。</li>
<li>n vcapp - 建立一个应用程序的VisualStudio项目文件。</li>
<li>n vclib - 建立一个库的VisualStudio项目文件。</li>
<li>n subdirs -这是一个特殊的模板，它可以创建一个能够进入特定目录并且为一个项目文件生成makefile并且为它调用make的makefile。</li>
</ul>
<p>l #指定生成的应用程序名：</p>
<p><strong>TARGET</strong> = QtDemo</p>
<p>l #工程中包含的头文件</p>
<p><strong>HEADERS</strong> += include/painter.h</p>
<p>l #工程中包含的.ui设计文件</p>
<p><strong>FORMS</strong> += forms/painter.ui</p>
<p>l #工程中包含的源文件</p>
<p><strong>SOURCES</strong> += sources/main.cpp sources/painter.cpp</p>
<p>l #工程中包含的资源文件</p>
<p><strong>RESOURCES</strong> += qrc/painter.qrc</p>
<p>l <strong>greaterThan(QT_MAJOR_VERSION, 4): QT += widgets</strong></p>
<p><strong>这条语句的含义是，如果QT_MAJOR_VERSION大于4（也就是当前使用的Qt5及更高版本）需要增加widgets模块。如果项目仅需支持Qt5，也可以直接添加“QT += widgets”一句。不过为了保持代码兼容，最好还是按照QtCreator生成的语句编写。</strong></p>
<p>l #配置信息</p>
<p>CONFIG用来告诉qmake关于应用程序的配置信息。</p>
<p>CONFIG += c++11 //使用c++11的特性</p>
<p>在这里使用“+=”，是因为我们添加我们的配置选项到任何一个已经存在中。这样做比使用“=”那样替换已经指定的所有选项更安全。</p>
</blockquote>
<h2 id="2-4-一个最简单的Qt应用程序"><a href="#2-4-一个最简单的Qt应用程序" class="headerlink" title="2.4 一个最简单的Qt应用程序"></a>2.4 一个最简单的Qt应用程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QWidget&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    QWidget w;</span><br><span class="line"></span><br><span class="line">    w.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释：</p>
<blockquote>
<p>l Qt头文件没有.h后缀</p>
<p>l Qt一个类对应一个头文件，类名就是头文件名</p>
<p>l QApplication应用程序类</p>
<p>n 管理图形用户界面应用程序的控制流和主要设置。</p>
<p>n 是Qt的整个后台管理的命脉它<strong>包含主事件循环</strong>，在其中来自窗口系统和其它资源的<strong>所有事件处理和调度</strong>。它也处理<strong>应用程序的初始化和结束</strong>，并且<strong>提供对话管理</strong>。</p>
<p>n 对于任何一个使用Qt的图形用户界面应用程序，都正好存在一个QApplication 对象，而不论这个应用程序在同一时间内是不是有0、1、2或更多个窗口。</p>
<p>l a.exec()</p>
<p>程序进入消息循环，等待对用户输入进行响应。这里main()把控制权转交给Qt，Qt完成事件处理工作，当应用程序退出的时候exec()的值就会返回。<strong>在exec()中，Qt接受并处理用户和系统的事件并且把它们传递给适当的窗口部件。</strong></p>
</blockquote>
<h1 id="3-信号和槽机制-listener"><a href="#3-信号和槽机制-listener" class="headerlink" title="3 信号和槽机制(listener)"></a>3 信号和槽机制(listener)</h1><p>信号槽是 Qt 框架引以为豪的机制之一。所谓信号槽，实际就是观察者模式。<strong>当某个事件发生之后</strong>，比如，按钮检测到自己被点击了一下，<strong>它就会发出一个信号（signal）</strong>。这种发出是没有目的的，类似广播。<strong>如果有对象对这个信号感兴趣，它就会使用连接（connect）函数</strong>，意思是，<strong>将想要处理的信号和自己的一个函数（称为槽（slot））绑定来处理这个信号</strong>。也就是说，<strong>当信号发出时，被连接的槽函数会自动被回调</strong>。这就类似观察者模式：当发生了感兴趣的事件，某一个操作就会被自动触发。（这里提一句，<strong>Qt 的信号槽使用了额外的处理来实现，并不是 GoF 经典的观察者模式的实现方式</strong>。</p>
<h2 id="3-1-信号和槽"><a href="#3-1-信号和槽" class="headerlink" title="3.1 信号和槽"></a>3.1 信号和槽</h2><p>为了体验一下信号槽的使用，我们以一段简单的代码说明：</p>
<p>Qt5 的书写方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QApplication&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QPushButton&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    <span class="function">QPushButton <span class="title">button</span><span class="params">(<span class="string">&quot;Quit&quot;</span>)</span></span>;</span><br><span class="line">	QObject::<span class="built_in">connect</span>(&amp;button, &amp;QPushButton::clicked,&amp;app, &amp;QApplication::quit);</span><br><span class="line"></span><br><span class="line">    button.<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们按照前面文章中介绍的在 Qt Creator 中创建工程的方法创建好工程，然后将main()函数修改为上面的代码。点击运行，我们会看到一个按钮，上面有“Quit”字样。点击按钮，程序退出。</p>
<p>connect()函数最常用的一般形式：<code>connect(sender, signal, receiver, slot);</code></p>
<p>参数：</p>
<ul>
<li>n sender：发出信号的对象</li>
<li>n signal：发送对象发出的信号</li>
<li>n receiver：接收信号的对象</li>
<li>n slot：接收对象在接收到信号之后所需要调用的函数</li>
</ul>
<p><strong>信号槽要求信号和槽的参数一致，所谓一致，是参数类型一致。如果不一致，允许的情况是，槽函数的参数可以比信号的少，即便如此，槽函数存在的那些参数的顺序也必须和信号的前面几个一致起来。这是因为，你可以在槽函数中选择忽略信号传来的数据（也就是槽函数的参数比信号的少），但是不能说信号根本没有这个数据，你就要在槽函数中使用（就是槽函数的参数比信号的多，这是不允许的）。</strong></p>
<p>如果信号槽不符合，或者根本找不到这个信号或者槽函数，比如我们改成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(&amp;button, &amp;QPushButton::clicked, &amp;QApplication::quit2);</span><br></pre></td></tr></table></figure>
<p>由于 QApplication 没有 quit2 这样的函数，因此在编译时会有编译错误：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;quit2&#x27;</span> is <span class="keyword">not</span> a member of QApplication</span><br></pre></td></tr></table></figure>
<p>这样，使用成员函数指针我们就不会担心在编写信号槽的时候出现函数错误。</p>
<p>Qt4 的书写方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">        <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>; </span><br><span class="line"></span><br><span class="line">        QPushButton *button = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;Quit&quot;</span>); </span><br><span class="line"></span><br><span class="line">        <span class="built_in">connect</span>(button, <span class="built_in">SIGNAL</span>(<span class="built_in">clicked</span>()), &amp;a, <span class="built_in">SLOT</span>(<span class="built_in">quit</span>())); </span><br><span class="line"></span><br><span class="line">        button-&gt;<span class="built_in">show</span>(); </span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">exec</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用了<strong>SIGNAL和SLOT这两个宏，将两个函数名转换成了字符串</strong>。注意到connect()函数的 signal 和 slot 都是接受字符串，一旦出现连接不成功的情况，<strong>Qt4是没有编译错误的</strong>（因为一切都是字符串，编译期是不检查字符串是否匹配），而是在运行时给出错误。这无疑会增加程序的不稳定性。</p>
<p>Qt5在语法上完全兼容Qt4</p>
<h2 id="3-2-自定义信号槽"><a href="#3-2-自定义信号槽" class="headerlink" title="3.2 自定义信号槽"></a>3.2 自定义信号槽</h2><p>使用connect()可以让我们连接系统提供的信号和槽。但是，Qt 的信号槽机制并不仅仅是使用系统提供的那部分，还会允许我们自己设计自己的信号和槽。</p>
<p>下面我们看看使用 Qt 的信号槽，实现一个报纸和订阅者的例子：</p>
<p>有一个报纸类Newspaper，有一个订阅者类Subscriber。Subscriber可以订阅Newspaper。这样，当Newspaper有了新的内容的时候，Subscriber可以立即得到通知。</p>
<p>////////// newspaper.h //////////</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Newspaper</span> : <span class="keyword">public</span> QObject</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Newspaper</span>(<span class="type">const</span> QString &amp; name) :</span><br><span class="line"></span><br><span class="line">        <span class="built_in">m_name</span>(name)</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">send</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">emit <span class="title">newPaper</span><span class="params">(m_name)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">newPaper</span><span class="params">(<span class="type">const</span> QString &amp;name)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QString m_name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>////////// reader.h //////////</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QObject&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QDebug&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Reader</span> : <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Reader</span>() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">receiveNewspaper</span><span class="params">(<span class="type">const</span> QString &amp; name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Receives Newspaper: &quot;</span> &lt;&lt; name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>////////// main.cpp //////////</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;QCoreApplication&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;newspaper.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;reader.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">QCoreApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Newspaper <span class="title">newspaper</span><span class="params">(<span class="string">&quot;Newspaper A&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    Reader reader;</span><br><span class="line"></span><br><span class="line">    QObject::<span class="built_in">connect</span>(&amp;newspaper, &amp;Newspaper::newPaper, &amp;reader,    &amp;Reader::receiveNewspaper);</span><br><span class="line"></span><br><span class="line">    newspaper.<span class="built_in">send</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>首先看Newspaper这个类。这个类继承了QObject类。<strong>只有继承了QObject类的类，才具有信号槽的能力。</strong>所以，为了使用信号槽，必须继承QObject。<strong>凡是QObject类（不管是直接子类还是间接子类），都应该在第一行代码写上Q_OBJECT</strong>。不管是不是使用信号槽，都应该添加这个宏。这个宏的展开将为我们的类提供信号槽机制、国际化机制以及 Qt 提供的不基于 C++ RTTI 的反射能力。</li>
<li>Newspaper类的 public 和 private 代码块都比较简单，只不过它新加了一个 signals。signals 块所列出的，就是该类的信号。<strong>信号就是一个个的函数名，返回值是 void（因为无法获得信号的返回值，所以也就无需返回任何值），参数是该类需要让外界知道的数据。信号作为函数名，不需要在 cpp 函数中添加任何实现。</strong></li>
<li>Newspaper类的send()函数比较简单，只有一个语句emit newPaper(m_name);。emit 是 Qt 对 C++ 的扩展，是一个关键字（其实也是一个宏）。emit 的含义是发出，也就是发出newPaper()信号。感兴趣的接收者会关注这个信号，可能还需要知道是哪份报纸发出的信号？所以，我们将实际的报纸名字m_name当做参数传给这个信号。当接收者连接这个信号时，就可以通过槽函数获得实际值。这样就完成了数据从发出者到接收者的一个转移。</li>
<li>Reader类更简单。因为这个类需要接受信号，所以我们将其继承了QObject，并且添加了Q_OBJECT宏。后面则是默认构造函数和一个普通的成员函数。<strong>Qt 5 中，任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数。</strong>与信号函数不同，槽函数必须自己完成实现代码。槽函数就是普通的成员函数，因此作为成员函数，也会受到 public、private 等访问控制符的影响。（如果信号是 private 的，这个信号就不能在类的外面连接，也就没有任何意义。）</li>
</ul>
<h3 id="自定义信号槽需要注意的事项"><a href="#自定义信号槽需要注意的事项" class="headerlink" title="自定义信号槽需要注意的事项"></a>自定义信号槽需要注意的事项</h3><blockquote>
<ul>
<li>l<strong>发送者和接收者都需要是QObject的子类（当然，槽函数是全局函数、Lambda 表达式等无需接收者的时候除外）；</strong></li>
<li><strong>使用 signals 标记信号函数，信号是一个函数声明，返回 void，不需要实现函数代码；</strong></li>
<li><strong>槽函数是普通的成员函数，作为成员函数，会受到 public、private、protected 的影响；</strong></li>
<li><strong>使用 emit 在恰当的位置发送信号；</strong></li>
<li><strong>使用QObject::connect()函数连接信号和槽。</strong></li>
<li><strong>任何成员函数、static 函数、全局函数和 Lambda 表达式都可以作为槽函数</strong></li>
</ul>
</blockquote>
<h3 id="信号槽的更多用法"><a href="#信号槽的更多用法" class="headerlink" title="信号槽的更多用法"></a>信号槽的更多用法</h3><blockquote>
<ul>
<li>一个信号可以和多个槽相连</li>
</ul>
<p><strong>如果是这种情况，这些槽会一个接一个的被调用，但是它们的</strong>调用顺序是不确定的。</p>
<ul>
<li>多个信号可以连接到一个槽</li>
</ul>
<p><strong>只要任意一个信号发出，这个槽就会被调用</strong>。</p>
<ul>
<li>一个信号可以连接到另外的一个信号</li>
</ul>
<p><strong>当第一个信号发出时，第二个信号被发出。除此之外，这种信号-信号的形式和信号-槽的形式没有什么区别。</strong></p>
<ul>
<li><p>槽可以被取消链接</p>
<p>这种情况并不经常出现，因为<strong>当一个对象delete之后，Qt自动取消所有连接到这个对象上面的槽</strong>。</p>
</li>
<li><p>使用Lambda 表达式</p>
<p>在使用 Qt 5 的时候，能够支持 Qt 5 的编译器都是支持 Lambda 表达式的。</p>
<p>我们的代码可以写成下面这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(&amp;newspaper, <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (Newspaper:: *)</span><br><span class="line"></span><br><span class="line">(<span class="type">const</span> QString &amp;)&gt;(&amp;Newspaper::newPaper),=](<span class="type">const</span> QString &amp;name) </span><br><span class="line"></span><br><span class="line">&#123; <span class="comment">/* Your code here. */</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>在连接信号和槽的时候，槽函数可以使用Lambda表达式的方式进行处理。</p>
</li>
</ul>
</blockquote>
<h2 id="3-3-Lambda表达式"><a href="#3-3-Lambda表达式" class="headerlink" title="3.3 Lambda表达式"></a>3.3 Lambda表达式</h2><p>C++11中的Lambda表达式<strong>用于定义并创建匿名的函数对象</strong>，以简化编程工作。首先看一下Lambda表达式的基本构成：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/clip_image020.jpg" alt="img">‘</p>
<p>函数对象参数mutable或exception -&gt;返回值{函数体}</p>
<p>① <strong>函数对象参数</strong>；</p>
<p>[]，标识一个<strong>Lambda的开始</strong>，这部分必须存在，<strong>不能省略</strong>。函数对象参数是传递给编译器自动生成的函数对象类的构造函数的。函数对象参数只能使用那些到定义Lambda为止时Lambda所在作用范围内可见的局部变量（包括Lambda所在类的this）。函数对象参数有以下形式：</p>
<ul>
<li>空，没有使用任何函数对象参数。</li>
<li>=，函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是<strong>值传递方式</strong>（相当于编译器自动为我们按值传递了<strong>所有局部变量</strong>）。</li>
<li>&amp;，函数体内可以使用Lambda所在作用范围内所有可见的局部变量（包括Lambda所在类的this），并且是<strong>引用传递方式</strong>（相当于编译器自动为我们按引用传递了所有局部变量）。</li>
<li>this，函数体内可以使用Lambda所在类中的成员变量。</li>
<li>a，将a按值进行传递。按值进行传递时，函数体内不能修改传递进来的a的拷贝，因为默认情况下函数是const的。要修改传递进来的a的拷贝，可以添加mutable修饰符。</li>
<li>&amp;a，将a按引用进行传递。</li>
<li>a, &amp;b，将a按值进行传递，b按引用进行传递。</li>
<li>=，&amp;a, &amp;b，除a和b按引用进行传递外，其他参数都按值进行传递。</li>
<li>&amp;, a, b，除a和b按值进行传递外，其他参数都按引用进行传递。</li>
</ul>
<p>② 操作符重载函数参数；</p>
<p>标识重载的()操作符的参数，没有参数时，这部分可以省略。参数可以通过按值（如：(a,b)）和按引用（如：(&amp;a,&amp;b)）两种方式进行传递。</p>
<p>③ 可修改标示符；</p>
<p>mutable声明，这部分可以省略。按值传递函数对象参数时，加上mutable修饰符后，可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）。</p>
<p>④ 错误抛出标示符；</p>
<p>exception声明，这部分也可以省略。exception声明用于指定函数抛出的异常，如抛出整数类型的异常，可以使用throw(int)</p>
<p>⑤ 函数返回值；</p>
<p>返回值类型，标识函数返回值的类型，当返回值为void，或者函数体中只有一处return的地方（此时编译器可以自动推断出返回值类型）时，这部分可以省略。</p>
<p>⑥ 是函数体；</p>
<p> {}，标识函数的实现，这部分不能省略，但函数体可以为空。</p>
<h1 id="Qt窗口系统"><a href="#Qt窗口系统" class="headerlink" title="Qt窗口系统"></a>Qt窗口系统</h1><h2 id="4-1-Qt窗口坐标体系"><a href="#4-1-Qt窗口坐标体系" class="headerlink" title="4.1 Qt窗口坐标体系"></a>4.1 Qt窗口坐标体系</h2><h3 id="坐标体系"><a href="#坐标体系" class="headerlink" title="坐标体系"></a>坐标体系</h3><p>以左上角为原点，X向右增加，Y向下增加。</p>
<blockquote>
<p>对于嵌套窗口，其坐标是<strong>相对于父窗口</strong>来说的。</p>
</blockquote>
<h3 id="4-2-1-对象模型"><a href="#4-2-1-对象模型" class="headerlink" title="4.2.1 对象模型"></a>4.2.1 对象模型</h3><p>在Qt中创建对象的时候会提供一个<strong>Parent对象指针</strong>，下面来解释这个parent到底是干什么的。</p>
<ol>
<li><p><strong>QObject是以对象树的形式组织起来的</strong>。</p>
<blockquote>
<p>当你创建一个QObject对象时，会看到QObject的构造函数接收一个QObject指针作为参数，这个参数就是 parent，也就是父对象指针。这相当于，<strong>在创建QObject对象时，可以提供一个其父对象，我们创建的这个QObject对象会自动添加到其父对象的children()列表。</strong></p>
<p> <strong>当父对象析构的时候，这个列表中的所有对象也会被析构。（注意，这里的父对象并不是继承意义上的父类！）</strong>这种机制在 GUI 程序设计中相当有用。例如，一个按钮有一个QShortcut（快捷键）对象作为其子对象。当我们删除按钮的时候，这个快捷键理应被删除。这是合理的。</p>
</blockquote>
</li>
<li><p><strong>QWidget是能够在屏幕上显示的一切组件的父类。</strong></p>
<blockquote>
<p> <strong>QWidget</strong>继承自QObject，因此也继承了这种对象树关系。一个孩子自动地成为父组件的一个子组件。因此，它会显示在父组件的坐标系统中，被父组件的边界剪裁。例如，当用户关闭一个对话框的时候，应用程序将其删除，那么，我们希望属于这个对话框的按钮、图标等应该一起被删除。事实就是如此，因为这些都是对话框的子组件。</p>
<p> 当然，<strong>我们也可以自己删除子对象，它们会自动从其父对象列表中删除。</strong>比如，当我们删除了一个工具栏时，其所在的主窗口会自动将该工具栏从其子对象列表中删除，并且自动调整屏幕显示。</p>
</blockquote>
</li>
</ol>
<p><strong>Qt 引入对象树的概念，在一定程度上解决了内存问题。</strong></p>
<ol>
<li><p>当一个QObject对象在堆上创建的时候，Qt 会同时为其创建一个对象树。不过，对象树中对象的顺序是没有定义的。这意味着，销毁这些对象的顺序也是未定义的。</p>
</li>
<li><p>任何对象树中的 QObject对象 delete 的时候，如果这个对象有 parent，则自动将其从 parent 的children()列表中删除；如果有孩子，则自动 delete 每一个孩子。<strong>Qt 保证没有QObject会被 delete 两次，这是由析构顺序决定的。</strong></p>
<p> 如果QObject在栈上创建，Qt 保持同样的行为。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    QWidget window;</span><br><span class="line">    <span class="function">QPushButton <span class="title">quit</span><span class="params">(<span class="string">&quot;Quit&quot;</span>, &amp;window)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 作为父组件的 window 和作为子组件的 quit 都是QObject的子类（事实上，它们都是QWidget的子类，而QWidget是QObject的子类）。这段代码是正确的，quit 的析构函数不会被调用两次，因为标准 C++要求，<strong>局部对象的析构顺序应该按照其创建顺序的相反过程</strong>。因此，这段代码在超出作用域时，会先调用 quit 的析构函数，将其从父对象 window 的子对象列表中删除，然后才会再调用 window 的析构函数。</p>
<p>但是，如果我们使用下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">QPushButton <span class="title">quit</span><span class="params">(<span class="string">&quot;Quit&quot;</span>)</span></span>;</span><br><span class="line">    QWidget window;</span><br><span class="line">    quit.<span class="built_in">setParent</span>(&amp;window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 情况又有所不同，析构顺序就有了问题。我们看到，在上面的代码中，作为父对象的 window 会首先被析构，因为它是最后一个创建的对象。在析构过程中，它会调用子对象列表中每一个对象的析构函数，也就是说， quit 此时就被析构了。然后，代码继续执行，在 window 析构之后，quit 也会被析构，因为 quit 也是一个局部变量，在超出作用域的时候当然也需要析构。但是，这时候已经是第二次调用 quit 的析构函数了，<strong>C++ 不允许调用两次析构函数</strong>，因此，程序崩溃了。</p>
<p>由此我们看到，Qt 的对象树机制虽然帮助我们在一定程度上解决了内存问题，但是也引入了一些值得注意的事情。这些细节在今后的开发过程中很可能时不时跳出来烦扰一下，所以，我们最好从开始就养成良好习惯，在 Qt 中，<strong>尽量在构造的时候就指定 parent 对象，并且大胆在堆上创建</strong>。</p>
<h2 id="4-3-QMainWindow"><a href="#4-3-QMainWindow" class="headerlink" title="4.3 QMainWindow"></a>4.3 QMainWindow</h2><p> QMainWindow是一个<strong>为用户提供主窗口程序的类，包含一个菜单栏（menu bar）、多个工具栏(tool bars)、多个锚接部件(dock widgets)、一个状态栏(status bar)及一个中心部件(central widget)，是许多应用程序的基础</strong>，如文本编辑器，图片编辑器等。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/clip_image024.gif" alt="img"></p>
<h3 id="4-3-1-菜单栏"><a href="#4-3-1-菜单栏" class="headerlink" title="4.3.1 菜单栏"></a>4.3.1 菜单栏</h3><p>一个主窗口最多只有一个菜单栏。位于主窗口顶部、主窗口标题栏下面。</p>
<ul>
<li><p>创建菜单栏，通过QMainWindow类的menubar（）函数获取主窗口菜单栏指针</p>
<p><code>QMenuBar * menuBar() const</code></p>
</li>
<li><p>创建菜单，调用QMenu的成员函数addMenu来添加菜单</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QAction* <span class="title">addMenu</span><span class="params">(QMenu * menu)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QMenu* <span class="title">addMenu</span><span class="params">(<span class="type">const</span> QString &amp; title)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QMenu* <span class="title">addMenu</span><span class="params">(<span class="type">const</span> QIcon &amp; icon, <span class="type">const</span> QString &amp; title)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建菜单项，调用QMenu的成员函数addAction来添加菜单项</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QAction* <span class="title">activeAction</span><span class="params">()</span> <span class="type">const</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QAction* <span class="title">addAction</span><span class="params">(<span class="type">const</span> QString &amp; text)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QAction* <span class="title">addAction</span><span class="params">(<span class="type">const</span> QIcon &amp; icon, <span class="type">const</span> QString &amp; text)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QAction* <span class="title">addAction</span><span class="params">(<span class="type">const</span> QString &amp; text, <span class="type">const</span> QObject * receiver,</span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> <span class="type">char</span> * member, <span class="type">const</span> QKeySequence &amp; shortcut = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">QAction* <span class="title">addAction</span><span class="params">(<span class="type">const</span> QIcon &amp; icon, <span class="type">const</span> QString &amp; text, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> QObject * receiver, <span class="type">const</span> <span class="type">char</span> * member, </span></span></span><br><span class="line"><span class="params"><span class="function"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="type">const</span> QKeySequence &amp; shortcut = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p> Qt 并没有专门的菜单项类，只是<strong>使用一个QAction类，抽象出公共的动作</strong>。当我们把QAction对象添加到菜单，就显示成一个菜单项，添加到工具栏，就显示成一个工具按钮。用户可以通过点击菜单项、点击工具栏按钮、点击快捷键来激活这个动作。</p>
<h3 id="4-3-2-工具栏"><a href="#4-3-2-工具栏" class="headerlink" title="4.3.2 工具栏"></a>4.3.2 工具栏</h3><p>主窗口的工具栏上可以有多个工具条，通常采用一个菜单对应一个工具条的的方式，也可根据需要进行工具条的划分。</p>
<ul>
<li>直接调用QMainWindow类的addToolBar（）函数获取主窗口的工具条对象，每增加一个工具条都需要调用一次该函数。</li>
<li>插入属于工具条的动作，即在工具条上添加操作。通过QToolBar类的addAction函数添加。</li>
<li>工具条是一个可移动的窗口，它的停靠区域由QToolBar的allowAreas决定，包括：</li>
</ul>
<blockquote>
<p>Qt::LeftToolBarArea 停靠在左侧</p>
<p>Qt::RightToolBarArea 停靠在右侧</p>
<p>Qt::TopToolBarArea 停靠在顶部</p>
<p>Qt::BottomToolBarArea 停靠在底部</p>
<p>Qt::AllToolBarAreas 以上四个位置都可停靠</p>
<p><strong>使用setAllowedAreas（）函数指定停靠区域：</strong></p>
<p>setAllowedAreas（Qt::LeftToolBarArea | Qt::RightToolBarArea）</p>
<p><strong>使用setMoveable（）函数设定工具栏的可移动性：</strong></p>
<p>setMoveable（false）//工具条不可移动, 只能停靠在初始化的位置上</p>
</blockquote>
<h3 id="4-3-3-状态栏"><a href="#4-3-3-状态栏" class="headerlink" title="4.3.3 状态栏"></a>4.3.3 状态栏</h3><p>派生自QWidget类，使用方法与QWidget类似，<strong>QStatusBar</strong>类常用成员函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加小部件</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addWidget</span><span class="params">(QWidget * widget, <span class="type">int</span> stretch = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">//插入小部件</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">insertWidget</span><span class="params">(<span class="type">int</span> index, QWidget * widget, <span class="type">int</span> stretch = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//删除小部件</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">removeWidget</span><span class="params">(QWidget * widget)</span></span></span><br></pre></td></tr></table></figure>
<h2 id="4-4-资源文件"><a href="#4-4-资源文件" class="headerlink" title="4.4 资源文件"></a>4.4 资源文件</h2><p> Qt 资源系统是一个跨平台的资源机制，用于将程序运行时所需要的资源以二进制的形式存储于可执行文件内部。如果你的程序需要加载特定的资源（图标、文本翻译等），那么，将其放置在资源文件中，就再也不需要担心这些文件的丢失。也就是说，如果你将资源以资源文件形式存储，它是会编译到可执行文件内部。</p>
<p>使用 Qt Creator 可以很方便地创建资源文件。我们可以在工程上点右键，选择“添加新文件…”，可以在 Qt 分类下找到“Qt 资源文件”：</p>
<p>点击“选择…”按钮，打开“新建 Qt 资源文件”对话框。在这里我们输入资源文件的名字和路径：</p>
<p>点击下一步，选择所需要的版本控制系统，然后直接选择完成。我们可以在 Qt Creator 的左侧文件列表中看到“资源文件”一项，也就是我们新创建的资源文件：</p>
<p>右侧的编辑区有个“添加”，我们首先需要添加前缀，比如我们将前缀取名为 images。然后选中这个前缀，继续点击添加文件，可以找到我们所需添加的文件。这里，我们选择 document-open.png 文件。当我们完成操作之后，Qt Creator 应该是这样子的：</p>
<p>接下来，我们还可以添加另外的前缀或者另外的文件。这取决于你的需要。当我们添加完成之后，我们可以像前面一章讲解的那样，通过使用 : 开头的路径来找到这个文件。比如，我们的前缀是 /images，文件是 document-open.png，那么就可以使用:/images/document-open.png找到这个文件。</p>
<p>这么做带来的一个问题是，如果以后我们要更改文件名，比如将 docuemnt-open.png 改成 docopen.png，那么，所有使用了这个名字的路径都需要修改。所以，更好的办法是，我们给这个文件去一个“别名”，以后就以这个别名来引用这个文件。具体做法是，选中这个文件，添加别名信息：</p>
<p>这样，我们可以直接使用:/images/doc-open引用到这个资源，无需关心图片的真实文件名。</p>
<h2 id="4-5-对话框QDialog"><a href="#4-5-对话框QDialog" class="headerlink" title="4.5 对话框QDialog"></a>4.5 对话框<strong>QDialog</strong></h2><h3 id="4-5-1-基本概念"><a href="#4-5-1-基本概念" class="headerlink" title="4.5.1 基本概念"></a>4.5.1 基本概念</h3><blockquote>
<p> 对话框是 GUI 程序中不可或缺的组成部分。很多不能或者不适合放入主窗口的功能组件都必须放在对话框中设置。对话框通常会是一个顶层窗口，出现在程序最上层，用于实现短期任务或者简洁的用户交互。</p>
<p> Qt 中使用QDialog类实现对话框。就像主窗口一样，我们通常会设计一个类继承QDialog。QDialog（及其子类，以及所有Qt::Dialog类型的类）的对于其 parent 指针都有额外的解释：<strong>如果 parent 为 NULL，则该对话框会作为一个顶层窗口，否则则作为其父组件的子对话框（此时，其默认出现的位置是 parent 的中心）。顶层窗口与非顶层窗口的区别在于，顶层窗口在任务栏会有自己的位置，而非顶层窗口则会共享其父组件的位置。</strong> <strong>对话框分为模态对话框和非模态对话框。</strong></p>
<ul>
<li>模态对话框，就是会<strong>阻塞同一应用程序中其它窗口的输入</strong>。模态对话框很常见，比如“打开文件”功能。你可以尝试一下记事本的打开文件，当打开文件对话框出现时，我们是不能对除此对话框之外的窗口部分进行操作的。</li>
<li>与此相反的是非模态对话框，例如查找对话框，我们可以在显示着查找对话框的同时，继续对记事本的内容进行编辑。</li>
</ul>
</blockquote>
<h3 id="4-5-2-标准对话框"><a href="#4-5-2-标准对话框" class="headerlink" title="4.5.2 标准对话框"></a>4.5.2 标准对话框</h3><p> 所谓标准对话框，是 Qt 内置的一系列对话框，用于简化开发。事实上，有很多对话框都是通用的，比如打开文件、设置颜色、打印设置等。这些对话框在所有程序中几乎相同，因此没有必要在每一个程序中都自己实现这么一个对话框。</p>
<p>Qt 的内置对话框大致分为以下几类：</p>
<ul>
<li>QColorDialog： 选择颜色；</li>
<li>QFileDialog： 选择文件或者目录；</li>
<li>QFontDialog： 选择字体；</li>
<li>QInputDialog： 允许用户输入一个值，并将其值返回；</li>
<li>QMessageBox： 模态对话框，用于显示信息、询问问题等；</li>
<li>QPageSetupDialog： 为打印机提供纸张相关的选项；</li>
<li>QPrintDialog： 打印机配置；</li>
<li>QPrintPreviewDialog：打印预览；</li>
<li>QProgressDialog： 显示操作过程。</li>
</ul>
<h3 id="4-5-3-自定义消息框"><a href="#4-5-3-自定义消息框" class="headerlink" title="4.5.3 自定义消息框"></a>4.5.3 自定义消息框</h3><p>Qt 支持模态对话框和非模态对话框。</p>
<p>模态与非模态的实现：</p>
<ul>
<li>使用QDialog::exec()实现应用程序级别的模态对话框</li>
<li>使用QDialog::open()实现窗口级别的模态对话框</li>
<li>使用QDialog::show()实现非模态对话框。</li>
</ul>
<h4 id="模态对话框"><a href="#模态对话框" class="headerlink" title="模态对话框"></a>模态对话框</h4><blockquote>
<p> Qt 有两种级别的模态对话框：</p>
<ul>
<li>应用程序级别的模态</li>
</ul>
<p>当该种模态的对话框出现时，用户必须<strong>首先对对话框进行交互，直到关闭对话框，然后才能访问程序中其他的窗口</strong>。</p>
<ul>
<li>窗口级别的模态</li>
</ul>
<p>该模态仅仅阻塞与对话框关联的窗口，但是<strong>依然允许用户与程序中其它窗口交互</strong>。窗口级别的模态尤其适用于多窗口模式。</p>
<p>一般默认是应用程序级别的模态。</p>
<p>在下面的示例中，我们调用了exec()将对话框显示出来，因此这就是一个模态对话框。当对话框出现时，我们不能与主窗口进行任何交互，直到我们关闭了该对话框。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::open</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">       QDialog dialog;</span><br><span class="line">       dialog.<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Hello, dialog!&quot;</span>));</span><br><span class="line">	   dialog.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">非模态对话框</span><br><span class="line">下面我们试着将<span class="built_in">exec</span>()修改为<span class="built_in">show</span>()，看看非模态对话框：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::open</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QDialog <span class="title">dialog</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    dialog.<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Hello, dialog!&quot;</span>));</span><br><span class="line">    dialog.<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对话框竟然一闪而过！这是因为，<strong>show()函数不会阻塞当前线程，对话框会显示出来，然后函数立即返回，代码继续执行。</strong>注意，dialog 是建立在栈上的，show()函数返回，MainWindow::open()函数结束，dialog 超出作用域被析构，因此对话框消失了。知道了原因就好改了，我们将 dialog 改成堆上建立，当然就没有这个问题了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::open</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QDialog *dialog = <span class="keyword">new</span> QDialog;</span><br><span class="line">    dialog-&gt;<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Hello, dialog!&quot;</span>));</span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>dialog 存在内存泄露</strong>！dialog 使用 new 在堆上分配空间，却一直没有 delete。解决方案也很简单：将 MainWindow 的指针赋给 dialog 即可。还记得我们前面说过的 Qt 的对象系统吗？</p>
<p> 不过，这样做有一个问题：如果我们的对话框不是在一个界面类中出现呢？由于QWidget的 parent 必须是QWidget指针，那就限制了我们不能将一个普通的 C++ 类指针传给 Qt 对话框。另外，如果对内存占用有严格限制的话，当我们将主窗口作为 parent 时，主窗口不关闭，对话框就不会被销毁，所以会一直占用内存。在这种情景下，我们可以设置 dialog 的WindowAttribute：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::open</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QDialog *dialog = <span class="keyword">new</span> QDialog;</span><br><span class="line">    dialog-&gt;<span class="built_in">setAttribute</span>(Qt::WA_DeleteOnClose);</span><br><span class="line">    dialog-&gt;<span class="built_in">setWindowTitle</span>(<span class="built_in">tr</span>(<span class="string">&quot;Hello, dialog!&quot;</span>));</span><br><span class="line">    dialog-&gt;<span class="built_in">show</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>setAttribute() </strong> <strong>函数设置对话框关闭时，自动销毁对话框。</strong></p>
</blockquote>
<h3 id="4-5-4-消息对话框"><a href="#4-5-4-消息对话框" class="headerlink" title="4.5.4 消息对话框"></a>4.5.4 消息对话框</h3><p><strong>QMessageBox</strong>用于显示消息提示。我们一般会使用其提供的几个 static 函数：</p>
<ul>
<li>显示关于对话框。</li>
</ul>
<p>void about(QWidget * parent, const QString &amp; title, const QString &amp; text)</p>
<p>这是一个最简单的对话框，其标题是 title，内容是 text，父窗口是 parent。对话框只有一个 OK 按钮。</p>
<ul>
<li>显示关于 Qt 对话框。该对话框用于显示有关 Qt 的信息。</li>
</ul>
<p>void aboutQt(QWidget * parent, const QString &amp; title = QString())：</p>
<ul>
<li>显示严重错误对话框。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">critical</span><span class="params">(QWidget * parent, <span class="type">const</span> QString &amp; title, <span class="type">const</span> QString &amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)</span></span></span><br></pre></td></tr></table></figure>
<p> 这个对话框将显示一个红色的错误符号。我们可以通过 buttons 参数指明其显示的按钮。默认情况下只有一个 Ok 按钮，我们可以使用StandardButtons类型指定多种按钮。</p>
<ul>
<li>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个普通信息图标。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">information</span><span class="params">(QWidget * parent, <span class="type">const</span> QString &amp; title, <span class="type">const</span> QString &amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个问号图标，并且其显示的按钮是“是”和“否”。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">question</span><span class="params">(QWidget * parent,<span class="type">const</span> QString &amp; title, <span class="type">const</span> QString &amp; text, StandardButtons buttons = StandardButtons( Yes | No ), StandardButton defaultButton = NoButton)</span> </span></span><br></pre></td></tr></table></figure>
<ul>
<li>与QMessageBox::critical()类似，不同之处在于这个对话框提供一个黄色叹号图标。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StandardButton <span class="title">warning</span><span class="params">(QWidget * parent, <span class="type">const</span> QString &amp; title, <span class="type">const</span> QString &amp; text, StandardButtons buttons = Ok, StandardButton defaultButton = NoButton)</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以通过下面的代码来演示下如何使用QMessageBox。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (QMessageBox::Yes == QMessageBox::<span class="built_in">question</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;Question&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;Are you OK?&quot;</span>),</span><br><span class="line">QMessageBox::Yes | QMessageBox::No,QMessageBox::Yes)) </span><br><span class="line">&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Hmmm...&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;I&#x27;m glad to hear that!&quot;</span>));</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Hmmm...&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;I&#x27;m sorry!&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用QMessageBox::question()来询问一个问题。</p>
<blockquote>
<ul>
<li>这个对话框的父窗口是 this。QMessageBox是QDialog的子类，这意味着它的初始显示位置将会是在 parent 窗口的中央。</li>
<li>第二个参数是对话框的标题。</li>
<li>第三个参数是我们想要显示的内容。这里就是我们需要询问的文字。下面，我们使用或运算符（|）指定对话框应该出现的按钮。这里我们希望是一个 Yes 和一个 No。</li>
<li>最后一个参数指定默认选择的按钮。</li>
</ul>
</blockquote>
<p> 这个函数有一个返回值，用于确定用户点击的是哪一个按钮。按照我们的写法，应该很容易的看出，这是一个模态对话框，因此我们可以直接获取其返回值。</p>
<p> QMessageBox类的 static 函数优点是方便使用，缺点也很明显：非常不灵活。我们只能使用简单的几种形式。为了能够定制QMessageBox细节，我们必须使用QMessageBox的属性设置 API。如果我们希望制作一个询问是否保存的对话框，我们可以使用如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">QMessageBox msgBox;</span><br><span class="line">msgBox.<span class="built_in">setText</span>(<span class="built_in">tr</span>(<span class="string">&quot;The document has been modified.&quot;</span>));</span><br><span class="line">msgBox.<span class="built_in">setInformativeText</span>(<span class="built_in">tr</span>(<span class="string">&quot;Do you want to save your changes?&quot;</span>));</span><br><span class="line">msgBox.<span class="built_in">setDetailedText</span>(<span class="built_in">tr</span>(<span class="string">&quot;Differences here...&quot;</span>));</span><br><span class="line">msgBox.<span class="built_in">setStandardButtons</span>(QMessageBox::Save | QMessageBox::Discard| QMessageBox::Cancel);</span><br><span class="line">msgBox.<span class="built_in">setDefaultButton</span>(QMessageBox::Save);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ret = msgBox.<span class="built_in">exec</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (ret) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Save:</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Save document!&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Discard:</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Discard changes!&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> QMessageBox::Cancel:</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Close document!&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> msgBox 是一个建立在栈上的QMessageBox实例。我们设置其主要文本信息为“The document has been modified.”，informativeText 则是会在对话框中显示的简单说明文字。下面我们使用了一个detailedText，也就是详细信息，当我们点击了详细信息按钮时，对话框可以自动显示更多信息。我们自己定义的对话框的按钮有三个：保存、丢弃和取消。然后我们使用了exec()是其成为一个模态对话框，根据其返回值进行相应的操作。</p>
<h3 id="4-5-5-标准文件对话框"><a href="#4-5-5-标准文件对话框" class="headerlink" title="4.5.5 标准文件对话框"></a>4.5.5 标准文件对话框</h3><p> QFileDialog，也就是文件对话框。我们尝试编写一个简单的文本文件编辑器，我们将使用QFileDialog来打开一个文本文件，并将修改过的文件保存到硬盘。</p>
<p> 首先，我们需要创建一个带有文本编辑功能的窗口。借用我们前面的程序代码，应该可以很方便地完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">openAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/images/file-open&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;&amp;Open...&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">openAction-&gt;<span class="built_in">setShortcuts</span>(QKeySequence::Open);</span><br><span class="line"></span><br><span class="line">openAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Open an existing file&quot;</span>));</span><br><span class="line"></span><br><span class="line">saveAction = <span class="keyword">new</span> <span class="built_in">QAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/images/file-save&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;&amp;Save...&quot;</span>), <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">saveAction-&gt;<span class="built_in">setShortcuts</span>(QKeySequence::Save);</span><br><span class="line"></span><br><span class="line">saveAction-&gt;<span class="built_in">setStatusTip</span>(<span class="built_in">tr</span>(<span class="string">&quot;Save a new file&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">QMenu *file = <span class="built_in">menuBar</span>()-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">file-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">file-&gt;<span class="built_in">addAction</span>(saveAction);</span><br><span class="line"></span><br><span class="line">QToolBar *toolBar = <span class="built_in">addToolBar</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(openAction);</span><br><span class="line">toolBar-&gt;<span class="built_in">addAction</span>(saveAction);</span><br><span class="line"></span><br><span class="line">textEdit = <span class="keyword">new</span> <span class="built_in">QTextEdit</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">setCentralWidget</span>(textEdit);</span><br></pre></td></tr></table></figure>
<p> 我们在菜单和工具栏添加了两个动作：打开和保存。接下来是一个QTextEdit类，这个类用于显示富文本文件。也就是说，它不仅仅用于显示文本，还可以显示图片、表格等等。不过，我们现在只用它显示纯文本文件。QMainWindow有一个setCentralWidget()函数，可以将一个组件作为窗口的中心组件，放在窗口中央显示区。显然，在一个文本编辑器中，文本编辑区就是这个中心组件，因此我们将QTextEdit作为这种组件。</p>
<p>我们使用connect()函数，为这两个QAction对象添加响应的动作：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">connect</span>(openAction, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::openFile);</span><br><span class="line"></span><br><span class="line"><span class="built_in">connect</span>(saveAction, &amp;QAction::triggered, <span class="keyword">this</span>, &amp;MainWindow::saveFile);</span><br></pre></td></tr></table></figure>
<p>下面是最主要的openFile()和saveFile()这两个函数的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::openFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString path = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Open File&quot;</span>), <span class="string">&quot;.&quot;</span>, <span class="built_in">tr</span>(<span class="string">&quot;Text Files(*.txt)&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!path.<span class="built_in">isEmpty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QFile <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::ReadOnly | QIODevice::Text)) </span><br><span class="line">        &#123;</span><br><span class="line">            QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Read File&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;Cannot open file:\n%1&quot;</span>).<span class="built_in">arg</span>(path));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">QTextStream <span class="title">in</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        textEdit-&gt;<span class="built_in">setText</span>(in.<span class="built_in">readAll</span>());</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Path&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;You did not select any file.&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainWindow::saveFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString path = QFileDialog::<span class="built_in">getSaveFileName</span>(<span class="keyword">this</span>,<span class="built_in">tr</span>(<span class="string">&quot;Open File&quot;</span>), <span class="string">&quot;.&quot;</span>, <span class="built_in">tr</span>(<span class="string">&quot;Text Files(*.txt)&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!path.<span class="built_in">isEmpty</span>()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">QFile <span class="title">file</span><span class="params">(path)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!file.<span class="built_in">open</span>(QIODevice::WriteOnly | QIODevice::Text)) </span><br><span class="line">        &#123;</span><br><span class="line">            QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Write File&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;Cannot open file:\n%1&quot;</span>).<span class="built_in">arg</span>(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">QTextStream <span class="title">out</span><span class="params">(&amp;file)</span></span>;</span><br><span class="line">        out &lt;&lt; textEdit-&gt;<span class="built_in">toPlainText</span>();</span><br><span class="line">        file.<span class="built_in">close</span>();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        QMessageBox::<span class="built_in">warning</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Path&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;You did not select any file.&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在openFile()函数中，我们使用QFileDialog::getOpenFileName()来获取需要打开的文件的路径。这个函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">getOpenFileName</span><span class="params">(QWidget * parent = <span class="number">0</span>, <span class="type">const</span> QString &amp; caption = QString(), <span class="type">const</span> QString &amp; dir = QString(), <span class="type">const</span> QString &amp; filter = QString(), QString * selectedFilter = <span class="number">0</span>,Options options = <span class="number">0</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>不过注意，它的所有参数都是可选的，因此在一定程度上说，这个函数也是简单的。这六个参数分别是：</p>
<ul>
<li>parent：父窗口。Qt 的标准对话框提供静态函数，用于返回一个模态对话框；</li>
<li>caption：对话框标题；</li>
<li>dir：对话框打开时的默认目录</li>
</ul>
<blockquote>
<p>“.” 代表程序运行目录</p>
<p>“/” 代表当前盘符的根目录（特指 Windows 平台；Linux 平台当然就是根目录），这个参数也可以是平台相关的，比如“C:\”等；</p>
</blockquote>
<ul>
<li>filter：过滤器。</li>
</ul>
<blockquote>
<p> 我们使用文件对话框可以浏览很多类型的文件，但是，很多时候我们仅希望打开特定类型的文件。比如，文本编辑器希望打开文本文件，图片浏览器希望打开图片文件。<strong>过滤器就是用于过滤特定的后缀名</strong>。如果我们使用“Image Files(<em>.jpg \</em>.png)”，则只能显示后缀名是 jpg 或者 png 的文件。<strong>如果需要多个过滤器，使用“;;”分割</strong>，比如“JPEG Files(*.jpg);;PNG Files(*.png)”；</p>
</blockquote>
<ul>
<li>selectedFilter：默认选择的过滤器；</li>
<li>options：对话框的一些参数设定。比如只显示文件夹等等，它的取值是enum QFileDialog::Option，每个选项可以使用 | 运算组合起来。</li>
</ul>
<blockquote>
<p> <strong>QFileDialog::getOpenFileName() </strong> <strong>返回值是选择的文件路径。 </strong>我们将其赋值给 path。通过判断 path 是否为空，可以确定用户是否选择了某一文件。只有当用户选择了一个文件时，我们才执行下面的操作。</p>
<p> 在saveFile()中使用的QFileDialog::getSaveFileName()也是类似的。使用这种静态函数，在 Windows、Mac OS 上面都是直接调用本地对话框，但是 Linux 上则是QFileDialog自己的模拟。这暗示了，如果你不使用这些静态函数，而是直接使用QFileDialog进行设置，那么得到的对话框很可能与系统对话框的外观不一致。这一点是需要注意的。</p>
</blockquote>
<h2 id="4-6-常用控件"><a href="#4-6-常用控件" class="headerlink" title="4.6 常用控件"></a>4.6 常用控件</h2><p>Qt为我们应用程序界面开发提供的一系列的控件，下面我们介绍两种最常用的两种，所有控件的使用方法我们都可以通过帮助文档获取。</p>
<h3 id="4-6-1-QLabel控件使用"><a href="#4-6-1-QLabel控件使用" class="headerlink" title="4.6.1 QLabel控件使用"></a>4.6.1 QLabel控件使用</h3><p>QLabel是我们最常用的控件之一，其功能很强大，我们可以用来显示文本，图片和动画等。</p>
<h4 id="显示文字-（普通文本、html）"><a href="#显示文字-（普通文本、html）" class="headerlink" title="显示文字 （普通文本、html）"></a>显示文字 （普通文本、html）</h4><p>通过QLabel类的setText函数设置显示的内容:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>   <span class="title">setText</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以显示普通文本字符串</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">QLable *label = <span class="keyword">new</span> QLable;</span><br><span class="line"></span><br><span class="line">label-&gt;<span class="built_in">setText</span>(“Hello, World!”);</span><br></pre></td></tr></table></figure>
<ul>
<li>可以显示HTML格式的字符串。比如显示一个链接:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">label -&gt;<span class="built_in">setText</span>(<span class="string">&quot;Hello, World&quot;</span>);</span><br><span class="line">label -&gt;<span class="built_in">setText</span>(<span class="string">&quot;&lt;h1&gt;&lt;a href=\&quot;https://www.baidu.com\&quot;&gt;百度一下&lt;/a&gt;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">label -&gt;<span class="built_in">setOpenExternalLinks</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p> 其中setOpenExternalLinks()函数是用来设置用户点击链接之后是否自动打开链接，<strong>如果参数指定为true则会自动打开</strong>，如果设置为false，想要打开链接只能通过捕捉linkActivated()信号，在自定义的槽函数中使用<strong>QDesktopServices::openUrl()</strong>打开链接，该函数参数默认值为false</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> <span class="built_in">QLabel</span>(<span class="keyword">this</span>);</span><br><span class="line">label -&gt;<span class="built_in">setText</span>(<span class="string">&quot;Hello, World&quot;</span>);</span><br><span class="line">label -&gt;<span class="built_in">setText</span>(<span class="string">&quot;&lt;h1&gt;&lt;a href=\&quot;https://www.baidu.com\&quot;&gt;百度一下&lt;/a&gt;&lt;/h1&gt;&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// label-&gt;setOpenExternalLinks(true);</span></span><br><span class="line"><span class="built_in">connect</span>(label, &amp;QLabel::linkActivated, <span class="keyword">this</span>, &amp;MyWidget::slotOpenUrl);</span><br><span class="line"></span><br><span class="line"><span class="comment">//槽函数    </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::slotOpenUrl</span><span class="params">(<span class="type">const</span> QString &amp;link)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QDesktopServices::<span class="built_in">openUrl</span>(<span class="built_in">QUrl</span>(link));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="显示图片"><a href="#显示图片" class="headerlink" title="显示图片"></a>显示图片</h4><blockquote>
<p>可以使用QLabel的成员函数setPixmap设置图片</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setPixmap</span><span class="params">(<span class="type">const</span> QPixmap &amp;)</span></span></span><br></pre></td></tr></table></figure>
<p>首先定义QPixmap对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QPixmap pixmap;</span><br></pre></td></tr></table></figure>
<p>然后加载图片</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pixmap.<span class="built_in">load</span>(<span class="string">&quot;:/Image/boat.jpg&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>最后将图片设置到QLabel中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> QLabel;</span><br><span class="line">label.<span class="built_in">setPixmap</span>(pixmap);</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="显示动画"><a href="#显示动画" class="headerlink" title="显示动画"></a>显示动画</h4><blockquote>
<p>可以使用QLabel 的成员函数setMovie加载动画，可以播放gif格式的文件</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setMovie</span><span class="params">(QMovie * movie)</span></span></span><br></pre></td></tr></table></figure>
<p>首先定义QMovied对象，并初始化:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QMovie *movie = <span class="keyword">new</span> <span class="built_in">QMovie</span>(<span class="string">&quot;:/Mario.gif&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>播放加载的动画：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movie-&gt;<span class="built_in">start</span>();</span><br></pre></td></tr></table></figure>
<p>将动画设置到QLabel中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLabel *label = <span class="keyword">new</span> QLabel；</span><br><span class="line">label-&gt;<span class="built_in">setMovie</span>(movie);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="4-6-2-QLineEdit"><a href="#4-6-2-QLineEdit" class="headerlink" title="4.6.2 QLineEdit"></a>4.6.2 QLineEdit</h3><p>Qt提供的单行文本编辑框。</p>
<h4 id="设置-获取内容"><a href="#设置-获取内容" class="headerlink" title="设置/获取内容"></a>设置/获取内容</h4><ul>
<li>获取编辑框内容使用text（），函数声明如下：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QString <span class="title">text</span><span class="params">()</span> <span class="type">const</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>设置编辑框内容</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setText</span><span class="params">(<span class="type">const</span> QString &amp;)</span></span></span><br></pre></td></tr></table></figure>
<h4 id="设置显示模式"><a href="#设置显示模式" class="headerlink" title="设置显示模式"></a>设置显示模式</h4><p>使用QLineEdit类的setEchoMode () 函数设置文本的显示模式,函数声明:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>   <span class="title">setEchoMode</span><span class="params">(EchoMode mode)</span></span></span><br></pre></td></tr></table></figure>
<p>EchoMode是一个枚举类型,一共定义了四种显示模式:</p>
<ul>
<li>QLineEdit::Normal 模式显示方式，按照输入的内容显示。</li>
<li>QLineEdit::NoEcho 不显示任何内容，此模式下无法看到用户的输入。</li>
<li>QLineEdit::Password 密码模式，输入的字符会根据平台转换为特殊字符。</li>
<li>QLineEdit::PasswordEchoOnEdit 编辑时显示字符否则显示字符作为密码。</li>
</ul>
<p>另外，我们再使用QLineEdit显示文本的时候，希望在左侧留出一段空白的区域，那么就可以使用QLineEdit给我们提供的setTextMargins函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setTextMargins</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> top, <span class="type">int</span> right, <span class="type">int</span> bottom)</span></span></span><br></pre></td></tr></table></figure>
<p>用此函数可以<strong>指定显示的文本与输入框上下左右边界的间隔的像素数。</strong></p>
<h4 id="设置输入提示"><a href="#设置输入提示" class="headerlink" title="设置输入提示"></a>设置输入提示</h4><p>如果我们想实现一个与百度的搜索框类似的功能：输入一个或几个字符，下边会列出几个跟输入的字符相匹配的字符串，QLineEdit要实现这样的功能可以使用该类的成员函数setComleter()函数来实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setCompleter</span><span class="params">(QCompleter * c)</span></span></span><br></pre></td></tr></table></figure>
<p>创建QCompleter对象，并初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QStringList tipList;</span><br><span class="line">tipList&lt;&lt; “Hello” &lt;&lt; “how are you” &lt;&lt; “Haha” &lt;&lt; “oh, hello”;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不区分大小写</span></span><br><span class="line">completer-&gt;<span class="built_in">setCaseSensitivity</span>(Qt::CaseInsensitive);</span><br><span class="line">QCompleter *completer = <span class="keyword">new</span> <span class="built_in">QCompleter</span>(tipList, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>QCompleter类的setCaseSensitivity()函数可以设置是否区分大小写，它的参数是一个枚举类型：</p>
<ul>
<li>Qt::CaseInsensitive 不区分大小写</li>
<li>Qt::CaseSensitive 区分大小写</li>
</ul>
<p>如果不设置该属性，默认匹配字符串时是区分大小写的。</p>
<p>另外我们还可以设置字符串其中某一部分匹配，此功能可通过QCompleter类的setFilterMode函数来实现,函数声明如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">setFilterMode</span><span class="params">(Qt::MatchFlags filterMode)</span></span></span><br></pre></td></tr></table></figure>
<p>其参数为Qt定义的宏,有多重类型,具体可参考Qt帮助稳定，要实现我们上边提到的功能，参数可以使用 Qt::MatchContains：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">completer-&gt;<span class="built_in">setFilterMode</span>(Qt::MatchContains);</span><br></pre></td></tr></table></figure>
<p>属性设置完成之后，将QCompleter对象设置到QLineEdit中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">QLineEdit *edit = <span class="keyword">new</span> <span class="built_in">QLineEdit</span>(<span class="keyword">this</span>);</span><br><span class="line">edit-&gt;<span class="built_in">setCompleter</span>(completer);</span><br></pre></td></tr></table></figure>
<h2 id="4-7-布局管理器"><a href="#4-7-布局管理器" class="headerlink" title="4.7 布局管理器"></a>4.7 布局管理器</h2><p> 所谓 GUI 界面，归根结底，就是一堆组件的叠加。我们创建一个窗口，把按钮放上面，把图标放上面，这样就成了一个界面。在放置时，组件的位置尤其重要。我们<strong>必须要指定组件放在哪里，以便窗口能够按照我们需要的方式进行渲染</strong>。这就涉及到组件定位的机制。<strong>Qt</strong> <strong>提供了两种组件定位机制：绝对定位和布局定位。</strong></p>
<ul>
<li>绝对定位就是一种最原始的定位方法：给出这个组件的坐标和长宽值。</li>
</ul>
<blockquote>
<p>这样，Qt 就知道该把组件放在哪里以及如何设置组件的大小。但是这样做带来的一个问题是，如果用户改变了窗口大小，比如点击最大化按钮或者使用鼠标拖动窗口边缘，采用绝对定位的组件是不会有任何响应的。这也很自然，因为你并没有告诉 Qt，在窗口变化时，组件是否要更新自己以及如何更新。或者，还有更简单的方法：禁止用户改变窗口大小。但这总不是长远之计。</p>
</blockquote>
<ul>
<li>布局定位：你只要把组件放入某一种布局，布局由专门的布局管理器进行管理。当需要调整大小或者位置的时候，Qt 使用对应的布局管理器进行调整。</li>
</ul>
<blockquote>
<p>布局定位完美的解决了使用绝对定位的缺陷。</p>
<p>Qt 提供的布局中以下三种是我们最常用的：</p>
<ul>
<li>QHBoxLayout：按照水平方向从左到右布局；</li>
<li>QVBoxLayout：按照竖直方向从上到下布局；</li>
<li>QGridLayout：在一个网格中进行布局，类似于 HTML 的 table；</li>
</ul>
</blockquote>
<h3 id="4-7-1-水平-垂直-网格布局"><a href="#4-7-1-水平-垂直-网格布局" class="headerlink" title="4.7.1 水平/垂直/网格布局"></a>4.7.1 水平/垂直/网格布局</h3><p>下面我们通过一个例子来学习以下水平布局管理器的使用方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">   </span><br><span class="line">    QWidget window;</span><br><span class="line">    window.<span class="built_in">setWindowTitle</span>(<span class="string">&quot;Enter your age&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    QSpinBox *spinBox = <span class="keyword">new</span> <span class="built_in">QSpinBox</span>(&amp;window);</span><br><span class="line">    QSlider *slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal, &amp;window);</span><br><span class="line"></span><br><span class="line">    spinBox-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">130</span>);</span><br><span class="line">    slider-&gt;<span class="built_in">setRange</span>(<span class="number">0</span>, <span class="number">130</span>);</span><br><span class="line"></span><br><span class="line">	QObject::<span class="built_in">connect</span>(slider, &amp;QSlider::valueChanged, spinBox, &amp;QSpinBox::setValue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">void</span> (QSpinBox:: *spinBoxSignal)(<span class="type">int</span>) = &amp;QSpinBox::valueChanged;</span><br><span class="line"></span><br><span class="line">	QObject::<span class="built_in">connect</span>(spinBox, spinBoxSignal, slider, &amp;QSlider::setValue);</span><br><span class="line"></span><br><span class="line">    spinBox-&gt;<span class="built_in">setValue</span>(<span class="number">35</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给控件设置布局</span></span><br><span class="line">    QHBoxLayout *layout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(spinBox);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(slider);</span><br><span class="line"></span><br><span class="line">	window.<span class="built_in">setLayout</span>(layout);</span><br><span class="line">    window.<span class="built_in">show</span>();</span><br><span class="line">    <span class="keyword">return</span> app.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在这段代码中引入了两个新的组件：QSpinBox和QSlider。<strong>QSpinBox就是只能输入数字的输入框，并且带有上下箭头的步进按钮。QSlider则是带有滑块的滑竿。</strong></p>
<p><a target="_blank" rel="noopener" href="https://github.com/gochao/QT-1/blob/master/QT快速入门.assets/clip_image037.jpg"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/clip_image037.jpg" alt="img"></a></p>
<p>上面的代码中<strong>window.setLayout(layout);</strong> 是将布局设置到窗口window中，在窗口中设置布局还有另一种写法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//给控件设置布局</span></span><br><span class="line">QHBoxLayout *layout = <span class="keyword">new</span> QHBoxLayout（window）;</span><br><span class="line"></span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(spinBox);</span><br><span class="line">layout-&gt;<span class="built_in">addWidget</span>(slider);</span><br></pre></td></tr></table></figure>
<p><strong>在创建布局对象的时候给新对象指定父窗口，就等于给传入的窗口设置了布局</strong>。</p>
<p>另外布局与布局之间是可以<strong>嵌套使用</strong>的，使用addLayout（）方法。QVBoxLayout的使用方法与QHBoxLayout完全相同。</p>
<p><strong>关于上述代码中信号和槽连接的解释：</strong></p>
<blockquote>
<p>当数字输入框显示的内容发生改变的时候，会发出一股信息，滑块会接收这一信号，并作出改变。如果二者的信号槽连接写成下边这样：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(spinBox, &amp;QSpinBox::valueChanged, slider, &amp;QSlider::setValue);</span><br></pre></td></tr></table></figure>
<p>编译器却会报错</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">no matching function <span class="keyword">for</span> call to <span class="string">&#x27;QObject::connect(QSpinBox*&amp;, &lt;unresolved overloaded function type&gt;, QSlider*&amp;, void (QAbstractSlider::*)(int))&#x27;</span></span><br></pre></td></tr></table></figure>
<p> 这是怎么回事呢？从出错信息可以看出，编译器认为QSpinBox::valueChanged是一个 overloaded 的函数。我们看一下QSpinBox的文档发现，QSpinBox的确有两个信号：</p>
<ul>
<li>void valueChanged(int)</li>
<li><p>void valueChanged(const QString &amp;)</p>
<p>当我们使用&amp;QSpinBox::valueChanged取函数指针时，编译器不知道应该取哪一个函数（记住前面我们介绍过的，signal 也是一个普通的函数。）的地址，因此报错。解决的方法很简单，编译器不是不能确定哪一个函数吗？那么我们就显式指定一个函数。方法就是，我们创建一个函数指针，这个函数指针参数指定为 int：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> (QSpinBox:: *spinBoxSignal)(<span class="type">int</span>) = &amp;QSpinBox::valueChanged;</span><br></pre></td></tr></table></figure>
<p>然后我们将这个函数指针作为 signal，与 QSlider 的函数连接：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">QObject::<span class="built_in">connect</span>(spinBox, spinBoxSignal, slider, &amp;QSlider::setValue);</span><br></pre></td></tr></table></figure>
<p>这样便避免了编译错误。</p>
</blockquote>
<h4 id="动手"><a href="#动手" class="headerlink" title="动手"></a>动手</h4><p>通过布局管理器搭建如下登陆界面：</p>
<h3 id="4-7-2-自定义控件"><a href="#4-7-2-自定义控件" class="headerlink" title="4.7.2 自定义控件"></a>4.7.2 自定义控件</h3><p>在搭建Qt窗口界面的时候，在一个项目中很多窗口，或者是窗口中的某个模块会被经常性的重复使用。一般遇到这种情况我们都会将这个窗口或者模块拿出来做成一个独立的窗口类，以备以后重复使用。</p>
<p>在使用Qt的ui文件搭建界面的时候，工具栏栏中只为我们提供了标准的窗口控件，如果我们想使用自定义控件怎么办？</p>
<p>例如：我们从QWidget派生出一个类SmallWidget，实现了一个自定窗口，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smallwidget.h</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SmallWidget</span> : <span class="keyword">public</span> QWidget</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">SmallWidget</span><span class="params">(QWidget *parent = <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    signals:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> slots:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        QSpinBox* spin;</span><br><span class="line">        QSlider* slider;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smallwidget.cpp</span></span><br><span class="line">SmallWidget::<span class="built_in">SmallWidget</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    spin = <span class="keyword">new</span> <span class="built_in">QSpinBox</span>(<span class="keyword">this</span>);</span><br><span class="line">    slider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建布局对象</span></span><br><span class="line">    QHBoxLayout* layout = <span class="keyword">new</span> QHBoxLayout;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将控件添加到布局中</span></span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(spin);</span><br><span class="line">    layout-&gt;<span class="built_in">addWidget</span>(slider);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将布局设置到窗口中</span></span><br><span class="line">    <span class="built_in">setLayout</span>(layout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加消息响应</span></span><br><span class="line">    <span class="built_in">connect</span>(spin, <span class="built_in">static_cast</span>&lt;<span class="built_in">void</span> (QSpinBox::*)(<span class="type">int</span>)&gt;(&amp;QSpinBox::valueChanged),slider, &amp;QSlider::setValue);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">connect</span>(slider, &amp;QSlider::valueChanged, spin, &amp;QSpinBox::setValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这个SmallWidget可以作为独立的窗口显示,也可以作为一个控件来使用：</p>
<p>打开Qt的.ui文件,因为SmallWidget是派生自Qwidget类,所以需要在ui文件中先放入一个QWidget控件, 然后再上边鼠标右键</p>
<p>弹出提升窗口部件对话框</p>
<p>添加要提升的类的名字,然后选择 添加</p>
<p>添加之后,类名会显示到上边的列表框中,然后单击提升按钮,完成操作.</p>
<p>我们可以看到, 这个窗口对应的类从原来的QWidget变成了SmallWidget</p>
<p>再次运行程序,这个widget_3中就能显示出我们自定义的窗口了.</p>
<h1 id="Qt消息机制和事件"><a href="#Qt消息机制和事件" class="headerlink" title="Qt消息机制和事件"></a>Qt消息机制和事件</h1><h2 id="5-1-事件"><a href="#5-1-事件" class="headerlink" title="5.1 事件"></a>5.1 事件</h2><p> 事件（event）是由系统或者 Qt 本身在不同的时刻发出的。当用户按下鼠标、敲下键盘，或者是窗口需要重新绘制的时候，都会发出一个相应的事件。一些事件在对用户操作做出响应时发出，如键盘事件等；另一些事件则是由系统自动发出，如计时器事件。</p>
<p> 在前面我们也曾经简单提到，<strong>Qt 程序</strong>需要在main()函数创建一个QApplication对象，然后调用它的exec()函数。这个函数就是开始 Qt 的事件循环。在执行exec()函数之后，程序将进入事件循环来监听应用程序的事件。当事件发生时，Qt 将创建一个事件对象。<strong>Qt 中所有事件类都继承于QEvent</strong>。在事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。<strong>event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数</strong>（event handler），关于这一点，会在后边详细说明。</p>
<p>在所有组件的父类QWidget中，定义了很多事件处理的回调函数，如</p>
<ul>
<li>keyPressEvent()</li>
<li>keyReleaseEvent()</li>
<li>mouseDoubleClickEvent()</li>
<li>mouseMoveEvent()</li>
<li>mousePressEvent()</li>
<li>mouseReleaseEvent() 等。</li>
</ul>
<p>这些函数都是 protected virtual 的，也就是说，我们可以在子类中重新实现这些函数。下面来看一个例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventLabel</span> : <span class="keyword">public</span> QLabel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLabel::mouseMoveEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;&lt;center&gt;&lt;h1&gt;Move: (%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;</span>).<span class="built_in">arg</span>(QString::<span class="built_in">number</span>(event-&gt;<span class="built_in">x</span>()), QString::<span class="built_in">number</span>(event-&gt;<span class="built_in">y</span>())));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLabel::mousePressEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(<span class="built_in">QString</span>(<span class="string">&quot;&lt;center&gt;&lt;h1&gt;Press:(%1, %2)&lt;/h1&gt;&lt;/center&gt;&quot;</span>).<span class="built_in">arg</span>(QString::<span class="built_in">number</span>(event-&gt;<span class="built_in">x</span>()),</span><br><span class="line">QString::<span class="built_in">number</span>(event-&gt;<span class="built_in">y</span>())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EventLabel::mouseReleaseEvent</span><span class="params">(QMouseEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    QString msg;</span><br><span class="line">    msg.<span class="built_in">sprintf</span>(<span class="string">&quot;&lt;center&gt;&lt;h1&gt;Release: (%d, %d)&lt;/h1&gt;&lt;/center&gt;&quot;</span>, event-&gt;<span class="built_in">x</span>(), event-&gt;<span class="built_in">y</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>-&gt;<span class="built_in">setText</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">QApplication <span class="title">a</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line">    EventLabel *label = <span class="keyword">new</span> EventLabel;</span><br><span class="line"></span><br><span class="line">    label-&gt;<span class="built_in">setWindowTitle</span>(<span class="string">&quot;MouseEvent Demo&quot;</span>);</span><br><span class="line">    label-&gt;<span class="built_in">resize</span>(<span class="number">300</span>, <span class="number">200</span>);</span><br><span class="line">    label-&gt;<span class="built_in">show</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a.<span class="built_in">exec</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>EventLabel继承了QLabel，覆盖了mousePressEvent()、mouseMoveEvent()和MouseReleaseEvent()三个函数。我们并没有添加什么功能，只是在鼠标按下（press）、鼠标移动（move）和鼠标释放（release）的时候，把当前鼠标的坐标值显示在这个Label上面。由于QLabel是支持 HTML 代码的，因此我们直接使用了 HTML 代码来格式化文字。</li>
<li>QString的arg()函数可以自动替换掉QString中出现的占位符。其占位符以 % 开始，后面是占位符的位置，例如 %1，%2 这种。<code>QString(&quot;[%1, %2]&quot;).arg(x).arg(y);</code>语句将会使用x替换 %1，y替换 %2，因此，生成的QString为[x, y]。</li>
<li>在mouseReleaseEvent()函数中，我们使用了另外一种QString的构造方法。我们使用类似 C 风格的格式化函数sprintf()来构造QString。</li>
</ul>
<p>运行上面的代码，当我们点击了一下鼠标之后，label 上将显示鼠标当前坐标值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/clip_image052.gif" alt="img"></p>
<p>为什么要点击鼠标之后才能在mouseMoveEvent()函数中显示鼠标坐标值？</p>
<p><strong>这是因为QWidget中有一个mouseTracking属性，该属性用于设置是否追踪鼠标。只有鼠标被追踪时，mouseMoveEvent()才会发出。如果mouseTracking是 false（默认即是），组件在至少一次鼠标点击之后，才能够被追踪，也就是能够发出mouseMoveEvent()事件。如果mouseTracking为 true，则mouseMoveEvent()直接可以被发出。</strong></p>
<p>知道了这一点，我们就可以在main()函数中添加如下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">label-&gt;<span class="built_in">setMouseTracking</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h2 id="5-2-event（）"><a href="#5-2-event（）" class="headerlink" title="5.2 event（）"></a>5.2 event（）</h2><p> 事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数。event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）。</p>
<p> 如上所述，<strong>event()函数主要用于事件的分发</strong>。所以，如果你希望在事件分发之前做一些操作，就可以重写这个event()函数了。例如，我们希望在一个QWidget组件中监听 tab 键的按下，那么就可以继承QWidget，并重写它的event()函数，来达到这个目的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CustomWidget::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line"></span><br><span class="line">        QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Tab) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;You press tab.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QWidget::<span class="built_in">event</span>(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CustomWidget是一个普通的QWidget子类。我们重写了它的event()函数，这个函数有一个QEvent对象作为参数，也就是需要转发的事件对象。函数返回值是 bool 类型。</p>
<blockquote>
<ul>
<li><strong>如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false。如果返回值是 true，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件</strong>。</li>
<li><strong>在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播</strong>。</li>
</ul>
</blockquote>
<p> 我们可以通过使用QEvent::type()函数可以检查事件的实际类型，其返回值是QEvent::Type类型的枚举。我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理；对于其它我们不关心的事件，则需要调用父类的event()函数继续转发，否则这个组件就只能处理我们定义的事件了。为了测试这一种情况，我们可以尝试下面的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">CustomTextEdit::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) </span><br><span class="line">    &#123;</span><br><span class="line">       QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(e);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Tab) </span><br><span class="line">       &#123;</span><br><span class="line">           <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;You press tab.&quot;</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> CustomTextEdit是QTextEdit的一个子类。我们重写了其event()函数，却没有调用父类的同名函数。这样，我们的组件就只能处理 Tab 键，再也无法输入任何文本，也不能响应其它事件，比如鼠标点击之后也不会有光标出现。这是因为我们只处理的KeyPress类型的事件，并且如果不是KeyPress事件，则直接返回 false，鼠标事件根本不会被转发，也就没有了鼠标事件。</p>
<p>通过查看QObject::event()的实现，我们可以理解，event()函数同前面的章节中我们所说的事件处理器有什么联系：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!!! Qt5</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QObject::event</span><span class="params">(QEvent *e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (e-&gt;<span class="built_in">type</span>()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> QEvent::Timer:</span><br><span class="line">            <span class="built_in">timerEvent</span>((QTimerEvent*)e);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> QEvent::ChildAdded:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> QEvent::ChildPolished:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> QEvent::ChildRemoved:</span><br><span class="line"></span><br><span class="line">            <span class="built_in">childEvent</span>((QChildEvent*)e);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;<span class="built_in">type</span>() &gt;= QEvent::User) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">customEvent</span>(e);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 这是 Qt 5 中QObject::event()函数的源代码（Qt 4 的版本也是类似的）。我们可以看到，同前面我们所说的一样，Qt 也是使用QEvent::type()判断事件类型，然后调用了特定的事件处理器。比如，如果event-&gt;type()返回值是QEvent::Timer，则调用timerEvent()函数。可以想象，QWidget::event()中一定会有如下的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (event-&gt;<span class="built_in">type</span>()) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> QEvent::MouseMove:</span><br><span class="line">        <span class="built_in">mouseMoveEvent</span>((QMouseEvent*)event);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 事实也的确如此。timerEvent()和mouseMoveEvent()这样的函数，就是我们前面章节所说的事件处理器 event handler。也就是说，<strong>event()函数中实际是通过事件处理器来响应一个具体的事件。这相当于event()函数将具体事件的处理“委托”给具体的事件处理器。而这些事件处理器是 protected virtual 的，因此，我们重写了某一个事件处理器，即可让 Qt 调用我们自己实现的版本。</strong></p>
<p> 由此可以见，event()是一个集中处理不同类型的事件的地方。如果你不想重写一大堆事件处理器，就可以重写这个event()函数，通过QEvent::type()判断不同的事件。鉴于重写event()函数需要十分小心注意父类的同名函数的调用，一不留神就可能出现问题，所以一般还是建议只重写事件处理器（当然，也必须记得是不是应该调用父类的同名处理器）。这其实暗示了event()函数的另外一个作用：屏蔽掉某些不需要的事件处理器。正如我们前面的CustomTextEdit例子看到的那样，我们创建了一个只能响应 tab 键的组件。这种作用是重写事件处理器所不能实现的。</p>
<h2 id="5-3-事件过滤器"><a href="#5-3-事件过滤器" class="headerlink" title="5.3 事件过滤器"></a>5.3 事件过滤器</h2><p> 有时候，对象需要查看、甚至要拦截发送到另外对象的事件。例如，对话框可能想要拦截按键事件，不让别的组件接收到；或者要修改回车键的默认处理。</p>
<p> 通过前面的章节，我们已经知道，Qt 创建了QEvent事件对象之后，会调用QObject的event()函数处理事件的分发。显然，我们可以在event()函数中实现拦截的操作。由于event()函数是 protected 的，因此，需要继承已有类。如果组件很多，就需要重写很多个event()函数。这当然相当麻烦，更不用说重写event()函数还得小心一堆问题。好在 Qt 提供了另外一种机制来达到这一目的：事件过滤器。QObject有一个eventFilter()函数，用于建立事件过滤器。函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">QObject::eventFilter</span> <span class="params">( QObject * watched, QEvent * event )</span></span>;</span><br></pre></td></tr></table></figure>
<p> 这个函数正如其名字显示的那样，是一个“事件过滤器”。所谓事件过滤器，可以理解成一种过滤代码。事件过滤器会检查接收到的事件。如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发。这个函数返回一个 bool 类型，如果你想将参数 event 过滤出来，比如，<strong>不想让它继续转发，就返回 true，否则返回 false。</strong>事件过滤器的调用时间是目标对象（也就是参数里面的watched对象）接收到事件对象之前。也就是说，如果你在事件过滤器中停止了某个事件，那么，watched对象以及以后所有的事件过滤器根本不会知道这么一个事件。</p>
<p>我们来看一段简单的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainWindow</span> : <span class="keyword">public</span> QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">public</span>:</span><br><span class="line">         <span class="built_in">MainWindow</span>();</span><br><span class="line"></span><br><span class="line">     <span class="keyword">protected</span>:</span><br><span class="line">         <span class="function"><span class="type">bool</span> <span class="title">eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span>:</span><br><span class="line">         QTextEdit *textEdit;</span><br><span class="line"></span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> MainWindow::<span class="built_in">MainWindow</span>()</span><br><span class="line"> &#123;</span><br><span class="line">     textEdit = <span class="keyword">new</span> QTextEdit;</span><br><span class="line">     <span class="built_in">setCentralWidget</span>(textEdit);</span><br><span class="line">     textEdit-&gt;<span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">bool</span> <span class="title">MainWindow::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (obj == textEdit) &#123;</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span> (event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) &#123;</span><br><span class="line"></span><br><span class="line">             QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line"></span><br><span class="line">             <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Ate key press&quot;</span> &lt;&lt; keyEvent-&gt;<span class="built_in">key</span>();</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">             <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// pass the event on to the parent class</span></span><br><span class="line">         <span class="keyword">return</span> QMainWindow::<span class="built_in">eventFilter</span>(obj, event);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>MainWindow是我们定义的一个类。我们重写了它的eventFilter()函数。为了过滤特定组件上的事件，首先需要判断这个对象是不是我们感兴趣的组件，然后判断这个事件的类型。在上面的代码中，我们不想让textEdit组件处理键盘按下的事件。所以，首先我们找到这个组件，如果这个事件是键盘事件，则直接返回 true，也就是过滤掉了这个事件，其他事件还是要继续处理，所以返回 false。对于其它的组件，我们并不保证是不是还有过滤器，于是最保险的办法是调用父类的函数。</li>
<li>eventFilter()函数相当于创建了过滤器，然后我们需要安装这个过滤器。安装过滤器需要调用QObject::installEventFilter()函数。函数的原型如下：<code>void QObject::installEventFilter ( QObject * filterObj )</code>这个函数接受一个QObject *类型的参数。记得刚刚我们说的，eventFilter()函数是QObject的一个成员函数，因此，任意QObject都可以作为事件过滤器（问题在于，如果你没有重写eventFilter()函数，这个事件过滤器是没有任何作用的，因为默认什么都不会过滤）。已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除。</li>
<li>我们可以向一个对象上面安装多个事件处理器，只要调用多次installEventFilter()函数。如果一个对象存在多个事件过滤器，那么，最后一个安装的会第一个执行，也就是后进先执行的顺序。</li>
</ul>
<p>还记得我们前面的那个例子吗？我们使用event()函数处理了 Tab 键：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bool CustomWidget::event(QEvent *e)</span><br><span class="line">&#123;</span><br><span class="line">    if (e-&gt;type() == QEvent::KeyPress) &#123;</span><br><span class="line"></span><br><span class="line">        QKeyEvent *keyEvent = static_cast&lt;QKeyEvent *&gt;(e);</span><br><span class="line"></span><br><span class="line">        if (keyEvent-&gt;key() == Qt::Key_Tab) &#123;</span><br><span class="line"></span><br><span class="line">            qDebug() &lt;&lt; &quot;You press tab.&quot;;</span><br><span class="line"></span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return QWidget::event(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，我们可以给出一个使用事件过滤器的版本：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">FilterObject::eventFilter</span><span class="params">(QObject *object, QEvent *event)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object == target &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::KeyPress) </span><br><span class="line">    &#123;</span><br><span class="line">        QKeyEvent *keyEvent = <span class="built_in">static_cast</span>&lt;QKeyEvent *&gt;(event);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (keyEvent-&gt;<span class="built_in">key</span>() == Qt::Key_Tab) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;You press tab.&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 事件过滤器的强大之处在于，我们可以为整个应用程序添加一个事件过滤器。记得，installEventFilter()函数是QObject的函数，QApplication或者QCoreApplication对象都是QObject的子类，因此，我们可以向QApplication或者QCoreApplication添加事件过滤器。<strong>这种全局的事件过滤器将会在所有其它特性对象的事件过滤器之前调用。尽管很强大，但这种行为会严重降低整个应用程序的事件分发效率。</strong>因此，除非是不得不使用的情况，否则的话我们不应该这么做。</p>
<p><strong>注意，</strong> <strong>事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用。另外，如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效。</strong></p>
<h2 id="5-4-总结"><a href="#5-4-总结" class="headerlink" title="5.4 总结"></a>5.4 总结</h2><p> Qt 的事件是整个 Qt 框架的核心机制之一，也比较复杂。说它复杂，更多是因为它涉及到的函数众多，而处理方法也很多，有时候让人难以选择。现在我们简单总结一下 Qt 中的事件机制。Qt 中有很多种事件：鼠标事件、键盘事件、大小改变的事件、位置移动的事件等等。如何处理这些事件，实际有两种选择：</p>
<ul>
<li>所有事件对应一个事件处理函数，在这个事件处理函数中用一个很大的分支语句进行选择，其代表作就是 win32 API 的WndProc()函数：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT message, WPARAM wParam,  LPARAM lParam)</span></span></span><br></pre></td></tr></table></figure>
<p>在这个函数中，我们需要使用switch语句，选择message参数的类型进行处理，典型代码是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(message)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> WM_PAINT:</span><br><span class="line">        <span class="comment">// ..</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ..</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每一种事件对应一个事件处理函数。Qt 就是使用的这么一种机制：</li>
</ul>
<p>mouseEvent()</p>
<p>keyPressEvent()</p>
<p>…</p>
<p> Qt 具有这么多种事件处理函数，肯定有一个地方对其进行分发，否则，Qt 怎么知道哪一种事件调用哪一个事件处理函数呢？这个分发的函数，就是<strong>event()</strong>。显然，当QMouseEvent产生之后，event()函数将其分发给mouseEvent()事件处理器进行处理。</p>
<p>event()函数会有两个问题：</p>
<ul>
<li>event()函数是一个 protected 的函数，这意味着我们要想重写event()，必须继承一个已有的类。试想，我的程序根本不想要鼠标事件，程序中所有组件都不允许处理鼠标事件，是不是我得继承所有组件，一一重写其event()函数？protected 函数带来的另外一个问题是，如果我基于第三方库进行开发，而对方没有提供源代码，只有一个链接库，其它都是封装好的。我怎么去继承这种库中的组件呢？</li>
<li>event()函数的确有一定的控制，不过有时候我的需求更严格一些：我希望那些组件根本看不到这种事件。event()函数虽然可以拦截，但其实也是接收到了QMouseEvent对象。我连让它收都收不到。这样做的好处是，模拟一种系统根本没有那个事件的效果，所以其它组件根本不会收到这个事件，也就无需修改自己的事件处理函数。这种需求怎么办呢？</li>
</ul>
<p>这两个问题是event()函数无法处理的。于是，Qt 提供了另外一种解决方案：<strong>事件过滤器</strong>。事件过滤器给我们一种能力，让我们能够完全移除某种事件。事件过滤器可以安装到任意QObject类型上面，并且可以安装多个。如果要实现全局的事件过滤器，则可以安装到QApplication或者QCoreApplication上面。这里需要注意的是，如果使用installEventFilter()函数给一个对象安装事件过滤器，那么该事件过滤器只对该对象有效，只有这个对象的事件需要先传递给事件过滤器的eventFilter()函数进行过滤，其它对象不受影响。如果给QApplication对象安装事件过滤器，那么该过滤器对程序中的每一个对象都有效，任何对象的事件都是先传给eventFilter()函数。</p>
<p><strong>事件过滤器可以解决刚刚我们提出的event()函数的两点不足：</strong></p>
<ul>
<li><strong>首先，事件过滤器不是 protected 的，因此我们可以向任何QObject子类安装事件过滤器；</strong></li>
<li><strong>其次，事件过滤器在目标对象接收到事件之前进行处理，如果我们将事件过滤掉，目标对象根本不会见到这个事件。</strong></li>
</ul>
<p>事实上，还有一种方法，我们没有介绍。Qt 事件的调用最终都会追溯到QCoreApplication::notify()函数，因此，<strong>最大的控制权实际上是重写QCoreApplication::notify()</strong>。这个函数的声明是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">QCoreApplication::notify</span> <span class="params">( QObject * receiver, QEvent * event )</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数会将event发送给receiver，也就是调用receiver-&gt;event(event)，其返回值就是来自receiver的事件处理器。注意，这个函数为任意线程的任意对象的任意事件调用，因此，它不存在事件过滤器的线程的问题。不过我们并不推荐这么做，因为notify()函数只有一个，而事件过滤器要灵活得多。</p>
<p><strong>现在我们可以总结一下 Qt 的事件处理，实际上是有五个层次：</strong></p>
<ul>
<li>重写paintEvent()、mousePressEvent()等事件处理函数。这是最普通、最简单的形式，同时功能也最简单。</li>
<li>重写event()函数。event()函数是所有对象的事件入口，QObject和QWidget中的实现，默认是把事件传递给特定的事件处理函数。</li>
<li>在特定对象上面安装事件过滤器。该过滤器仅过滤该对象接收到的事件。</li>
<li>在QCoreApplication::instance()上面安装事件过滤器。该过滤器将过滤所有对象的所有事件，因此和notify()函数一样强大，但是它更灵活，因为可以安装多个过滤器。全局的事件过滤器可以看到 disabled 组件上面发出的鼠标事件。全局过滤器有一个问题：只能用在主线程。</li>
<li>重写QCoreApplication::notify()函数。这是最强大的，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用（因为QCoreApplication是单例的）。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.totorocatcat.top/">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/2024/04/03/QT%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/">http://totorocatcat.top/2024/04/03/QT%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post_share"><div class="social-share" data-image="https://npm.elemecdn.com/ushio-api-img-moe@5.0.12/img_122_808x1400_350.011993408203_null_normal.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/04/3%E9%9A%BE%E5%BA%A6%E5%9B%BE%E8%AE%BA%E6%A0%91%E8%AE%BA%E9%A2%98%E7%BB%83%E6%89%8B/" title="div3难度图论树论题练手"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.29/img_296_4134x2337_72_null_normal.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">div3难度图论树论题练手</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/03/%E6%8D%A2%E6%A0%B9dp/" title="换根dp"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.18/img_188_1240x1754_150.012390136719_null_normal.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">换根dp</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/05/16/2022C-%E8%AF%95%E5%8D%B7/" title="2022C++试卷"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_80.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-16</div><div class="title">2022C++试卷</div></div></a></div><div><a href="/2024/05/16/2022%E5%B9%B4C-%E8%AF%95%E5%8D%B7%E8%BD%AF%E4%BB%B6%E5%AD%A6%E9%99%A2/" title="2022年C++试卷软件学院"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_80.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-16</div><div class="title">2022年C++试卷软件学院</div></div></a></div><div><a href="/2024/05/14/ASP-NET%E5%9F%BA%E7%A1%80%E4%B9%8BWebPages/" title="ASP.NET基础之WebPages"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_169_2560x1440_96_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-14</div><div class="title">ASP.NET基础之WebPages</div></div></a></div><div><a href="/2024/05/16/AJAX%E5%9F%BA%E7%A1%80/" title="AJAX基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_169_2560x1440_96_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-16</div><div class="title">AJAX基础</div></div></a></div><div><a href="/2024/03/04/C-%E5%9F%BA%E7%A1%80/" title="C++基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.24/img_249_2081x1420_96_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-04</div><div class="title">C++基础</div></div></a></div><div><a href="/2024/03/23/CSS%E7%AC%94%E8%AE%B0/" title="CSS笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_169_2560x1440_96_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-23</div><div class="title">CSS笔记</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description">敲代码的SCUT学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">471</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">26</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Qt%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">Qt概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AFQt"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 什么是Qt</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-Qt%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 Qt的发展史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E6%94%AF%E6%8C%81%E7%9A%84%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 支持的平台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Qt%E7%89%88%E6%9C%AC"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 Qt版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5Qt%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">1.5Qt的优点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAQt%E9%A1%B9%E7%9B%AE"><span class="toc-number">2.</span> <span class="toc-text">创建Qt项目</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E4%BD%BF%E7%94%A8%E5%90%91%E5%AF%BC%E5%88%9B%E5%BB%BA"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 使用向导创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%89%8B%E5%8A%A8%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 手动创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-pro%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">2.3 .pro文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E4%B8%80%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84Qt%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 一个最简单的Qt应用程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD%E6%9C%BA%E5%88%B6-listener"><span class="toc-number">3.</span> <span class="toc-text">3 信号和槽机制(listener)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A7%BD"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 信号和槽</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E6%A7%BD"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 自定义信号槽</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BF%A1%E5%8F%B7%E6%A7%BD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.2.1.</span> <span class="toc-text">自定义信号槽需要注意的事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E6%A7%BD%E7%9A%84%E6%9B%B4%E5%A4%9A%E7%94%A8%E6%B3%95"><span class="toc-number">3.2.2.</span> <span class="toc-text">信号槽的更多用法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 Lambda表达式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Qt%E7%AA%97%E5%8F%A3%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text">Qt窗口系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Qt%E7%AA%97%E5%8F%A3%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 Qt窗口坐标体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E4%BD%93%E7%B3%BB"><span class="toc-number">4.1.1.</span> <span class="toc-text">坐标体系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">4.2.1 对象模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-QMainWindow"><span class="toc-number">4.2.</span> <span class="toc-text">4.3 QMainWindow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E8%8F%9C%E5%8D%95%E6%A0%8F"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.3.1 菜单栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E5%B7%A5%E5%85%B7%E6%A0%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.3.2 工具栏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E7%8A%B6%E6%80%81%E6%A0%8F"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.3.3 状态栏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">4.3.</span> <span class="toc-text">4.4 资源文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%AF%B9%E8%AF%9D%E6%A1%86QDialog"><span class="toc-number">4.4.</span> <span class="toc-text">4.5 对话框QDialog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">4.4.1.</span> <span class="toc-text">4.5.1 基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E6%A0%87%E5%87%86%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">4.4.2.</span> <span class="toc-text">4.5.2 标准对话框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E6%A1%86"><span class="toc-number">4.4.3.</span> <span class="toc-text">4.5.3 自定义消息框</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%80%81%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">4.4.3.1.</span> <span class="toc-text">模态对话框</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-4-%E6%B6%88%E6%81%AF%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">4.4.4.</span> <span class="toc-text">4.5.4 消息对话框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-5-%E6%A0%87%E5%87%86%E6%96%87%E4%BB%B6%E5%AF%B9%E8%AF%9D%E6%A1%86"><span class="toc-number">4.4.5.</span> <span class="toc-text">4.5.5 标准文件对话框</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E5%B8%B8%E7%94%A8%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.5.</span> <span class="toc-text">4.6 常用控件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-QLabel%E6%8E%A7%E4%BB%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">4.5.1.</span> <span class="toc-text">4.6.1 QLabel控件使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E6%96%87%E5%AD%97-%EF%BC%88%E6%99%AE%E9%80%9A%E6%96%87%E6%9C%AC%E3%80%81html%EF%BC%89"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">显示文字 （普通文本、html）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%9B%BE%E7%89%87"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">显示图片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%8A%A8%E7%94%BB"><span class="toc-number">4.5.1.3.</span> <span class="toc-text">显示动画</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-QLineEdit"><span class="toc-number">4.5.2.</span> <span class="toc-text">4.6.2 QLineEdit</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9"><span class="toc-number">4.5.2.1.</span> <span class="toc-text">设置&#x2F;获取内容</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.5.2.2.</span> <span class="toc-text">设置显示模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BE%93%E5%85%A5%E6%8F%90%E7%A4%BA"><span class="toc-number">4.5.2.3.</span> <span class="toc-text">设置输入提示</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86%E5%99%A8"><span class="toc-number">4.6.</span> <span class="toc-text">4.7 布局管理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-%E6%B0%B4%E5%B9%B3-%E5%9E%82%E7%9B%B4-%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80"><span class="toc-number">4.6.1.</span> <span class="toc-text">4.7.1 水平&#x2F;垂直&#x2F;网格布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%89%8B"><span class="toc-number">4.6.1.1.</span> <span class="toc-text">动手</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6"><span class="toc-number">4.6.2.</span> <span class="toc-text">4.7.2 自定义控件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Qt%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E5%92%8C%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.</span> <span class="toc-text">Qt消息机制和事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E4%BA%8B%E4%BB%B6"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-event%EF%BC%88%EF%BC%89"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 event（）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E4%BA%8B%E4%BB%B6%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 事件过滤器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%80%BB%E7%BB%93"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 总结</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/09/15/JAVA%E4%B9%8B%E5%8F%8D%E5%B0%84/" title="JAVA之反射"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4ac971f2c68732f5c2f67d23f62a0ce.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="JAVA之反射"/></a><div class="content"><a class="title" href="/2024/09/15/JAVA%E4%B9%8B%E5%8F%8D%E5%B0%84/" title="JAVA之反射">JAVA之反射</a><time datetime="2024-09-15T02:30:14.000Z" title="发表于 2024-09-15 10:30:14">2024-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/15/%E3%80%8A%E6%B2%89%E6%80%9D%E5%BD%95%E3%80%8B%E8%AF%AD%E5%BD%95/" title="《沉思录》语录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/98f3ec25d85972d866886a949796369.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《沉思录》语录"/></a><div class="content"><a class="title" href="/2024/09/15/%E3%80%8A%E6%B2%89%E6%80%9D%E5%BD%95%E3%80%8B%E8%AF%AD%E5%BD%95/" title="《沉思录》语录">《沉思录》语录</a><time datetime="2024-09-14T16:59:14.000Z" title="发表于 2024-09-15 00:59:14">2024-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/15/%E3%80%8A%E8%A5%BF%E8%A5%BF%E5%BC%97%E7%A5%9E%E8%AF%9D%E3%80%8B%E8%AF%AD%E5%BD%95/" title="《西西弗神话》语录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/2cc3d7f496a105bc9ad2b25ff6d83c9.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《西西弗神话》语录"/></a><div class="content"><a class="title" href="/2024/09/15/%E3%80%8A%E8%A5%BF%E8%A5%BF%E5%BC%97%E7%A5%9E%E8%AF%9D%E3%80%8B%E8%AF%AD%E5%BD%95/" title="《西西弗神话》语录">《西西弗神话》语录</a><time datetime="2024-09-14T16:44:06.000Z" title="发表于 2024-09-15 00:44:06">2024-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/14/%E5%AD%A6%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/" title="学一本好书《剑指offer》"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/offerbanner200_268.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学一本好书《剑指offer》"/></a><div class="content"><a class="title" href="/2024/09/14/%E5%AD%A6%E4%B8%80%E6%9C%AC%E5%A5%BD%E4%B9%A6%E3%80%8A%E5%89%91%E6%8C%87offer%E3%80%8B/" title="学一本好书《剑指offer》">学一本好书《剑指offer》</a><time datetime="2024-09-14T11:03:45.000Z" title="发表于 2024-09-14 19:03:45">2024-09-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/09/11/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound59/" title="牛客周赛Round59"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/Suzume.2022.2160p.BluRay.x265.10bit.DTS-CTRLHD.mkv_004852.053.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="牛客周赛Round59"/></a><div class="content"><a class="title" href="/2024/09/11/%E7%89%9B%E5%AE%A2%E5%91%A8%E8%B5%9BRound59/" title="牛客周赛Round59">牛客周赛Round59</a><time datetime="2024-09-11T10:01:19.000Z" title="发表于 2024-09-11 18:01:19">2024-09-11</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HT1PalaKkPaG1UqAXBhJXIu8-gzGzoHsz',
      appKey: 'iT0TnVVAwf9zuZ7NqwclQItY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="1" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="只此无为身，且前行,忘记过去的人注定重蹈覆辙,我是我，我靠自己站立，我会做好自身,如果我睡大觉，谁给我摘月亮呢,假期和朋友，是人生中顶好的两样东西啊。,去爱，去失去，要不负相遇,没什么想不想通的，只是固执而已,我们深爱星辰，乃至不惧夜的黑,吃，喝，享受幸福，接受奇迹,浊水若长流，自清澄,雅俗共赏,总会有什么也不想的幸福时刻吧,时间顺流而下，生活逆流而上,悟已往之不谏，知来者之可追,希望你的小世界里,山花烂漫,茶酒俱全,安宁清淡,明朗欢愉" data-fontsize="20px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACMの旅/&quot;);" href="javascript:void(0);">ACMの旅</a><span class="categoryBar-list-count">66</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/区域赛の旅/&quot;);" href="javascript:void(0);">区域赛の旅</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/期末の旅/&quot;);" href="javascript:void(0);">期末の旅</a><span class="categoryBar-list-count">22</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数学建模/&quot;);" href="javascript:void(0);">数学建模</a><span class="categoryBar-list-count">31</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/牛客の旅/&quot;);" href="javascript:void(0);">牛客の旅</a><span class="categoryBar-list-count">63</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题计划/&quot;);" href="javascript:void(0);">刷题计划</a><span class="categoryBar-list-count">42</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Codeforcesの旅/&quot;);" href="javascript:void(0);">Codeforcesの旅</a><span class="categoryBar-list-count">23</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Atcoderの旅/&quot;);" href="javascript:void(0);">Atcoderの旅</a><span class="categoryBar-list-count">52</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/前端の旅/&quot;);" href="javascript:void(0);">前端の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-の旅/&quot;);" href="javascript:void(0);">C++の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CSAPPの旅/&quot;);" href="javascript:void(0);">CSAPPの旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_24.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS知识/&quot;);" href="javascript:void(0);">CS知识</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_25.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程基础/&quot;);" href="javascript:void(0);">编程基础</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_26.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/个人安排/&quot;);" href="javascript:void(0);">个人安排</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_27.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂项/&quot;);" href="javascript:void(0);">杂项</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_28.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文学/&quot;);" href="javascript:void(0);">文学</a><span class="categoryBar-list-count">40</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_29.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/力扣の旅/&quot;);" href="javascript:void(0);">力扣の旅</a><span class="categoryBar-list-count">18</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_30.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/少年游/&quot;);" href="javascript:void(0);">少年游</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_31.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法提高课/&quot;);" href="javascript:void(0);">算法提高课</a><span class="categoryBar-list-count">4</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_32.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构/&quot;);" href="javascript:void(0);">数据结构</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_33.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/汇编の旅/&quot;);" href="javascript:void(0);">汇编の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_34.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/灵魂の旅/&quot;);" href="javascript:void(0);">灵魂の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_35.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-实训/&quot;);" href="javascript:void(0);">C++实训</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_36.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JAVAの旅/&quot;);" href="javascript:void(0);">JAVAの旅</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_37.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/离散数学/&quot;);" href="javascript:void(0);">离散数学</a><span class="categoryBar-list-count">11</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_38.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/🗡指offer/&quot;);" href="javascript:void(0);">🗡指offer</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/02/13/数据结构与算法-1/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.64/img_649_702x1000_300_null_normal.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-02-13</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/02/13/数据结构与算法-1/&quot;);" href="javascript:void(0);" alt="">数据结构与算法(总)</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/02/13/数据结构与算法-1/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/02/24/常见优化技巧/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_238.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-02-24</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/02/24/常见优化技巧/&quot;);" href="javascript:void(0);" alt="">常见优化技巧</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/02/24/常见优化技巧/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>