<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>动态分配 | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="最不愿意面对的一集 好有趣且卡哇伊的图  动态内存程序用堆（heap）来存储动态分配（dynamically allocate）的对象。动态对象的生存期由程序控制。 动态内存与智能指针（Dynamic Memory and Smart Pointers）C++中的动态内存管理通过一对运算符完成：new在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；delete接受一个动">
<meta property="og:type" content="article">
<meta property="og:title" content="动态分配">
<meta property="og:url" content="http://totorocatcat.top/2024/04/05/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="最不愿意面对的一集 好有趣且卡哇伊的图  动态内存程序用堆（heap）来存储动态分配（dynamically allocate）的对象。动态对象的生存期由程序控制。 动态内存与智能指针（Dynamic Memory and Smart Pointers）C++中的动态内存管理通过一对运算符完成：new在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；delete接受一个动">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.12/img_126_627x885_349.986572265625_null_normal.jpg">
<meta property="article:published_time" content="2024-04-05T04:25:19.000Z">
<meta property="article:modified_time" content="2024-04-05T04:31:05.907Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.12/img_126_627x885_349.986572265625_null_normal.jpg"><link rel="shortcut icon" href="https://source.fomal.cc/img/default_cover_227.webp"><link rel="canonical" href="http://totorocatcat.top/2024/04/05/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '动态分配',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-04-05 12:31:05'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">243</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://npm.elemecdn.com/ushio-api-img-moe@5.0.12/img_126_627x885_349.986572265625_null_normal.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">动态分配<a class="post-edit-link" href="null_posts/动态分配.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-05T04:25:19.000Z" title="发表于 2024-04-05 12:25:19">2024-04-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-05T04:31:05.907Z" title="更新于 2024-04-05 12:31:05">2024-04-05</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/">编程基础</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">8.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="动态分配"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>最不愿意面对的一集</p>
<p>好有趣且卡哇伊的图</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/27231f99c3e7cd3a3016c58b1d0f854e32844383.jpg@1192w.webp" alt="img"></p>
<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><p>程序用堆（heap）来存储动态分配（dynamically allocate）的对象。动态对象的生存期由程序控制。</p>
<h2 id="动态内存与智能指针（Dynamic-Memory-and-Smart-Pointers）"><a href="#动态内存与智能指针（Dynamic-Memory-and-Smart-Pointers）" class="headerlink" title="动态内存与智能指针（Dynamic Memory and Smart Pointers）"></a>动态内存与智能指针（Dynamic Memory and Smart Pointers）</h2><p>C++中的动态内存管理通过一对运算符完成：<code>new</code>在动态内存中为对象分配空间并返回指向该对象的指针，可以选择对对象进行初始化；<code>delete</code>接受一个动态对象的指针，销毁该对象并释放与之关联的内存。</p>
<p>新标准库提供了两种智能指针（smart pointer）类型来管理动态对象。智能指针的行为类似常规指针，但它自动释放所指向的对象。这两种智能指针的区别在于管理底层指针的方式：<code>shared_ptr</code>允许多个指针指向同一个对象；<code>unique_ptr</code>独占所指向的对象。标准库还定义了一个名为<code>weak_ptr</code>的伴随类，它是一种弱引用，指向<code>shared_ptr</code>所管理的对象。这三种类型都定义在头文件<code>memory</code>中。</p>
<h3 id="shared-ptr类（The-shared-ptr-Class）"><a href="#shared-ptr类（The-shared-ptr-Class）" class="headerlink" title="shared_ptr类（The shared_ptr Class）"></a><code>shared_ptr</code>类（The <code>shared_ptr</code> Class）</h3><p>智能指针是模板，创建时需要指明指针可以指向的类型。默认初始化的智能指针中保存着一个空指针。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;string&gt; p1;      <span class="comment">// shared_ptr that can point at a string</span></span><br><span class="line">shared_ptr&lt;list&lt;<span class="type">int</span>&gt;&gt; p2;   <span class="comment">// shared_ptr that can point at a list of ints</span></span><br></pre></td></tr></table></figure>
<p><code>shared_ptr</code>和<code>unique_ptr</code>都支持的操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shared_ptr&lt;T&gt; sp</code> <code>unique_ptr&lt;T&gt; up</code></td>
<td>默认初始化为空指针</td>
</tr>
<tr>
<td><code>p</code></td>
<td>若<code>p</code>指向一个对象，则为<code>true</code></td>
</tr>
<tr>
<td><code>*p</code></td>
<td>解引用<code>p</code></td>
</tr>
<tr>
<td><code>p-&gt;mem</code></td>
<td>等价于<code>(*p).mem</code></td>
</tr>
<tr>
<td><code>p.get()</code></td>
<td>返回<code>p</code>中的指针</td>
</tr>
</tbody>
</table>
</div>
<p><code>shared_ptr</code>独有的操作：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>p.use_count()</code></td>
<td>返回<code>p</code>的引用计数</td>
</tr>
<tr>
<td><code>p.unique()</code></td>
<td>若<code>p.use_count() == 1</code>，则返回<code>true</code></td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptr that points to an int with value 42</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p3 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// p4 points to a string with value 9999999999</span></span><br><span class="line">shared_ptr&lt;string&gt; p4 = <span class="built_in">make_shared</span>&lt;string&gt;(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);</span><br><span class="line"><span class="comment">// p5 points to an int that is value initialized</span></span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p5 = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码使用了C++11中的智能指针 <code>std::shared_ptr</code> 和 <code>std::make_shared</code> 函数来创建三个智能指针，并分别指向了不同类型的对象。让我逐步解释：</p>
<ol>
<li><p><code>shared_ptr&lt;int&gt; p3 = make_shared&lt;int&gt;(42);</code>：<br>这行代码创建了一个 <code>shared_ptr</code> 智能指针 <code>p3</code>，并使用 <code>make_shared</code> 函数将其初始化为指向一个整型对象，值为42。<code>make_shared&lt;int&gt;(42)</code> 创建了一个动态分配的整型对象，并将其初始化为42，并且返回一个指向该对象的 <code>shared_ptr</code>。因此，<code>p3</code> 现在指向了这个整型对象。</p>
</li>
<li><p><code>shared_ptr&lt;string&gt; p4 = make_shared&lt;string&gt;(10, &#39;9&#39;);</code>：<br>这行代码创建了一个 <code>shared_ptr</code> 智能指针 <code>p4</code>，并使用 <code>make_shared</code> 函数将其初始化为指向一个字符串对象，该字符串由10个字符’9’组成。<code>make_shared&lt;string&gt;(10, &#39;9&#39;)</code> 创建了一个动态分配的字符串对象，并用字符’9’重复初始化10次，返回一个指向该字符串对象的 <code>shared_ptr</code>。因此，<code>p4</code> 现在指向了这个字符串对象。</p>
</li>
<li><p><code>shared_ptr&lt;int&gt; p5 = make_shared&lt;int&gt;();</code>：<br>这行代码创建了一个 <code>shared_ptr</code> 智能指针 <code>p5</code>，并使用 <code>make_shared</code> 函数将其初始化为指向一个整型对象，该整型对象是通过值初始化得到的。<code>make_shared&lt;int&gt;()</code> 创建了一个动态分配的整型对象，并执行值初始化操作，将其值设为0（整型的默认初始化值），返回一个指向该整型对象的 <code>shared_ptr</code>。因此，<code>p5</code> 现在指向了这个整型对象。</p>
</li>
</ol>
<p>综上所述，这段代码使用 <code>std::make_shared</code> 函数创建了三个 <code>shared_ptr</code> 智能指针，分别指向一个整型对象、一个字符串对象和一个值初始化的整型对象。这样做可以保证动态分配的对象会被正确地管理，并且避免了手动管理内存的复杂性。</p>
</blockquote>
<p>进行拷贝或赋值操作时，每个<code>shared_ptr</code>会记录有多少个其他<code>shared_ptr</code>与其指向相同的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// object to which p points has one user</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">q</span><span class="params">(p)</span></span>;  <span class="comment">// p and q point to the same object</span></span><br><span class="line">            <span class="comment">// object to which p and q point has two users</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码展示了如何使用 <code>std::make_shared</code> 创建 <code>shared_ptr</code> 智能指针，并且演示了共享指针的引用计数机制。让我逐步解释：</p>
<ol>
<li><p><code>auto p = make_shared&lt;int&gt;(42);</code>：<br>这行代码创建了一个 <code>shared_ptr</code> 智能指针 <code>p</code>，并使用 <code>make_shared</code> 函数将其初始化为指向一个整型对象，值为42。这个对象的引用计数为1，因为此时只有 <code>p</code> 指向它。</p>
</li>
<li><p><code>auto q(p);</code>：<br>这行代码创建了另一个 <code>shared_ptr</code> 智能指针 <code>q</code>，并将其初始化为指向 <code>p</code> 所指向的对象。这时候，<code>p</code> 和 <code>q</code> 都指向同一个对象，因此这个对象的引用计数增加到2。</p>
</li>
</ol>
</blockquote>
<p>每个<code>shared_ptr</code>都有一个与之关联的计数器，通常称为引用计数（reference count）。拷贝<code>shared_ptr</code>时引用计数会递增。例如使用一个<code>shared_ptr</code>初始化另一个<code>shared_ptr</code>，或将它作为参数传递给函数以及作为函数的返回值返回。给<code>shared_ptr</code>赋予新值或<code>shared_ptr</code>被销毁时引用计数会递减。例如一个局部<code>shared_ptr</code>离开其作用域。一旦一个<code>shared_ptr</code>的引用计数变为0，它就会自动释放其所管理的对象。(感觉像py，也许是先学py的先入为主)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);  <span class="comment">// int to which r points has one user</span></span><br><span class="line">r = q;  <span class="comment">// assign to r, making it point to a different address</span></span><br><span class="line">        <span class="comment">// increase the use count for the object to which q points</span></span><br><span class="line">        <span class="comment">// reduce the use count of the object to which r had pointed</span></span><br><span class="line">        <span class="comment">// the object r had pointed to has no users; that object is automatically freed</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码涉及了智能指针的赋值操作，它展示了当一个 <code>shared_ptr</code> 指向另一个对象时，引用计数的变化。让我逐步解释：</p>
<ol>
<li><p><code>auto r = make_shared&lt;int&gt;(42);</code>：<br>这行代码创建了一个 <code>shared_ptr</code> 智能指针 <code>r</code>，并使用 <code>make_shared</code> 函数将其初始化为指向一个整型对象，值为42。这个对象的引用计数为1，因为此时只有 <code>r</code> 指向它。</p>
</li>
<li><p><code>r = q;</code>：<br>这行代码将 <code>r</code> 赋值为 <code>q</code>，即让 <code>r</code> 指向 <code>q</code> 所指向的对象。由于 <code>q</code> 和 <code>r</code> 都是 <code>shared_ptr</code> 智能指针，赋值操作会使得两个智能指针共享同一个对象。在这里，<code>r</code> 原本指向的对象（值为42的整型对象）的引用计数减少到0，因为没有任何指针指向它，所以会被自动释放。而 <code>q</code> 指向的对象的引用计数增加到3，因为此时有 <code>p</code>、<code>q</code> 和 <code>r</code> 三个智能指针指向它。</p>
</li>
</ol>
<p>综上所述，这段代码展示了赋值操作对智能指针引用计数的影响：当一个智能指针指向另一个对象时，原对象的引用计数会减少，新对象的引用计数会增加，从而确保内存资源的正确管理。</p>
</blockquote>
<p><code>shared_ptr</code>的析构函数会递减它所指向对象的引用计数。如果引用计数变为0，<code>shared_ptr</code>的析构函数会销毁对象并释放空间。</p>
<p>如果将<code>shared_ptr</code>存放于容器中，而后不再需要全部元素，而只使用其中一部分，应该用<code>erase</code>删除不再需要的元素。</p>
<p>程序使用动态内存通常出于以下三种原因之一：</p>
<ul>
<li>不确定需要使用多少对象。</li>
<li>不确定所需对象的准确类型。</li>
<li>需要在多个对象间共享数据。</li>
</ul>
<hr>
<h3 id="直接管理内存（Managing-Memory-Directly）"><a href="#直接管理内存（Managing-Memory-Directly）" class="headerlink" title="直接管理内存（Managing Memory Directly）"></a>直接管理内存（Managing Memory Directly）</h3><p>相对于智能指针，使用<code>new</code>和<code>delete</code>管理内存很容易出错。</p>
<p>默认情况下，动态分配的对象是默认初始化的。所以内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> string;    <span class="comment">// initialized to empty string</span></span><br><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="type">int</span>;     <span class="comment">// pi points to an uninitialized int</span></span><br></pre></td></tr></table></figure>
<p>可以使用值初始化方式、直接初始化方式、传统构造方式（圆括号<code>()</code>）或新标准下的列表初始化方式（花括号<code>&#123;&#125;</code>）初始化动态分配的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);            <span class="comment">// object to which pi points has value 1024</span></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">&#x27;9&#x27;</span>);   <span class="comment">// *ps is &quot;9999999999&quot;</span></span><br><span class="line"><span class="comment">// vector with ten elements with values from 0 to 9</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; *pv = <span class="keyword">new</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">string *ps1 = <span class="keyword">new</span> string;     <span class="comment">// default initialized to the empty string</span></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>();    <span class="comment">// value initialized to the empty string</span></span><br><span class="line"><span class="type">int</span> *pi1 = <span class="keyword">new</span> <span class="type">int</span>;      <span class="comment">// default initialized; *pi1 is undefined</span></span><br><span class="line"><span class="type">int</span> *pi2 = <span class="keyword">new</span> <span class="built_in">int</span>();    <span class="comment">// value initialized to 0; *pi2 is 0</span></span><br></pre></td></tr></table></figure>
<p>只有当初始化的括号中仅有单一初始化器时才可以使用<code>auto</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="built_in">auto</span>(obj);    <span class="comment">// p points to an object of the type of obj</span></span><br><span class="line">                            <span class="comment">// that object is initialized from obj</span></span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> <span class="keyword">auto</span>&#123;a,b,c&#125;;  <span class="comment">// error: must use parentheses for the initializer</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码展示了使用 <code>auto</code> 关键字与 <code>new</code> 运算符结合动态创建对象的方法。让我逐步解释：</p>
<ol>
<li><p><code>auto p1 = new auto(obj);</code>：<br>这行代码使用了 <code>auto</code> 关键字来推断指针 <code>p1</code> 所指向对象的类型，并且通过 <code>new</code> 运算符动态地创建了这个对象。对象的类型与 <code>obj</code> 相同，并且通过 <code>obj</code> 进行初始化。换句话说，<code>p1</code> 指向了一个类型与 <code>obj</code> 相同，并且由 <code>obj</code> 初始化的对象。</p>
</li>
<li><p><code>auto p2 = new auto&#123;a,b,c&#125;;</code>：<br>这行代码尝试使用 <code>auto</code> 关键字来推断指针 <code>p2</code> 所指向对象的类型，并且通过 <code>&#123;a, b, c&#125;</code> 进行初始化。然而，这里使用了花括号 <code>&#123;&#125;</code> 来初始化对象，但是这种初始化方式在使用 <code>auto</code> 关键字时是不允许的，必须使用圆括号 <code>()</code>。因此，这行代码会导致编译错误。</p>
</li>
</ol>
</blockquote>
<p>可以用<code>new</code>分配<code>const</code>对象，返回指向<code>const</code>类型的指针。动态分配的<code>const</code>对象必须初始化。</p>
<p>默认情况下，如果<code>new</code>不能分配所要求的内存空间，会抛出<code>bad_alloc</code>异常。使用定位<code>new</code>（placement new）可以阻止其抛出异常。定位<code>new</code>表达式允许程序向<code>new</code>传递额外参数。如果将<code>nothrow</code>传递给<code>new</code>，则<code>new</code>在分配失败后会返回空指针。<code>bad_alloc</code>和<code>nothrow</code>都定义在头文件<code>new</code>中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if allocation fails, new returns a null pointer</span></span><br><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>;            <span class="comment">// if allocation fails, new throws std::bad_alloc</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="built_in">new</span> (nothrow) <span class="type">int</span>;  <span class="comment">// if allocation fails, new returns a null pointer</span></span><br></pre></td></tr></table></figure>
<p>使用<code>delete</code>释放一块并非<code>new</code>分配的内存，或者将相同的指针值释放多次的行为是未定义的。</p>
<p>由内置指针管理的动态对象在被显式释放前一直存在。</p>
<p>注意下面一点：</p>
<p><code>delete</code>一个指针后，指针值就无效了（空悬指针，dangling pointer）。为了防止后续的错误访问，应该在<code>delete</code>之后将指针值置空。</p>
<h3 id="shared-ptr和new结合使用（Using-shared-ptrs-with-new）e"><a href="#shared-ptr和new结合使用（Using-shared-ptrs-with-new）e" class="headerlink" title="shared_ptr和new结合使用（Using shared_ptrs with new）e"></a><code>shared_ptr</code>和<code>new</code>结合使用（Using <code>shared_ptr</code>s with <code>new</code>）e</h3><p>可以用<code>new</code>返回的指针初始化智能指针。该构造函数是<code>explicit</code>的，因此必须使用直接初始化形式。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);    <span class="comment">// error: must use direct initialization</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;     <span class="comment">// ok: uses direct initialization</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码展示了使用<code>std::shared_ptr</code>来管理动态分配的整型对象。让我逐步解释：</p>
<ol>
<li><p><code>shared_ptr&lt;int&gt; p1 = new int(1024);</code>：<br>这行代码试图使用<code>std::shared_ptr</code>来管理动态分配的整型对象，但采用了拷贝初始化的方式。然而，<code>std::shared_ptr</code>的构造函数并没有接受一个裸指针作为参数的版本，因此这种方式是错误的。C++中的智能指针需要使用直接初始化的方式来构造，而不能使用拷贝初始化。</p>
</li>
<li><p><code>shared_ptr&lt;int&gt; p2(new int(1024));</code>：<br>这行代码使用了直接初始化的方式来创建一个<code>std::shared_ptr</code>对象<code>p2</code>，并让其指向一个动态分配的整型对象，值为1024。这种方式是正确的，因为<code>std::shared_ptr</code>的构造函数具有接受裸指针作为参数的重载版本，用于直接初始化指针。这样，<code>p2</code>就成功地管理了动态分配的整型对象，并在适当的时候自动释放内存，以避免内存泄漏。</p>
</li>
</ol>
<p>综上所述，正确的方式是使用直接初始化来创建<code>std::shared_ptr</code>对象，以确保正确地管理动态分配的内存。</p>
</blockquote>
<p>默认情况下，用来初始化智能指针的内置指针必须指向动态内存，因为智能指针默认使用<code>delete</code>释放它所管理的对象。如果要将智能指针绑定到一个指向其他类型资源的指针上，就必须提供自定义操作来代替<code>delete</code>。</p>
<p>不要混合使用内置指针和智能指针。当将<code>shared_ptr</code>绑定到内置指针后，资源管理就应该交由<code>shared_ptr</code>负责。不应该再使用内置指针访问<code>shared_ptr</code>指向的内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ptr is created and initialized when process is called</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">process</span><span class="params">(shared_ptr&lt;<span class="type">int</span>&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// use ptr</span></span><br><span class="line">&#125;   <span class="comment">// ptr goes out of scope and is destroyed</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;   <span class="comment">// dangerous: x is a plain pointer, not a smart pointer</span></span><br><span class="line"><span class="built_in">process</span>(x);     <span class="comment">// error: cannot convert int* to shared_ptr&lt;int&gt;</span></span><br><span class="line"><span class="built_in">process</span>(<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(x));    <span class="comment">// legal, but the memory will be deleted!</span></span><br><span class="line"><span class="type">int</span> j = *x;     <span class="comment">// undefined: x is a dangling pointer!</span></span><br><span class="line"></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;   <span class="comment">// reference count is 1</span></span><br><span class="line"><span class="built_in">process</span>(p);     <span class="comment">// copying p increments its count; in process the reference count is 2</span></span><br><span class="line"><span class="type">int</span> i = *p;     <span class="comment">// ok: reference count is 1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码展示了关于智能指针和裸指针之间的一些潜在问题。让我逐步解释：</p>
<ol>
<li><p><code>int *x(new int(1024));</code>：<br>这行代码创建了一个动态分配的整型对象，并将其地址赋给了裸指针 <code>x</code>。裸指针不具备智能指针的内存管理功能，需要手动释放内存。</p>
</li>
<li><p><code>process(x);</code>：<br>这行代码试图将裸指针 <code>x</code> 传递给接受 <code>shared_ptr&lt;int&gt;</code> 类型参数的函数 <code>process()</code>。然而，由于 <code>process()</code> 函数需要的是一个智能指针，因此无法将裸指针传递给它，会导致编译错误。</p>
</li>
<li><p><code>process(shared_ptr&lt;int&gt;(x));</code>：<br>这行代码通过使用 <code>shared_ptr&lt;int&gt;</code> 的临时对象来传递裸指针 <code>x</code> 给 <code>process()</code> 函数。这样做是合法的，但是需要注意的是，<code>shared_ptr</code> 会假定它所管理的资源是通过 <code>new</code> 创建的，因此会尝试释放 <code>x</code> 所指向的内存，这样做会导致内存泄漏或者程序崩溃，因为 <code>x</code> 不是通过 <code>new</code> 创建的。</p>
</li>
<li><p><code>int j = *x;</code>：<br>这行代码试图使用裸指针 <code>x</code> 来访问其所指向的内存中的值。然而，由于之前已经将 <code>x</code> 所指向的内存释放了，因此 <code>x</code> 成为了悬空指针，访问它的值会导致未定义行为。</p>
</li>
<li><p><code>shared_ptr&lt;int&gt; p(new int(42));</code>：<br>这行代码创建了一个动态分配的整型对象，并用 <code>shared_ptr&lt;int&gt;</code> 对象 <code>p</code> 来管理它。智能指针 <code>p</code> 具有内存管理功能，可以确保在适当的时候自动释放内存。</p>
</li>
<li><p><code>process(p);</code>：<br>这行代码将 <code>shared_ptr&lt;int&gt;</code> 对象 <code>p</code> 传递给了 <code>process()</code> 函数。智能指针 <code>p</code> 的引用计数会增加，因为 <code>process()</code> 函数会对其进行拷贝，这样在函数内部也会有一个指向相同内存的智能指针。</p>
</li>
<li><p><code>int i = *p;</code>：<br>这行代码试图使用智能指针 <code>p</code> 来访问其所管理的内存中的值。由于智能指针 <code>p</code> 是有效的，它所管理的内存也是有效的，因此可以正常地使用 <code>p</code> 来访问其所指向的值。</p>
</li>
</ol>
</blockquote>
<p>智能指针的<code>get</code>函数返回一个内置指针，指向智能指针管理的对象。主要用于向不能使用智能指针的代码传递内置指针。使用<code>get</code>返回指针的代码不能<code>delete</code>此指针。</p>
<p>不要使用<code>get</code>初始化另一个智能指针或为智能指针赋值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;    <span class="comment">// reference count is 1</span></span><br><span class="line"><span class="type">int</span> *q = p.<span class="built_in">get</span>();   <span class="comment">// ok: but don&#x27;t use q in any way that might delete its pointer</span></span><br><span class="line">&#123;   <span class="comment">// new block</span></span><br><span class="line">    <span class="comment">// undefined: two independent shared_ptrs point to the same memory</span></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(q);</span><br><span class="line">&#125; <span class="comment">// block ends, q is destroyed, and the memory to which q points is freed</span></span><br><span class="line"><span class="type">int</span> foo = *p;   <span class="comment">// undefined; the memory to which p points was freed</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码涉及了在使用 <code>shared_ptr</code> 时通过 <code>get()</code> 函数获取其内部裸指针的情况。让我逐步解释：</p>
<ol>
<li><p><code>shared_ptr&lt;int&gt; p(new int(42));</code>：<br>这行代码创建了一个动态分配的整型对象，并用 <code>shared_ptr&lt;int&gt;</code> 对象 <code>p</code> 来管理它。智能指针 <code>p</code> 的引用计数为1。</p>
</li>
<li><p><code>int *q = p.get();</code>：<br>这行代码通过 <code>get()</code> 函数获取了 <code>shared_ptr</code> 对象 <code>p</code> 内部所指向的裸指针，并将其赋值给了裸指针 <code>q</code>。但是需要注意的是，尽管 <code>q</code> 指向了与 <code>p</code> 相同的内存地址，但它不会增加引用计数。<code>get()</code> 函数的目的是为了兼容传统接口，但是使用裸指针 <code>q</code> 的任何地方都需要格外小心，以避免在 <code>p</code> 的生命周期内使用了已经释放的内存。</p>
</li>
<li><p><code>&#123;&#125;</code> 内的新块：<br>在这个新块中，创建了一个匿名的 <code>shared_ptr&lt;int&gt;</code> 对象，其构造函数接受了裸指针 <code>q</code>。由于这个 <code>shared_ptr</code> 对象是在一个新的作用域中创建的，所以它会在块结束时被销毁。因此，当块结束时，引用计数会减少，并且由 <code>q</code> 所指向的内存也会被释放。</p>
</li>
<li><p><code>int foo = *p;</code>：<br>这行代码试图使用智能指针 <code>p</code> 来访问其所管理的内存中的值。然而，在上一步中，由于块结束时释放了 <code>q</code> 所指向的内存，因此 <code>p</code> 现在成为了悬空指针，访问它的值将导致未定义行为。</p>
</li>
</ol>
<p>综上所述，尽管使用 <code>get()</code> 函数获取了智能指针的裸指针，但需要特别小心地使用裸指针，以确保不会在智能指针的生命周期内使用已释放的内存，避免出现未定义行为。</p>
</blockquote>
<p>可以用<code>reset</code>函数将新的指针赋予<code>shared_ptr</code>。与赋值类似，<code>reset</code>会更新引用计数，如果需要的话，还会释放内存空间。<code>reset</code>经常与<code>unique</code>一起使用，来控制多个<code>shared_ptr</code>共享的对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.<span class="built_in">unique</span>())</span><br><span class="line">    p.<span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">string</span>(*p));   <span class="comment">// we aren&#x27;t alone; allocate a new copy</span></span><br><span class="line">*p += newVal;   <span class="comment">// now that we know we&#x27;re the only pointer, okay to change this object</span></span><br></pre></td></tr></table></figure>
<h3 id="智能指针和异常（Smart-Pointers-and-Exceptions）"><a href="#智能指针和异常（Smart-Pointers-and-Exceptions）" class="headerlink" title="智能指针和异常（Smart Pointers and Exceptions）"></a>智能指针和异常（Smart Pointers and Exceptions）</h3><p>如果使用智能指针，即使程序块过早结束，智能指针类也能确保在内存不再需要时将其释放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> *ip = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">42</span>);    <span class="comment">// dynamically allocate a new object</span></span><br><span class="line">    <span class="comment">// code that throws an exception that is not caught inside f</span></span><br><span class="line">    <span class="keyword">delete</span> ip;     <span class="comment">// free the memory before exiting</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;    <span class="comment">// allocate a new object</span></span><br><span class="line">    <span class="comment">// code that throws an exception that is not caught inside f</span></span><br><span class="line">&#125; <span class="comment">// shared_ptr freed automatically when the function ends</span></span><br></pre></td></tr></table></figure>
<p>默认情况下<code>shared_ptr</code>假定其指向动态内存，使用<code>delete</code>释放对象。创建<code>shared_ptr</code>时可以传递一个（可选）指向删除函数的指针参数，用来代替<code>delete</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">destination</span>;    <span class="comment">// represents what we are connecting to</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">connection</span>;     <span class="comment">// information needed to use the connection</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination*)</span></span>;   <span class="comment">// open the connection</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">disconnect</span><span class="params">(connection)</span></span>;    <span class="comment">// close the given connection</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">disconnect</span>(*p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* other parameters */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">    <span class="function">shared_ptr&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;</span><br><span class="line">    <span class="comment">// use the connection</span></span><br><span class="line">    <span class="comment">// when f exits, even if by an exception, the connection will be properly closed</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>智能指针规范：</p>
<ul>
<li>不使用相同的内置指针值初始化或<code>reset</code>多个智能指针。</li>
<li>不释放<code>get</code>返回的指针。</li>
<li>不使用<code>get</code>初始化或<code>reset</code>另一个智能指针。</li>
<li>使用<code>get</code>返回的指针时，如果最后一个对应的智能指针被销毁，指针就无效了。</li>
<li>使用<code>shared_ptr</code>管理并非<code>new</code>分配的资源时，应该传递删除函数。</li>
</ul>
<h3 id="unique-ptr（unique-ptr）"><a href="#unique-ptr（unique-ptr）" class="headerlink" title="unique_ptr（unique_ptr）"></a><code>unique_ptr</code>（<code>unique_ptr</code>）</h3><p>与<code>shared_ptr</code>不同，同一时刻只能有一个<code>unique_ptr</code>指向给定的对象。当<code>unique_ptr</code>被销毁时，它指向的对象也会被销毁。</p>
<p><code>make_unique</code>函数（C++14新增，定义在头文件<code>memory</code>中）在动态内存中分配一个对象并初始化它，返回指向此对象的<code>unique_ptr</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line"><span class="comment">// C++14</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p2 = <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>由于<code>unique_ptr</code>独占其指向的对象，因此<code>unique_ptr</code>不支持普通的拷贝或赋值操作。</p>
<p><code>release</code>函数返回<code>unique_ptr</code>当前保存的指针并将其置为空。</p>
<p><code>reset</code>函数成员接受一个可选的指针参数，重新设置<code>unique_ptr</code>保存的指针。如果<code>unique_ptr</code>不为空，则它原来指向的对象会被释放。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// transfers ownership from p1 (which points to the string Stegosaurus) to p2</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>;    <span class="comment">// release makes p1 null</span></span><br><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> string(<span class="string">&quot;Trex&quot;</span>))</span></span>;</span><br><span class="line"><span class="comment">// transfers ownership from p3 to p2</span></span><br><span class="line">p2.<span class="built_in">reset</span>(p3.<span class="built_in">release</span>()); <span class="comment">// reset deletes the memory to which p2 had pointed</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码展示了如何使用 <code>release()</code> 和 <code>reset()</code> 函数在 <code>unique_ptr</code> 之间转移所有权。让我逐步解释：</p>
<ol>
<li><p><code>unique_ptr&lt;string&gt; p2(p1.release());</code>：</p>
<ul>
<li><code>p1.release()</code> 函数释放了 <code>p1</code> 所管理的内存，同时返回了指向该内存的指针，并且将 <code>p1</code> 置空（指向 <code>nullptr</code>）。</li>
<li>然后，将这个指针传递给了 <code>unique_ptr</code> 构造函数，用于构造一个新的 <code>unique_ptr</code> 对象 <code>p2</code>，从而完成了所有权的转移。现在，<code>p2</code> 拥有了原先由 <code>p1</code> 管理的内存，而 <code>p1</code> 不再拥有该内存。</li>
</ul>
</li>
<li><p><code>unique_ptr&lt;string&gt; p3(new string(&quot;Trex&quot;));</code>：</p>
<ul>
<li>创建了一个动态分配的字符串对象，并用 “Trex” 来初始化它，并将其管理权交给 <code>unique_ptr</code> 对象 <code>p3</code>。</li>
</ul>
</li>
<li><p><code>p2.reset(p3.release());</code>：</p>
<ul>
<li><code>p3.release()</code> 函数释放了 <code>p3</code> 所管理的内存，并返回了指向该内存的指针，同时将 <code>p3</code> 置空。</li>
<li>然后，<code>reset()</code> 函数接受这个指针作为参数，并释放了 <code>p2</code> 所管理的内存，然后将 <code>p2</code> 重新指向了这块新的内存。这样，所有权从 <code>p3</code> 转移到了 <code>p2</code>。</li>
</ul>
</li>
</ol>
<p>综上所述，<code>release()</code> 函数将 <code>unique_ptr</code> 对象的所有权释放，并返回指向管理的内存的指针，同时将 <code>unique_ptr</code> 置空。而 <code>reset()</code> 函数允许将 <code>unique_ptr</code> 重新指向新的内存，并释放原先管理的内存。通过这两个函数的组合使用，可以实现 <code>unique_ptr</code> 之间的所有权转移。</p>
</blockquote>
<p>调用<code>release</code>会切断<code>unique_ptr</code>和它原来管理的对象之间的联系。<code>release</code>返回的指针通常被用来初始化另一个智能指针或给智能指针赋值。如果没有用另一个智能指针保存<code>release</code>返回的指针，程序就要负责资源的释放。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p2.<span class="built_in">release</span>();   <span class="comment">// WRONG: p2 won&#x27;t free the memory and we&#x27;ve lost the pointer</span></span><br><span class="line"><span class="keyword">auto</span> p = p2.<span class="built_in">release</span>();   <span class="comment">// ok, but we must remember to delete(p)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码使用了 <code>release()</code> 函数来释放 <code>unique_ptr</code> 对象 <code>p2</code> 所管理的内存，但是存在一些问题。让我详细解释一下：</p>
<ol>
<li><p><code>p2.release();</code>：</p>
<ul>
<li>这行代码调用了 <code>release()</code> 函数，该函数释放了 <code>p2</code> 所管理的内存，并返回了指向该内存的指针。但是需要注意的是，<code>release()</code> 函数只是释放了内存，而并没有将 <code>unique_ptr</code> 置空。</li>
<li>这是一个错误的用法，因为 <code>release()</code> 函数只是释放了内存，而并没有将 <code>unique_ptr</code> 置空，所以 <code>p2</code> 仍然持有对原始内存的所有权，但是丢失了对原始指针的控制，这样会导致内存泄漏。</li>
</ul>
</li>
<li><p><code>auto p = p2.release();</code>：</p>
<ul>
<li>这行代码调用了 <code>release()</code> 函数，将 <code>p2</code> 所管理的内存释放，并返回了指向该内存的指针。然后，使用 <code>auto</code> 关键字声明一个指针 <code>p</code>，将返回的指针赋给了 <code>p</code>。</li>
<li>这种用法也是正确的，但是需要注意的是，现在需要手动管理内存的释放。在使用 <code>auto</code> 声明的指针 <code>p</code> 后，需要在适当的时候使用 <code>delete p</code> 手动释放内存，否则会导致内存泄漏。</li>
</ul>
</li>
</ol>
<p>总的来说，<code>release()</code> 函数用于释放 <code>unique_ptr</code> 对象所管理的内存，并返回指向该内存的裸指针，但是需要注意确保在适当的时候手动管理内存的释放，以避免内存泄漏。</p>
</blockquote>
<p>不能拷贝<code>unique_ptr</code>的规则有一个例外：可以拷贝或赋值一个即将被销毁的<code>unique_ptr</code>（移动构造、移动赋值）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="type">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span> (p))</span></span>;</span><br><span class="line">    <span class="comment">// . . .</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="weak-ptr（weak-ptr）"><a href="#weak-ptr（weak-ptr）" class="headerlink" title="weak_ptr（weak_ptr）"></a><code>weak_ptr</code>（<code>weak_ptr</code>）</h3><p><code>weak_ptr</code>是一种不控制所指向对象生存期的智能指针，它指向一个由<code>shared_ptr</code>管理的对象。将<code>weak_ptr</code>绑定到<code>shared_ptr</code>不会改变<code>shared_ptr</code>的引用计数。如果<code>shared_ptr</code>被销毁，即使有<code>weak_ptr</code>指向对象，对象仍然有可能被释放。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>操作</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>weak_ptr&lt;T&gt; w(sp)</code></td>
<td><code>w</code>与<code>shared_ptr sp</code>指向相同对象</td>
</tr>
<tr>
<td><code>w.use_count()</code></td>
<td>返回与<code>w</code>共享对象的<code>shared_ptr</code>的数量·</td>
</tr>
<tr>
<td><code>w.expired()</code></td>
<td>若<code>w.use_count() == 0</code>，则返回<code>true</code></td>
</tr>
<tr>
<td><code>w.lock()</code></td>
<td>若<code>w.expired() == true</code>，则返回空<code>shared_ptr</code>；否则返回一个指向<code>w</code>的对象的<code>shared_ptr</code></td>
</tr>
</tbody>
</table>
</div>
<p>创建一个<code>weak_ptr</code>时，需要使用<code>shared_ptr</code>来初始化它。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="function">weak_ptr&lt;<span class="type">int</span>&gt; <span class="title">wp</span><span class="params">(p)</span></span>;    <span class="comment">// wp weakly shares with p; use count in p is unchanged</span></span><br></pre></td></tr></table></figure>
<p>使用<code>weak_ptr</code>访问对象时，必须先调用<code>lock</code>函数。该函数检查<code>weak_ptr</code>指向的对象是否仍然存在。如果存在，则返回指向共享对象的<code>shared_ptr</code>，否则返回空指针。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (shared_ptr&lt;<span class="type">int</span>&gt; np = wp.<span class="built_in">lock</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// true if np is not null</span></span><br><span class="line">    <span class="comment">// inside the if, np shares its object with p</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="动态数组（Dynamic-Arrays）"><a href="#动态数组（Dynamic-Arrays）" class="headerlink" title="动态数组（Dynamic Arrays）"></a>动态数组（Dynamic Arrays）</h2><p>使用<code>allocator</code>类可以将内存分配和初始化过程分离，这通常会提供更好的性能和更灵活的内存管理能力。</p>
<h3 id="new和数组（new-and-Arrays）"><a href="#new和数组（new-and-Arrays）" class="headerlink" title="new和数组（new and Arrays）"></a><code>new</code>和数组（<code>new</code> and Arrays）</h3><p>使用<code>new</code>分配对象数组时需要在类型名之后跟一对方括号，在其中指明要分配的对象数量（必须是整型，但不必是常量）。<code>new</code>返回指向第一个对象的指针（元素类型）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// call get_size to determine how many ints to allocate</span></span><br><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="built_in">get_size</span>()];   <span class="comment">// pia points to the first of these ints</span></span><br></pre></td></tr></table></figure>
<p>由于<code>new</code>分配的内存并不是数组类型，因此不能对动态数组调用<code>begin</code>和<code>end</code>，也不能用范围<code>for</code>语句处理其中的元素。</p>
<p>默认情况下，<code>new</code>分配的对象是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小后面跟一对空括号<code>()</code>。在新标准中，还可以提供一个元素初始化器的花括号列表。如果初始化器数量大于元素数量，则<code>new</code>表达式失败，不会分配任何内存，并抛出<code>bad_array_new_length</code>异常。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pia = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>];     <span class="comment">// block of ten uninitialized ints</span></span><br><span class="line"><span class="type">int</span> *pia2 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]();    <span class="comment">// block of ten ints value initialized to 0</span></span><br><span class="line">string *psa = <span class="keyword">new</span> string[<span class="number">10</span>];    <span class="comment">// block of ten empty strings</span></span><br><span class="line">string *psa2 = <span class="keyword">new</span> string[<span class="number">10</span>]();    <span class="comment">// block of ten empty strings</span></span><br><span class="line"><span class="comment">// block of ten ints each initialized from the corresponding initializer</span></span><br><span class="line"><span class="type">int</span> *pia3 = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>] &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// block of ten strings; the first four are initialized from the given initializers</span></span><br><span class="line"><span class="comment">// remaining elements are value initialized</span></span><br><span class="line">string *psa3 = <span class="keyword">new</span> string[<span class="number">10</span>] &#123; <span class="string">&quot;a&quot;</span>, <span class="string">&quot;an&quot;</span>, <span class="string">&quot;the&quot;</span>, <span class="built_in">string</span>(<span class="number">3</span>,<span class="string">&#x27;x&#x27;</span>) &#125;;</span><br></pre></td></tr></table></figure>
<p>虽然可以使用空括号对<code>new</code>分配的数组元素进行值初始化，但不能在括号中指定初始化器。这意味着不能用<code>auto</code>分配数组。</p>
<p>动态分配一个空数组是合法的，此时<code>new</code>会返回一个合法的非空指针。对于零长度的数组来说，该指针类似尾后指针，不能解引用。</p>
<p>使用<code>delete[]</code>释放动态数组。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> p;       <span class="comment">// p must point to a dynamically allocated object or be null</span></span><br><span class="line"><span class="keyword">delete</span> [] pa;   <span class="comment">// pa must point to a dynamically allocated array or be null</span></span><br></pre></td></tr></table></figure>
<p>如果在<code>delete</code>数组指针时忘记添加方括号，或者在<code>delete</code>单一对象时使用了方括号，编译器很可能不会给出任何警告，程序可能会在执行过程中行为异常。</p>
<p><code>unique_ptr</code>可以直接管理动态数组，定义时需要在对象类型后添加一对空方括号<code>[]</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// up points to an array of ten uninitialized ints</span></span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">up.<span class="built_in">release</span>();   <span class="comment">// automatically uses delete[] to destroy its pointer</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li>自动使用 <code>delete[]</code>：<ul>
<li>当 <code>release()</code> 函数被调用时，<code>unique_ptr</code> 对象会自动根据其类型来决定使用 <code>delete</code> 还是 <code>delete[]</code> 操作符来销毁其所管理的内存。</li>
<li>对于 <code>unique_ptr&lt;int[]&gt;</code> 类型，<code>unique_ptr</code> 知道它所管理的是一个动态分配的数组，因此在调用 <code>release()</code> 函数后，它会使用 <code>delete[]</code> 操作符来销毁该数组。</li>
</ul>
</li>
</ol>
</blockquote>
<p>与<code>unique_ptr</code>不同，<code>shared_ptr</code>不直接支持动态数组管理。如果想用<code>shared_ptr</code>管理动态数组，必须提供自定义的删除器。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// to use a shared_ptr we must supply a deleter</span></span><br><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span> *p) &#123; <span class="keyword">delete</span>[] p; &#125;)</span></span>;</span><br><span class="line">sp.<span class="built_in">reset</span>();    <span class="comment">// uses the lambda we supplied that uses delete[] to free the array</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><p><code>shared_ptr&lt;int&gt; sp(new int[10], [](int *p) &#123; delete[] p; &#125;);</code>：</p>
<ul>
<li>这行代码创建了一个名为 <code>sp</code> 的 <code>shared_ptr</code> 对象，用于管理一个动态分配的整型数组。</li>
<li>构造函数的第一个参数是指向动态分配的数组的指针，第二个参数是一个 lambda 表达式，用于自定义删除器。</li>
<li>lambda 表达式 <code>[](int *p) &#123; delete[] p; &#125;</code> 接受一个 <code>int*</code> 类型的指针参数，并使用 <code>delete[]</code> 操作符来释放指向数组的内存。这样就确保了当 <code>shared_ptr</code> 对象销毁时，使用自定义删除器来正确释放动态分配的数组内存。</li>
</ul>
</li>
<li><p><code>sp.reset();</code>：</p>
<ul>
<li>这行代码调用了 <code>reset()</code> 函数，该函数将 <code>shared_ptr</code> 对象 <code>sp</code> 置空，释放其所管理的内存。</li>
<li>在调用 <code>reset()</code> 函数时，<code>shared_ptr</code> 对象将会调用之前提供的自定义删除器 lambda 表达式，使用 <code>delete[]</code> 操作符来释放动态分配的数组内存。</li>
<li>这样可以确保在使用 <code>shared_ptr</code> 管理动态分配数组的情况下，内存能够正确释放，避免内存泄漏问题。</li>
</ul>
</li>
</ol>
</blockquote>
<p><code>shared_ptr</code>未定义下标运算符，智能指针类型也不支持指针算术运算。因此如果想访问<code>shared_ptr</code>管理的数组元素，必须先用<code>get</code>获取内置指针，再用内置指针进行访问。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// shared_ptrs don&#x27;t have subscript operator and don&#x27;t support pointer arithmetic</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    *(sp.<span class="built_in">get</span>() + i) = i;    <span class="comment">// use get to get a built-in pointer</span></span><br></pre></td></tr></table></figure>
<h3 id="allocator类（The-allocator-Class）"><a href="#allocator类（The-allocator-Class）" class="headerlink" title="allocator类（The allocator Class）"></a><code>allocator</code>类（The <code>allocator</code> Class）</h3><p><code>allocator</code>类是一个模板，定义时必须指定其可以分配的对象类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;string&gt; alloc;    <span class="comment">// object that can allocate strings</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> p = alloc.<span class="built_in">allocate</span>(n);   <span class="comment">// allocate n unconstructed strings</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>这段代码创建了一个名为 <code>alloc</code> 的 <code>allocator&lt;string&gt;</code> 对象，该对象可以用来分配字符串类型的内存空间。然后，使用 <code>allocate()</code> 函数来分配了 <code>n</code> 个未构造的字符串对象，并将分配的内存空间的起始地址赋值给了 <code>p</code>。</p>
</blockquote>
<p><code>allocator</code>分配的内存是未构造的，程序需要在此内存中构造对象。新标准库的<code>construct</code>函数接受一个指针和零或多个额外参数，在给定位置构造一个元素。额外参数用来初始化构造的对象，必须与对象类型相匹配。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> q = p;     <span class="comment">// q will point to one past the last constructed element</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++);    <span class="comment">// *q is the empty string</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++, <span class="number">10</span>, <span class="string">&#x27;c&#x27;</span>);  <span class="comment">// *q is cccccccccc</span></span><br><span class="line">alloc.<span class="built_in">construct</span>(q++, <span class="string">&quot;hi&quot;</span>);     <span class="comment">// *q is hi!</span></span><br></pre></td></tr></table></figure>
<blockquote>
<ol>
<li><p><code>auto q = p;</code>：</p>
<ul>
<li>这行代码将 <code>p</code> 的值赋给了 <code>q</code>，使得 <code>q</code> 指向分配的内存空间的起始位置。</li>
</ul>
</li>
<li><p><code>alloc.construct(q++);</code>：</p>
<ul>
<li>这行代码调用了 <code>construct()</code> 函数，用于在 <code>q</code> 指向的位置构造一个未初始化的字符串对象。</li>
<li><code>q++</code> 表示先使用 <code>q</code> 的值进行构造，然后递增 <code>q</code> 指向下一个位置。因此，此时 <code>q</code> 指向下一个未构造的字符串对象的位置。</li>
<li>构造后的字符串对象是空字符串，因为未提供任何参数来初始化它。</li>
</ul>
</li>
<li><p><code>alloc.construct(q++, 10, &#39;c&#39;);</code>：</p>
<ul>
<li>这行代码调用了 <code>construct()</code> 函数，用于在 <code>q</code> 指向的位置构造一个未初始化的字符串对象。</li>
<li><code>10, &#39;c&#39;</code> 是传递给 <code>construct()</code> 函数的参数，用于初始化构造的字符串对象。这表示该字符串对象由10个字符 <code>&#39;c&#39;</code> 组成。</li>
<li><code>q++</code> 递增了 <code>q</code>，使得 <code>q</code> 指向下一个未构造的字符串对象的位置。</li>
</ul>
</li>
<li><p><code>alloc.construct(q++, &quot;hi&quot;);</code>：</p>
<ul>
<li>这行代码调用了 <code>construct()</code> 函数，用于在 <code>q</code> 指向的位置构造一个未初始化的字符串对象。</li>
<li><code>&quot;hi&quot;</code> 是传递给 <code>construct()</code> 函数的参数，用于初始化构造的字符串对象。这表示该字符串对象的内容为 <code>&quot;hi&quot;</code>。</li>
<li><code>q++</code> 递增了 <code>q</code>，使得 <code>q</code> 指向下一个未构造的字符串对象的位置。</li>
</ul>
</li>
</ol>
</blockquote>
<p>直接使用<code>allocator</code>返回的未构造内存是错误行为，其结果是未定义的。</p>
<p>对象使用完后，必须对每个构造的元素调用<code>destroy</code>进行销毁。<code>destroy</code>函数接受一个指针，对指向的对象执行析构函数。</p>
<blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (q != p)</span><br><span class="line">    alloc.<span class="built_in">destroy</span>(--q);  <span class="comment">// free the strings we actually allocated</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>deallocate</code>函数用于释放<code>allocator</code>分配的内存空间。传递给<code>deallocate</code>的指针不能为空，它必须指向由<code>allocator</code>分配的内存。而且传递给<code>deallocate</code>的大小参数必须与调用<code>allocator</code>分配内存时提供的大小参数相一致。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alloc.<span class="built_in">deallocate</span>(p, n);</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://github.com/czs108/Cpp-Primer-5th-Notes-CN?tab=readme-ov-file">czs108/Cpp-Primer-5th-Notes-CN: 📚 《C++ Primer中文版（第5版）》笔记 (github.com)</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://totorocatcat.top">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/2024/04/05/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/">http://totorocatcat.top/2024/04/05/%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9F%BA%E7%A1%80/">基础</a></div><div class="post_share"><div class="social-share" data-image="https://npm.elemecdn.com/ushio-api-img-moe@5.0.12/img_126_627x885_349.986572265625_null_normal.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/05/%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/" title="拷贝控制"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_80.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">拷贝控制</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/05/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/" title="关联容器"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.29/img_292_2480x1650_200_null_normal.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">关联容器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/03/12/CF933/" title="CF933"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.77/img_771_600x839_72_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-12</div><div class="title">CF933</div></div></a></div><div><a href="/2024/03/04/C-%E5%9F%BA%E7%A1%80/" title="C++基础"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.24/img_249_2081x1420_96_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-04</div><div class="title">C++基础</div></div></a></div><div><a href="/2024/03/16/HTML%E5%88%9D%E6%AD%A5/" title="HTML初步"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.16/img_169_2560x1440_96_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-16</div><div class="title">HTML初步</div></div></a></div><div><a href="/2024/04/05/IO%E5%BA%93/" title="IO库"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.45/img_457_2249x1064_350_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-05</div><div class="title">IO库</div></div></a></div><div><a href="/2024/04/06/Library/" title="chapter8.the.Library"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.26/img_260_1920x1115_72_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-06</div><div class="title">chapter8.the.Library</div></div></a></div><div><a href="/2024/03/03/Markdown%E6%A0%BC%E5%BC%8F/" title="Markdown格式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.48/img_482_1920x1080_96_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-03</div><div class="title">Markdown格式</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">243</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98"><span class="toc-number">1.</span> <span class="toc-text">动态内存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E4%B8%8E%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%EF%BC%88Dynamic-Memory-and-Smart-Pointers%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">动态内存与智能指针（Dynamic Memory and Smart Pointers）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr%E7%B1%BB%EF%BC%88The-shared-ptr-Class%EF%BC%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">shared_ptr类（The shared_ptr Class）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%AE%A1%E7%90%86%E5%86%85%E5%AD%98%EF%BC%88Managing-Memory-Directly%EF%BC%89"><span class="toc-number">1.1.2.</span> <span class="toc-text">直接管理内存（Managing Memory Directly）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared-ptr%E5%92%8Cnew%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%EF%BC%88Using-shared-ptrs-with-new%EF%BC%89e"><span class="toc-number">1.1.3.</span> <span class="toc-text">shared_ptr和new结合使用（Using shared_ptrs with new）e</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%82%E5%B8%B8%EF%BC%88Smart-Pointers-and-Exceptions%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">智能指针和异常（Smart Pointers and Exceptions）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#unique-ptr%EF%BC%88unique-ptr%EF%BC%89"><span class="toc-number">1.1.5.</span> <span class="toc-text">unique_ptr（unique_ptr）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#weak-ptr%EF%BC%88weak-ptr%EF%BC%89"><span class="toc-number">1.1.6.</span> <span class="toc-text">weak_ptr（weak_ptr）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%EF%BC%88Dynamic-Arrays%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">动态数组（Dynamic Arrays）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new%E5%92%8C%E6%95%B0%E7%BB%84%EF%BC%88new-and-Arrays%EF%BC%89"><span class="toc-number">1.2.1.</span> <span class="toc-text">new和数组（new and Arrays）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#allocator%E7%B1%BB%EF%BC%88The-allocator-Class%EF%BC%89"><span class="toc-number">1.2.2.</span> <span class="toc-text">allocator类（The allocator Class）</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="只此无为身，且前行,忘记过去的人注定重蹈覆辙,我是我，我靠自己站立，我会做好自身,如果我睡大觉，谁给我摘月亮呢,假期和朋友，是人生中顶好的两样东西啊。,去爱，去失去，要不负相遇,没什么想不想通的，只是固执而已,我们深爱星辰，乃至不惧夜的黑,吃，喝，享受幸福，接受奇迹,浊水若长流，自清澄,雅俗共赏,总会有什么也不想的幸福时刻吧,时间顺流而下，生活逆流而上,悟已往之不谏，知来者之可追,希望你的小世界里,山花烂漫,茶酒俱全,安宁清淡,明朗欢愉" data-fontsize="18px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" href="categories/刷题计划/">刷题计划</a><span class="categoryBar-list-count">84</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" href="categories/ACMの旅/">ACMの旅</a><span class="categoryBar-list-count">64</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" href="categories/数学建模/">数学建模</a><span class="categoryBar-list-count">31</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" href="categories/编程基础/">编程基础</a><span class="categoryBar-list-count">28</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" href="categories/CS知识/">CS知识</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" href="categories/前端の旅/">前端の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" href="categories/个人安排/">个人安排</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" href="categories/文学/">文学</a><span class="categoryBar-list-count">28</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" href="categories/杂项/">杂项</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" href="categories/数据结构/">数据结构</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" href="categories/少年游/">少年游</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/01/29/诗兴大发/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" href="2024/01/29/诗兴大发/" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" href="2024/01/29/诗兴大发/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/02/13/数据结构与算法-1/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.64/img_649_702x1000_300_null_normal.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-02-13</span><a class="blog-slider__title" href="2024/02/13/数据结构与算法-1/" alt="">数据结构与算法(总)</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" href="2024/02/13/数据结构与算法-1/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/02/24/常见优化技巧/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_238.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-02-24</span><a class="blog-slider__title" href="2024/02/24/常见优化技巧/" alt="">常见优化技巧</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2024/02/24/常见优化技巧/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>