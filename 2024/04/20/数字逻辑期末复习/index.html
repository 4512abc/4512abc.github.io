<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数字逻辑期末复习 | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数字逻辑第一章大体题目可能就是数字转换，补码和基础逻辑门了 这些练习涉及了二进制加法、十六进制加法和二进制减法，并且一些情况下可能会出现溢出。让我们一一解释： 练习 1.56 (a) 010000 + 001001 &#x3D; 011001：  这是两个二进制数的简单加法。结果为6位，不会发生溢出。   (b) 011011 + 011111 &#x3D; 111010 (overflow)：  这两个二进制数相加">
<meta property="og:type" content="article">
<meta property="og:title" content="数字逻辑期末复习">
<meta property="og:url" content="http://totorocatcat.top/2024/04/20/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="数字逻辑第一章大体题目可能就是数字转换，补码和基础逻辑门了 这些练习涉及了二进制加法、十六进制加法和二进制减法，并且一些情况下可能会出现溢出。让我们一一解释： 练习 1.56 (a) 010000 + 001001 &#x3D; 011001：  这是两个二进制数的简单加法。结果为6位，不会发生溢出。   (b) 011011 + 011111 &#x3D; 111010 (overflow)：  这两个二进制数相加">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.0/img_7_2000x1102_299.719970703125_null_normal.jpg">
<meta property="article:published_time" content="2024-04-20T12:21:47.000Z">
<meta property="article:modified_time" content="2024-05-27T13:20:48.704Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="有趣">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.0/img_7_2000x1102_299.719970703125_null_normal.jpg"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/b5ca6e582a7a45e6fde46e616eeb68e.png"><link rel="canonical" href="http://totorocatcat.top/2024/04/20/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto:wght@700&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":765,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数字逻辑期末复习',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2024-05-27 21:20:48'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (true) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">746</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg fixed" id="page-header" style="background-image: url('https://npm.elemecdn.com/ushio-api-img-moe@5.0.0/img_7_2000x1102_299.719970703125_null_normal.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home-alt"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/project/"><i class="fa-fw fas fas fa-folder"></i><span> 项目</span></a></div><div class="menus_item"><a class="site-page" href="/stars/"><i class="fa-fw fas fa-bookmark"></i><span> 收藏</span></a></div><div class="menus_item"><a class="site-page" href="/bilibili/"><i class="fa-fw fas fa-tv"></i><span> 追番</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数字逻辑期末复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-20T12:21:47.000Z" title="发表于 2024-04-20 20:21:47">2024-04-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-05-27T13:20:48.704Z" title="更新于 2024-05-27 21:20:48">2024-05-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9C%9F%E6%9C%AB%E3%81%AE%E6%97%85/">期末の旅</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">22.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>89分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数字逻辑期末复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数字逻辑第一章"><a href="#数字逻辑第一章" class="headerlink" title="数字逻辑第一章"></a>数字逻辑第一章</h1><p>大体题目可能就是数字转换，补码和基础逻辑门了</p>
<p>这些练习涉及了二进制加法、十六进制加法和二进制减法，并且一些情况下可能会出现溢出。让我们一一解释：</p>
<h3 id="练习-1-56"><a href="#练习-1-56" class="headerlink" title="练习 1.56"></a>练习 1.56</h3><ol>
<li><p>(a) 010000 + 001001 = 011001：</p>
<ul>
<li>这是两个二进制数的简单加法。结果为6位，不会发生溢出。</li>
</ul>
</li>
<li><p>(b) 011011 + 011111 = 111010 (overflow)：</p>
<ul>
<li>这两个二进制数相加后，结果为6位，但是最高位有进位，导致溢出。</li>
</ul>
</li>
<li><p>(c) 111100 + 010011 = 001111：</p>
<ul>
<li>二进制加法，结果为6位，不会发生溢出。</li>
</ul>
</li>
<li><p>(d) 000011 + 100000 = 100011：</p>
<ul>
<li>结果为6位，不会溢出。</li>
</ul>
</li>
<li><p>(e) 110000 + 110111 = 100111：</p>
<ul>
<li>结果为6位，不会溢出。</li>
</ul>
</li>
<li><p>(f) 100101 + 100001 = 000110 (overflow)：</p>
<ul>
<li>结果为6位，但是最高位有进位，导致溢出。</li>
</ul>
</li>
</ol>
<h3 id="练习-1-57"><a href="#练习-1-57" class="headerlink" title="练习 1.57"></a>练习 1.57</h3><ol>
<li><p>(a) 000111 + 001101 = 010100：</p>
<ul>
<li>结果为6位，不会溢出。</li>
</ul>
</li>
<li><p>(b) 010001 + 011001 = 101010, overflow：</p>
<ul>
<li>结果为6位，但是最高位有进位，导致溢出。</li>
</ul>
</li>
<li><p>(c) 100110 + 001000 = 101110：</p>
<ul>
<li>结果为6位，不会溢出。</li>
</ul>
</li>
<li><p>(d) 011111 + 110010 = 010001：</p>
<ul>
<li>结果为6位，不会溢出。</li>
</ul>
</li>
<li><p>(e) 101101 + 101010 = 010111, overflow：</p>
<ul>
<li>结果为6位，但是最高位有进位，导致溢出。</li>
</ul>
</li>
<li><p>(f) 111110 + 100011 = 100001：</p>
<ul>
<li>结果为6位，不会溢出。</li>
</ul>
</li>
</ol>
<h3 id="练习-1-58"><a href="#练习-1-58" class="headerlink" title="练习 1.58"></a>练习 1.58</h3><ol>
<li><p>(a) 10：</p>
<ul>
<li>这是十进制数转换成二进制数。10的二进制表示为<code>1010</code>。</li>
</ul>
</li>
<li><p>(b) 3B：</p>
<ul>
<li>这是十六进制数转换成二进制数。3B的十六进制表示为<code>00111011</code>，对应的二进制是<code>111011</code>。</li>
</ul>
</li>
<li><p>(c) E9：</p>
<ul>
<li>这是十六进制数转换成二进制数。E9的十六进制表示为<code>11101001</code>，对应的二进制是<code>11101001</code>。</li>
</ul>
</li>
<li><p>(d) 13C (overflow)：</p>
<ul>
<li>这是十六进制数转换成二进制数，结果为4位，但是溢出了。</li>
</ul>
</li>
</ol>
<h3 id="练习-1-59"><a href="#练习-1-59" class="headerlink" title="练习 1.59"></a>练习 1.59</h3><ol>
<li><p>(a) 0x2A：</p>
<ul>
<li>这是十六进制数的直接转换。0x2A十六进制表示的十进制数是42，对应的二进制是<code>00101010</code>。</li>
</ul>
</li>
<li><p>(b) 0x9F：</p>
<ul>
<li>这是十六进制数的直接转换。0x9F十六进制表示的十进制数是159，对应的二进制是<code>10011111</code>。</li>
</ul>
</li>
<li><p>(c) 0xFE：</p>
<ul>
<li>这是十六进制数的直接转换。0xFE十六进制表示的十进制数是254，对应的二进制是<code>11111110</code>。</li>
</ul>
</li>
<li><p>(d) 0x66, overflow：</p>
<ul>
<li>这是十六进制数的直接转换。0x66十六进制表示的十进制数是102，对应的二进制是<code>01100110</code>。结果为8位，但是溢出了。</li>
</ul>
</li>
</ol>
<h3 id="练习-1-60"><a href="#练习-1-60" class="headerlink" title="练习 1.60"></a>练习 1.60</h3><ol>
<li>(a) 01001 - 00111 = 00010；</li>
<li>(b) 01100 - 01111 = 11101；</li>
<li>(c) 11010 - 01011 = 01111；</li>
<li>(d) 00100 - 11000 = 01100。</li>
</ol>
<h3 id="练习-1-61"><a href="#练习-1-61" class="headerlink" title="练习 1.61"></a>练习 1.61</h3><ol>
<li>(a) 010010 + 110100 = 000110；</li>
<li>(b) 011110 + 110111 = 010101；</li>
<li>(c) 100100 + 111101 = 100001；</li>
<li>(d) 110000 + 101011 = 011011, overflow。</li>
</ol>
<p>还有一种题型就是列出无符号，有符号和补码</p>
<p>注意有符号有2个0就可以了，还有补码可以比有符号多表示一位负数</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/2024/04/20/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/Totoro.trip\blog-demo\source\images\image-20240527164409341.png" alt="image-20240527164409341"></p>
<p>还有一类题就是逻辑门的真值表书写和逻辑门的绘画</p>
<p>五输入与非门</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
<th>Y</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
</tbody>
</table>
</div>
<p>还有一类题就是计算下面这些东西</p>
<p>这些参数是指数字逻辑电路中使用的逻辑电平的标准值。它们通常用于描述数字信号的电气特性，例如逻辑门的输入和输出电平。</p>
<ul>
<li><strong>VIL</strong>（低电平输入电压）：表示逻辑门将输入视为低电平的最大电压值。</li>
<li><strong>VIH</strong>（高电平输入电压）：表示逻辑门将输入视为高电平的最小电压值。</li>
<li><strong>VOL</strong>（低电平输出电压）：表示逻辑门输出的最大低电平电压值。</li>
<li><strong>VOH</strong>（高电平输出电压）：表示逻辑门输出的最小高电平电压值。</li>
<li><strong>NML</strong>（低电平噪声容忍度）：表示逻辑门在低电平状态下的电压噪声容忍度。</li>
<li><strong>NMH</strong>（高电平噪声容忍度）：表示逻辑门在高电平状态下的电压噪声容忍度。</li>
</ul>
<p>减一下就可以了</p>
<h1 id="数字逻辑第二章"><a href="#数字逻辑第二章" class="headerlink" title="数字逻辑第二章"></a>数字逻辑第二章</h1><p>第二章的题型是通过布尔一系列公式和卡诺图（注意是格雷码，还有四个角落）对表达式进行化简。</p>
<p>这些需要掌握一系列公理和相应的卡诺图化简的思路。</p>
<blockquote>
<p>卡诺图化简的规则如下：</p>
<ol>
<li><p>用最少的圈来圈住所有的1：确保使用最少数量的圈覆盖所有为1的方格。</p>
</li>
<li><p>圈中的所有方格必须都为1：每个圈内的方格都必须为1，不能有任何0。</p>
</li>
<li><p>每一个圈必须是矩形，其每边长必须是2的整数次幂（即1、2或者4）：圈必须是横向或纵向相邻的方格组成的矩形，且每条边的长度必须是2的整数次幂。</p>
</li>
<li><p>每一个圈必须尽可能大：圈应该尽可能地包括更多的1，但不能重叠。</p>
</li>
<li><p>圈可以环绕卡诺图的边界：圈可以延伸到卡诺图的边界。</p>
</li>
<li><p>如果可以使用更少数量的圈，卡诺图中一个为1的方格可以被多次圈住：如果通过使用更少的圈来覆盖相同的1，可以多次圈住某个方格。</p>
</li>
</ol>
<p>遵循这些规则，可以通过卡诺图化简布尔表达式，以得到最简化的结果。</p>
</blockquote>
<p>除此之外还有与或式和或与式，与或式就是找到为1的并全部换为1加起来，或与式就是找到所有为0的变成0后与起来。</p>
<blockquote>
<p>在逻辑电路设计中，真值表描述了输入和输出之间的关系，而与或式则是一种常用的布尔表达式形式，用于描述真值表中输出为真的所有最小项之和。</p>
<p>在与或式中，每个最小项对应着一个与门的输入，而整个布尔表达式则是这些最小项之间的或运算。这样的表达式称为“与或式（sum-of-products）”。</p>
<p>例如，给定一个真值表，可以列出所有输出为真的最小项，然后将这些最小项进行或运算，得到布尔表达式。比如，对于图中所示的真值表，最小项为AB和BA，所以布尔表达式为Y = AB + BA。</p>
<p>这种形式的布尔表达式可以通过求和符号写成连续相加的形式，如Y = Σ(AB, BA)，其中Σ表示求和。</p>
<p>根据例2.2的描述，我们有以下输入和输出：</p>
<ul>
<li>输入A表示是否有蚂蚁，为真时表示有蚂蚁，为假时表示没有蚂蚁。</li>
<li>输入R表示天气是否下雨，为真时表示下雨，为假时表示没有下雨。</li>
<li>输出E表示Ben是否可以享受野炊，为真时表示可以享受野炊，为假时表示不能享受野炊。</li>
</ul>
<p>根据例2.2的描述，当且仅当没有蚂蚁也没有下雨时，Ben可以享受野炊。因此，布尔表达式为：</p>
<p>$[ E = \overline{A} \cdot \overline{R} $]</p>
<p>这表示当A和R都为假时，E为真。换句话说，当没有蚂蚁并且天气不下雨时，Ben可以享受野炊。</p>
<p>或与式（product-of-sums）是一种布尔函数的表达形式，适用于真值表中输出为假的行较少的情况。在这种形式中，每一行输出为假的最大项相乘，得到整个布尔表达式。</p>
</blockquote>
<p>还有一类题目就是计算时延，找到关键路径和最短路径就可以进行计算了。</p>
<blockquote>
<p>组合逻辑电路的时序特征包括传输延迟（tpd）和最小延迟（tcd）。</p>
<p>传输延迟（tpd）是指从输入信号发生变化到输出信号达到最终稳定状态所经历的最长时间。它反映了电路中信号传输的时间，通常由关键路径上的各个元件的传输延迟之和确定。</p>
<p>最小延迟（tcd）是指从输入信号发生变化到任何一个输出信号开始改变的最短时间。它是电路中的最快路径上各个元件的最小延迟之和。</p>
<p>计算传输延迟和最小延迟需要考虑电路中的关键路径和最短路径。关键路径是电路中最长的传输路径，决定了电路的最大传输延迟；而最短路径则是电路中最短的传输路径，决定了电路的最小传输延迟。</p>
<p>例如，对于图中的逻辑电路，我们可以确定其关键路径和最短路径。关键路径是从输入A或B经过三个门到达输出Y，因此传输延迟为三个门的传输延迟之和，即300ps。最短路径是从输入C、D或E经过两个门到达输出Y，因此最小延迟为两个门的最小延迟之和，即120ps。</p>
<p>这些延迟可以通过数据手册提供的每个门的传输延迟和最小延迟来确定，然后按照关键路径和最短路径的规则进行计算。</p>
</blockquote>
<hr>
<p>卡诺图注意事项：</p>
<p>1.用最小项的写法</p>
<p>2.圈要大，少</p>
<p>3.表是循环的，如上图AB栏，00左边延续10，1下面延续0等</p>
<p>3.圈内元素为2的n次幂，如：1，2，4，8等</p>
<p>4.边角4个可以组成一个圈</p>
<hr>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20240411154142521.png" alt="image-20240411154142521"></p>
<hr>
<h1 id="数字逻辑第三章"><a href="#数字逻辑第三章" class="headerlink" title="数字逻辑第三章"></a>数字逻辑第三章</h1><p>第三章最重要还是一堆的元件的原理和有限状态机的设计，图和表要怎么画出来，然后就是两个延迟的满足条件，还有一个的话就是分时概念和吞吐量的概念。</p>
<blockquote>
<p>SR锁存器是一种基本的时序电路，由一对耦合的或非门组成，具有两个输入S和R，以及两个输出Q和Q（Q的反相输出）。SR锁存器的状态可以通过输入S（Set）和R（Reset）来控制，可以实现置位或复位输出Q的功能。</p>
<p>通过真值表可以清楚地理解SR锁存器的工作原理。考虑四种输入组合情况：</p>
<ol>
<li>当R=1，S=0时，输出Q被复位为0，Q=1。</li>
<li>当R=0，S=1时，输出Q被置位为1，Q=0。</li>
<li>当R=1，S=1时，输出Q和Q都为0，这种情况表示SR锁存器处于禁止状态，输出不确定。</li>
<li>当R=0，S=0时，输出Q保持上一状态不变，即Qprev。</li>
</ol>
<p>SR锁存器的符号表示如图中所示，其中S和R分别表示置位和复位的输入。这种符号表示使得SR锁存器的使用更加简洁和直观。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/cf00a112603849819313dbfba5fefbfb-1716810994650-9.png" alt="image.png"></p>
<p>D锁存器是一种常用的时序电路，用于存储一个比特的状态。与SR锁存器相比，D锁存器引入了时钟输入CLK，以控制状态的改变时间，从而解决了SR锁存器中S和R同时有效时输出不确定的问题，并且将内容和时间分开考虑，使得电路设计更加简单。</p>
<p>通过真值表可以清晰地分析D锁存器的工作原理。当时钟输入CLK为0时，锁存器处于阻塞状态，不论数据输入D的值为何，输出Q保持不变，即Q保持上一个状态不变。而当时钟输入CLK为1时，锁存器处于透明状态，数据输入D的值直接传输到输出Q，即Q的值等于D的值。</p>
<p>D锁存器的符号表示如图中所示，其中D表示数据输入，CLK表示时钟输入。在时钟为1时，D的值被传输到输出Q；在时钟为0时，输出Q保持上一个状态不变。</p>
<p>D锁存器常被称为透明锁存器或电平敏感锁存器，因为它在时钟为1时透明地传输输入数据，而在时钟为0时阻塞输入数据。它的工作原理简单清晰，易于理解和应用。</p>
<p>需要注意的是，时钟输入CLK的变化时刻决定了状态更新的时间，这将在后续部分介绍D触发器时更详细地讨论。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/e05d829cc5284dcd8b8b415936b0fee2-1716811000164-12.png" alt="image.png"></p>
<p>D触发器是一种常用的时序电路，由两个反相时钟控制的背靠背的D锁存器组成。其中，一个锁存器称为主锁存器，另一个称为从锁存器。D触发器的工作原理可以通过如下步骤理解：</p>
<ol>
<li>当时钟输入CLK为0时，主锁存器是透明的，允许数据输入D的值传输到节点N1。</li>
<li>当时钟输入CLK从0上升到1时，主锁存器变为阻塞状态，从锁存器变为透明状态。此时，节点N1的值将被传输到输出Q，但是D和N1之间的连接被切断，防止D的值进一步传输。</li>
<li>在时钟上升沿时，D触发器将节点N1的值复制到输出Q，即Q的值等于N1的值。这意味着D触发器在时钟上升沿时响应输入D的值，并将其复制到输出Q。</li>
<li>在时钟上升沿之前和之后，由于总有一个锁存器处于阻塞状态，D的值无法传输到Q，因此Q保持原有的状态不变。</li>
</ol>
<p>因此，D触发器在时钟上升沿时触发，并将输入D的值复制到输出Q。其他时间，D触发器保持其输出状态不变。这种时钟边沿触发的特性使得D触发器在数字电路中被广泛应用。</p>
<p>D触发器也常被称为主从触发器、边沿触发器或者正边沿触发器，其中电路符号中的三角形表示触发器使用时钟边沿触发。在不需要输出Q时，常常省略触发器的符号，简化电路图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/a52c7eb71d3b4738966786d410d38be6-1716811005260-15.png" alt="image.png"></p>
</blockquote>
<p>可能还会有一类题是计算晶体管</p>
<p>计算触发器的晶体管数量。构成一个本节介绍的D触发器需要多少个晶体管？<br>解：构成一个与非门或者一个或非门需要用4个晶体管。一个非门需要用2个晶体管。一个与门可以由一个与非门和一个非门组成，所以它将用6个晶体管。一个SR锁存器需要用2个或非门或8个晶体管。一个D锁存器需要用一个SR锁存器、2个与门和一个非门或22个晶体管。一个D触发器需要用两个D锁存器和一个非门或46个晶体管。3.2.7节中介绍了一种使用传输门的更高效的CMOS实现方法。</p>
<p>可能还会有判断同步时序电路：<br>如果一个电路是同步时序电路，它必须由相互连接的电路元件构成，且需要满足以下条件：</p>
<p>每一个电路元件要么是寄存器要么是组合电路；<br>至少有一个电路元件是寄存器；<br>所有寄存器接收同一个时钟信号；<br>每一个环路至少包含一个寄存器。</p>
<p>设计有限状态机应该就是最难的了</p>
<p>画出图，写出表，编码，写出式子，再化简式子</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/46a1827c5a3d4931bbfe025e93cc82d8-1716811203310-18.png" alt="image.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/957eb05fe0d54e35b3091f9e04428db3-1716811226361-21.png" alt="image.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/5cb71340d61647c8913ac731cd8a8436-1716811240982-24.png" alt="image.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/bf7a782ef89f40ed8713e41228c4a0bf-1716811247192-27.png" alt="image.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/388fd8be7d88482e97628b495bc60406-1716811253319-30.png" alt="image.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/82394cdea28e4851ab67b04cce918a14.png" alt="image.png"></p>
<p>对比一下两种状态机，一种是输出和输入一起写的</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/6943344e20e14ff6b519e0fa9a4c44f9.png" alt="image.png"></p>
<p>一类题是计算约束：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/e1cb6b67d7e244da9ff4ab1cfb301cff.png" alt="image.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/8a863f307c09448f9cf9753b874fb712.png" alt="image.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/ad1dc9be4ecc4da7989716807d88fc27.png" alt="image.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/1917fd8ed2194f89836ec8fde11442db.png" alt="image.png"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/55da5c45346045018354ac73e2c9c902.png" alt="image.png"></p>
<h1 id="数字逻辑第四章"><a href="#数字逻辑第四章" class="headerlink" title="数字逻辑第四章"></a>数字逻辑第四章</h1><p>看懂程序画图？</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> xor_4(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] a,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line"><span class="keyword">assign</span> y = ^a;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这是一个 XOR 门的 4 个输入版本的 Verilog 模块。以下是对该模块的解释：</p>
<ul>
<li><p><code>input logic [3:0] a</code>：这是一个输入端口，它声明了一个 4 位的逻辑向量，表示了四个输入信号。<code>[3:0]</code> 表示这是一个 4 位的向量，索引范围是 3 到 0。因此，<code>a</code> 变量是一个包含了四个输入信号的逻辑向量。</p>
</li>
<li><p><code>output logic y</code>：这是一个输出端口，表示了一个单独的输出信号。<code>y</code> 是一个逻辑变量，用于存储 XOR 门的输出结果。</p>
</li>
<li><p><code>assign y = ^a;</code>：这一行代码是逻辑连线语句，用于将输入信号 <code>a</code> 的 XOR 运算结果赋值给输出信号 <code>y</code>。<code>^a</code> 表示对 <code>a</code> 中的所有位进行异或运算。因为 <code>a</code> 是一个 4 位的向量，所以 <code>^a</code> 将对 <code>a</code> 中的所有位进行异或运算，得到一个单独的比特值作为输出。</p>
</li>
</ul>
<p>综上所述，这个 Verilog 模块实现了一个四输入的 XOR 门，将四个输入信号的异或运算结果作为单个输出信号 <code>y</code>。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_4_testbench();</span><br><span class="line"><span class="keyword">logic</span> clk, reset;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] a;</span><br><span class="line"><span class="keyword">logic</span> yexpected;</span><br><span class="line"><span class="keyword">logic</span> y;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] vectornum, errors;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">4</span>:<span class="number">0</span>] testvectors[<span class="number">10000</span>:<span class="number">0</span>];</span><br><span class="line"><span class="comment">// instantiate device under test</span></span><br><span class="line">xor_4 dut(a, y);</span><br><span class="line"><span class="comment">// generate clock</span></span><br><span class="line"><span class="keyword">always</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">clk = <span class="number">1</span>; #<span class="number">5</span>; clk = <span class="number">0</span>; #<span class="number">5</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// at start of test, load vectors</span></span><br><span class="line"><span class="comment">// and pulse reset</span></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line"><span class="built_in">$readmemb</span>(<span class="string">&quot;ex4_4.tv&quot;</span>, testvectors);</span><br><span class="line">vectornum = <span class="number">0</span>; errors = <span class="number">0</span>;</span><br><span class="line">reset = <span class="number">1</span>; #<span class="number">27</span>; reset = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// apply test vectors on rising edge of clk</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">#<span class="number">1</span>; &#123;a, yexpected&#125; =</span><br><span class="line">testvectors[vectornum];</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// check results on falling edge of clk</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">negedge</span> clk)</span><br><span class="line"><span class="keyword">if</span> (~reset) <span class="keyword">begin</span> <span class="comment">// skip during reset</span></span><br><span class="line"><span class="keyword">if</span> (y !== yexpected) <span class="keyword">begin</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;Error: inputs = %h&quot;</span>, a);</span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot; outputs = %b (%b expected)&quot;</span>,</span><br><span class="line">y, yexpected);</span><br><span class="line">errors = errors + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">vectornum = vectornum + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (testvectors[vectornum] === <span class="number">5&#x27;bx</span>) <span class="keyword">begin</span></span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;%d tests completed with %d errors&quot;</span>,</span><br><span class="line">vectornum, errors);</span><br><span class="line"><span class="built_in">$finish</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这是一个用于测试 <code>xor_4</code> 模块的 Verilog 测试台（testbench）。以下是对测试台的解释：</p>
<ul>
<li><p><code>module ex4_4_testbench();</code>：定义了一个名为 <code>ex4_4_testbench</code> 的测试台模块。</p>
</li>
<li><p><code>logic clk, reset;</code>：声明了两个逻辑信号 <code>clk</code> 和 <code>reset</code>，用于模拟时钟和复位信号。</p>
</li>
<li><p><code>logic [3:0] a;</code>：声明了一个 4 位宽的逻辑向量 <code>a</code>，用于模拟输入信号。</p>
</li>
<li><p><code>logic yexpected;</code>：声明了一个逻辑信号 <code>yexpected</code>，用于存储期望的输出信号值。</p>
</li>
<li><p><code>logic y;</code>：声明了一个逻辑信号 <code>y</code>，用于存储 <code>xor_4</code> 模块的输出信号值。</p>
</li>
<li><p><code>logic [31:0] vectornum, errors;</code>：声明了两个 32 位宽的逻辑向量 <code>vectornum</code> 和 <code>errors</code>，用于存储测试向量编号和错误计数。</p>
</li>
<li><p><code>logic [4:0] testvectors[10000:0];</code>：声明了一个二维逻辑数组 <code>testvectors</code>，用于存储测试向量。</p>
</li>
<li><p><code>xor_4 dut(a, y);</code>：实例化了 <code>xor_4</code> 模块，并将输入信号 <code>a</code> 和输出信号 <code>y</code> 连接到测试台。</p>
</li>
<li><p><code>always begin clk = 1; #5; clk = 0; #5; end</code>：在 <code>clk</code> 上实现了一个时钟生成器，周期为 10 个时间单位。</p>
</li>
<li><p><code>initial begin ... end</code>：在模拟开始时执行的初始化过程。从文件 “ex4_4.tv” 中读取测试向量，然后对复位信号进行脉冲操作。</p>
</li>
<li><p><code>always @(posedge clk) begin ... end</code>：在时钟信号上升沿执行的过程。根据 <code>vectornum</code> 选择一个测试向量，并将其应用到输入端口 <code>a</code> 和期望输出端口 <code>yexpected</code>。</p>
</li>
<li><p><code>always @(negedge clk) begin ... end</code>：在时钟信号下降沿执行的过程。检查当前输出 <code>y</code> 是否与期望输出 <code>yexpected</code> 相匹配，并更新错误计数。同时更新 <code>vectornum</code>，并检查是否已经完成了所有测试向量。</p>
</li>
</ul>
<p>该测试台通过模拟输入信号、比较输出信号与期望值，并输出错误信息来验证 <code>xor_4</code> 模块的功能。</p>
<p>这个太难了，应该不会考。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mux8</span><br><span class="line">#(<span class="keyword">parameter</span> width = <span class="number">4</span>)</span><br><span class="line">(<span class="keyword">input</span> <span class="keyword">logic</span> [width-<span class="number">1</span>:<span class="number">0</span>] d0, d1, d2, d3,</span><br><span class="line">d4, d5, d6, d7,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] s,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> [width-<span class="number">1</span>:<span class="number">0</span>] y);</span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (s)</span><br><span class="line"><span class="number">0</span>: y = d0;</span><br><span class="line"><span class="number">1</span>: y = d1;</span><br><span class="line"><span class="number">2</span>: y = d2;</span><br><span class="line"><span class="number">3</span>: y = d3;</span><br><span class="line"><span class="number">4</span>: y = d4;</span><br><span class="line"><span class="number">5</span>: y = d5;</span><br><span class="line"><span class="number">6</span>: y = d6;</span><br><span class="line"><span class="number">7</span>: y = d7;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这是一个 8 选 1 复用器（MUX）的 Verilog 模块。以下是对该模块的解释：</p>
<ul>
<li><p><code>module mux8(input logic [width-1:0] d0, d1, d2, d3, d4, d5, d6, d7, input logic [2:0] s, output logic [width-1:0] y);</code>：定义了一个名为 <code>mux8</code> 的模块，它有 8 个输入端口 <code>d0</code> 到 <code>d7</code>，一个 3 位宽的选择信号端口 <code>s</code>，以及一个输出端口 <code>y</code>。</p>
</li>
<li><p><code>parameter width = 4</code>：定义了一个名为 <code>width</code> 的参数，默认值为 4。这个参数用于指定输入和输出端口的宽度。</p>
</li>
<li><p><code>always_comb</code>：使用 <code>always_comb</code> 块来表示组合逻辑。这意味着输出 <code>y</code> 的值将根据输入和选择信号的值立即组合计算，而不受时序影响。</p>
</li>
<li><p><code>case (s)</code>：这是一个 <code>case</code> 语句，根据选择信号 <code>s</code> 的值，将输入端口 <code>d0</code> 到 <code>d7</code> 中的一个赋值给输出端口 <code>y</code>。</p>
</li>
<li><p><code>0: y = d0;</code>：当选择信号 <code>s</code> 的值为 0 时，输出端口 <code>y</code> 被赋值为输入端口 <code>d0</code> 的值。</p>
</li>
<li><p><code>1: y = d1;</code>：当选择信号 <code>s</code> 的值为 1 时，输出端口 <code>y</code> 被赋值为输入端口 <code>d1</code> 的值。</p>
</li>
<li><p><code>...</code>：依此类推，根据选择信号的不同值，将对应输入端口的值赋给输出端口。</p>
</li>
<li><p><code>endcase</code>：结束 <code>case</code> 语句块。</p>
</li>
</ul>
<p>综上所述，这个 Verilog 模块实现了一个 8 选 1 复用器，根据选择信号 <code>s</code> 的值选择对应的输入信号 <code>d0</code> 到 <code>d7</code>，并将其输出到 <code>y</code> 端口。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_9</span><br><span class="line">(<span class="keyword">input</span> <span class="keyword">logic</span> a, b, c,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line">mux8 <span class="variable">#(1)</span> mux8_1(<span class="number">1&#x27;b1</span>, <span class="number">1&#x27;b0</span>, <span class="number">1&#x27;b0</span>, <span class="number">1&#x27;b1</span>,</span><br><span class="line"><span class="number">1&#x27;b1</span>, <span class="number">1&#x27;b1</span>, <span class="number">1&#x27;b0</span>, <span class="number">1&#x27;b0</span>,</span><br><span class="line">&#123;a,b,c&#125;, y);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这是一个名为 <code>ex4_9</code> 的 Verilog 模块，它实例化了一个名为 <code>mux8_1</code> 的 8 选 1 复用器（MUX）并将其连接到模块的输入和输出端口。以下是对该模块的解释：</p>
<ul>
<li><p><code>module ex4_9(input logic a, b, c, output logic y);</code>：定义了一个名为 <code>ex4_9</code> 的模块，它有三个输入端口 <code>a</code>、<code>b</code> 和 <code>c</code>，以及一个输出端口 <code>y</code>。</p>
</li>
<li><p><code>mux8 #(1) mux8_1(1&#39;b1, 1&#39;b0, 1&#39;b0, 1&#39;b1, 1&#39;b1, 1&#39;b1, 1&#39;b0, 1&#39;b0, &#123;a,b,c&#125;, y);</code>：实例化了一个 8 选 1 复用器 <code>mux8_1</code>，并将其连接到输入端口 <code>a</code>、<code>b</code>、<code>c</code> 和输出端口 <code>y</code>。</p>
<ul>
<li><p><code>mux8 #(1)</code>：使用 <code>mux8</code> 模块，并且为其指定一个参数 <code>width = 1</code>，这表示输入和输出端口的宽度为 1 位。</p>
</li>
<li><p><code>mux8_1</code>：这是实例化的名称。</p>
</li>
<li><p><code>(1&#39;b1, 1&#39;b0, 1&#39;b0, 1&#39;b1, 1&#39;b1, 1&#39;b1, 1&#39;b0, 1&#39;b0)</code>：这些是 8 个输入端口 <code>d0</code> 到 <code>d7</code> 的值。在这里，它们的值分别是 <code>1&#39;b1</code>、<code>1&#39;b0</code>、<code>1&#39;b0</code>、<code>1&#39;b1</code>、<code>1&#39;b1</code>、<code>1&#39;b1</code>、<code>1&#39;b0</code>、<code>1&#39;b0</code>。</p>
</li>
<li><p><code>&#123;a, b, c&#125;</code>：这是一个连接操作符，用于将输入端口 <code>a</code>、<code>b</code> 和 <code>c</code> 连接成一个 3 位宽的向量，作为选择信号 <code>s</code>。</p>
</li>
<li><p><code>y</code>：这是输出端口，表示输出信号 <code>y</code>。</p>
</li>
</ul>
</li>
</ul>
<p>综上所述，这个 Verilog 模块实例化了一个 8 选 1 复用器，并将输入端口 <code>a</code>、<code>b</code> 和 <code>c</code> 连接到选择信号，将复用器的输出连接到输出端口 <code>y</code>。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_10</span><br><span class="line">(<span class="keyword">input</span> <span class="keyword">logic</span> a, b, c,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line">mux4 <span class="variable">#(1) mux4_1( ~c, c, 1&#x27;b1, 1&#x27;b0, &#123;a, b&#125;, y)</span>;</span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"><span class="keyword">module</span> mux4</span><br><span class="line">#(<span class="keyword">parameter</span> width = <span class="number">4</span>)</span><br><span class="line">(<span class="keyword">input</span> <span class="keyword">logic</span> [width-<span class="number">1</span>:<span class="number">0</span>] d0, d1, d2, d3,</span><br><span class="line"><span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] s,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> [width-<span class="number">1</span>:<span class="number">0</span>] y);</span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (s)</span><br><span class="line"><span class="number">0</span>: y = d0;</span><br><span class="line"><span class="number">1</span>: y = d1;</span><br><span class="line"><span class="number">2</span>: y = d2;</span><br><span class="line"><span class="number">3</span>: y = d3;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这里有两个 Verilog 模块：<code>ex4_10</code> 和 <code>mux4</code>。下面是对这两个模块的解释：</p>
<h3 id="mux4-模块："><a href="#mux4-模块：" class="headerlink" title="mux4 模块："></a><code>mux4</code> 模块：</h3><ul>
<li><p><code>module mux4(input logic [width-1:0] d0, d1, d2, d3, input logic [1:0] s, output logic [width-1:0] y);</code>：定义了一个 4 选 1 复用器（MUX）的模块，它有四个输入端口 <code>d0</code> 到 <code>d3</code>，一个 2 位宽的选择信号端口 <code>s</code>，以及一个输出端口 <code>y</code>。</p>
</li>
<li><p><code>parameter width = 4</code>：定义了一个名为 <code>width</code> 的参数，默认值为 4。这个参数用于指定输入和输出端口的宽度。</p>
</li>
<li><p><code>always_comb</code>：使用 <code>always_comb</code> 块来表示组合逻辑。这意味着输出 <code>y</code> 的值将根据输入和选择信号的值立即组合计算，而不受时序影响。</p>
</li>
<li><p><code>case (s)</code>：这是一个 <code>case</code> 语句，根据选择信号 <code>s</code> 的值，将输入端口 <code>d0</code> 到 <code>d3</code> 中的一个赋值给输出端口 <code>y</code>。</p>
</li>
<li><p><code>0: y = d0;</code>：当选择信号 <code>s</code> 的值为 0 时，输出端口 <code>y</code> 被赋值为输入端口 <code>d0</code> 的值。</p>
</li>
<li><p><code>1: y = d1;</code>：当选择信号 <code>s</code> 的值为 1 时，输出端口 <code>y</code> 被赋值为输入端口 <code>d1</code> 的值。</p>
</li>
<li><p><code>2: y = d2;</code>：当选择信号 <code>s</code> 的值为 2 时，输出端口 <code>y</code> 被赋值为输入端口 <code>d2</code> 的值。</p>
</li>
<li><p><code>3: y = d3;</code>：当选择信号 <code>s</code> 的值为 3 时，输出端口 <code>y</code> 被赋值为输入端口 <code>d3</code> 的值。</p>
</li>
</ul>
<h3 id="ex4-10-模块："><a href="#ex4-10-模块：" class="headerlink" title="ex4_10 模块："></a><code>ex4_10</code> 模块：</h3><ul>
<li><p><code>module ex4_10(input logic a, b, c, output logic y);</code>：定义了一个名为 <code>ex4_10</code> 的模块，它有三个输入端口 <code>a</code>、<code>b</code> 和 <code>c</code>，以及一个输出端口 <code>y</code>。</p>
</li>
<li><p><code>mux4 #(1) mux4_1( ~c, c, 1&#39;b1, 1&#39;b0, &#123;a, b&#125;, y);</code>：实例化了一个 4 选 1 复用器 <code>mux4_1</code>，并将其连接到输入端口 <code>a</code>、<code>b</code> 和输出端口 <code>y</code>。</p>
<ul>
<li><p><code>mux4 #(1)</code>：使用 <code>mux4</code> 模块，并且为其指定一个参数 <code>width = 1</code>，这表示输入和输出端口的宽度为 1 位。</p>
</li>
<li><p><code>mux4_1</code>：这是实例化的名称。</p>
</li>
<li><p><code>( ~c, c, 1&#39;b1, 1&#39;b0, &#123;a, b&#125;, y)</code>：这些是 4 个输入端口 <code>d0</code> 到 <code>d3</code> 的值，其中 <code>~c</code> 和 <code>c</code> 是通过对 <code>c</code> 取反来表示的。此外，选择信号 <code>s</code> 是 <code>&#123;a, b&#125;</code> 组成的 2 位宽向量，输出信号连接到 <code>y</code>。</p>
</li>
</ul>
</li>
</ul>
<p>综上所述，<code>ex4_10</code> 模块实例化了一个 4 选 1 复用器，并通过对输入端口进行取反来实现一种特定的功能。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> <span class="keyword">priority</span>(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] a,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] y);</span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">casez</span> (a)</span><br><span class="line"><span class="number">8&#x27;b1</span>???????: y = <span class="number">8&#x27;b10000000</span>;</span><br><span class="line"><span class="number">8&#x27;b01</span>??????: y = <span class="number">8&#x27;b01000000</span>;</span><br><span class="line"><span class="number">8&#x27;b001</span>?????: y = <span class="number">8&#x27;b00100000</span>;</span><br><span class="line"><span class="number">8&#x27;b0001</span>????: y = <span class="number">8&#x27;b00010000</span>;</span><br><span class="line"><span class="number">8&#x27;b00001</span>???: y = <span class="number">8&#x27;b00001000</span>;</span><br><span class="line"><span class="number">8&#x27;b000001</span>??: y = <span class="number">8&#x27;b00000100</span>;</span><br><span class="line"><span class="number">8&#x27;b0000001</span>?: y = <span class="number">8&#x27;b00000010</span>;</span><br><span class="line"><span class="number">8&#x27;b00000001</span>: y = <span class="number">8&#x27;b00000001</span>;</span><br><span class="line"><span class="keyword">default</span>: y = <span class="number">8&#x27;b00000000</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这是一个名为 <code>priority</code> 的 Verilog 模块，实现了一个优先级编码器。以下是对该模块的解释：</p>
<ul>
<li><p><code>module priority(input logic [7:0] a, output logic [7:0] y);</code>：定义了一个名为 <code>priority</code> 的模块，它有一个 8 位宽的输入端口 <code>a</code> 和一个 8 位宽的输出端口 <code>y</code>。</p>
</li>
<li><p><code>always_comb</code>：使用 <code>always_comb</code> 块来表示组合逻辑。这意味着输出 <code>y</code> 的值将根据输入 <code>a</code> 的值立即组合计算，而不受时序影响。</p>
</li>
<li><p><code>casez (a)</code>：这是一个 <code>casez</code> 语句，根据输入 <code>a</code> 的模式进行匹配，并确定输出 <code>y</code> 的值。</p>
</li>
<li><p><code>8&#39;b1???????: y = 8&#39;b10000000;</code>：当输入的前一位是 1 时，输出为 10000000。</p>
</li>
<li><p><code>8&#39;b01??????: y = 8&#39;b01000000;</code>：当输入的前两位是 01 时，输出为 01000000。</p>
</li>
<li><p><code>8&#39;b001?????: y = 8&#39;b00100000;</code>：当输入的前三位是 001 时，输出为 00100000。</p>
</li>
<li><p><code>8&#39;b0001????: y = 8&#39;b00010000;</code>：当输入的前四位是 0001 时，输出为 00010000。</p>
</li>
<li><p><code>8&#39;b00001???: y = 8&#39;b00001000;</code>：当输入的前五位是 00001 时，输出为 00001000。</p>
</li>
<li><p><code>8&#39;b000001??: y = 8&#39;b00000100;</code>：当输入的前六位是 000001 时，输出为 00000100。</p>
</li>
<li><p><code>8&#39;b0000001?: y = 8&#39;b00000010;</code>：当输入的前七位是 0000001 时，输出为 00000010。</p>
</li>
<li><p><code>8&#39;b00000001: y = 8&#39;b00000001;</code>：当输入的所有位都是 1 时，输出为 00000001。</p>
</li>
<li><p><code>default: y = 8&#39;b00000000;</code>：如果没有匹配到上述任何模式，则输出默认值 00000000。</p>
</li>
</ul>
<p>综上所述，该 Verilog 模块根据输入信号 <code>a</code> 的不同模式，将其编码为相应的优先级输出值，并输出到 <code>y</code> 端口。</p>
<hr>
<figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> decoder2_4(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] a,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] y);</span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (a)</span><br><span class="line"><span class="number">2&#x27;b00</span>: y = <span class="number">4&#x27;b0001</span>;</span><br><span class="line"><span class="number">2&#x27;b01</span>: y = <span class="number">4&#x27;b0010</span>;</span><br><span class="line"><span class="number">2&#x27;b10</span>: y = <span class="number">4&#x27;b0100</span>;</span><br><span class="line"><span class="number">2&#x27;b11</span>: y = <span class="number">4&#x27;b1000</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这是一个名为 <code>decoder2_4</code> 的 Verilog 模块，实现了一个 2 到 4 解码器。以下是对该模块的解释：</p>
<ul>
<li><p><code>module decoder2_4(input logic [1:0] a, output logic [3:0] y);</code>：定义了一个名为 <code>decoder2_4</code> 的模块，它有一个 2 位宽的输入端口 <code>a</code> 和一个 4 位宽的输出端口 <code>y</code>。</p>
</li>
<li><p><code>always_comb</code>：使用 <code>always_comb</code> 块来表示组合逻辑。这意味着输出 <code>y</code> 的值将根据输入 <code>a</code> 的值立即组合计算，而不受时序影响。</p>
</li>
<li><p><code>case (a)</code>：这是一个 <code>case</code> 语句，根据输入 <code>a</code> 的值进行匹配，并确定输出 <code>y</code> 的值。</p>
</li>
<li><p><code>2&#39;b00: y = 4&#39;b0001;</code>：当输入 <code>a</code> 的值为 00 时，输出 <code>y</code> 被赋值为 0001。</p>
</li>
<li><p><code>2&#39;b01: y = 4&#39;b0010;</code>：当输入 <code>a</code> 的值为 01 时，输出 <code>y</code> 被赋值为 0010。</p>
</li>
<li><p><code>2&#39;b10: y = 4&#39;b0100;</code>：当输入 <code>a</code> 的值为 10 时，输出 <code>y</code> 被赋值为 0100。</p>
</li>
<li><p><code>2&#39;b11: y = 4&#39;b1000;</code>：当输入 <code>a</code> 的值为 11 时，输出 <code>y</code> 被赋值为 1000。</p>
</li>
</ul>
<p>综上所述，该 Verilog 模块实现了一个 2 到 4 解码器，根据输入信号 <code>a</code> 的不同值，将其解码为对应的输出信号 <code>y</code>。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> decoder6_64(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">5</span>:<span class="number">0</span>] a,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">63</span>:<span class="number">0</span>] y);</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">11</span>:<span class="number">0</span>] y2_4;</span><br><span class="line">decoder2_4 dec0(a[<span class="number">1</span>:<span class="number">0</span>], y2_4[<span class="number">3</span>:<span class="number">0</span>]);</span><br><span class="line">decoder2_4 dec1(a[<span class="number">3</span>:<span class="number">2</span>], y2_4[<span class="number">7</span>:<span class="number">4</span>]);</span><br><span class="line">decoder2_4 dec2(a[<span class="number">5</span>:<span class="number">4</span>], y2_4[<span class="number">11</span>:<span class="number">8</span>]);</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">0</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">1</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">2</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">3</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">4</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">5</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">6</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">7</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">8</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">9</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">10</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">11</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">12</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">13</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">14</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">15</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">16</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">17</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">18</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">19</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">20</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">21</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">22</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">23</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">24</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">25</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">26</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">27</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">28</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">29</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">30</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">9</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">31</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">9</span>];<span class="keyword">assign</span> y[<span class="number">32</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">33</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">34</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">35</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">36</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">37</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">38</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">39</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">40</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">41</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">42</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">43</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">44</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">45</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">46</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">47</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">48</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">49</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">50</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">51</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">4</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">52</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">53</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">54</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">55</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">5</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">56</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">57</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">58</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">59</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">6</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">60</span>] = y2_4[<span class="number">0</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">61</span>] = y2_4[<span class="number">1</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">62</span>] = y2_4[<span class="number">2</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">assign</span> y[<span class="number">63</span>] = y2_4[<span class="number">3</span>] &amp; y2_4[<span class="number">7</span>] &amp; y2_4[<span class="number">11</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这是一个名为 <code>decoder6_64</code> 的 Verilog 模块，实现了一个 6 到 64 解码器。以下是对该模块的解释：</p>
<ul>
<li><p><code>module decoder6_64(input logic [5:0] a, output logic [63:0] y);</code>：定义了一个名为 <code>decoder6_64</code> 的模块，它有一个 6 位宽的输入端口 <code>a</code> 和一个 64 位宽的输出端口 <code>y</code>。</p>
</li>
<li><p><code>logic [11:0] y2_4;</code>：定义了一个 12 位宽的临时信号 <code>y2_4</code>，用于存储 2 到 4 解码器的输出。</p>
</li>
<li><p><code>decoder2_4 dec0(a[1:0], y2_4[3:0]);</code>：实例化了一个 2 到 4 解码器，将输入 <code>a</code> 的低 2 位传递给解码器，并将其输出连接到 <code>y2_4</code> 的低 4 位。</p>
</li>
<li><p><code>decoder2_4 dec1(a[3:2], y2_4[7:4]);</code>：实例化了第二个 2 到 4 解码器，将输入 <code>a</code> 的中间 2 位传递给解码器，并将其输出连接到 <code>y2_4</code> 的中间 4 位。</p>
</li>
<li><p><code>decoder2_4 dec2(a[5:4], y2_4[11:8]);</code>：实例化了第三个 2 到 4 解码器，将输入 <code>a</code> 的高 2 位传递给解码器，并将其输出连接到 <code>y2_4</code> 的高 4 位。</p>
</li>
<li><p><code>assign y[0] = y2_4[0] &amp; y2_4[4] &amp; y2_4[8];</code> 到 <code>assign y[63] = y2_4[3] &amp; y2_4[7] &amp; y2_4[11];</code>：使用逻辑与运算符将 <code>y2_4</code> 的输出组合成一个 64 位的输出信号 <code>y</code>。每个输出位都由 <code>y2_4</code> 的特定位组合而成。</p>
</li>
</ul>
<p>综上所述，该 Verilog 模块实现了一个 6 到 64 解码器，根据输入信号 <code>a</code> 的不同值，将其解码为对应的输出信号 <code>y</code>。</p>
<hr>
<p>一些基本的布尔就不说了</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_15c(<span class="keyword">input</span> <span class="keyword">logic</span> a, b, c, d,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line"><span class="keyword">assign</span> y = (~a &amp; ~b &amp; ~c &amp; ~d) | (a &amp; ~b &amp; ~c) |</span><br><span class="line">(a &amp; ~b &amp; c &amp; ~d) | (a &amp; b &amp; d) |</span><br><span class="line">(~a &amp; ~b &amp; c &amp; ~d) | (b &amp; ~c &amp; d) | ~a;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这是一个名为 <code>ex4_15c</code> 的 Verilog 模块，实现了一个逻辑功能，根据输入信号 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 的组合产生输出信号 <code>y</code>。以下是对该模块的解释：</p>
<ul>
<li><p><code>module ex4_15c(input logic a, b, c, d, output logic y);</code>：定义了一个名为 <code>ex4_15c</code> 的模块，它有四个输入端口 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code>，以及一个输出端口 <code>y</code>。</p>
</li>
<li><p><code>assign y = (~a &amp; ~b &amp; ~c &amp; ~d) | (a &amp; ~b &amp; ~c) | (a &amp; ~b &amp; c &amp; ~d) | (a &amp; b &amp; d) | (~a &amp; ~b &amp; c &amp; ~d) | (b &amp; ~c &amp; d) | ~a;</code>：使用逻辑与（<code>&amp;</code>）、逻辑或（<code>|</code>）和逻辑非（<code>~</code>）运算符，将输入信号的不同组合转换为输出信号 <code>y</code>。具体来说：</p>
<ul>
<li><code>(~a &amp; ~b &amp; ~c &amp; ~d)</code> 表示当 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 均为低电平时，<code>y</code> 为高电平。</li>
<li><code>(a &amp; ~b &amp; ~c)</code> 表示当 <code>a</code> 为高电平而 <code>b</code> 和 <code>c</code> 均为低电平时，<code>y</code> 为高电平。</li>
<li><code>(a &amp; ~b &amp; c &amp; ~d)</code> 表示当 <code>a</code> 和 <code>c</code> 为高电平，而 <code>b</code> 和 <code>d</code> 均为低电平时，<code>y</code> 为高电平。</li>
<li><code>(a &amp; b &amp; d)</code> 表示当 <code>a</code>、<code>b</code> 和 <code>d</code> 均为高电平时，<code>y</code> 为高电平。</li>
<li><code>(~a &amp; ~b &amp; c &amp; ~d)</code> 表示当 <code>a</code> 和 <code>b</code> 为低电平，而 <code>c</code> 和 <code>d</code> 为高电平时，<code>y</code> 为高电平。</li>
<li><code>(b &amp; ~c &amp; d)</code> 表示当 <code>b</code> 为高电平，而 <code>c</code> 和 <code>d</code> 均为低电平时，<code>y</code> 为高电平。</li>
<li><code>~a</code> 表示当 <code>a</code> 为低电平时，<code>y</code> 为高电平。</li>
</ul>
</li>
</ul>
<p>综上所述，该模块根据输入信号的不同组合产生相应的输出信号 <code>y</code>。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_18(<span class="keyword">input</span> <span class="keyword">logic</span> a, b, c, d,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> y);</span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">casez</span> (&#123;a, b, c, d&#125;)</span><br><span class="line"><span class="comment">// note: outputs cannot be assigned don’t care</span></span><br><span class="line"><span class="number">0</span>: y = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="number">1</span>: y = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="number">2</span>: y = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="number">3</span>: y = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="number">4</span>: y = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="number">5</span>: y = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="number">6</span>: y = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="number">7</span>: y = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="number">8</span>: y = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="number">9</span>: y = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="number">10</span>: y = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="number">11</span>: y = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="number">12</span>: y = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="number">13</span>: y = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="number">14</span>: y = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="number">15</span>: y = <span class="number">1&#x27;b1</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这是一个名为 <code>ex4_18</code> 的 Verilog 模块，实现了一个逻辑功能，根据输入信号 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 的组合产生输出信号 <code>y</code>。以下是对该模块的解释：</p>
<ul>
<li><p><code>module ex4_18(input logic a, b, c, d, output logic y);</code>：定义了一个名为 <code>ex4_18</code> 的模块，它有四个输入端口 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code>，以及一个输出端口 <code>y</code>。</p>
</li>
<li><p><code>always_comb</code>：使用 <code>always_comb</code> 关键字表示该模块中的逻辑组合块，表明 <code>y</code> 的赋值是基于组合逻辑的。</p>
</li>
<li><p><code>casez (&#123;a, b, c, d&#125;)</code>：<code>casez</code> 语句根据输入信号 <code>&#123;a, b, c, d&#125;</code> 的组合情况进行匹配。</p>
</li>
<li><p><code>0: y = 1&#39;b0;</code> 到 <code>15: y = 1&#39;b1;</code>：每一个数字代表一个二进制组合的情况，其中 <code>0</code> 表示所有输入都为低电平，而 <code>15</code> 表示所有输入都为高电平。在这个 <code>casez</code> 语句中，输出信号 <code>y</code> 的值根据输入信号的组合情况进行赋值。每一个数字都对应着一个特定的输入组合，对应的 <code>y</code> 的值通过赋值语句确定。</p>
</li>
</ul>
<p>综上所述，该模块根据输入信号的不同组合产生相应的输出信号 <code>y</code>。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_18(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] a,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> p, d);</span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (a)</span><br><span class="line"><span class="number">0</span>: &#123;p, d&#125; = <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="number">1</span>: &#123;p, d&#125; = <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="number">2</span>: &#123;p, d&#125; = <span class="number">2&#x27;b10</span>;</span><br><span class="line"><span class="number">3</span>: &#123;p, d&#125; = <span class="number">2&#x27;b11</span>;</span><br><span class="line"><span class="number">4</span>: &#123;p, d&#125; = <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="number">5</span>: &#123;p, d&#125; = <span class="number">2&#x27;b10</span>;</span><br><span class="line"><span class="number">6</span>: &#123;p, d&#125; = <span class="number">2&#x27;b01</span>;</span><br><span class="line"><span class="number">7</span>: &#123;p, d&#125; = <span class="number">2&#x27;b10</span>;</span><br><span class="line"><span class="number">8</span>: &#123;p, d&#125; = <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="number">9</span>: &#123;p, d&#125; = <span class="number">2&#x27;b01</span>;</span><br><span class="line"><span class="number">10</span>: &#123;p, d&#125; = <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="number">11</span>: &#123;p, d&#125; = <span class="number">2&#x27;b10</span>;</span><br><span class="line"><span class="number">12</span>: &#123;p, d&#125; = <span class="number">2&#x27;b01</span>;</span><br><span class="line"><span class="number">13</span>: &#123;p, d&#125; = <span class="number">2&#x27;b10</span>;</span><br><span class="line"><span class="number">14</span>: &#123;p, d&#125; = <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="number">15</span>: &#123;p, d&#125; = <span class="number">2&#x27;b01</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这是一个名为 <code>ex4_18</code> 的 Verilog 模块，其功能是根据输入信号 <code>a</code> 的不同组合生成输出信号 <code>p</code> 和 <code>d</code>。以下是对该模块的解释：</p>
<ul>
<li><p><code>module ex4_18(input logic [3:0] a, output logic p, d);</code>：定义了一个名为 <code>ex4_18</code> 的模块，它有一个四位宽的输入端口 <code>a</code> 和两个输出端口 <code>p</code>、<code>d</code>。</p>
</li>
<li><p><code>always_comb</code>：使用 <code>always_comb</code> 关键字表示该模块中的逻辑组合块，表明 <code>p</code> 和 <code>d</code> 的赋值是基于组合逻辑的。</p>
</li>
<li><p><code>case (a)</code>：<code>case</code> 语句根据输入信号 <code>a</code> 的不同值进行匹配。</p>
</li>
<li><p><code>0: &#123;p, d&#125; = 2&#39;b00;</code> 到 <code>15: &#123;p, d&#125; = 2&#39;b01;</code>：每一个数字对应着一个四位二进制数的组合情况，其中 <code>0</code> 表示所有输入都为 <code>0000</code>，而 <code>15</code> 表示所有输入都为 <code>1111</code>。在这个 <code>case</code> 语句中，根据输入信号 <code>a</code> 的值，通过赋值语句确定输出信号 <code>p</code> 和 <code>d</code> 的值。每一行中的 <code>&#123;p, d&#125; = 2&#39;bxx;</code> 表示 <code>p</code> 和 <code>d</code> 的赋值。</p>
</li>
</ul>
<p>综上所述，该模块根据输入信号 <code>a</code> 的不同组合生成相应的输出信号 <code>p</code> 和 <code>d</code>。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> trafficFSM(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, ta, tb,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] la, lb);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3&#125;</span><br><span class="line">statetype;</span><br><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"><span class="keyword">parameter</span> green = <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="keyword">parameter</span> yellow = <span class="number">2&#x27;b01</span>;</span><br><span class="line"><span class="keyword">parameter</span> red = <span class="number">2&#x27;b10</span>;</span><br><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (ta) nextstate = S0;</span><br><span class="line"><span class="keyword">else</span> nextstate = S1;</span><br><span class="line">S1: nextstate = S2;</span><br><span class="line">S2: <span class="keyword">if</span> (tb) nextstate = S2;</span><br><span class="line"><span class="keyword">else</span> nextstate = S3;</span><br><span class="line">S3: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: &#123;la, lb&#125; = &#123;green, red&#125;;</span><br><span class="line">S1: &#123;la, lb&#125; = &#123;yellow, red&#125;;</span><br><span class="line">S2: &#123;la, lb&#125; = &#123;red, green&#125;;</span><br><span class="line">S3: &#123;la, lb&#125; = &#123;red, yellow&#125;;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段代码是一个简单的交通灯有限状态机（Finite State Machine, FSM）的 Verilog 实现。让我来逐行解释一下：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> trafficFSM(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, ta, tb,</span><br><span class="line">                  <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] la, lb);</span><br></pre></td></tr></table></figure>
<p>这里定义了一个模块 <code>trafficFSM</code>，它有四个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>、两个交通灯分别对应的检测信号 <code>ta</code> 和 <code>tb</code>，以及两个输出信号 <code>la</code> 和 <code>lb</code>，分别对应两个交通灯的状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个类型为 <code>statetype</code> 的枚举，包含了四个状态 <code>S0</code>、<code>S1</code>、<code>S2</code> 和 <code>S3</code>，用来表示交通灯的不同状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>这里声明了两个状态变量 <code>state</code> 和 <code>nextstate</code>，都是 <code>statetype</code> 类型的两位向量。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> green = <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="keyword">parameter</span> yellow = <span class="number">2&#x27;b01</span>;</span><br><span class="line"><span class="keyword">parameter</span> red = <span class="number">2&#x27;b10</span>;</span><br></pre></td></tr></table></figure>
<p>这里定义了三个参数 <code>green</code>、<code>yellow</code> 和 <code>red</code>，分别表示交通灯的三种颜色状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这是状态寄存器的代码。当时钟上升沿来临或者复位信号被触发时，根据是否复位，将 <code>state</code> 寄存器更新为当前状态或者下一个状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (ta) nextstate = S0;</span><br><span class="line"><span class="keyword">else</span> nextstate = S1;</span><br><span class="line">S1: nextstate = S2;</span><br><span class="line">S2: <span class="keyword">if</span> (tb) nextstate = S2;</span><br><span class="line"><span class="keyword">else</span> nextstate = S3;</span><br><span class="line">S3: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这是下一个状态逻辑的代码。根据当前状态和输入信号 <code>ta</code> 和 <code>tb</code>，确定下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: &#123;la, lb&#125; = &#123;green, red&#125;;</span><br><span class="line">S1: &#123;la, lb&#125; = &#123;yellow, red&#125;;</span><br><span class="line">S2: &#123;la, lb&#125; = &#123;red, green&#125;;</span><br><span class="line">S3: &#123;la, lb&#125; = &#123;red, yellow&#125;;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这是输出逻辑的代码。根据当前状态，确定交通灯的颜色状态输出到 <code>la</code> 和 <code>lb</code> 信号上。</p>
<p>综合起来，这段 Verilog 代码实现了一个简单的交通灯有限状态机，根据输入信号控制交通灯的状态，输出交通灯的颜色状态。</p>
<hr>
<figure class="highlight v"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mode(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, p, r,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> m);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> &#123;S0, S1&#125; statetype;</span><br><span class="line">statetype state, nextstate;</span><br><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (p) nextstate = S1;</span><br><span class="line"><span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S1: <span class="keyword">if</span> (r) nextstate = S0;</span><br><span class="line"><span class="keyword">else</span> nextstate = S1;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> m = state;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个简单的状态机模块，让我来逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> mode(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, p, r,</span><br><span class="line">            <span class="keyword">output</span> <span class="keyword">logic</span> m);</span><br></pre></td></tr></table></figure>
<p>这里定义了一个模块 <code>mode</code>，它有四个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>、以及两个控制信号 <code>p</code> 和 <code>r</code>，以及一个输出信号 <code>m</code>，用于输出当前状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> &#123;S0, S1&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，它包含两个状态 <code>S0</code> 和 <code>S1</code>，用来表示状态机的当前状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype state, nextstate;</span><br></pre></td></tr></table></figure>
<p>这里声明了两个状态变量 <code>state</code> 和 <code>nextstate</code>，它们用来记录当前状态和下一个状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在时钟上升沿到来时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (p) nextstate = S1;</span><br><span class="line"><span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S1: <span class="keyword">if</span> (r) nextstate = S0;</span><br><span class="line"><span class="keyword">else</span> nextstate = S1;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这段代码表示了状态转移逻辑。根据当前状态 <code>state</code> 和输入信号 <code>p</code> 和 <code>r</code> 的状态，确定下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> m = state;</span><br></pre></td></tr></table></figure>
<p>这段代码将当前状态 <code>state</code> 直接赋值给输出信号 <code>m</code>。</p>
<p>综上所述，这个状态机模块根据输入信号 <code>p</code> 和 <code>r</code> 的状态来实现状态转移逻辑，然后将当前状态输出到输出信号 <code>m</code>。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> lights(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, ta, tb, m,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] la, lb);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3&#125;</span><br><span class="line">statetype;</span><br><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"><span class="keyword">parameter</span> green = <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="keyword">parameter</span> yellow = <span class="number">2&#x27;b01</span>;</span><br><span class="line"><span class="keyword">parameter</span> red = <span class="number">2&#x27;b10</span>;</span><br><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (ta) nextstate = S0;</span><br><span class="line"><span class="keyword">else</span> nextstate = S1;</span><br><span class="line">S1: nextstate = S2;</span><br><span class="line">S2: <span class="keyword">if</span> (tb | m) nextstate = S2;</span><br><span class="line"><span class="keyword">else</span> nextstate = S3;</span><br><span class="line">S3: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: &#123;la, lb&#125; = &#123;green, red&#125;;</span><br><span class="line">S1: &#123;la, lb&#125; = &#123;yellow, red&#125;;</span><br><span class="line">S2: &#123;la, lb&#125; = &#123;red, green&#125;;</span><br><span class="line">S3: &#123;la, lb&#125; = &#123;red, yellow&#125;;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个交通灯控制模块，与前两个模块不同的是，它引入了一个额外的输入信号 <code>m</code>，用来控制交通灯的工作模式。让我来逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> lights(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, ta, tb, m,</span><br><span class="line">              <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] la, lb);</span><br></pre></td></tr></table></figure>
<p>这里定义了一个模块 <code>lights</code>，它有五个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>、两个交通灯分别对应的检测信号 <code>ta</code> 和 <code>tb</code>，以及一个模式控制信号 <code>m</code>，以及两个输出信号 <code>la</code> 和 <code>lb</code>，分别对应两个交通灯的状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了四个状态 <code>S0</code>、<code>S1</code>、<code>S2</code> 和 <code>S3</code>，用来表示交通灯的不同状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>这里声明了两个状态变量 <code>state</code> 和 <code>nextstate</code>，都是 <code>statetype</code> 类型的两位向量。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> green = <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="keyword">parameter</span> yellow = <span class="number">2&#x27;b01</span>;</span><br><span class="line"><span class="keyword">parameter</span> red = <span class="number">2&#x27;b10</span>;</span><br></pre></td></tr></table></figure>
<p>这里定义了三个参数 <code>green</code>、<code>yellow</code> 和 <code>red</code>，分别表示交通灯的三种颜色状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在时钟上升沿到来时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (ta) nextstate = S0;</span><br><span class="line"><span class="keyword">else</span> nextstate = S1;</span><br><span class="line">S1: nextstate = S2;</span><br><span class="line">S2: <span class="keyword">if</span> (tb | m) nextstate = S2;</span><br><span class="line"><span class="keyword">else</span> nextstate = S3;</span><br><span class="line">S3: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这段代码表示了状态转移逻辑。根据当前状态 <code>state</code> 和输入信号 <code>ta</code>、<code>tb</code> 和 <code>m</code> 的状态，确定下一个状态 <code>nextstate</code>。当 <code>m</code> 为高电平时，交通灯保持在红色状态，不受 <code>tb</code> 的影响。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: &#123;la, lb&#125; = &#123;green, red&#125;;</span><br><span class="line">S1: &#123;la, lb&#125; = &#123;yellow, red&#125;;</span><br><span class="line">S2: &#123;la, lb&#125; = &#123;red, green&#125;;</span><br><span class="line">S3: &#123;la, lb&#125; = &#123;red, yellow&#125;;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这段代码将当前状态 <code>state</code> 对应的交通灯颜色状态输出到 <code>la</code> 和 <code>lb</code> 信号上。</p>
<p>综上所述，这个模块实现了一个交通灯控制器，根据输入信号 <code>ta</code>、<code>tb</code> 和 <code>m</code> 控制交通灯的状态，并将状态输出到 <code>la</code> 和 <code>lb</code> 信号上。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fig3_42(<span class="keyword">input</span> <span class="keyword">logic</span> clk, a, b, c, d,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> x, y);</span><br><span class="line"><span class="keyword">logic</span> n1, n2;</span><br><span class="line"><span class="keyword">logic</span> areg, breg, creg, dreg;</span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">areg &lt;= a;</span><br><span class="line">breg &lt;= b;</span><br><span class="line">creg &lt;= c;</span><br><span class="line">dreg &lt;= d;</span><br><span class="line">x &lt;= n2;</span><br><span class="line">y &lt;= ~(dreg | n2);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">assign</span> n1 = areg &amp; breg;</span><br><span class="line"><span class="keyword">assign</span> n2 = n1 | creg;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个简单的逻辑电路，并且输出了两个信号 <code>x</code> 和 <code>y</code>。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fig3_42(<span class="keyword">input</span> <span class="keyword">logic</span> clk, a, b, c, d,</span><br><span class="line">               <span class="keyword">output</span> <span class="keyword">logic</span> x, y);</span><br></pre></td></tr></table></figure>
<p>这里定义了一个模块 <code>fig3_42</code>，它有五个输入信号 <code>a</code>、<code>b</code>、<code>c</code>、<code>d</code> 和时钟信号 <code>clk</code>，以及两个输出信号 <code>x</code> 和 <code>y</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> n1, n2;</span><br><span class="line"><span class="keyword">logic</span> areg, breg, creg, dreg;</span><br></pre></td></tr></table></figure>
<p>这里声明了四个内部逻辑信号 <code>n1</code> 和 <code>n2</code>，以及四个寄存器 <code>areg</code>、<code>breg</code>、<code>creg</code> 和 <code>dreg</code>，用来存储输入信号的值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    areg &lt;= a;</span><br><span class="line">    breg &lt;= b;</span><br><span class="line">    creg &lt;= c;</span><br><span class="line">    dreg &lt;= d;</span><br><span class="line">    x &lt;= n2;</span><br><span class="line">    y &lt;= ~(dreg | n2);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这段代码是时序逻辑块，在时钟信号的上升沿触发时执行。它将输入信号 <code>a</code>、<code>b</code>、<code>c</code>、<code>d</code> 分别赋值给寄存器 <code>areg</code>、<code>breg</code>、<code>creg</code>、<code>dreg</code>，然后将 <code>n2</code> 赋值给输出信号 <code>x</code>，同时将 <code>dreg</code> 与 <code>n2</code> 的非运算结果赋值给输出信号 <code>y</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> n1 = areg &amp; breg;</span><br><span class="line"><span class="keyword">assign</span> n2 = n1 | creg;</span><br></pre></td></tr></table></figure>
<p>这段代码是组合逻辑块，它计算了 <code>n1</code> 和 <code>n2</code> 的值。<code>n1</code> 等于 <code>areg</code> 和 <code>breg</code> 的逻辑与运算结果，而 <code>n2</code> 等于 <code>n1</code> 和 <code>creg</code> 的逻辑或运算结果。</p>
<p>综上所述，这个模块实现了一个逻辑电路，根据输入信号 <code>a</code>、<code>b</code>、<code>c</code>、<code>d</code> 的值，在时钟信号的上升沿触发时更新寄存器值，并根据更新后的寄存器值计算输出信号 <code>x</code> 和 <code>y</code>。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fig3_69(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, a, b,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> q);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2&#125; statetype;</span><br><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line"><span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S1: <span class="keyword">if</span> (b) nextstate = S2;</span><br><span class="line"><span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S2: nextstate = S0;</span><br><span class="line"><span class="keyword">default</span>: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> q = state[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这个 Verilog 模块实现了一个状态机，根据输入信号 <code>a</code> 和 <code>b</code> 的状态，输出一个信号 <code>q</code>。下面是逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fig3_69(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, a, b,</span><br><span class="line">               <span class="keyword">output</span> <span class="keyword">logic</span> q);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>fig3_69</code>，它有四个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>、以及两个控制信号 <code>a</code> 和 <code>b</code>。它有一个输出信号 <code>q</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了三个状态 <code>S0</code>、<code>S1</code> 和 <code>S2</code>，用来表示状态机的不同状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>声明了两个状态寄存器，<code>state</code> 和 <code>nextstate</code>，都是两位的 <code>statetype</code> 类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在时钟上升沿来临时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S1: <span class="keyword">if</span> (b) nextstate = S2;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S2: nextstate = S0;</span><br><span class="line"><span class="keyword">default</span>: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这段代码表示了状态转移逻辑。根据当前状态 <code>state</code> 和输入信号 <code>a</code>、<code>b</code> 的状态，确定下一个状态 <code>nextstate</code>。如果 <code>a</code> 为高电平，状态转移到 <code>S1</code>；如果 <code>b</code> 为高电平，状态转移到 <code>S2</code>；否则，状态保持在 <code>S0</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> q = state[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>这段代码将状态寄存器 <code>state</code> 的第二位作为输出信号 <code>q</code>。</p>
<p>综上所述，这个模块实现了一个状态机，根据输入信号 <code>a</code> 和 <code>b</code> 的状态，输出一个信号 <code>q</code>，该信号表示状态机当前所处的状态。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fig3_70(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, a, b,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> q);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2&#125; statetype;</span><br><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line"><span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S1: <span class="keyword">if</span> (b) nextstate = S2;</span><br><span class="line"><span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S2: <span class="keyword">if</span> (a &amp; b) nextstate = S2;</span><br><span class="line"><span class="keyword">else</span> nextstate = S0;</span><br><span class="line"><span class="keyword">default</span>: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: q = <span class="number">0</span>;</span><br><span class="line">S1: q = <span class="number">0</span>;</span><br><span class="line">S2: <span class="keyword">if</span> (a &amp; b) q = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">default</span>: q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这个 Verilog 模块实现了一个简单的状态机，根据输入信号 <code>a</code> 和 <code>b</code> 的状态，输出一个信号 <code>q</code>。下面是逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fig3_70(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, a, b,</span><br><span class="line">               <span class="keyword">output</span> <span class="keyword">logic</span> q);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>fig3_70</code>，它有四个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>、以及两个控制信号 <code>a</code> 和 <code>b</code>。它有一个输出信号 <code>q</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了三个状态 <code>S0</code>、<code>S1</code> 和 <code>S2</code>，用来表示状态机的不同状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>声明了两个状态寄存器，<code>state</code> 和 <code>nextstate</code>，都是两位的 <code>statetype</code> 类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在时钟上升沿来临时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S1: <span class="keyword">if</span> (b) nextstate = S2;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S2: <span class="keyword">if</span> (a &amp; b) nextstate = S2;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line"><span class="keyword">default</span>: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这段代码表示了状态转移逻辑。根据当前状态 <code>state</code> 和输入信号 <code>a</code>、<code>b</code> 的状态，确定下一个状态 <code>nextstate</code>。状态 <code>S2</code> 在 <code>a</code> 和 <code>b</code> 同时为高电平时保持，否则转移到 <code>S0</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: q = <span class="number">0</span>;</span><br><span class="line">S1: q = <span class="number">0</span>;</span><br><span class="line">S2: <span class="keyword">if</span> (a &amp; b) q = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">default</span>: q = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这段代码将状态机的状态映射到输出信号 <code>q</code> 上。当状态为 <code>S2</code> 且 <code>a</code> 和 <code>b</code> 同时为高电平时，<code>q</code> 输出为 1；否则为 0。</p>
<p>综上所述，这个模块实现了一个状态机，根据输入信号 <code>a</code> 和 <code>b</code> 的状态，输出一个信号 <code>q</code>。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_34(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, ta, tb,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] la, lb);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3, S4, S5&#125;</span><br><span class="line">statetype;</span><br><span class="line">statetype [<span class="number">2</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"><span class="keyword">parameter</span> green = <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="keyword">parameter</span> yellow = <span class="number">2&#x27;b01</span>;</span><br><span class="line"><span class="keyword">parameter</span> red = <span class="number">2&#x27;b10</span>;</span><br><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (ta) nextstate = S0;</span><br><span class="line"><span class="keyword">else</span> nextstate = S1;</span><br><span class="line">S1: nextstate = S2;</span><br><span class="line">S2: nextstate = S3;</span><br><span class="line">S3: <span class="keyword">if</span> (tb) nextstate = S3;</span><br><span class="line"><span class="keyword">else</span> nextstate = S4;</span><br><span class="line">S4: nextstate = S5;</span><br><span class="line">S5: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: &#123;la, lb&#125; = &#123;green, red&#125;;</span><br><span class="line">S1: &#123;la, lb&#125; = &#123;yellow, red&#125;;</span><br><span class="line">S2: &#123;la, lb&#125; = &#123;red, red&#125;;</span><br><span class="line">S3: &#123;la, lb&#125; = &#123;red, green&#125;;</span><br><span class="line">S4: &#123;la, lb&#125; = &#123;red, yellow&#125;;</span><br><span class="line">S5: &#123;la, lb&#125; = &#123;red, red&#125;;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个具有六种状态的交通灯控制器。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_34(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, ta, tb,</span><br><span class="line">              <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] la, lb);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>ex4_34</code>，它有四个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>、以及两个交通灯分别对应的检测信号 <code>ta</code> 和 <code>tb</code>，以及两个输出信号 <code>la</code> 和 <code>lb</code>，分别对应两个交通灯的状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3, S4, S5&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了六个状态 <code>S0</code> 到 <code>S5</code>，用来表示交通灯的不同状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">2</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>声明了两个状态寄存器 <code>state</code> 和 <code>nextstate</code>，它们都是 3 位 <code>statetype</code> 类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> green = <span class="number">2&#x27;b00</span>;</span><br><span class="line"><span class="keyword">parameter</span> yellow = <span class="number">2&#x27;b01</span>;</span><br><span class="line"><span class="keyword">parameter</span> red = <span class="number">2&#x27;b10</span>;</span><br></pre></td></tr></table></figure>
<p>定义了三个参数 <code>green</code>、<code>yellow</code> 和 <code>red</code>，分别表示交通灯的三种颜色状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>状态寄存器的行为。在时钟上升沿到来时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (ta) nextstate = S0;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S1;</span><br><span class="line">S1: nextstate = S2;</span><br><span class="line">S2: nextstate = S3;</span><br><span class="line">S3: <span class="keyword">if</span> (tb) nextstate = S3;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S4;</span><br><span class="line">S4: nextstate = S5;</span><br><span class="line">S5: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>状态转移逻辑。根据当前状态 <code>state</code> 和输入信号 <code>ta</code>、<code>tb</code> 的状态，确定下一个状态 <code>nextstate</code>。当 <code>ta</code> 和 <code>tb</code> 分别为高电平时，交通灯保持在 <code>S0</code> 和 <code>S3</code> 的状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: &#123;la, lb&#125; = &#123;green, red&#125;;</span><br><span class="line">S1: &#123;la, lb&#125; = &#123;yellow, red&#125;;</span><br><span class="line">S2: &#123;la, lb&#125; = &#123;red, red&#125;;</span><br><span class="line">S3: &#123;la, lb&#125; = &#123;red, green&#125;;</span><br><span class="line">S4: &#123;la, lb&#125; = &#123;red, yellow&#125;;</span><br><span class="line">S5: &#123;la, lb&#125; = &#123;red, red&#125;;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>输出逻辑。根据当前状态 <code>state</code>，确定交通灯的颜色状态输出到 <code>la</code> 和 <code>lb</code> 信号上。不同状态下，交通灯的颜色状态不同，如绿灯、黄灯、红灯等。</p>
<p>这样，这个模块实现了一个具有六种状态的交通灯控制器。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> daughterfsm(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, a,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">logic</span> smile);</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3, S4&#125;</span><br><span class="line">statetype;</span><br><span class="line">statetype [<span class="number">2</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line"><span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S1: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line"><span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S2: <span class="keyword">if</span> (a) nextstate = S4;</span><br><span class="line"><span class="keyword">else</span> nextstate = S3;</span><br><span class="line">S3: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line"><span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S4: <span class="keyword">if</span> (a) nextstate = S4;</span><br><span class="line"><span class="keyword">else</span> nextstate = S3;</span><br><span class="line"><span class="keyword">default</span>: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> smile = ((state == S3) &amp; a) |</span><br><span class="line">((state == S4) &amp; ~a);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这个 Verilog 模块实现了一个具有五种状态的有限状态机，用来控制一个输出信号 <code>smile</code>。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> daughterfsm(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, a,</span><br><span class="line">                   <span class="keyword">output</span> <span class="keyword">logic</span> smile);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>daughterfsm</code>，它有三个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>，以及一个控制信号 <code>a</code>。它有一个输出信号 <code>smile</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3, S4&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了五个状态 <code>S0</code> 到 <code>S4</code>，用来表示有限状态机的不同状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">2</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>声明了两个状态寄存器 <code>state</code> 和 <code>nextstate</code>，它们都是 3 位 <code>statetype</code> 类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在时钟上升沿到来时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br><span class="line">S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S1: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S2: <span class="keyword">if</span> (a) nextstate = S4;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S3;</span><br><span class="line">S3: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S4: <span class="keyword">if</span> (a) nextstate = S4;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S3;</span><br><span class="line"><span class="keyword">default</span>: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这段代码表示了状态转移逻辑。根据当前状态 <code>state</code> 和输入信号 <code>a</code> 的状态，确定下一个状态 <code>nextstate</code>。具体逻辑为：当 <code>a</code> 为高电平时，有限状态机从当前状态转移到下一个状态；当 <code>a</code> 为低电平时，有限状态机回到初始状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> smile = ((state == S3) &amp; a) | ((state == S4) &amp; ~a);</span><br></pre></td></tr></table></figure>
<p>这段代码确定了输出信号 <code>smile</code> 的逻辑。当状态为 <code>S3</code> 且 <code>a</code> 为高电平时，<code>smile</code> 输出为 1；当状态为 <code>S4</code> 且 <code>a</code> 为低电平时，<code>smile</code> 输出为 1；否则 <code>smile</code> 输出为 0。</p>
<p>这样，这个模块实现了一个有限状态机，根据输入信号 <code>a</code> 控制状态转移，并输出一个信号 <code>smile</code>。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_36(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, n, d, q,</span><br><span class="line"> <span class="keyword">output</span> <span class="keyword">logic</span> dispense,</span><br><span class="line"> return5, return10,</span><br><span class="line"> return2_10);</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] &#123;S0 = <span class="number">4&#x27;b0000</span>,</span><br><span class="line"> S5 = <span class="number">4&#x27;b0001</span>,</span><br><span class="line"> S10 = <span class="number">4&#x27;b0010</span>,</span><br><span class="line"> S25 = <span class="number">4&#x27;b0011</span>,</span><br><span class="line"> S30 = <span class="number">4&#x27;b0100</span>,</span><br><span class="line"> S15 = <span class="number">4&#x27;b0101</span>,</span><br><span class="line"> S20 = <span class="number">4&#x27;b0110</span>,</span><br><span class="line"> S35 = <span class="number">4&#x27;b0111</span>,</span><br><span class="line"> S40 = <span class="number">4&#x27;b1000</span>,</span><br><span class="line"> S45 = <span class="number">4&#x27;b1001</span>&#125;</span><br><span class="line"> statetype;</span><br><span class="line"> statetype [<span class="number">3</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"> <span class="comment">// State Register</span></span><br><span class="line"> <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"> <span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"> <span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"> <span class="comment">// Next State Logic</span></span><br><span class="line"> <span class="keyword">always_comb</span></span><br><span class="line"> <span class="keyword">case</span> (state)</span><br><span class="line"> S0: <span class="keyword">if</span> (n) nextstate = S5;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (d) nextstate = S10;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (q) nextstate = S25;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S0;</span><br><span class="line"> S5: <span class="keyword">if</span> (n) nextstate = S10;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (d) nextstate = S15;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (q) nextstate = S30;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S5;</span><br><span class="line"> S10: <span class="keyword">if</span> (n) nextstate = S15;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (d) nextstate = S20;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (q) nextstate = S35;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S10;</span><br><span class="line"> S25: nextstate = S0;</span><br><span class="line"> S30: nextstate = S0;</span><br><span class="line"> S15: <span class="keyword">if</span> (n) nextstate = S20;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (d) nextstate = S25;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (q) nextstate = S40;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S15;</span><br><span class="line"> S20: <span class="keyword">if</span> (n) nextstate = S25;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (d) nextstate = S30;</span><br><span class="line"> <span class="keyword">else</span> <span class="keyword">if</span> (q) nextstate = S45;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S20;</span><br><span class="line"> S35: nextstate = S0;</span><br><span class="line"> S40: nextstate = S0;</span><br><span class="line"> S45: nextstate = S0;</span><br><span class="line"> <span class="keyword">default</span>: nextstate = S0;</span><br><span class="line"> <span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这个 Verilog 模块实现了一个自动售货机的状态机，根据输入的硬币类型和货物价格，控制货物的发放和找零。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_36(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, n, d, q,</span><br><span class="line">              <span class="keyword">output</span> <span class="keyword">logic</span> dispense, return5, return10, return2_10);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>ex4_36</code>，它有六个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>，以及三个硬币输入信号 <code>n</code>、<code>d</code> 和 <code>q</code>。它有四个输出信号：<code>dispense</code> 表示货物的发放信号，<code>return5</code>、<code>return10</code> 和 <code>return2_10</code> 分别表示找零的 5 分、10 分和两个 10 分的硬币信号。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] &#123;S0 = <span class="number">4&#x27;b0000</span>, S5 = <span class="number">4&#x27;b0001</span>, S10 = <span class="number">4&#x27;b0010</span>, S25 = <span class="number">4&#x27;b0011</span>,</span><br><span class="line">                           S30 = <span class="number">4&#x27;b0100</span>, S15 = <span class="number">4&#x27;b0101</span>, S20 = <span class="number">4&#x27;b0110</span>, S35 = <span class="number">4&#x27;b0111</span>,</span><br><span class="line">                           S40 = <span class="number">4&#x27;b1000</span>, S45 = <span class="number">4&#x27;b1001</span>&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了十个状态，分别对应不同的货币输入和货物发放的情况。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">3</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>声明了两个状态寄存器 <code>state</code> 和 <code>nextstate</code>，它们都是 4 位 <code>statetype</code> 类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在时钟上升沿到来时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br></pre></td></tr></table></figure>
<p>这里开始了状态转移逻辑的 <code>case</code> 分支语句。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">S0: <span class="keyword">if</span> (n) nextstate = S5;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d) nextstate = S10;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (q) nextstate = S25;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br></pre></td></tr></table></figure>
<p>在状态 <code>S0</code> 下，根据不同硬币类型的输入确定下一个状态 <code>nextstate</code>。如果输入了 5 分硬币，则进入状态 <code>S5</code>；如果输入了 10 分硬币，则进入状态 <code>S10</code>；如果输入了 25 分硬币，则进入状态 <code>S25</code>；否则保持在状态 <code>S0</code>。</p>
<p>类似地，其他状态下的状态转移逻辑也进行了定义。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>: nextstate = S0;</span><br></pre></td></tr></table></figure>
<p>对于其他未明确定义的状态，都将下一个状态设置为 <code>S0</code>。</p>
<p>这个模块的其余部分没有包含在您的消息中，但基于状态转移逻辑，可以推断出发放信号和找零信号的生成逻辑。根据状态的不同，当达到特定状态时，发放信号和找零信号被设置为相应的值，以触发货物的发放和硬币的找零。</p>
<p>综上所述，这个模块实现了一个自动售货机的状态机，根据输入的硬币类型和货物价格，控制货物的发放和找零。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"> <span class="keyword">assign</span> dispense = (state == S25) |</span><br><span class="line"> (state == S30) |</span><br><span class="line"> (state == S35) |</span><br><span class="line"> (state == S40) |</span><br><span class="line"> (state == S45);</span><br><span class="line"> <span class="keyword">assign</span> return5 = (state == S30) |</span><br><span class="line"> (state == S40);</span><br><span class="line"> <span class="keyword">assign</span> return10 = (state == S35) |</span><br><span class="line"> (state == S40);</span><br><span class="line"> <span class="keyword">assign</span> return2_10 = (state == S45);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码是关于输出逻辑的定义，它将根据状态机的当前状态，确定是否触发发放货物和找零的操作。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> dispense = (state == S25) |</span><br><span class="line">                  (state == S30) |</span><br><span class="line">                  (state == S35) |</span><br><span class="line">                  (state == S40) |</span><br><span class="line">                  (state == S45);</span><br></pre></td></tr></table></figure>
<p>这段代码将 <code>dispense</code> 输出信号设置为逻辑表达式的值，这个表达式判断当前状态是否为需要发放货物的状态。具体来说，状态 <code>S25</code>、<code>S30</code>、<code>S35</code>、<code>S40</code> 和 <code>S45</code> 分别对应需要发放货物的状态，所以如果状态机处于这些状态之一，<code>dispense</code> 信号被设置为逻辑 1，否则为逻辑 0。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> return5 = (state == S30) |</span><br><span class="line">                 (state == S40);</span><br></pre></td></tr></table></figure>
<p>这段代码将 <code>return5</code> 输出信号设置为逻辑表达式的值，这个表达式判断当前状态是否为需要找零 5 分硬币的状态。具体来说，状态 <code>S30</code> 和 <code>S40</code> 分别对应需要找零 5 分硬币的状态，所以如果状态机处于这两个状态之一，<code>return5</code> 信号被设置为逻辑 1，否则为逻辑 0。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> return10 = (state == S35) |</span><br><span class="line">                  (state == S40);</span><br></pre></td></tr></table></figure>
<p>这段代码将 <code>return10</code> 输出信号设置为逻辑表达式的值，这个表达式判断当前状态是否为需要找零 10 分硬币的状态。具体来说，状态 <code>S35</code> 和 <code>S40</code> 分别对应需要找零 10 分硬币的状态，所以如果状态机处于这两个状态之一，<code>return10</code> 信号被设置为逻辑 1，否则为逻辑 0。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> return2_10 = (state == S45);</span><br></pre></td></tr></table></figure>
<p>这段代码将 <code>return2_10</code> 输出信号设置为逻辑表达式的值，这个表达式判断当前状态是否为需要找零两个 10 分硬币的状态。具体来说，状态 <code>S45</code> 对应需要找零两个 10 分硬币的状态，所以如果状态机处于这个状态，<code>return2_10</code> 信号被设置为逻辑 1，否则为逻辑 0。</p>
<p>综上所述，这段代码描述了根据状态机的当前状态确定发放货物和找零的输出信号的逻辑。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_37(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset,</span><br><span class="line"> <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] q);</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;S0 = <span class="number">3&#x27;b000</span>,</span><br><span class="line"> S1 = <span class="number">3&#x27;b001</span>,</span><br><span class="line"> S2 = <span class="number">3&#x27;b011</span>,</span><br><span class="line"> S3 = <span class="number">3&#x27;b010</span>,</span><br><span class="line"> S4 = <span class="number">3&#x27;b110</span>,</span><br><span class="line"> S5 = <span class="number">3&#x27;b111</span>,</span><br><span class="line"> S6 = <span class="number">3&#x27;b101</span>,</span><br><span class="line"> S7 = <span class="number">3&#x27;b100</span>&#125;</span><br><span class="line"> statetype;</span><br><span class="line"> statetype [<span class="number">2</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"> <span class="comment">// State Register</span></span><br><span class="line"> <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"> <span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"> <span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"> <span class="comment">// Next State Logic</span></span><br><span class="line"> <span class="keyword">always_comb</span></span><br><span class="line"> <span class="keyword">case</span> (state)</span><br><span class="line"> S0: nextstate = S1;</span><br><span class="line"> S1: nextstate = S2;</span><br><span class="line"> S2: nextstate = S3;</span><br><span class="line"> S3: nextstate = S4;</span><br><span class="line"> S4: nextstate = S5;</span><br><span class="line"> S5: nextstate = S6;</span><br><span class="line"> S6: nextstate = S7;</span><br><span class="line"> S7: nextstate = S0;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> <span class="comment">// Output Logic</span></span><br><span class="line"> <span class="keyword">assign</span> q = state;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个简单的状态机，具有 8 个状态。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_37(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset,</span><br><span class="line">              <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] q);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>ex4_37</code>，它有两个输入信号：时钟 <code>clk</code> 和复位信号 <code>reset</code>，以及一个输出信号 <code>q</code>，它是一个 3 位的向量，用于表示状态机的当前状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;S0 = <span class="number">3&#x27;b000</span>, S1 = <span class="number">3&#x27;b001</span>, S2 = <span class="number">3&#x27;b011</span>, S3 = <span class="number">3&#x27;b010</span>,</span><br><span class="line">                           S4 = <span class="number">3&#x27;b110</span>, S5 = <span class="number">3&#x27;b111</span>, S6 = <span class="number">3&#x27;b101</span>, S7 = <span class="number">3&#x27;b100</span>&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了八个状态，分别用三位二进制数表示。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">2</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>声明了两个状态寄存器 <code>state</code> 和 <code>nextstate</code>，它们都是 3 位 <code>statetype</code> 类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在时钟上升沿到来时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为初始状态 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br></pre></td></tr></table></figure>
<p>这里开始了状态转移逻辑的 <code>case</code> 分支语句。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">S0: nextstate = S1;</span><br><span class="line">S1: nextstate = S2;</span><br><span class="line">S2: nextstate = S3;</span><br><span class="line">S3: nextstate = S4;</span><br><span class="line">S4: nextstate = S5;</span><br><span class="line">S5: nextstate = S6;</span><br><span class="line">S6: nextstate = S7;</span><br><span class="line">S7: nextstate = S0;</span><br></pre></td></tr></table></figure>
<p>这段代码定义了状态机的状态转移逻辑。从当前状态到下一个状态的转移是固定的，每个状态都有一个确定的下一个状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p><code>case</code> 语句结束。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> q = state;</span><br></pre></td></tr></table></figure>
<p>这段代码将当前状态 <code>state</code> 直接赋值给输出信号 <code>q</code>，以便将状态机的当前状态输出。</p>
<p>综上所述，这个模块实现了一个简单的状态机，具有 8 个状态。每个状态都有一个确定的下一个状态，并且在时钟信号的驱动下，根据状态转移逻辑进行状态的更新。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_38(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, up,</span><br><span class="line"> <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] q);</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;</span><br><span class="line"> S0 = <span class="number">3&#x27;b000</span>,</span><br><span class="line"> S1 = <span class="number">3&#x27;b001</span>,</span><br><span class="line"> S2 = <span class="number">3&#x27;b011</span>,</span><br><span class="line"> S3 = <span class="number">3&#x27;b010</span>,</span><br><span class="line"> S4 = <span class="number">3&#x27;b110</span>,</span><br><span class="line"> S5 = <span class="number">3&#x27;b111</span>,</span><br><span class="line"> S6 = <span class="number">3&#x27;b101</span>,</span><br><span class="line"> S7 = <span class="number">3&#x27;b100</span>&#125; statetype;</span><br><span class="line"> statetype [<span class="number">2</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"> <span class="comment">// State Register</span></span><br><span class="line"> <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"> <span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"> <span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"> <span class="comment">// Next State Logic</span></span><br><span class="line"> <span class="keyword">always_comb</span></span><br><span class="line"> <span class="keyword">case</span> (state)</span><br><span class="line"> S0: <span class="keyword">if</span> (up) nextstate = S1;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S7;</span><br><span class="line"> S1: <span class="keyword">if</span> (up) nextstate = S2;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S0;</span><br><span class="line"> S2: <span class="keyword">if</span> (up) nextstate = S3;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S1;</span><br><span class="line"> S3: <span class="keyword">if</span> (up) nextstate = S4;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S2;</span><br><span class="line"> S4: <span class="keyword">if</span> (up) nextstate = S5;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S3;</span><br><span class="line"> S5: <span class="keyword">if</span> (up) nextstate = S6;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S4;</span><br><span class="line"> S6: <span class="keyword">if</span> (up) nextstate = S7;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S5;</span><br><span class="line"> S7: <span class="keyword">if</span> (up) nextstate = S0;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S6;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> <span class="comment">// Output Logic</span></span><br><span class="line"> <span class="keyword">assign</span> q = state;</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个有 8 个状态的状态机，状态之间的转移受到输入信号 <code>up</code> 的控制。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_38(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, up,</span><br><span class="line">              <span class="keyword">output</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] q);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>ex4_38</code>，它有三个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>，以及控制信号 <code>up</code>。它有一个输出信号 <code>q</code>，是一个 3 位的向量，用于表示状态机的当前状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;S0 = <span class="number">3&#x27;b000</span>, S1 = <span class="number">3&#x27;b001</span>, S2 = <span class="number">3&#x27;b011</span>, S3 = <span class="number">3&#x27;b010</span>,</span><br><span class="line">                           S4 = <span class="number">3&#x27;b110</span>, S5 = <span class="number">3&#x27;b111</span>, S6 = <span class="number">3&#x27;b101</span>, S7 = <span class="number">3&#x27;b100</span>&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了八个状态，分别用三位二进制数表示。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">2</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>声明了两个状态寄存器 <code>state</code> 和 <code>nextstate</code>，它们都是 3 位 <code>statetype</code> 类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在时钟上升沿到来时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为初始状态 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br></pre></td></tr></table></figure>
<p>这里开始了状态转移逻辑的 <code>case</code> 分支语句。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">S0: <span class="keyword">if</span> (up) nextstate = S1;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S7;</span><br><span class="line">S1: <span class="keyword">if</span> (up) nextstate = S2;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S2: <span class="keyword">if</span> (up) nextstate = S3;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S1;</span><br><span class="line">S3: <span class="keyword">if</span> (up) nextstate = S4;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S2;</span><br><span class="line">S4: <span class="keyword">if</span> (up) nextstate = S5;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S3;</span><br><span class="line">S5: <span class="keyword">if</span> (up) nextstate = S6;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S4;</span><br><span class="line">S6: <span class="keyword">if</span> (up) nextstate = S7;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S5;</span><br><span class="line">S7: <span class="keyword">if</span> (up) nextstate = S0;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S6;</span><br></pre></td></tr></table></figure>
<p>这段代码定义了状态机的状态转移逻辑。根据当前状态 <code>state</code> 和输入信号 <code>up</code>，确定下一个状态 <code>nextstate</code>。如果 <code>up</code> 信号为高电平，则状态按照 S0-&gt;S1-&gt;S2-&gt;…-&gt;S7-&gt;S0 的顺序依次循环；如果 <code>up</code> 信号为低电平，则状态按照 S0-&gt;S7-&gt;S6-&gt;…-&gt;S1-&gt;S0 的顺序依次循环。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p><code>case</code> 语句结束。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> q = state;</span><br></pre></td></tr></table></figure>
<p>这段代码将当前状态 <code>state</code> 直接赋值给输出信号 <code>q</code>，以便将状态机的当前状态输出。</p>
<p>综上所述，这个模块实现了一个具有 8 个状态的状态机，状态之间的转移受到输入信号 <code>up</code> 的控制。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_39(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, a, b,</span><br><span class="line"> <span class="keyword">output</span> <span class="keyword">logic</span> z);</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3&#125;</span><br><span class="line"> statetype;</span><br><span class="line"> statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"> <span class="comment">// State Register</span></span><br><span class="line"> <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"> <span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"> <span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"> <span class="comment">// Next State Logic</span></span><br><span class="line"> <span class="keyword">always_comb</span></span><br><span class="line"> <span class="keyword">case</span> (state)</span><br><span class="line"> S0: <span class="keyword">case</span> (&#123;b,a&#125;)</span><br><span class="line"> <span class="number">2&#x27;b00</span>: nextstate = S0;</span><br><span class="line"> <span class="number">2&#x27;b01</span>: nextstate = S3;</span><br><span class="line"> <span class="number">2&#x27;b10</span>: nextstate = S0;</span><br><span class="line"> <span class="number">2&#x27;b11</span>: nextstate = S1;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> S1: <span class="keyword">case</span> (&#123;b,a&#125;)</span><br><span class="line"> <span class="number">2&#x27;b00</span>: nextstate = S0;</span><br><span class="line"> <span class="number">2&#x27;b01</span>: nextstate = S3;</span><br><span class="line"> <span class="number">2&#x27;b10</span>: nextstate = S2;</span><br><span class="line"> <span class="number">2&#x27;b11</span>: nextstate = S1;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> S2: <span class="keyword">case</span> (&#123;b,a&#125;)</span><br><span class="line"> <span class="number">2&#x27;b00</span>: nextstate = S0;</span><br><span class="line"> <span class="number">2&#x27;b01</span>: nextstate = S3;</span><br><span class="line"> <span class="number">2&#x27;b10</span>: nextstate = S2;</span><br><span class="line"> <span class="number">2&#x27;b11</span>: nextstate = S1;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> S3: <span class="keyword">case</span> (&#123;b,a&#125;)</span><br><span class="line"> <span class="number">2&#x27;b00</span>: nextstate = S0;</span><br><span class="line"> <span class="number">2&#x27;b01</span>: nextstate = S3;</span><br><span class="line"> <span class="number">2&#x27;b10</span>: nextstate = S2;</span><br><span class="line"> <span class="number">2&#x27;b11</span>: nextstate = S1;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> <span class="keyword">default</span>: nextstate = S0;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> <span class="comment">// Output Logic</span></span><br><span class="line"> <span class="keyword">always_comb</span></span><br><span class="line"> <span class="keyword">case</span> (state)</span><br><span class="line"> S0: z = a &amp; b;</span><br><span class="line"> S1: z = a | b;</span><br><span class="line"> S2: z = a &amp; b;</span><br><span class="line"> S3: z = a | b;</span><br><span class="line"> <span class="keyword">default</span>: z = <span class="number">1&#x27;b0</span>;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个状态机，根据输入信号 <code>a</code> 和 <code>b</code> 的组合确定下一个状态，并根据当前状态确定输出信号 <code>z</code>。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_39(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, a, b,</span><br><span class="line">              <span class="keyword">output</span> <span class="keyword">logic</span> z);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>ex4_39</code>，它有四个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>，以及两个数据信号 <code>a</code> 和 <code>b</code>。它有一个输出信号 <code>z</code>，用于表示状态机的输出。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了四个状态，分别用两位二进制数表示。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>声明了两个状态寄存器 <code>state</code> 和 <code>nextstate</code>，它们都是 2 位 <code>statetype</code> 类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"><span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"><span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在时钟上升沿到来时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为初始状态 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br></pre></td></tr></table></figure>
<p>这里开始了状态转移逻辑的 <code>case</code> 分支语句。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">S0: <span class="keyword">case</span> (&#123;b,a&#125;)</span><br><span class="line">     <span class="number">2&#x27;b00</span>: nextstate = S0;</span><br><span class="line">     <span class="number">2&#x27;b01</span>: nextstate = S3;</span><br><span class="line">     <span class="number">2&#x27;b10</span>: nextstate = S0;</span><br><span class="line">     <span class="number">2&#x27;b11</span>: nextstate = S1;</span><br><span class="line">     <span class="keyword">endcase</span></span><br><span class="line">S1: <span class="keyword">case</span> (&#123;b,a&#125;)</span><br><span class="line">     <span class="number">2&#x27;b00</span>: nextstate = S0;</span><br><span class="line">     <span class="number">2&#x27;b01</span>: nextstate = S3;</span><br><span class="line">     <span class="number">2&#x27;b10</span>: nextstate = S2;</span><br><span class="line">     <span class="number">2&#x27;b11</span>: nextstate = S1;</span><br><span class="line">     <span class="keyword">endcase</span></span><br><span class="line">S2: <span class="keyword">case</span> (&#123;b,a&#125;)</span><br><span class="line">     <span class="number">2&#x27;b00</span>: nextstate = S0;</span><br><span class="line">     <span class="number">2&#x27;b01</span>: nextstate = S3;</span><br><span class="line">     <span class="number">2&#x27;b10</span>: nextstate = S2;</span><br><span class="line">     <span class="number">2&#x27;b11</span>: nextstate = S1;</span><br><span class="line">     <span class="keyword">endcase</span></span><br><span class="line">S3: <span class="keyword">case</span> (&#123;b,a&#125;)</span><br><span class="line">     <span class="number">2&#x27;b00</span>: nextstate = S0;</span><br><span class="line">     <span class="number">2&#x27;b01</span>: nextstate = S3;</span><br><span class="line">     <span class="number">2&#x27;b10</span>: nextstate = S2;</span><br><span class="line">     <span class="number">2&#x27;b11</span>: nextstate = S1;</span><br><span class="line">     <span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这段代码定义了状态机的状态转移逻辑。根据当前状态 <code>state</code> 和输入信号 <code>&#123;b,a&#125;</code> 的组合确定下一个状态 <code>nextstate</code>。每个状态都有一个针对 <code>&#123;b,a&#125;</code> 不同组合的 <code>case</code> 语句，以确定下一个状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span>: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>如果状态机处于未明确定义的状态，则将下一个状态设置为初始状态 <code>S0</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br></pre></td></tr></table></figure>
<p>这段代码定义了状态机的输出逻辑。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">S0: z = a &amp; b;</span><br><span class="line">S1: z = a | b;</span><br><span class="line">S2: z = a &amp; b;</span><br><span class="line">S3: z = a | b;</span><br><span class="line"><span class="keyword">default</span>: z = <span class="number">1&#x27;b0</span>;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>根据当前状态 <code>state</code>，确定输出信号 <code>z</code> 的值。在状态 <code>S0</code> 和 <code>S2</code> 下，输出信号 <code>z</code> 等于输入信号 <code>a</code> 和 <code>b</code> 的与运算结果；在状态 <code>S1</code> 和 <code>S3</code> 下，输出信号 <code>z</code> 等于输入信号 <code>a</code> 和 <code>b</code> 的或运算结果；其他状态下，输出信号 <code>z</code> 被设置为逻辑 0。</p>
<p>综上所述，这个模块实现了一个根据输入信号 <code>a</code> 和 <code>b</code> 的组合确定状态转移，并根据当前状态确定输出信号 <code>z</code> 的状态机。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_37(<span class="keyword">input</span> <span class="keyword">logic</span> clk, a, b,</span><br><span class="line"> <span class="keyword">output</span> <span class="keyword">logic</span> z);</span><br><span class="line"> <span class="keyword">logic</span> aprev;</span><br><span class="line"> <span class="comment">// State Register</span></span><br><span class="line"> <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"> aprev &lt;= a;</span><br><span class="line"> <span class="keyword">assign</span> z = b ? (aprev | a) : (aprev &amp; a);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个游戏，其中根据输入信号 <code>a</code> 和 <code>b</code> 的状态以及之前的输入信号 <code>aprev</code>，确定输出信号 <code>z</code> 的值。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_37(<span class="keyword">input</span> <span class="keyword">logic</span> clk, a, b,</span><br><span class="line">              <span class="keyword">output</span> <span class="keyword">logic</span> z);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>ex4_37</code>，它有三个输入信号：时钟 <code>clk</code>，以及两个数据信号 <code>a</code> 和 <code>b</code>。它有一个输出信号 <code>z</code>，用于表示游戏的输出。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> aprev;</span><br></pre></td></tr></table></figure>
<p>声明了一个逻辑类型的变量 <code>aprev</code>，用于保存之前的输入信号 <code>a</code> 的值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    aprev &lt;= a;</span><br></pre></td></tr></table></figure>
<p>在时钟信号的上升沿触发时，将当前输入信号 <code>a</code> 的值赋给 <code>aprev</code> 变量，以便在下一个时钟周期使用。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assign</span> z = b ? (aprev | a) : (aprev &amp; a);</span><br></pre></td></tr></table></figure>
<p>这段代码根据输入信号 <code>b</code> 的状态选择性地执行位运算。如果 <code>b</code> 为逻辑真（高电平），则执行逻辑或运算（<code>|</code>），计算之前的输入信号 <code>aprev</code> 和当前输入信号 <code>a</code> 的逻辑或；如果 <code>b</code> 为逻辑假（低电平），则执行逻辑与运算（<code>&amp;</code>），计算之前的输入信号 <code>aprev</code> 和当前输入信号 <code>a</code> 的逻辑与。最终的结果赋给输出信号 <code>z</code>。</p>
<p>综上所述，这个模块的功能是根据输入信号 <code>a</code> 和 <code>b</code> 的状态以及之前的输入信号 <code>aprev</code>，确定输出信号 <code>z</code> 的值。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fsm_y(<span class="keyword">input</span> clk, reset, a,</span><br><span class="line"> <span class="keyword">output</span> y);</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0=<span class="number">2&#x27;b00</span>, S1=<span class="number">2&#x27;b01</span>,</span><br><span class="line"> S11=<span class="number">2&#x27;b11</span>&#125; statetype;</span><br><span class="line"> statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"> <span class="comment">// State Register</span></span><br><span class="line"> <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"> <span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"> <span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"> <span class="comment">// Next State Logic</span></span><br><span class="line"> <span class="keyword">always_comb</span></span><br><span class="line"> <span class="keyword">case</span> (state)</span><br><span class="line"> S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S0;</span><br><span class="line"> S1: <span class="keyword">if</span> (a) nextstate = S11;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S0;</span><br><span class="line"> S11: nextstate = S11;</span><br><span class="line"> <span class="keyword">default</span>: nextstate = S0;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> <span class="comment">// Output Logic</span></span><br><span class="line"> <span class="keyword">assign</span> y = state[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个简单的有限状态机（FSM），根据输入信号 <code>a</code> 的状态，确定状态机的状态并输出信号 <code>y</code>。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fsm_y(<span class="keyword">input</span> clk, reset, a,</span><br><span class="line">             <span class="keyword">output</span> y);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>fsm_y</code>，它有三个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>，以及数据信号 <code>a</code>。它有一个输出信号 <code>y</code>，用于表示状态机的输出。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0=<span class="number">2&#x27;b00</span>, S1=<span class="number">2&#x27;b01</span>, S11=<span class="number">2&#x27;b11</span>&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了三个状态，分别用两位二进制数表示。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>声明了两个状态寄存器 <code>state</code> 和 <code>nextstate</code>，它们都是 2 位 <code>statetype</code> 类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line">    <span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在时钟上升沿到来时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为初始状态 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br></pre></td></tr></table></figure>
<p>这里开始了状态转移逻辑的 <code>case</code> 分支语句。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S1: <span class="keyword">if</span> (a) nextstate = S11;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S11: nextstate = S11;</span><br><span class="line"><span class="keyword">default</span>: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这段代码定义了状态机的状态转移逻辑。根据当前状态 <code>state</code> 和输入信号 <code>a</code> 的状态确定下一个状态 <code>nextstate</code>。如果当前状态为 <code>S0</code>，并且输入信号 <code>a</code> 为高电平，则下一个状态为 <code>S1</code>；如果当前状态为 <code>S1</code>，并且输入信号 <code>a</code> 为高电平，则下一个状态为 <code>S11</code>；否则，保持当前状态不变。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> y = state[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>这段代码将当前状态的第二位（即最低有效位）作为输出信号 <code>y</code> 的值。因为状态 <code>S1</code> 和 <code>S11</code> 的最低有效位都是 1，所以只有在这两个状态下，输出信号 <code>y</code> 才为高电平。</p>
<p>综上所述，这个模块实现了一个简单的有限状态机（FSM），根据输入信号 <code>a</code> 的状态确定状态机的状态，并将状态机的当前状态的第二位作为输出信号 <code>y</code> 的值。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fsm_x(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, a,</span><br><span class="line"> <span class="keyword">output</span> <span class="keyword">logic</span> x);</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3&#125;</span><br><span class="line"> statetype;</span><br><span class="line"> statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"> <span class="comment">// State Register</span></span><br><span class="line"> <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"> <span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"> <span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"> <span class="comment">// Next State Logic</span></span><br><span class="line"> <span class="keyword">always_comb</span></span><br><span class="line"> <span class="keyword">case</span> (state)</span><br><span class="line"> S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S0;</span><br><span class="line"> S1: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S1;</span><br><span class="line"> S2: <span class="keyword">if</span> (a) nextstate = S3;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S2;</span><br><span class="line"> S3: nextstate = S3;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> <span class="comment">// Output Logic</span></span><br><span class="line"> <span class="keyword">assign</span> x = (state == S3);</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个简单的有限状态机（FSM），根据输入信号 <code>a</code> 的状态，确定状态机的状态并输出信号 <code>x</code>。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> fsm_x(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, a,</span><br><span class="line">             <span class="keyword">output</span> <span class="keyword">logic</span> x);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>fsm_x</code>，它有三个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>，以及数据信号 <code>a</code>。它有一个输出信号 <code>x</code>，用于表示状态机的输出。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了四个状态，分别用两位二进制数表示。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>声明了两个状态寄存器 <code>state</code> 和 <code>nextstate</code>，它们都是 2 位 <code>statetype</code> 类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line">    <span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在时钟上升沿到来时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为初始状态 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br></pre></td></tr></table></figure>
<p>这里开始了状态转移逻辑的 <code>case</code> 分支语句。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S1: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S1;</span><br><span class="line">S2: <span class="keyword">if</span> (a) nextstate = S3;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S2;</span><br><span class="line">S3: nextstate = S3;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这段代码定义了状态机的状态转移逻辑。根据当前状态 <code>state</code> 和输入信号 <code>a</code> 的状态确定下一个状态 <code>nextstate</code>。每个状态都根据输入信号 <code>a</code> 的状态决定是否转移到下一个状态，除了状态 <code>S3</code> 外，其余状态均会根据输入信号 <code>a</code> 的状态确定下一个状态。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> x = (state == S3);</span><br></pre></td></tr></table></figure>
<p>这段代码将输出信号 <code>x</code> 设置为逻辑表达式 <code>(state == S3)</code> 的值。当且仅当当前状态为 <code>S3</code> 时，输出信号 <code>x</code> 才为高电平。</p>
<p>综上所述，这个模块实现了一个简单的有限状态机（FSM），根据输入信号 <code>a</code> 的状态确定状态机的状态，并将状态机是否处于状态 <code>S3</code> 作为输出信号 <code>x</code> 的值。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_41(<span class="keyword">input</span> <span class="keyword">logic</span> clk, start, a,</span><br><span class="line"> <span class="keyword">output</span> <span class="keyword">logic</span> q);</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3&#125;</span><br><span class="line"> statetype;</span><br><span class="line"> statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"> <span class="comment">// State Register</span></span><br><span class="line"> <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> start)</span><br><span class="line"> <span class="keyword">if</span> (start) state &lt;= S0;</span><br><span class="line"> <span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"> <span class="comment">// Next State Logic</span></span><br><span class="line"> <span class="keyword">always_comb</span></span><br><span class="line"> <span class="keyword">case</span> (state)</span><br><span class="line"> S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S0;</span><br><span class="line"> S1: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S3;</span><br><span class="line"> S2: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S3;</span><br><span class="line"> S3: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S3;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> <span class="comment">// Output Logic</span></span><br><span class="line"> <span class="keyword">assign</span> q = state[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个简单的有限状态机（FSM），其行为受时钟信号 <code>clk</code> 和启动信号 <code>start</code> 的控制，根据输入信号 <code>a</code> 的状态确定状态机的状态，并输出信号 <code>q</code>。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_41(<span class="keyword">input</span> <span class="keyword">logic</span> clk, start, a,</span><br><span class="line">              <span class="keyword">output</span> <span class="keyword">logic</span> q);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>ex4_41</code>，它有三个输入信号：时钟 <code>clk</code>、启动信号 <code>start</code>，以及数据信号 <code>a</code>。它有一个输出信号 <code>q</code>，用于表示状态机的输出。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了四个状态，分别用两位二进制数表示。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>声明了两个状态寄存器 <code>state</code> 和 <code>nextstate</code>，它们都是 2 位 <code>statetype</code> 类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> start)</span><br><span class="line">    <span class="keyword">if</span> (start) state &lt;= S0;</span><br><span class="line">    <span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在启动信号 <code>start</code> 上升沿到来时，如果 <code>start</code> 为高电平，则将当前状态 <code>state</code> 设置为初始状态 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br></pre></td></tr></table></figure>
<p>这里开始了状态转移逻辑的 <code>case</code> 分支语句。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S1: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S3;</span><br><span class="line">S2: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S3;</span><br><span class="line">S3: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S3;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这段代码定义了状态机的状态转移逻辑。根据当前状态 <code>state</code> 和输入信号 <code>a</code> 的状态确定下一个状态 <code>nextstate</code>。在状态 <code>S0</code> 下，如果输入信号 <code>a</code> 为高电平，则转移到状态 <code>S1</code>，否则保持在状态 <code>S0</code>；在状态 <code>S1</code> 下，如果输入信号 <code>a</code> 为高电平，则转移到状态 <code>S2</code>，否则转移到状态 <code>S3</code>；在状态 <code>S2</code> 下，无论输入信号 <code>a</code> 的状态如何，都保持在状态 <code>S2</code>；在状态 <code>S3</code> 下，无论输入信号 <code>a</code> 的状态如何，都保持在状态 <code>S3</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> q = state[<span class="number">0</span>];</span><br></pre></td></tr></table></figure>
<p>这段代码将输出信号 <code>q</code> 设置为当前状态的第一位（即高位），以表示状态机的状态。</p>
<p>综上所述，这个模块实现了一个简单的有限状态机（FSM），其行为受时钟信号 <code>clk</code> 和启动信号 <code>start</code> 的控制，根据输入信号 <code>a</code> 的状态确定状态机的状态，并将状态机的当前状态的高位作为输出信号 <code>q</code> 的值。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_42(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, x,</span><br><span class="line"> <span class="keyword">output</span> <span class="keyword">logic</span> q);</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3&#125;</span><br><span class="line"> statetype;</span><br><span class="line"> statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"> <span class="comment">// State Register</span></span><br><span class="line"> <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"> <span class="keyword">if</span> (reset) state &lt;= S00;</span><br><span class="line"> <span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"> <span class="comment">// Next State Logic</span></span><br><span class="line"> <span class="keyword">always_comb</span></span><br><span class="line"> <span class="keyword">case</span> (state)</span><br><span class="line"> S00: <span class="keyword">if</span> (x) nextstate = S11;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S01;</span><br><span class="line"> S01: <span class="keyword">if</span> (x) nextstate = S10;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S00;</span><br><span class="line"> S10: nextstate = S01;</span><br><span class="line"> S11: nextstate = S01;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> <span class="comment">// Output Logic</span></span><br><span class="line"> <span class="keyword">assign</span> q = state[<span class="number">0</span>] | state[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个有限状态机（FSM），其行为受时钟信号 <code>clk</code> 和复位信号 <code>reset</code> 的控制，根据输入信号 <code>x</code> 的状态确定状态机的状态，并输出信号 <code>q</code>。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_42(<span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, x,</span><br><span class="line">              <span class="keyword">output</span> <span class="keyword">logic</span> q);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>ex4_42</code>，它有三个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>，以及数据信号 <code>x</code>。它有一个输出信号 <code>q</code>，用于表示状态机的输出。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2, S3&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了四个状态，分别用两位二进制数表示。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>声明了两个状态寄存器 <code>state</code> 和 <code>nextstate</code>，它们都是 2 位 <code>statetype</code> 类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span> (reset) state &lt;= S00;</span><br><span class="line">    <span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在时钟信号的上升沿到来时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为初始状态 <code>S00</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br></pre></td></tr></table></figure>
<p>这里开始了状态转移逻辑的 <code>case</code> 分支语句。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">S00: <span class="keyword">if</span> (x) nextstate = S11;</span><br><span class="line">     <span class="keyword">else</span> nextstate = S01;</span><br><span class="line">S01: <span class="keyword">if</span> (x) nextstate = S10;</span><br><span class="line">     <span class="keyword">else</span> nextstate = S00;</span><br><span class="line">S10: nextstate = S01;</span><br><span class="line">S11: nextstate = S01;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这段代码定义了状态机的状态转移逻辑。根据当前状态 <code>state</code> 和输入信号 <code>x</code> 的状态确定下一个状态 <code>nextstate</code>。在状态 <code>S00</code> 下，如果输入信号 <code>x</code> 为高电平，则转移到状态 <code>S11</code>，否则转移到状态 <code>S01</code>；在状态 <code>S01</code> 下，如果输入信号 <code>x</code> 为高电平，则转移到状态 <code>S10</code>，否则转移到状态 <code>S00</code>；在状态 <code>S10</code> 和 <code>S11</code> 下，无论输入信号 <code>x</code> 的状态如何，都转移到状态 <code>S01</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> q = state[<span class="number">0</span>] | state[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>这段代码将输出信号 <code>q</code> 设置为当前状态的两个位的逻辑或结果。因为状态机的状态都是两位二进制数，所以通过对两个状态位进行逻辑或操作，得到的结果表示状态机是否处于任一状态。</p>
<p>综上所述，这个模块实现了一个有限状态机（FSM），其行为受时钟信号 <code>clk</code> 和复位信号 <code>reset</code> 的控制，根据输入信号 <code>x</code> 的状态确定状态机的状态，并将状态机的当前状态的两个位的逻辑或结果作为输出信号 <code>q</code> 的值。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_43(<span class="keyword">input</span> clk, reset, a,</span><br><span class="line"> <span class="keyword">output</span> q);</span><br><span class="line"> <span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2&#125; statetype;</span><br><span class="line"> statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br><span class="line"> <span class="comment">// State Register</span></span><br><span class="line"> <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line"> <span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line"> <span class="keyword">else</span> state &lt;= nextstate;</span><br><span class="line"> <span class="comment">// Next State Logic</span></span><br><span class="line"> <span class="keyword">always_comb</span></span><br><span class="line"> <span class="keyword">case</span> (state)</span><br><span class="line"> S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S0;</span><br><span class="line"> S1: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S0;</span><br><span class="line"> S2: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line"> <span class="keyword">else</span> nextstate = S0;</span><br><span class="line"> <span class="keyword">default</span>: nextstate = S0;</span><br><span class="line"> <span class="keyword">endcase</span></span><br><span class="line"> <span class="comment">// Output Logic</span></span><br><span class="line"> <span class="keyword">assign</span> q = state[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个有限状态机（FSM），其行为受时钟信号 <code>clk</code> 和复位信号 <code>reset</code> 的控制，根据输入信号 <code>a</code> 的状态确定状态机的状态，并输出信号 <code>q</code>。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_43(<span class="keyword">input</span> clk, reset, a,</span><br><span class="line">              <span class="keyword">output</span> q);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>ex4_43</code>，它有三个输入信号：时钟 <code>clk</code>、复位信号 <code>reset</code>，以及数据信号 <code>a</code>。它有一个输出信号 <code>q</code>，用于表示状态机的输出。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">1</span>:<span class="number">0</span>] &#123;S0, S1, S2&#125; statetype;</span><br></pre></td></tr></table></figure>
<p>这里定义了一个名为 <code>statetype</code> 的枚举类型，包含了三个状态，分别用两位二进制数表示。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">statetype [<span class="number">1</span>:<span class="number">0</span>] state, nextstate;</span><br></pre></td></tr></table></figure>
<p>声明了两个状态寄存器 <code>state</code> 和 <code>nextstate</code>，它们都是 2 位 <code>statetype</code> 类型。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// State Register</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk, <span class="keyword">posedge</span> reset)</span><br><span class="line">    <span class="keyword">if</span> (reset) state &lt;= S0;</span><br><span class="line">    <span class="keyword">else</span> state &lt;= nextstate;</span><br></pre></td></tr></table></figure>
<p>这段代码表示状态寄存器的行为。在时钟信号的上升沿到来时，如果复位信号 <code>reset</code> 为高电平，则将当前状态 <code>state</code> 设置为初始状态 <code>S0</code>；否则，将当前状态更新为下一个状态 <code>nextstate</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Next State Logic</span></span><br><span class="line"><span class="keyword">always_comb</span></span><br><span class="line"><span class="keyword">case</span> (state)</span><br></pre></td></tr></table></figure>
<p>这里开始了状态转移逻辑的 <code>case</code> 分支语句。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">S0: <span class="keyword">if</span> (a) nextstate = S1;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S1: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line">S2: <span class="keyword">if</span> (a) nextstate = S2;</span><br><span class="line">    <span class="keyword">else</span> nextstate = S0;</span><br><span class="line"><span class="keyword">default</span>: nextstate = S0;</span><br><span class="line"><span class="keyword">endcase</span></span><br></pre></td></tr></table></figure>
<p>这段代码定义了状态机的状态转移逻辑。根据当前状态 <code>state</code> 和输入信号 <code>a</code> 的状态确定下一个状态 <code>nextstate</code>。在状态 <code>S0</code> 下，如果输入信号 <code>a</code> 为高电平，则转移到状态 <code>S1</code>，否则保持在状态 <code>S0</code>；在状态 <code>S1</code> 下，如果输入信号 <code>a</code> 为高电平，则转移到状态 <code>S2</code>，否则转移到状态 <code>S0</code>；在状态 <code>S2</code> 下，如果输入信号 <code>a</code> 为高电平，则保持在状态 <code>S2</code>，否则转移到状态 <code>S0</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Output Logic</span></span><br><span class="line"><span class="keyword">assign</span> q = state[<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>这段代码将输出信号 <code>q</code> 设置为当前状态的第二位（即低位），以表示状态机的状态。</p>
<p>综上所述，这个模块实现了一个有限状态机（FSM），其行为受时钟信号 <code>clk</code> 和复位信号 <code>reset</code> 的控制，根据输入信号 <code>a</code> 的状态确定状态机的状态，并将状态机的当前状态的低位作为输出信号 <code>q</code> 的值。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_44a(<span class="keyword">input</span> <span class="keyword">logic</span> clk, a, b, c, d,</span><br><span class="line"> <span class="keyword">output</span> <span class="keyword">logic</span> q);</span><br><span class="line"> <span class="keyword">logic</span> areg, breg, creg, dreg;</span><br><span class="line"> <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"> <span class="keyword">begin</span></span><br><span class="line"> areg &lt;= a;</span><br><span class="line"> breg &lt;= b;</span><br><span class="line"> creg &lt;= c;</span><br><span class="line"> dreg &lt;= d;</span><br><span class="line"> q &lt;= ((areg ^ breg) ^ creg) ^ dreg;</span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个组合逻辑电路，根据输入信号 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 的状态计算输出信号 <code>q</code>。让我逐行解释：</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ex4_44a(<span class="keyword">input</span> <span class="keyword">logic</span> clk, a, b, c, d,</span><br><span class="line">               <span class="keyword">output</span> <span class="keyword">logic</span> q);</span><br></pre></td></tr></table></figure>
<p>这个模块名为 <code>ex4_44a</code>，它有五个输入信号 <code>a</code>、<code>b</code>、<code>c</code>、<code>d</code> 和时钟信号 <code>clk</code>，以及一个输出信号 <code>q</code>。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> areg, breg, creg, dreg;</span><br></pre></td></tr></table></figure>
<p>这里声明了四个辅助信号 <code>areg</code>、<code>breg</code>、<code>creg</code> 和 <code>dreg</code>，用于在时钟信号的上升沿触发时存储输入信号的值。</p>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">    areg &lt;= a;</span><br><span class="line">    breg &lt;= b;</span><br><span class="line">    creg &lt;= c;</span><br><span class="line">    dreg &lt;= d;</span><br><span class="line">    q &lt;= ((areg ^ breg) ^ creg) ^ dreg;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>这段代码描述了时钟触发的 <code>always_ff</code> 块，表示在时钟信号 <code>clk</code> 的上升沿触发时执行以下操作：</p>
<ul>
<li>将输入信号 <code>a</code> 的值存储到 <code>areg</code> 中。</li>
<li>将输入信号 <code>b</code> 的值存储到 <code>breg</code> 中。</li>
<li>将输入信号 <code>c</code> 的值存储到 <code>creg</code> 中。</li>
<li>将输入信号 <code>d</code> 的值存储到 <code>dreg</code> 中。</li>
<li>计算输出信号 <code>q</code> 的值。这里使用了异或操作符 <code>^</code> 来计算输入信号 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 之间的异或结果，然后将这个结果再次与输入信号 <code>c</code> 异或，最后将得到的结果再次与输入信号 <code>d</code> 异或，得到最终的输出信号 <code>q</code>。</li>
</ul>
<p>综上所述，这个模块实现了一个组合逻辑电路，根据输入信号 <code>a</code>、<code>b</code>、<code>c</code> 和 <code>d</code> 的状态计算输出信号 <code>q</code>。</p>
<hr>
<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> syncbad(<span class="keyword">input</span> <span class="keyword">logic</span> clk,</span><br><span class="line"> <span class="keyword">input</span> <span class="keyword">logic</span> d,</span><br><span class="line"> <span class="keyword">output</span> <span class="keyword">logic</span> q);</span><br><span class="line"> <span class="keyword">logic</span> n1;</span><br><span class="line"> <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line"> <span class="keyword">begin</span></span><br><span class="line"> q &lt;= n1;<span class="comment">// nonblocking</span></span><br><span class="line"> n1 &lt;= d; <span class="comment">// nonblocking</span></span><br><span class="line"> <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<p>这段 Verilog 代码实现了一个模块，名为 <code>syncbad</code>，它具有一个时钟信号 <code>clk</code>、一个数据输入信号 <code>d</code> 和一个数据输出信号 <code>q</code>。</p>
<p>在这个模块中，存在一个问题导致同步错误（synchronization failure）。这是因为在时钟触发的 <code>always_ff</code> 块中，<code>q</code> 和 <code>n1</code> 都使用了非阻塞赋值（nonblocking assignment）。非阻塞赋值意味着在同一时刻对多个寄存器进行赋值，但是这些赋值在下一个时钟周期才会生效。这就导致了一个问题：在同一时刻，<code>q</code> 和 <code>n1</code> 会接收到不同的值，但由于非阻塞赋值，它们的更新并不是同时发生的，而是在下一个时钟周期。</p>
<p>具体来说，<code>q</code> 在当前时钟周期末会被赋值为 <code>n1</code> 的值，而 <code>n1</code> 在当前时钟周期末被赋值为输入信号 <code>d</code> 的值。因此，在当前时钟周期内，<code>q</code> 会保持上一个时钟周期的值，而 <code>n1</code> 则会更新为当前输入信号 <code>d</code> 的值。</p>
<p>这种情况下，<code>q</code> 的更新存在一个时钟周期的延迟，因此在时钟信号的上升沿到来时，<code>q</code> 的值可能与预期的不符，这就是同步错误。解决这个问题的一种方法是使用阻塞赋值（blocking assignment），确保在同一时刻只有一个寄存器被赋值。</p>
<hr>
<p>看懂题写程序？</p>
<p>另外一种题就是看题目画出状态机的图了。</p>
<p>这类题看程序然后读懂很好画的。</p>
<hr>
<h1 id="数字逻辑第五章"><a href="#数字逻辑第五章" class="headerlink" title="数字逻辑第五章"></a>数字逻辑第五章</h1><p>第一类题是求延迟</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20240527202049195.png" alt="image-20240527202049195"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20240527202102332.png" alt="image-20240527202102332"></p>
<p>第二类应该是浮点数</p>
<p>这个记住转换公式就行</p>
<p>第三类应该就是那个比较玄学的存储器阵列</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20240527202131879.png" alt="image-20240527202131879"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="https://www.totorocatcat.top/">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/2024/04/20/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">http://totorocatcat.top/2024/04/20/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%89%E8%B6%A3/">有趣</a></div><div class="post_share"><div class="social-share" data-image="https://npm.elemecdn.com/ushio-api-img-moe@5.0.0/img_7_2000x1102_299.719970703125_null_normal.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/04/21/%E7%89%9B%E5%AE%A2%E5%B0%8F%E7%99%BD%E6%9C%88%E8%B5%9B52/" title="牛客小白月赛52"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.36/img_361_2000x1125_96_null_normal.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">牛客小白月赛52</div></div></a></div><div class="next-post pull-right"><a href="/2024/04/20/AtCoder-Beginner-Contest-186/" title="AtCoder_Beginner_Contest_186"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.81/img_813_2400x1201_300_null_normal.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">AtCoder_Beginner_Contest_186</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/06/01/C-%E5%85%AB%E8%82%A1/" title="C++八股"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.likepoems.com/resource/pc/b702fcf4480034312d58d6f56e30d7624.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-01</div><div class="title">C++八股</div></div></a></div><div><a href="/2024/05/31/C-%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95-1/" title="C++期末考试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/%E5%9B%BE%E5%8C%85webp/%E5%8A%A8%E6%BC%AB%E7%BB%BC%E5%90%881/86815-106.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-31</div><div class="title">C++期末考试</div></div></a></div><div><a href="/2024/06/03/C-%E7%BB%83%E4%B9%A0%E9%A2%983/" title="C++练习题3"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://api.r10086.com/%E5%9B%BE%E5%8C%85webp/%E5%8A%A8%E6%BC%AB%E7%BB%BC%E5%90%881/73207-106.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-03</div><div class="title">C++练习题3</div></div></a></div><div><a href="/2024/05/31/C-%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/" title="C++期末考试"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.likepoems.com/resource/pc/68e21cc80a435c28fdf4c47e4652ebc17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-05-31</div><div class="title">C++期末考试</div></div></a></div><div><a href="/2024/06/03/C-%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%882%EF%BC%89/" title="C++练习题2"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.51/img_513_1920x1080_72_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-03</div><div class="title">C++练习题2</div></div></a></div><div><a href="/2024/06/02/C-%E9%80%89%E6%8B%A9%E9%A2%98%E5%8A%A0%E8%AE%AD/" title="C++选择题加训"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.37/img_371_3840x2160_72_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-06-02</div><div class="title">C++选择题加训</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description">热爱文学的SCUT软件学院学生</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">746</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">7</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">32</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%AC%AC%E4%B8%80%E7%AB%A0"><span class="toc-number">1.</span> <span class="toc-text">数字逻辑第一章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-1-56"><span class="toc-number">1.0.1.</span> <span class="toc-text">练习 1.56</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-1-57"><span class="toc-number">1.0.2.</span> <span class="toc-text">练习 1.57</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-1-58"><span class="toc-number">1.0.3.</span> <span class="toc-text">练习 1.58</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-1-59"><span class="toc-number">1.0.4.</span> <span class="toc-text">练习 1.59</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-1-60"><span class="toc-number">1.0.5.</span> <span class="toc-text">练习 1.60</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0-1-61"><span class="toc-number">1.0.6.</span> <span class="toc-text">练习 1.61</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%AC%AC%E4%BA%8C%E7%AB%A0"><span class="toc-number">2.</span> <span class="toc-text">数字逻辑第二章</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%AC%AC%E4%B8%89%E7%AB%A0"><span class="toc-number">3.</span> <span class="toc-text">数字逻辑第三章</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%AC%AC%E5%9B%9B%E7%AB%A0"><span class="toc-number">4.</span> <span class="toc-text">数字逻辑第四章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mux4-%E6%A8%A1%E5%9D%97%EF%BC%9A"><span class="toc-number">4.0.1.</span> <span class="toc-text">mux4 模块：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ex4-10-%E6%A8%A1%E5%9D%97%EF%BC%9A"><span class="toc-number">4.0.2.</span> <span class="toc-text">ex4_10 模块：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E7%AC%AC%E4%BA%94%E7%AB%A0"><span class="toc-number">5.</span> <span class="toc-text">数字逻辑第五章</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/11/27/XML%E7%AE%80%E4%BB%8B/" title="XML简介"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_6.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="XML简介"/></a><div class="content"><a class="title" href="/2024/11/27/XML%E7%AE%80%E4%BB%8B/" title="XML简介">XML简介</a><time datetime="2024-11-27T08:42:59.000Z" title="发表于 2024-11-27 16:42:59">2024-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/24/chat5/" title="Chapter 5 Basic Processing Unit"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/7c19b45104600b55d7e0a93de1eaff2.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 5 Basic Processing Unit"/></a><div class="content"><a class="title" href="/2024/11/24/chat5/" title="Chapter 5 Basic Processing Unit">Chapter 5 Basic Processing Unit</a><time datetime="2024-11-23T16:15:41.000Z" title="发表于 2024-11-24 00:15:41">2024-11-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/23/chat39/" title="Chapter 8 Cache(9)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4e0d02920af5e683a1aca9fd37a0596.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 8 Cache(9)"/></a><div class="content"><a class="title" href="/2024/11/23/chat39/" title="Chapter 8 Cache(9)">Chapter 8 Cache(9)</a><time datetime="2024-11-23T04:20:26.000Z" title="发表于 2024-11-23 12:20:26">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/23/chat38/" title="Chapter 8 Cache(8)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/7843e89e553c188c1b98b4e17ae922d.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 8 Cache(8)"/></a><div class="content"><a class="title" href="/2024/11/23/chat38/" title="Chapter 8 Cache(8)">Chapter 8 Cache(8)</a><time datetime="2024-11-23T04:20:09.000Z" title="发表于 2024-11-23 12:20:09">2024-11-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/11/23/chat37/" title="Chapter 8 Cache(7)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/2ef847e0b7524acf0407d9664f8d873.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Chapter 8 Cache(7)"/></a><div class="content"><a class="title" href="/2024/11/23/chat37/" title="Chapter 8 Cache(7)">Chapter 8 Cache(7)</a><time datetime="2024-11-23T04:19:49.000Z" title="发表于 2024-11-23 12:19:49">2024-11-23</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="fas fa-sms"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HT1PalaKkPaG1UqAXBhJXIu8-gzGzoHsz',
      appKey: 'iT0TnVVAwf9zuZ7NqwclQItY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="1" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="只此无为身，且前行,忘记过去的人注定重蹈覆辙,我是我，我靠自己站立，我会做好自身,如果我睡大觉，谁给我摘月亮呢,假期和朋友，是人生中顶好的两样东西啊。,去爱，去失去，要不负相遇,没什么想不想通的，只是固执而已,我们深爱星辰，乃至不惧夜的黑,吃，喝，享受幸福，接受奇迹,浊水若长流，自清澄,雅俗共赏,总会有什么也不想的幸福时刻吧,时间顺流而下，生活逆流而上,悟已往之不谏，知来者之可追,希望你的小世界里,山花烂漫,茶酒俱全,安宁清淡,明朗欢愉" data-fontsize="20px" data-random="false" async="async"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer@1.10.1/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener
  btf.removeGlobalFnEvent('pjax')
  btf.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS70の旅/&quot;);" href="javascript:void(0);">CS70の旅</a><span class="categoryBar-list-count">25</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS61B/&quot;);" href="javascript:void(0);">CS61B</a><span class="categoryBar-list-count">76</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/期末の旅/&quot;);" href="javascript:void(0);">期末の旅</a><span class="categoryBar-list-count">61</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/ACMの旅/&quot;);" href="javascript:void(0);">ACMの旅</a><span class="categoryBar-list-count">68</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/区域赛の旅/&quot;);" href="javascript:void(0);">区域赛の旅</a><span class="categoryBar-list-count">7</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数学建模/&quot;);" href="javascript:void(0);">数学建模</a><span class="categoryBar-list-count">31</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Codeforcesの旅/&quot;);" href="javascript:void(0);">Codeforcesの旅</a><span class="categoryBar-list-count">24</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/刷题计划/&quot;);" href="javascript:void(0);">刷题计划</a><span class="categoryBar-list-count">40</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/牛客の旅/&quot;);" href="javascript:void(0);">牛客の旅</a><span class="categoryBar-list-count">65</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/前端の旅/&quot;);" href="javascript:void(0);">前端の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/数据结构/&quot;);" href="javascript:void(0);">数据结构</a><span class="categoryBar-list-count">47</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_24.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/Atcoderの旅/&quot;);" href="javascript:void(0);">Atcoderの旅</a><span class="categoryBar-list-count">53</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_25.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-の旅/&quot;);" href="javascript:void(0);">C++の旅</a><span class="categoryBar-list-count">17</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_26.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CSAPPの旅/&quot;);" href="javascript:void(0);">CSAPPの旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_27.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS知识/&quot;);" href="javascript:void(0);">CS知识</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_28.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/编程基础/&quot;);" href="javascript:void(0);">编程基础</a><span class="categoryBar-list-count">22</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_29.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/离散数学/&quot;);" href="javascript:void(0);">离散数学</a><span class="categoryBar-list-count">28</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_30.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/JAVAの旅/&quot;);" href="javascript:void(0);">JAVAの旅</a><span class="categoryBar-list-count">10</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_31.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/MIT-6-031-Software-Construction/&quot;);" href="javascript:void(0);">MIT 6.031:Software Construction</a><span class="categoryBar-list-count">16</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_32.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/CS-110L/&quot;);" href="javascript:void(0);">CS 110L</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_33.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/灵魂の旅/&quot;);" href="javascript:void(0);">灵魂の旅</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_34.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/个人安排/&quot;);" href="javascript:void(0);">个人安排</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_35.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/杂项/&quot;);" href="javascript:void(0);">杂项</a><span class="categoryBar-list-count">12</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_36.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/计算机组成原理/&quot;);" href="javascript:void(0);">计算机组成原理</a><span class="categoryBar-list-count">30</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_37.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/文学/&quot;);" href="javascript:void(0);">文学</a><span class="categoryBar-list-count">49</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_38.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/力扣の旅/&quot;);" href="javascript:void(0);">力扣の旅</a><span class="categoryBar-list-count">20</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_39.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/千里十二行/&quot;);" href="javascript:void(0);">千里十二行</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_40.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/🗡指offer/&quot;);" href="javascript:void(0);">🗡指offer</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_41.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/少年游/&quot;);" href="javascript:void(0);">少年游</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_42.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/算法提高课/&quot;);" href="javascript:void(0);">算法提高课</a><span class="categoryBar-list-count">3</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_43.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/汇编の旅/&quot;);" href="javascript:void(0);">汇编の旅</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_44.webp);"> <a class="categoryBar-list-link" onclick="pjax.loadUrl(&quot;categories/C-实训/&quot;);" href="javascript:void(0);">C++实训</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/4b31456c6f0f4489f99177f89e936de7286431045.png@1256w_708h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt="">诗录</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/01/诗录/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/01/29/诗兴大发/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/4512abc/Pictures@main/Pictures/51d37eba99d243607ddedfff6e91568f617436609.jpg@1256w_1884h_!web-article-pic.avif" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-10-05</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">TotoroのPlan</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/10/05/TotoroのPlan/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.48/img_482_1920x1080_96_null_normal.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-03-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt="">Markdown格式</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;2024/03/03/Markdown格式/&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>