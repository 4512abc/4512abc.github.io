<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>数据结构与算法(总) | Totoroの旅</title><meta name="author" content="Totoro"><meta name="copyright" content="Totoro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="方便大二看（）">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法(总)">
<meta property="og:url" content="http://totorocatcat.top/2024/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-1/index.html">
<meta property="og:site_name" content="Totoroの旅">
<meta property="og:description" content="方便大二看（）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.64/img_649_702x1000_300_null_normal.jpg">
<meta property="article:published_time" content="2024-02-13T12:28:38.000Z">
<meta property="article:modified_time" content="2024-03-20T15:07:27.706Z">
<meta property="article:author" content="Totoro">
<meta property="article:tag" content="提高">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://npm.elemecdn.com/ushio-api-img-moe@5.0.64/img_649_702x1000_300_null_normal.jpg"><link rel="shortcut icon" href="https://source.fomal.cc/img/default_cover_227.webp"><link rel="canonical" href="http://totorocatcat.top/2024/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-1/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体中文","cht_to_chs":"你已切换为简体中文","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"top-right"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构与算法(总)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-03-20 23:07:27'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><link rel="stylesheet" href="/css/custom.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="/css/universe.css"><link rel="stylesheet" href="/css/scrollbar.css"><link rel="stylesheet" href="/css/cat.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-categories-card@1.0.0/lib/categorybar.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">328</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://npm.elemecdn.com/ushio-api-img-moe@5.0.64/img_649_702x1000_300_null_normal.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Totoroの旅"><span class="site-name">Totoroの旅</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group hide" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/comments/"><i class="fa-fw fas fa-envelope-open"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 趣味</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构与算法(总)<a class="post-edit-link" href="null_posts/数据结构与算法-1.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-02-13T12:28:38.000Z" title="发表于 2024-02-13 20:28:38">2024-02-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-03-20T15:07:27.706Z" title="更新于 2024-03-20 23:07:27">2024-03-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">38.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>144分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构与算法(总)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=1319520140&auto=1&height=66"></iframe>

<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote>
<p>各位新年快乐，祝你也祝我新年依然保持一份温柔—-世间温柔，不过是芳春柳摇染花香，槐序蝉鸣入深巷，白茂叶落醉故乡。</p>
</blockquote>
<h1 id="背景与前置知识"><a href="#背景与前置知识" class="headerlink" title="背景与前置知识"></a>背景与前置知识</h1><blockquote>
<p>随着应用程序变得越来越复杂和数据越来越丰富，几百万、几十亿甚至几百亿的数据就会出现，而对这么大对数据进行搜索、插入或者排序等的操作就越来越慢，数据结构就是用来解决这些问题的。</p>
</blockquote>
<p>总而言之</p>
<blockquote>
<p>数据结构指的是“一组数据的存储结构”，算法指的是“操作数据的一组方法”。<br>数据结构是为算法服务的，算法是要作用再特定的数据结构上的。</p>
</blockquote>
<p>需要学习</p>
<blockquote>
<p>这里面有10个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。</p>
<p>数据结构三要素：逻辑结构、存储结构、数据的运算；其中逻辑结构包括线性结构（线性表、栈、队列）和非线性结构（树、图、集合）</p>
<p>数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构。</p>
<p>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合。</p>
<p>数据元素是数据的基本单位，可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位，<br>数据对象是具有相同性质的数据元素的集合，是数据的一个子集</p>
<p>数据类型是一个值的集合和定义在此集合上的一组操作的总称</p>
<p>数据类型包括：原子类型、结构类型、抽象数据类型</p>
<p>1）原子类型。其值不可再分的数据类型。<br>2）结构类型。其值可以再分解为若干成分（分量）的数据类型。</p>
<p>3）抽象数据类型。抽象数据组织及与之相关的操作。</p>
<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合，它包括逻辑结构、存储结构和数据运算三方面内容</p>
<p>（1）集合结构</p>
<p>数据元素之间除了“属于同一集合”的关系外，别无其他关系。例如，确定一名学生是否为班级成员，只需将班级看做一个集合结构。</p>
<p>（2）线性结构</p>
<p>数据元素之间存在一对一的关系。例如，将学生信息数据按照其入学报到的时间先后顺序进行排列，将组成一个线性结构。</p>
<p>（3）树结构</p>
<p>数据元素之间存在一对多的关系。例如，在班级的管理体系中，班长管理多个组长，每位组长管理多名组员，从而构成树形结构。</p>
<p>（4）图结构或网状结构</p>
<p>数据元素之间存在多对多的关系。例如，多位同学之间的朋友关系，任何两位同学都可以是朋友，从而构成图形结构或网状结构。</p>
<p>数据的逻辑结构和存储结构是密不可分的，算法的设计取决于所选定的逻辑结构，而算法的实现依赖于采用的存储结构</p>
<h2 id="数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储"><a href="#数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储" class="headerlink" title="数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储"></a>数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储</h2><blockquote>
<p>顺序存储：把逻辑上相邻的数据元素存储在物理位置也相邻的存储单元里，元素之间的关系由存储单元之间的位置关系，即相邻关系来体现。如顺序表。<br>优点：容易实现随机存取，每个元素占用最少的存储空间。<br>缺点：只能使用相邻的一整块存储空间，容易产生较多的外部内存碎片。<br>链式存储：使用表示元素存储地址的指针来表示元素之间的逻辑关系，此时不要求逻辑上相邻的数据元素在物理位置上也相邻。如单链表。<br>优点：不会出现碎片内存，能充分利用存储单元。<br>缺点：每个元素由于存储指针而占用额外的存储空间，且只能通过遍历实现顺序存取。<br>索引存储：在存储数据元素的同时，建立一个附加的索引表。索引表中的每一项称为索引项项，其形式通常为（关键字，地址）。<br>优点：检索速度快。<br>缺点：附加的索引表会占用额外的存储空间。在添加或者删除数据元素时，需要同步修改索引表，因此会花费额外的时间。<br>散列存储：根据元素的关键字以某种方式计算出该元素的存储地址，又称为 hash 存储。如哈希表。<br>优点：检索、添加、删除的操作速度都很快。<br>如果散列函数（或者 hash 函数）设计不好的话，可能会出现 hash 冲突，解决冲突又会增加时间和空间开销。</p>
</blockquote>
<p>施加在数据上的运算包括运算的定义和实现。运算的定义是针对逻辑结构的，指出运算的功能；运算的实现是针对存储结构的，指出运算的具体操作步骤</p>
<p>在存储数据时，通常不仅要存储各数据元素的值，而且要存储数据元素之间的关系</p>
<p>对于两种不同的数据结构，逻辑结构或物理结构一定不同吗？</p>
<p>数据运算也是数据结构的一个重要方面。对于两种不同的数据结构，他们的逻辑结构和物理结构完全有可能相同（比如二叉树和二叉排序树）</p>
<p>链式存储设计时，各个不同结点的存储空间可以不连续，但结点内的存储单元地址必须连续</p>
<p>算法是对特定问题求解步骤的一种描述，它是指令的有限序列，其中每条指令包括一个或多个操作。</p>
<p>算法的五个特性：有穷性、确定性、可行性、输入、输出（字面意思，第一遍看的话建议看看书具体概念）</p>
<p>通常设计一个好的算法应考虑：正确性、可读性、健壮性、效率与低存储量需求</p>
<p>算法的时间复杂度不仅依赖于问题的规模n，也取决于待输入数据的性质</p>
<p>若输入数据所占空间只取决于问题本身而和算法无关，则只需分析除输入和程序之外的额外空间</p>
<p>算法原地工作是指算法所需辅助空间为常量，即O(1)</p>
<p>一个算法应该是问题求解步骤的描述</p>
<p>所谓时间复杂度，是指最坏情况下估算算法执行时间的一个上界</p>
<p>同一个算法，实现语言的级别越高，执行效率越低</p>
</blockquote>
<h1 id="时间复杂度与空间复杂度"><a href="#时间复杂度与空间复杂度" class="headerlink" title="时间复杂度与空间复杂度"></a>时间复杂度与空间复杂度</h1><h2 id="算法效率"><a href="#算法效率" class="headerlink" title="算法效率"></a>算法效率</h2><p>算法效率分析分为两种：第一种是<strong>时间效率</strong>，第二种是<strong>空间效率</strong>。时间效率被称为<strong>时间复杂度</strong>，而空间效率被称作<strong>空间复杂度</strong>。</p>
<p>时间复杂度主要衡量的是一个算法的<strong>运行速度</strong>，而空间复杂度主要衡量一个算法所<strong>需要的额外空间</strong>。</p>
<h2 id="大O的表示法规则"><a href="#大O的表示法规则" class="headerlink" title="大O的表示法规则"></a>大O的表示法规则</h2><p>时间复杂度和空间复杂度一般都使用大O的渐进表示法进行表示，大O的渐进表示法规则如下：</p>
<p><strong>1、所有常数都用常数1表示。<br>2、只保留最高阶项。<br>3、如果最高阶项存在且不是1，则去除与这个项的系数，得到的结果就是大O阶。</strong></p>
<p>常见的时间复杂度量级有：</p>
<ul>
<li>常数阶O(1)</li>
<li>对数阶O(logN)</li>
<li>线性阶O(n)</li>
<li>线性对数阶O(nlogN)</li>
<li>平方阶O(n²)</li>
<li>立方阶O(n³)</li>
<li>K次方阶O(n^k)</li>
<li>指数阶(2^n)</li>
</ul>
<blockquote>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h4 id="事后统计法"><a href="#事后统计法" class="headerlink" title="事后统计法"></a>事后统计法</h4><p>T(n) = O( f(n) )</p>
<p>这种方法可行，但不是一个好的方法。该方法有两个缺陷：一是要想对设计的算法的运行性能进行评测，必须先依据算法编制相应的程序并实际运行；二是所得时间的统计量依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优势。</p>
<p>事前分析估算的方法<br>因事后统计方法更多的依赖于计算机的硬件、软件等环境因素，有时容易掩盖算法本身的优劣。因此人们常常采用事前分析估算的方法。<br>在编写程序前，依据统计方法对算法进行估算。一个程序在计算机上运行时所消耗的时间取决于下列因素：<br>(1) 算法采用的策略、方法；(2).编译产生的代码质量；(3) 问题的输入规模；(4)机器执行指令的速度。</p>
</blockquote>
<p>常数阶</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br></pre></td></tr></table></figure>
<p>线性阶</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">   j = i;</span><br><span class="line">   j++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对数阶</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i&lt;n)</span><br><span class="line">&#123;</span><br><span class="line">    i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>线性对数阶</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(m=<span class="number">1</span>; m&lt;n; m++)</span><br><span class="line">&#123;</span><br><span class="line">    i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n)</span><br><span class="line">    &#123;</span><br><span class="line">        i = i * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>平方阶</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for(x=1; i&lt;=n; x++)</span><br><span class="line">&#123;</span><br><span class="line">   for(i=1; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一种O（m*n)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=<span class="number">1</span>; i&lt;=m; x++)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">       j = i;</span><br><span class="line">       j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其余以此类推</p>
<p>空间复杂度</p>
<p>O(1)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">2</span>;</span><br><span class="line">++i;</span><br><span class="line">j++;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>O(n)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] m = <span class="keyword">new</span> <span class="type">int</span>[n]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ACM时间复杂度"><a href="#ACM时间复杂度" class="headerlink" title="ACM时间复杂度"></a>ACM时间复杂度</h2><blockquote>
<p>O(1) &lt; O ( l o g n )  &lt; O ( n ) &lt; O ( n l o g n )  &lt; O ( n 2 ) &lt; O ( n 3 ) &lt;O(2^n)&lt; O ( n ! )</p>
<p>n&lt;200, 可以选择复杂度为O ( n 3 )的算法。例：dp，floyd<br>n &lt; 5000，可以选择复杂度为O(n^2)的算法。例：dp，Dijkstra,朴素版Prim<br>n &lt; 1 e 6 ,可以选择复杂度为O ( n l o g n ) 或(O(n^2logn)的算法。例：sort，线段树，树状数组，set，map，spfa，凸包，二分<br>n &lt; 1 e 7 ，可以选择复杂度为O ( n ) 的算法。例：哈希，双指针，kmp，AC自动机。部分sort，树状数组，spfa<br>n &lt; 1 e 8 ，可以选择复杂度为O ( n )的算法。例：双指针，kmp，AC自动机，线性筛<br>n &lt; 1 e 9，可以选择复杂度为 O(sqrt(n))的算法。例：判断质数<br>n &lt; 1 e 18 ，可以选择复杂度为O ( l o g n ) 的算法。例：二分，欧几里得算法，幂运算</p>
</blockquote>
<h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><h2 id="一、线性表的定义"><a href="#一、线性表的定义" class="headerlink" title="一、线性表的定义"></a>一、线性表的定义</h2><p>线性表（List）：零个或多个数据元素的有限序列。</p>
<blockquote>
<p>元素数据类型相同，可以是整型也可以是结构体。</p>
<p>有限一词的解释</p>
<ul>
<li><h3 id="有限："><a href="#有限：" class="headerlink" title="有限："></a><strong>有限</strong>：</h3><p>表中的数据元素个数为<strong>n</strong>（也叫做<strong>线性表的长度</strong>，n&gt;=0），是有限个元素。当线性表长度n=0时，此时线性表是一个空表。</p>
</li>
<li><h3 id="序列"><a href="#序列" class="headerlink" title="序列"></a>序列</h3><p>一列，一对一</p>
</li>
</ul>
</blockquote>
<p>线性表的数据集合为{a1,a2,…,an}，假设每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</p>
<blockquote>
<p>除第一个元素外，每个元素有且仅有一个直接前驱。除最后一个元素外，每个元素有且只有一个直接后继。</p>
<p>a1是唯一的“第一个”元素，又称<strong>表头元素</strong>；an是唯一的“最后一个元素”，又称<strong>表尾元素。</strong></p>
<p>在较复杂的线性表中，一个数据元素可以由若干个数据项组成。在这种情况下，常把数据元素称为记录，含有大量记录的线性表又称为文件</p>
<p>注意：线性表是一种逻辑结构，表示元素之间一对一的相邻关系。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ul>
<li>线性表的置空操作clear()：将一个已经存在的线性表置为空表；</li>
<li>线性表判空操作isEmpty()：判断线性表是否为空，若为空，则返回true；否则，返回为false；</li>
<li>求线性表的长度操作length()：求线性表中的数据元素的个数并返回其值；</li>
<li>取元素操作get(i)：读取并返回线性表中的第i个数据元素的值。其中i的取值范围为0≤i≤length()-1；</li>
<li>插入操作insert(i,x)：在线性表的第i个数据元素之前插入一个值为x的数据元素。其中i的取值范围为0≤i≤length()。当i=0时，在表头插入x；当i=length()时，在表尾插入x；</li>
<li>删除操作remove(i)：删除并返回线性表中第i个数据元素。其中i的取值范围为0≤i≤length()-1；</li>
<li>查找操作indexOf(x)：返回线性表中首次出现的指定的数据元素的位序号，若线性表中不包含此数据元素，则返回-1；</li>
</ul>
</blockquote>
<h2 id="二、线性表的存储结构"><a href="#二、线性表的存储结构" class="headerlink" title="二、线性表的存储结构"></a>二、线性表的存储结构</h2><h3 id="线性表的顺序表示和实现"><a href="#线性表的顺序表示和实现" class="headerlink" title="线性表的顺序表示和实现"></a>线性表的顺序表示和实现</h3><blockquote>
<p>顺序存储是用一组地址连续的存储单元依次存放线性表中各个元素的存储结构。</p>
<p>顺序表的特点就是逻辑顺序与物理顺序相同</p>
<ul>
<li>在线性表中逻辑上相邻的数据元素，在物理存储上也是相邻的；</li>
<li>存储密度高，但要预先分配“足够应用”的存储空间，这可能会造成存储空间的浪费；</li>
<li>便于随机存储；</li>
<li>不便于插入和删除操作，这是因为在顺序表上进行的插入和删除操作会引起大量数据元素的移动；</li>
</ul>
</blockquote>
<h2 id="代码实现步骤"><a href="#代码实现步骤" class="headerlink" title="代码实现步骤"></a>代码实现步骤</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//头文件部分</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//变量空间</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100                  <span class="comment">//最大值</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;                <span class="comment">//元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType* elem;                  <span class="comment">//存储空间动态申请</span></span><br><span class="line">	<span class="type">int</span> length;                      <span class="comment">//顺序表的长度</span></span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; Ok, Error &#125;;               <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个空表，并将length置零，初始化存储容量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">InitSeqList</span><span class="params">(SeqList&amp; L)</span></span></span><br><span class="line"><span class="function"><span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	L.elem = <span class="keyword">new</span> ElemType[MAXSIZE];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!L.elem)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;申请空间失败！&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">插入操作</span></span><br><span class="line"><span class="comment">在顺序表L的第i（1≤i≤L.length+1）个位置插入新元素e。如果 i 的输入不合法，则返回false，表示插入失败；否则，将顺序表的第 i 个元素以及其后的所有元素右移一个位置，腾出一个空位置插入新元素e，顺序表长度增加1，插入成功，返回true。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">算法思路：</span></span><br><span class="line"><span class="comment">1.判断 i 的值是否正确</span></span><br><span class="line"><span class="comment">2.判断表长是否超过数组长度</span></span><br><span class="line"><span class="comment">3.从后向前到第 i 个位置，分别将这些元素都向后移动一位</span></span><br><span class="line"><span class="comment">4.将该元素插入位置 i 并修改表长</span></span><br><span class="line"><span class="comment">线性表插入算法的平均时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">SeqListInsert</span><span class="params">(SeqList&amp; L, <span class="type">int</span> i, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((i &lt; <span class="number">1</span>) || (i &gt; L.length + <span class="number">1</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;i位置不合法&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (L.length == MAXSIZE)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;顺序表已满&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = L.length<span class="number">-1</span>; j &gt;= i<span class="number">-1</span>; j--) &#123;</span><br><span class="line">		L.elem[j + <span class="number">1</span>] = L.elem[j];</span><br><span class="line">	&#125;</span><br><span class="line">	L.elem[i<span class="number">-1</span>] = e;</span><br><span class="line">	L.length++;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除操作</span></span><br><span class="line"><span class="comment">删除顺序表L中第i（1≤i≤L.length）个位置的元素，成功则返回true，并将被删除的元素用引用变量e返回，否则返回false。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">算法思路：</span></span><br><span class="line"><span class="comment">1.判断 i 的值是否正确</span></span><br><span class="line"><span class="comment">2.取删除的元素</span></span><br><span class="line"><span class="comment">3.将被删元素后面的所有元素都依次向前移动一位</span></span><br><span class="line"><span class="comment">4.修改表长</span></span><br><span class="line"><span class="comment">线性表删除算法的平均时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">SeqListDelete</span><span class="params">(SeqList&amp; L, <span class="type">int</span> i)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;i位置不合法&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//i后的元素向前移动一位</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; L.length; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		L.elem[j - <span class="number">1</span>] = L.elem[j];</span><br><span class="line">	&#125;</span><br><span class="line">	L.length--;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历顺序表</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">TraverseSeqList</span><span class="params">(SeqList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;顺序表为空！&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; L.elem[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空线性表中数据</span></span><br><span class="line"><span class="function">Status <span class="title">ClearList</span><span class="params">(SeqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;线性表为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; L.length; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		L.elem[j] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	L.length = <span class="number">0</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;线性表已经数据已清空&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//销毁线性表</span></span><br><span class="line"><span class="function">Status <span class="title">DestroySeqList</span><span class="params">(SeqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!L.elem)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;线性表不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">free</span>(L.elem);</span><br><span class="line">	L.elem = <span class="literal">NULL</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;顺序表成功销毁&quot;</span> &lt;&lt; endl;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线性表是否为空</span></span><br><span class="line"><span class="function">Status <span class="title">ListEmpty</span><span class="params">(SeqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Ok;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Error;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线性表的长度</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength</span><span class="params">(SeqList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> L.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回e在线性表中的位置</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查询某个值在顺序表中是否存在，存在时，其位置是多少，其实就是将顺序表从第一个元素开始依次和这个值相比较。最多比较length次，最少比较一次。（表非空的情况下）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LocateElem</span><span class="params">(SeqList&amp; L, ElemType&amp; e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> currentIndex = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">if</span> (L.length == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;当前线性表为空&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> currentIndex;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; L.length; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (L.elem[i] == e)</span><br><span class="line">		&#123;</span><br><span class="line">			currentIndex = i + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (currentIndex == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;数据  &quot;</span> &lt;&lt; e &lt;&lt; <span class="string">&quot;  不存在当前线性表中&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> currentIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">PriorElem</span><span class="params">(SeqList&amp; L, ElemType cur_e, ElemType&amp; pre_e)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//查找cur_e所在的位置</span></span><br><span class="line">	<span class="type">int</span> flag = <span class="built_in">LocateElem</span>(L, cur_e);</span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;该数据不存在直接前驱&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		pre_e = L.elem[flag - <span class="number">2</span>];</span><br><span class="line">		<span class="keyword">return</span> Ok;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果cur_e不是最后一个的值，就next_e返回cur_e后一个值</span></span><br><span class="line"><span class="function">Status <span class="title">NextElem</span><span class="params">(SeqList&amp; L, ElemType cur_e, ElemType&amp; next_e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> flag = <span class="built_in">LocateElem</span>(L, cur_e);</span><br><span class="line">	<span class="keyword">if</span> (flag == <span class="number">-1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (flag == L.length)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;该数据不存在直接后继&quot;</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		next_e = L.elem[flag];</span><br><span class="line">		<span class="keyword">return</span> Ok;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线性表的链式存储和实现"><a href="#线性表的链式存储和实现" class="headerlink" title="线性表的链式存储和实现"></a>线性表的链式存储和实现</h2><p><strong>一、定义</strong></p>
<p>链表属于一种离散的存储方式，离散是与连续相对的，数组是常见的连续存储方式。</p>
<p>线性的链式存储结构（链表）是指用任意的存储单元来依次存放线性表的结点，<strong>这组单元既可以是连续的，也可以是不连续的，甚至是零散的分布在内存中的任意位置上。</strong>因此，链表中的结点的逻辑次序和物理次序不一定相同。为了正确表示结点间的逻辑结构，在存储每个结点值的同时，还必须存储指示其后继结点的地址（或位置）信息，这两部分组成了链表中的结点结构（如图）。</p>
<p>链式存储的结构包含两个域：一个用于存储数据元素的信息，另一个用于存储直接后继的存储位置；<strong>存储数据元素信息的域称为数据域</strong>，<strong>存储直接后继存储位置的域称为指针域</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/v2-6f53b0cb799d8142cba20b2babf771c2_720w.png" alt="img"></p>
<p>其中，data是数据域，用来存放结点的值。Next是指针域（也称链域），用来存放后继结点的地址。链表正是通过每个结点的链域将线性表的n个结点按其逻辑次序连接在一起的。结点有一个链域的称为单链表</p>
<p>整个单链表的存取必须从头结点开始进行，头指针指向head指向第一个结点。同时，由最后一个结点无后继，故其指针域为空，即NULL。</p>
<blockquote>
<p>数据结构中，在单链表的开始结点之前一般要附设一个类型相同的结点，称之为<strong>头结点</strong>。<strong><em>头结点的数据域可以不存储任何信息，头结点的指针域存储指向开始结点的指针</em></strong>，即第一个元素结点的存储位置。</p>
<p>头结点的好处：</p>
<ol>
<li>便于首元结点的处理</li>
</ol>
<p>首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理;</p>
<p>   2.便于空表和非空表的统一处理</p>
<p>无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。</p>
<p>在单链表中，任何两个元素的存储位置之间没有固定的联系，每个元素的存储位置都包含在其直接前驱结点的信息中。因此，单链表，在单链表中，想要取得第i个数据元素，必须从头指针出发寻找。所以，单链表是非随机存取的存储结构。</p>
</blockquote>
<h2 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 100                  <span class="comment">//最大值</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;                <span class="comment">//元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LNode</span> &#123;</span><br><span class="line">	ElemType  data;               <span class="comment">//数据域 </span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LNode</span>* next;          <span class="comment">//指针域,指向一整个结点(结构体,该结构体中包含数据域和指针域) </span></span><br><span class="line">&#125;LNode, * LinkList;</span><br><span class="line"></span><br><span class="line"><span class="comment">//为了方便，可以利用typedef 给某种数据类型起个别名；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; Ok, Error &#125;;               <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造一个空的头结点</span></span><br><span class="line"><span class="function">Status <span class="title">InitList_L</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">	L = <span class="keyword">new</span> LNode;      <span class="comment">//产生头结点，并使L指向该头结点(L也称头指针)</span></span><br><span class="line">	<span class="keyword">if</span> (!L)  <span class="keyword">return</span> Error;          <span class="comment">//如果存储空间分配失败，返回ERROR</span></span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;                <span class="comment">//将指针域赋值为NULL</span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;空的头结点创建成功/n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对线性表进行赋值 </span></span><br><span class="line"><span class="function">Status <span class="title">ValueList_L</span><span class="params">(LinkList&amp; L, ElemType e)</span> </span>&#123;</span><br><span class="line">	LinkList s, p;</span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">	&#125;</span><br><span class="line">	s = <span class="keyword">new</span> LNode;       <span class="comment">//生成一个新结点 </span></span><br><span class="line">	s-&gt;data = e;                 <span class="comment">//将e赋值给新结点的数据域 </span></span><br><span class="line">	s-&gt;next = p-&gt;next;           <span class="comment">//将新结点与后一个结点的地址连接</span></span><br><span class="line">	p-&gt;next = s;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对线性表进行销毁</span></span><br><span class="line"><span class="comment">//注意是销毁，头节点要删除</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在对单链表进行销毁操作时，从头结点开始逐一释放，释放前使q指向开始释放的结点，当开始结点不为空时，执行释放过程，先释放头结点，然后将L，q都向后移，依次释放，因为q始终是L的后继，所以最后一定是L留到最后，最后释放L结点</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">为什么在delete L;之后还要将L赋值为空？</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">因为delete函数只是将之前动态分配给L的内存归还给系统，但是指针类型的结点L仍然存在，为了防止之后发生野指针访问，将L赋值为NULL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">Status <span class="title">DistoryList_L</span><span class="params">(LinkList&amp; L)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!L) &#123;            <span class="comment">//如果线性表不存在，返回ERROR </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;线性表不存在/n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkList q = L-&gt;next;    <span class="comment">//使q指向单链表的首元结点  </span></span><br><span class="line">	<span class="keyword">while</span> (q != <span class="literal">NULL</span>) &#123;     <span class="comment">//当q结点不为空时一直进入循环 </span></span><br><span class="line">		<span class="keyword">delete</span> L;          <span class="comment">//释放L结点 </span></span><br><span class="line">		L = q;            <span class="comment">//将q结点赋值给L结点 </span></span><br><span class="line">		q = L-&gt;next;      <span class="comment">//将q结点赋值给L结点以后使q结点指向L的下一个结点 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> L;    <span class="comment">//此时q的值为NULL，L指向尾结点，将其释放</span></span><br><span class="line">	L = <span class="literal">NULL</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;线性表已销毁/n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//对线性表进行重置</span></span><br><span class="line"><span class="comment">//重置则是不销毁头结点</span></span><br><span class="line"><span class="function">Status <span class="title">ClearList_L</span><span class="params">(LinkList&amp; L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!L-&gt;next) &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;线性表为空表，不需要重置/n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkList p, q;</span><br><span class="line">	p = L-&gt;next;          <span class="comment">//将单链表的头结点赋值给p</span></span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		q = p-&gt;next;      <span class="comment">//将单链表的首元结点赋值给q</span></span><br><span class="line">		<span class="keyword">delete</span> p;</span><br><span class="line">		p = q;</span><br><span class="line">	&#125;</span><br><span class="line">	L-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//将头结点的指针域赋值为空 </span></span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;线性表已重置/n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断线性表是否为空</span></span><br><span class="line"><span class="function">Status <span class="title">ListEmpty_L</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (L) &#123;</span><br><span class="line">		<span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)       <span class="comment">//如果首元结点不存在 </span></span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;线性表是空表/n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			cout&lt;&lt;<span class="string">&quot;线性表不是空表/n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;线性表不存在，无法判断/n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线性表的长度</span></span><br><span class="line"><span class="comment">//获取线性表长度的核心思路是遍历单链表</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListLength_L</span><span class="params">(LinkList L, <span class="type">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//L为带头结点的单链表的头指针，count为计数器</span></span><br><span class="line">	LinkList p = L-&gt;next;    <span class="comment">//定义p为单链表L的指针域 </span></span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取线性表某一位置对应的元素/</span></span><br><span class="line"><span class="comment">//与获取单链表的长度思路一样，获取单链表某一位置的元素也需要遍历单链表，只不过什么时候停止遍历由自己决定，可能不需要全部遍历。</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem_L</span><span class="params">(LinkList L, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p;</span><br><span class="line">	p = L-&gt;next;       <span class="comment">//使p指向L的首元结点</span></span><br><span class="line">	<span class="type">int</span>  count = <span class="number">1</span>;    <span class="comment">//count为计数器 ，赋值等于1的原因是从首元结点开始计数 </span></span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; count &lt; index) &#123;    <span class="comment">//顺着指针向后查找，直到p指向第index个元素或p为空 </span></span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		count++;        <span class="comment">//此时p一直指向第count个元素 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!p || count &gt; index) &#123;</span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;当前位置没有元素/n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;第&quot;</span>&lt;&lt;index&lt;&lt;<span class="string">&quot;个元素的值是：&quot;</span>&lt;&lt; p-&gt;data&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在线性表某一位置插入元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListInsert_L</span><span class="params">(LinkList&amp; L, <span class="type">int</span> index, ElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p, q;</span><br><span class="line">	p = L;      <span class="comment">//将线性表的头结点赋值给p</span></span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;    <span class="comment">//count为计数器 </span></span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; count &lt; index - <span class="number">1</span>) &#123;      <span class="comment">//寻找第index-1个结点 </span></span><br><span class="line">		p = p-&gt;next;         <span class="comment">//此时的p结点指向第index-1个结点 </span></span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!p || count &gt; index - <span class="number">1</span>) &#123;        <span class="comment">//越界判断,index小于1或是index大于表长加1 </span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;当前结点无法插入元素/n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	q = <span class="keyword">new</span> LNode;</span><br><span class="line">	q-&gt;data = e;            <span class="comment">//将e赋值到q的数据域当中</span></span><br><span class="line">	q-&gt;next = p-&gt;next;</span><br><span class="line">	p-&gt;next = q;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;元素插入成功/n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除线性表某一位置的元素</span></span><br><span class="line"><span class="function">Status <span class="title">DeleteList_L</span><span class="params">(LinkList&amp; L, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p, q;</span><br><span class="line">	p = L;           <span class="comment">//将线性表的头结点赋值给p</span></span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;   <span class="comment">//计数器</span></span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next &amp;&amp; count &lt; index - <span class="number">1</span>) &#123;</span><br><span class="line">		p = p-&gt;next;</span><br><span class="line">		count++;            <span class="comment">//此时p一直指向第count个结点 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(p-&gt;next) || count &gt; index - <span class="number">1</span>) &#123;     <span class="comment">//越界判断 </span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;当前位置无法删除元素/n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	q = p-&gt;next;</span><br><span class="line">	p-&gt;next = q-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> q;</span><br><span class="line">	q = <span class="literal">NULL</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;当前位置元素已删除/n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//求线性表某一元素的前驱 </span></span><br><span class="line"><span class="function">Status <span class="title">PriorElem_L</span><span class="params">(LinkList L, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;       <span class="comment">//count为计数器 </span></span><br><span class="line">	p = L;</span><br><span class="line">	<span class="keyword">while</span> (p-&gt;next &amp;&amp; count &lt; index - <span class="number">1</span>) &#123;       <span class="comment">//寻找第index-1个结点 </span></span><br><span class="line">		p = p-&gt;next;            <span class="comment">//p一直指向第count个结点 </span></span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(p-&gt;next) || count &gt; index - <span class="number">1</span>) &#123;       <span class="comment">//越界判断 </span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;当前位置无法求该元素的前驱/n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (p != L)            <span class="comment">//如果要获取第一个元素的前驱，就是获取头结点数据域的值 </span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;该元素的前驱为：&quot;</span>&lt;&lt;p-&gt;data&lt;&lt;<span class="string">&quot;/n&quot;</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;该位置的前驱是头结点/n头结点的数据域中存储的值为&quot;</span>&lt;&lt; p-&gt;data&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//求线性表某一元素的后继 </span></span><br><span class="line"><span class="function">Status <span class="title">NextElem_L</span><span class="params">(LinkList L, <span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LinkList p;</span><br><span class="line">	<span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">	p = L-&gt;next;</span><br><span class="line">	<span class="keyword">while</span> (p &amp;&amp; count &lt; index) &#123;        <span class="comment">//不断遍历寻找第index之后的结点 </span></span><br><span class="line">		p = p-&gt;next;      <span class="comment">//p一直指向index-1的后一个结点 </span></span><br><span class="line">		count++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//!p的目的是为了确保i不大于表长-1，count&gt;index的目的是为了确保index不小于0 </span></span><br><span class="line">	<span class="keyword">if</span> (!p || count &gt; index) &#123;          <span class="comment">//越界判断</span></span><br><span class="line">		cout&lt;&lt;<span class="string">&quot;当前位置无法求该元素的后继/n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	 cout&lt;&lt;<span class="string">&quot;该元素的后继为：&quot;</span>&lt;&lt; p-&gt;data&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打印线性表</span></span><br><span class="line"><span class="function">Status <span class="title">PrintList_L</span><span class="params">(LinkList L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!L) &#123;            <span class="comment">//如果线性表不存在，返回ERROR </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;线性表不存在，无法打印/n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> Error;</span><br><span class="line">	&#125;</span><br><span class="line">	LinkList p;</span><br><span class="line">	p = L-&gt;next;    <span class="comment">//将L的首元结点赋值给p ,为了不将头结点打印出来 </span></span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&quot; &quot;</span>;   <span class="comment">//将p结点的数据域输出 </span></span><br><span class="line">		p = p-&gt;next;    <span class="comment">//结点不断的向后移动 </span></span><br><span class="line">	&#125;</span><br><span class="line">	cout&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="介绍两种插法，头插法和尾插法"><a href="#介绍两种插法，头插法和尾插法" class="headerlink" title="介绍两种插法，头插法和尾插法"></a>介绍两种插法，头插法和尾插法</h2><p>头插法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function">LinkList  <span class="title">CreateList1</span><span class="params">(LinkList &amp;L)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">                  <span class="comment">//从表尾到表头逆向建立单链表 L ，每次均在头结点之后插入元素</span></span><br><span class="line"></span><br><span class="line">                  LNode  *s ;</span><br><span class="line">                  <span class="type">int</span>  x ;</span><br><span class="line">                  L =<span class="keyword">new</span> LNode  ;                 </span><br><span class="line">    			 <span class="comment">// 创建头结点</span></span><br><span class="line">                  L-&gt;next = <span class="literal">NULL</span> ;                                                   </span><br><span class="line">     			<span class="comment">// 初始为空链表</span></span><br><span class="line">                cin&gt;&gt;x;                                               </span><br><span class="line">     			<span class="comment">// 输入结点的值</span></span><br><span class="line"></span><br><span class="line">                  <span class="keyword">while</span>( x!= <span class="number">0</span>)&#123;                                                      </span><br><span class="line">                   <span class="comment">// 输入0 表示结束</span></span><br><span class="line">                         s = <span class="keyword">new</span> LNode  ;         </span><br><span class="line">                    <span class="comment">// 创建新结点</span></span><br><span class="line">                         s-&gt;data =  x ;</span><br><span class="line">                         s-&gt;next = L-&gt;next;                                          </span><br><span class="line">                     <span class="comment">// 将新结点插入表中，L为头指针</span></span><br><span class="line">                         L-&gt;next = s ;</span><br><span class="line">                      cin&gt;&gt;x;                                     </span><br><span class="line">                  &#125;                                                                         </span><br><span class="line">                 <span class="keyword">return</span>  L;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*采用头插法建立单链表，读入数据的顺序与生成的链表中元素的顺序是相反的。</span></span><br></pre></td></tr></table></figure>
<p>尾插法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkList  <span class="title">CreateList2</span><span class="params">( LinkList &amp;L)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">                   <span class="comment">// 从表头到表尾正向建立单链表 L ，每次均在表尾插入元素</span></span><br><span class="line">                   <span class="type">int</span>  x ;                                      <span class="comment">// 设置元素类型为整型</span></span><br><span class="line">                   L = <span class="keyword">new</span> LNode  ;</span><br><span class="line">                   LNode  *s , *r = L ;                    <span class="comment">// r 为表尾指针</span></span><br><span class="line">                cin&gt;&gt;x ;                 <span class="comment">// 输入结点的值</span></span><br><span class="line">                   <span class="keyword">while</span>( x!= <span class="number">0</span>)&#123;                       <span class="comment">// 输入 0 表示结束</span></span><br><span class="line">                         s = <span class="keyword">new</span> LNode  ;</span><br><span class="line">                         s-&gt;data = x;</span><br><span class="line">                         r-next = s ;</span><br><span class="line">                         r = s ;                              <span class="comment">// r 指向新的表尾结点</span></span><br><span class="line">                         cin&gt;&gt;x ;</span><br><span class="line">                   &#125;</span><br><span class="line">                   r-&gt;next = <span class="literal">NULL</span>;                     <span class="comment">// 尾结点指针置空</span></span><br><span class="line">                   <span class="keyword">return</span>  L ;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>知识点</p>
<ol>
<li>头指针和头结点区分：不管带不带头结点，头指针都始终指向链表的第一个结点，而头结点是带头结点的链表中的第一个结点，结点内通常不存储信息</li>
<li>采用头插法建立单链表时，读入数据的顺序与生成的链表中的元素的顺序是相反的，每个结点插入时间为O(1)一共为O(n)</li>
</ol>
</blockquote>
<h2 id="优缺点分析"><a href="#优缺点分析" class="headerlink" title="优缺点分析"></a>优缺点分析</h2><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><blockquote>
<ul>
<li>数据元素的个数可以自由扩充</li>
</ul>
<ul>
<li>插入、删除等操作不必移动数据，只需修改链接指针，修改效率较高</li>
</ul>
</blockquote>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><blockquote>
<ul>
<li>存储密度小</li>
</ul>
<ul>
<li>存取效率不高，必须采用顺序存取，即存取数据元素时，只能按链表的顺序进行访问（顺藤摸瓜）</li>
</ul>
</blockquote>
<h2 id="其他链表"><a href="#其他链表" class="headerlink" title="其他链表"></a>其他链表</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wkd_007/article/details/130108368">【数据结构与算法】 - 双向链表 - 详细实现思路及代码_c语言双向链表不同结构体怎么找链表数据-CSDN博客</a></p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a><code>双向链表</code></h2><p>：在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</p>
<blockquote>
<p>双向链表每个结点除了存储数据data外，还有两个指针记录上一个结点和下一个结点的地址，分别是前驱指针prev和后继指针next.</p>
<p>这两个指针使得双向链表的插入、删除等操作不需要像单向链表那样需要遍历整个链表来寻找前驱节点，提高了链表的操作效率。双向链表与单链表的区别</p>
<p>单向链表是一种链表，在每个节点中包含指向下一个节点的指针。这意味着在单向链表中，节点只能从头开始遍历到尾部。在单向链表中，每个节点只存储指向下一个节点的指针，而不存储指向前一个节点的指针。</p>
<p>双向链表是一种链表，在每个节点中包含指向下一个节点和前一个节点的指针。这意味着在双向链表中，节点可以被从头到尾或从尾到头遍历。在双向链表中，每个节点存储指向前一个节点和下一个节点的指针。</p>
<p>因此，双向链表可以更方便地进行双向遍历，但是需要更多的内存空间来存储每个节点的两个指针。相比之下，在单向链表中，只需要一个指针来指向下一个节点，因此内存占用量更小。</p>
</blockquote>
<p>单链表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/8241119f9a7f45b387906eb4567170c4.png" alt="img"></p>
<p>双向链表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/65a12ddb33ec4ea29c2e4f967175456b.png" alt="在这里插入图片描述"></p>
<blockquote>
<p>特点</p>
<p>双向链表的特点：</p>
<ol>
<li>双向链表可以反向访问到链表的结点，因为它有指向前一个结点的指针piror；</li>
<li>带有头结点的双向链表，<strong>为空链表时，头结点的两个指针域都指向</strong><code>NULL</code>。</li>
<li>带有头结点的双向链表，为非空链表时，<br>头结点的前驱指针域指向<code>NULL</code>，后驱指针域指向第一个结点；<br>最后一个结点的前驱指针域指向前一个结点，后驱指针域指向<code>NULL</code>；<br>其他结点的前驱指针域指向前一个结点，后驱指针域指向后一个结点；</li>
</ol>
</blockquote>
<h3 id="代码综述"><a href="#代码综述" class="headerlink" title="代码综述"></a>代码综述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_DoubleListNode</span></span><br><span class="line">&#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_DoubleListNode</span>* prior;	<span class="comment">// 前驱指针</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_DoubleListNode</span>* next;	<span class="comment">// 后驱指针</span></span><br><span class="line">&#125;DoubleListNode,* DoubleLinkList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; Ok, Error &#125;;               <span class="comment">//枚举类型</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、分配一个结点的存储空间作为头结点，并将头指针指向头结点；</span></span><br><span class="line"><span class="comment">2、让头结点的 prior指针 和 next指针 都指向NULL，头结点的数据填一个无效值；</span></span><br><span class="line"><span class="comment">3、将头指针返回给函数调用者。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">DoubleLinkList <span class="title">ListInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DoubleLinkList list = <span class="keyword">new</span> DoubleListNode;</span><br><span class="line">	list-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">	list-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	list-&gt;data = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表插入数据</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">双向链表插入数据大致分为两个步骤：首先，找到插入位置n的前一个结点；其次，是插入新结点，可以：先连接新结点、再指向新结点的顺序。</span></span><br><span class="line"><span class="comment">先连接新结点：是先把新结点的两个指针域分别连接当前结点和下个结点，_new-&gt;prior = cur;、_new-&gt;next = cur-&gt;next;</span></span><br><span class="line"><span class="comment">再指向新结点：将当前节点的的指针域指向新节点，与旧节点断开，cur-&gt;next-&gt;prior = _new;、cur-&gt;next = _new;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListInsert</span><span class="params">(DoubleLinkList list, <span class="type">int</span> data, <span class="type">int</span> n)</span><span class="comment">// 将node插入到第n位,n从1开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (list == <span class="literal">NULL</span> || n &lt; <span class="number">1</span>) <span class="comment">// 判断参数有效性</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	DoubleListNode* cur = list;	<span class="comment">// cur指向当前结点，初始化指向头结点</span></span><br><span class="line">	<span class="type">int</span> cur_i = <span class="number">0</span>;			<span class="comment">// cur_i表示当前结点的序号,0-头结点</span></span><br><span class="line">	<span class="keyword">while</span> (cur &amp;&amp; cur_i &lt; (n - <span class="number">1</span>))<span class="comment">// 当前结点有效，且不是插入位置的前一个结点，就后移一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">		cur_i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!cur)			<span class="comment">// 当前结点无效，说明已经移动到最后</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">	&#125;</span><br><span class="line">	DoubleListNode* _new = <span class="keyword">new</span> DoubleListNode;</span><br><span class="line">	_new-&gt;data = data;</span><br><span class="line">	_new-&gt;prior = cur;</span><br><span class="line">	_new-&gt;next = cur-&gt;next;</span><br><span class="line">	<span class="keyword">if</span> (cur-&gt;next)		<span class="comment">// 在最后一个结点插入时，cur-&gt;next==NULL</span></span><br><span class="line">		cur-&gt;next-&gt;prior = _new;</span><br><span class="line">	cur-&gt;next = _new;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表删除数据</span></span><br><span class="line"><span class="comment">// 删除第n个结点，且将删除的值通过data传出</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListDelete</span><span class="params">(DoubleLinkList list, <span class="type">int</span>* data, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (list == <span class="literal">NULL</span> || data == <span class="literal">NULL</span> || n &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	DoubleListNode* cur = list;	<span class="comment">// cur指向当前结点，初始化指向头结点</span></span><br><span class="line">	<span class="type">int</span> cur_i = <span class="number">0</span>;				<span class="comment">// cur_i表示当前结点的序号,0-头结点</span></span><br><span class="line">	<span class="keyword">while</span> (cur-&gt;next &amp;&amp; cur_i &lt; (n - <span class="number">1</span>))</span><br><span class="line">	&#123;<span class="comment">// 下个结点有效，且当前位置不是删除位置的前一个，就后移一个</span></span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">		cur_i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!cur-&gt;next)		<span class="comment">// 下个结点无效，说明已经移动到最后</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;		<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">	&#125;</span><br><span class="line">	DoubleListNode* _delete = cur-&gt;next;</span><br><span class="line">	_delete-&gt;prior-&gt;next = _delete-&gt;next;</span><br><span class="line">	_delete-&gt;next-&gt;prior = _delete-&gt;prior;</span><br><span class="line">	<span class="keyword">delete</span> _delete;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表查找数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListFind</span><span class="params">(DoubleLinkList list, <span class="type">int</span>* data, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (list == <span class="literal">NULL</span> || data == <span class="literal">NULL</span> || n &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	DoubleListNode* cur = list-&gt;next;<span class="comment">// 指向第一个节点</span></span><br><span class="line">	<span class="type">int</span> cur_i = <span class="number">1</span>;			<span class="comment">// i表示当前结点的序号</span></span><br><span class="line">	<span class="keyword">while</span> (cur &amp;&amp; cur_i &lt; n)	<span class="comment">// 当前结点有效，且当前位置不是查找位置n，就往后移动一个</span></span><br><span class="line">	&#123;</span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">		cur_i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!cur)			<span class="comment">// 当前结点无效，说明已经移动到最后</span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">	&#125;</span><br><span class="line">	*data = cur-&gt;data;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;个结点值为&quot;</span> &lt;&lt; *data &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//双向链表的销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListDestroy</span><span class="params">(DoubleLinkList list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	DoubleListNode* cur = list-&gt;next;	<span class="comment">// 指向第一个节点</span></span><br><span class="line">	DoubleListNode* next = <span class="literal">NULL</span>;		<span class="comment">// 用于保存下个结点地址</span></span><br><span class="line">	<span class="keyword">while</span> (cur)	<span class="comment">// 当前结点有效，就往后移动</span></span><br><span class="line">	&#123;</span><br><span class="line">		next = cur-&gt;next;		<span class="comment">// 保存下个结点地址</span></span><br><span class="line">		<span class="keyword">delete</span> cur;				<span class="comment">// 删除当前结点、并释放内存</span></span><br><span class="line">		cur = next;				<span class="comment">// 将当前结点指针指向下个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	list-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">	list-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><blockquote>
<ol>
<li><p><strong>循环链表</strong>:是一种头尾相接的链表(表中最后一个结点的指针域指向头结点，整个链表形成一个环</p>
</li>
<li><p><strong>优点:</strong> 从表中任一结点出发均可找到表中其他结点</p>
<ol>
<li><p>循环链表中<strong>没有NULL指针</strong>，当遍历链表时，终止条件是<strong>最后一个结点的指针域是否等于头指针</strong></p>
</li>
<li><p>尾指针表示单循环链表:</p>
<pre><code>首元结点的存储位置: R-&gt;next-&gt;next;

最后一个结点的存储位置: R
</code></pre><p>//用尾指针表示单循环链表访问首尾结点时间复杂度都为O(1)</p>
<p>需要注意的是，虽然循环链表成环状，但本质上还是链表，因此在循环链表中，依然能够找到头指针和首元节点等。循环链表和普通链表相比，唯一的不同就是循环链表首尾相连，其他都完全一样。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/1b33a2d3487c49b18886e28aa559e148.png" alt="在这里插入图片描述"></p>
</li>
</ol>
</li>
</ol>
</blockquote>
<h3 id="代码综述-1"><a href="#代码综述-1" class="headerlink" title="代码综述"></a>代码综述</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">_ListNode</span>* next; <span class="comment">// 指向结点的指针</span></span><br><span class="line">&#125;ListNode,* CyclicList;<span class="comment">//定义链表结点：包含数据域，指针域 .定义循环链表头指针，是指向结点的指针</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; Ok, Error &#125;;               <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环链表初始化</span></span><br><span class="line"><span class="function">CyclicList <span class="title">ListInit</span><span class="params">()</span><span class="comment">// 创建一个头结点，让其指针域指向自己，并返回头结点地址</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CyclicList list = <span class="keyword">new</span> ListNode;</span><br><span class="line">	list-&gt;next = list; <span class="comment">// 指向头结点</span></span><br><span class="line">	list-&gt;data = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环链表插入数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListInsert</span><span class="params">(CyclicList list, <span class="type">int</span> data, <span class="type">int</span> n)</span><span class="comment">// 将node插入到第n位,n从1开始</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (list == <span class="literal">NULL</span> || n &lt; <span class="number">1</span>) <span class="comment">// 判断参数有效性</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	ListNode* cur = list;<span class="comment">// cur指向当前结点，初始化指向头结点</span></span><br><span class="line">	<span class="type">int</span> cur_i = <span class="number">0</span>;			<span class="comment">// i表示当前结点的序号,0-头结点</span></span><br><span class="line">	<span class="keyword">while</span> (cur-&gt;next != list &amp;&amp; cur_i &lt; (n - <span class="number">1</span>))</span><br><span class="line">	&#123;<span class="comment">//不是最后一个结点，且不是插入位置的前一个结点，就后移一个</span></span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">		cur_i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cur-&gt;next == list)			<span class="comment">// 移动到最后结点 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (cur_i != (n - <span class="number">1</span>))		<span class="comment">// 仍然不是插入位置前一个结点，出错</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* _new = <span class="keyword">new</span> ListNode;</span><br><span class="line">	_new-&gt;data = data;</span><br><span class="line">	_new-&gt;next = cur-&gt;next;</span><br><span class="line">	cur-&gt;next = _new;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环链表删除数据</span></span><br><span class="line"><span class="comment">// 删除第n个结点，且将删除的值通过data传出</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListDelete</span><span class="params">(CyclicList list, <span class="type">int</span>* data, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (list == <span class="literal">NULL</span> || data == <span class="literal">NULL</span> || n &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	ListNode* cur = list;	<span class="comment">// cur指向当前结点，初始化指向头结点</span></span><br><span class="line">	<span class="type">int</span> cur_i = <span class="number">0</span>;			<span class="comment">// i表示当前结点的序号,0-头结点</span></span><br><span class="line">	<span class="keyword">while</span> (cur-&gt;next != list &amp;&amp; cur_i &lt; (n - <span class="number">1</span>))</span><br><span class="line">	&#123;<span class="comment">//不是最后一个结点，且不是删除位置的前一个结点，就后移一个</span></span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">		cur_i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cur-&gt;next == list)		<span class="comment">// 移动到最后结点 </span></span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;			<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">	&#125;</span><br><span class="line">	ListNode* _delete = cur-&gt;next;</span><br><span class="line">	cur-&gt;next = _delete-&gt;next;</span><br><span class="line">	<span class="keyword">delete</span> _delete;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//循环链表查找数据</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ListFind</span><span class="params">(CyclicList list, <span class="type">int</span>* data, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (list == <span class="literal">NULL</span> || data == <span class="literal">NULL</span> || n &lt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">	ListNode* cur = list-&gt;next;	<span class="comment">// 指向第一个节点</span></span><br><span class="line">	<span class="type">int</span> cur_i = <span class="number">1</span>;				<span class="comment">// i表示当前结点的序号</span></span><br><span class="line">	<span class="keyword">if</span> (cur == list)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (cur-&gt;next != list &amp;&amp; cur_i &lt; n)</span><br><span class="line">	&#123;<span class="comment">//不是最后一个结点，且当前位置不是查找位置n，就往后移动一个</span></span><br><span class="line">		cur = cur-&gt;next;</span><br><span class="line">		cur_i++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (cur-&gt;next == list)			<span class="comment">// 移动到最后结点 </span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (cur_i != n)		<span class="comment">// 仍然不是查找位置n，出错</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;链表不够长&quot;</span> &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">// 链表没有 n 那么长</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	*data = cur-&gt;data;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot;个结点的值是&quot;</span> &lt;&lt; *data &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环链表的销毁</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ListDestroy</span><span class="params">(CyclicList list)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ListNode* cur = list-&gt;next;	<span class="comment">// 指向第一个节点</span></span><br><span class="line">	ListNode* next = <span class="literal">NULL</span>;		<span class="comment">// 用于保存下个结点地址</span></span><br><span class="line">	<span class="keyword">while</span> (cur != list)			<span class="comment">// 不是最后一个结点的指针域就后移</span></span><br><span class="line">	&#123;</span><br><span class="line">		next = cur-&gt;next;		<span class="comment">// 保存下个结点地址	</span></span><br><span class="line">		<span class="keyword">delete</span> cur;				<span class="comment">// 删除当前结点、并释放内存</span></span><br><span class="line">		cur = next;				<span class="comment">// 将当前结点指针指向下个结点</span></span><br><span class="line">	&#125;</span><br><span class="line">	list-&gt;next = list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>选择数组还是链表？</li>
</ul>
<p>1.插入、删除和随机访问的时间复杂度<br>数组：插入、删除的时间复杂度是O(n)，随机访问的时间复杂度是O(1)。<br>链表：插入、删除的时间复杂度是O(1)，随机访问的时间复杂端是O(n)。</p>
<p>2.数组缺点<br>1）若申请内存空间很大，比如100M，但若内存空间没有100M的连续空间时，则会申请失败，尽管内存可用空间超过100M。<br>2）大小固定，若存储空间不足，需进行扩容，一旦扩容就要进行数据复制，而这时非常费时的。<br>3.链表缺点<br>1）内存空间消耗更大，因为需要额外的空间存储指针信息。<br>2）对链表进行频繁的插入和删除操作，会导致频繁的内存申请和释放，容易造成内存碎片。<br>4.如何选择？<br>数组简单易用，在实现上使用连续的内存空间，可以借助CPU的缓冲机制预读数组中的数据，所以访问效率更高，而链表在内存中并不是连续存储，所以对CPU缓存不友好，没办法预读。<br>如果代码对内存的使用非常苛刻，那数组就更适合。</p>
</blockquote>
<h1 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="一、栈的基本概念"><a href="#一、栈的基本概念" class="headerlink" title="一、栈的基本概念"></a>一、栈的基本概念</h3><h4 id="1、栈的定义"><a href="#1、栈的定义" class="headerlink" title="1、栈的定义"></a>1、栈的定义</h4><p><strong>栈</strong>（Stack）：是只允许在一端进行插入或删除的线性表。首先栈是一种线性表，但限定这种线性表只能在某一端进行插入和删除操作。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/20210218204524571.png" alt="img"></p>
<p><strong>栈顶</strong>（Top）：线性表允许进行插入删除的那一端。<br><strong>栈底</strong>（Bottom）：固定的，不允许进行插入和删除的另一端。<br><strong>空栈</strong>：不含任何元素的空表。</p>
<p><strong>栈又称为后进先出（Last In First Out）的线性表，简称LIFO结构</strong></p>
<h3 id="二、栈的顺序存储结构"><a href="#二、栈的顺序存储结构" class="headerlink" title="二、栈的顺序存储结构"></a>二、栈的顺序存储结构</h3><p>1、栈的顺序存储<br>采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。<br>若存储栈的长度为StackSize，则栈顶位置top必须小于StackSize。当栈存在一个元素时，top等于0，因此通常把空栈的判断条件定位top等于-1。<br>栈的基本操作</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 50  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;   <span class="comment">//ElemType的类型根据实际情况而定，这里假定为int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    ElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top;    <span class="comment">//用于栈顶指针</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; Ok, Error &#125;;               <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack* S)</span> </span>&#123;</span><br><span class="line">    S-&gt;top = <span class="number">-1</span>;    <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S.top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">//栈空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;   <span class="comment">//不空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入元素e为新的栈顶元素*/</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack* S, ElemType e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//满栈</span></span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == MAXSIZE - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;top++;   <span class="comment">//栈顶指针增加一</span></span><br><span class="line">    S-&gt;data[S-&gt;top] = e;    <span class="comment">//将新插入元素赋值给栈顶空间</span></span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack* S, ElemType* e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = S-&gt;data[S-&gt;top];   <span class="comment">//将要删除的栈顶元素赋值给e</span></span><br><span class="line">    S-&gt;top--;   <span class="comment">//栈顶指针减一</span></span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*读栈顶元素*/</span></span><br><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack *S, ElemType* e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top == <span class="number">-1</span>) &#123;   <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = S-&gt;data[S-&gt;top];   <span class="comment">//记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="偏向于ACM的栈实现"><a href="#偏向于ACM的栈实现" class="headerlink" title="偏向于ACM的栈实现"></a>偏向于ACM的栈实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"><span class="comment">// 这里使用 st[0] (即 *st) 代表栈中元素数量，同时也是栈顶下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 压栈 ：</span></span><br><span class="line">st[++*st] = var1;</span><br><span class="line"><span class="comment">// 取栈顶 ：</span></span><br><span class="line"><span class="type">int</span> u = st[*st];</span><br><span class="line"><span class="comment">// 弹栈 ：注意越界问题, *st == 0 时不能继续弹出</span></span><br><span class="line"><span class="keyword">if</span> (*st) --*st;</span><br><span class="line"><span class="comment">// 清空栈</span></span><br><span class="line">*st = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">C++ 中的 STL 也提供了一个容器 std::stack，使用前需要引入 stack 头文件。</span></span><br><span class="line"><span class="comment">STL 中的 stack 容器提供了一众成员函数以供调用，其中较为常用的有：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">元素访问</span></span><br><span class="line"><span class="comment">st.top() 返回栈顶</span></span><br><span class="line"><span class="comment">修改</span></span><br><span class="line"><span class="comment">st.push() 插入传入的参数到栈顶</span></span><br><span class="line"><span class="comment">st.pop() 弹出栈顶</span></span><br><span class="line"><span class="comment">容量</span></span><br><span class="line"><span class="comment">st.empty() 返回是否为空</span></span><br><span class="line"><span class="comment">st.size() 返回元素数量</span></span><br><span class="line"><span class="comment">此外，std::stack 还提供了一些运算符。较为常用的是使用赋值运算符 = 为 stack 赋值，示例：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 新建两个栈 st1 和 st2</span></span><br><span class="line"><span class="comment">std::stack&lt;int&gt; st1, st2;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 为 st1 装入 1</span></span><br><span class="line"><span class="comment">st1.push(1);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 将 st1 赋值给 st2</span></span><br><span class="line"><span class="comment">st2 = st1;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">// 输出 st2 的栈顶元素</span></span><br><span class="line"><span class="comment">cout &lt;&lt; st2.top() &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">// 输出: 1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h4 id="共享栈（两栈共享空间）"><a href="#共享栈（两栈共享空间）" class="headerlink" title="共享栈（两栈共享空间）"></a>共享栈（两栈共享空间）</h4><h5 id="（1）共享栈概念"><a href="#（1）共享栈概念" class="headerlink" title="（1）共享栈概念"></a>（1）共享栈概念</h5><p>利用栈底位置相对不变的特征，可让两个顺序栈共享一个一维数组空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸，如下图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/2021021909353762.png" alt="在这里插入图片描述"></p>
<p><strong>两个栈的栈顶指针都指向栈顶元素，top0=-1时0号栈为空，top1=MaxSize时1号栈为空；仅当两个栈顶指针相邻（top0+1=top1）时，判断为栈满。当0号栈进栈时top0先加1再赋值，1号栈进栈时top1先减一再赋值出栈时则刚好相反。</strong></p>
<h5 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*两栈共享空间结构*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 50  <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;   <span class="comment">//ElemType的类型根据实际情况而定，这里假定为int</span></span><br><span class="line"><span class="comment">/*两栈共享空间结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	ElemType data[MAXSIZE];</span><br><span class="line">	<span class="type">int</span> top0=<span class="number">0</span>;	<span class="comment">//栈0栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1 = MAXSIZE;	<span class="comment">//栈1栈顶指针</span></span><br><span class="line">&#125;SqDoubleStack;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span> &#123; Ok, Error &#125;;               <span class="comment">//枚举类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*插入元素e为新的栈顶元素*/</span></span><br><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqDoubleStack* S, ElemType e, <span class="type">int</span> stackNumber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (S-&gt;top0 + <span class="number">1</span> == S-&gt;top1) &#123;   <span class="comment">//栈满</span></span><br><span class="line">        <span class="keyword">return</span> Error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stackNumber == <span class="number">0</span>) &#123;   <span class="comment">//栈0有元素进栈</span></span><br><span class="line">        S-&gt;data[++S-&gt;top0] = e; <span class="comment">//若栈0则先top0+1后给数组元素赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber == <span class="number">1</span>) &#123; <span class="comment">//栈1有元素进栈</span></span><br><span class="line">        S-&gt;data[--S-&gt;top1] = e; <span class="comment">//若栈1则先top1-1后给数组元素赋值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR*/</span></span><br><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqDoubleStack* S, ElemType* e, <span class="type">int</span> stackNumber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stackNumber == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S-&gt;top0 == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Error;   <span class="comment">//说明栈0已经是空栈，溢出</span></span><br><span class="line">        &#125;</span><br><span class="line">        *e = S-&gt;data[S-&gt;top0--]; <span class="comment">//将栈0的栈顶元素出栈，随后栈顶指针减1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (stackNumber == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S-&gt;top1 == MAXSIZE) &#123;</span><br><span class="line">            <span class="keyword">return</span> Error;   <span class="comment">//说明栈1是空栈，溢出</span></span><br><span class="line">        &#125;</span><br><span class="line">        *e = S-&gt;data[S-&gt;top1++];    <span class="comment">//将栈1的栈顶元素出栈，随后栈顶指针加1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="三、栈的顺序存储结构"><a href="#三、栈的顺序存储结构" class="headerlink" title="三、栈的顺序存储结构"></a>三、栈的顺序存储结构</h3><p>　对于链栈来说，基本不存在栈满的情况，除非内存已经没有使用空间了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">/*两栈共享空间结构*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">StackNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> data;<span class="comment">//结点数据域</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">StackNode</span>* next;<span class="comment">//结点指针域</span></span><br><span class="line">&#125;StackNode, * Linktop;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链栈的数据结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkStack</span></span><br><span class="line">&#123;</span><br><span class="line">	Linktop top;   <span class="comment">//栈顶结点,定义了一个指向上个结构体的指针</span></span><br><span class="line">	<span class="type">int</span> count;<span class="comment">//元素个数</span></span><br><span class="line">&#125;LinkStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//压栈:先将压入元素放入到链表表中，然后再将栈顶指针指向压入的元素，然后count+1.</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">push</span><span class="params">(LinkStack* stack, <span class="type">int</span> e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!stack)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	StackNode* node = <span class="keyword">new</span> StackNode;</span><br><span class="line">	node-&gt;next = stack-&gt;top;           <span class="comment">//将元素加入链表中</span></span><br><span class="line">	node-&gt;data = e;</span><br><span class="line">	stack-&gt;top = node;                 <span class="comment">//栈顶元素指向压入元素</span></span><br><span class="line">	stack-&gt;count++;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹栈:栈顶指针指向要弹出元素前置结点，然后释放弹出元素内存空间，然后count-1</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">(LinkStack* stack, <span class="type">int</span>* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!stack &amp;&amp; stack-&gt;count)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>	<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	StackNode* node = stack-&gt;top;</span><br><span class="line">	*e = node-&gt;data;</span><br><span class="line">	stack-&gt;top = node-&gt;next;   <span class="comment">//栈顶指针指向新的栈顶元素</span></span><br><span class="line">	<span class="keyword">delete</span> node;                <span class="comment">//释放元素空间</span></span><br><span class="line">	stack-&gt;count--;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h2><p>何为单调栈？顾名思义，单调栈即满足单调性的栈结构。与单调队列相比，其只在一端进行进出。</p>
<p>为了描述方便，以下举例及伪代码以维护一个整数的单调递增栈为例。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">insert x</span><br><span class="line"><span class="keyword">while</span> !sta.<span class="built_in">empty</span>() &amp;&amp; sta.<span class="built_in">top</span>()&lt;x</span><br><span class="line">    sta.<span class="built_in">pop</span>()</span><br><span class="line">sta.<span class="built_in">push</span>(x)</span><br></pre></td></tr></table></figure>
<h3 id="洛谷单调栈"><a href="#洛谷单调栈" class="headerlink" title="洛谷单调栈"></a>洛谷单调栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for(int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">5e6</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> stk[N];</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;a[i];</span><br><span class="line"><span class="keyword">while</span>(top &amp;&amp; !(a[stk[top]]&gt;=a[i]))	</span><br><span class="line">ans[stk[top--]]=i;</span><br><span class="line">	stk[++top]=i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造一个单调递减栈</span></span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><h3 id="一、队列的基本概念"><a href="#一、队列的基本概念" class="headerlink" title="一、队列的基本概念"></a>一、队列的基本概念</h3><h4 id="1、队列的定义"><a href="#1、队列的定义" class="headerlink" title="1、队列的定义"></a>1、队列的定义</h4><p><strong>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</strong><br>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/20210219144731888.png" alt="img"></p>
<p><strong>队头（Front）</strong>：允许删除的一端，又称队首。<br><strong>队尾（Rear）</strong>：允许插入的一端。<br><strong>空队列</strong>：不包含任何元素的空表。</p>
<p>向队列中插入新的数据元素称为<strong>入队</strong>，新入队的元素就成为了队列的队尾元素。</p>
<p>从队列中删除队头元素称为<strong>出队</strong>，其后继元素成为新的队头元素。</p>
<h3 id="二、队列的顺序存储结构"><a href="#二、队列的顺序存储结构" class="headerlink" title="二、队列的顺序存储结构"></a>二、队列的顺序存储结构</h3><p>队列的顺序实现是指分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针 front指向队头元素，队尾指针 rear 指向队尾元素的下一个位置。</p>
<p>但是会有假溢出的出现，因此需要另外一种队列，这种<strong>队列的这种头尾相接的顺序存储结构称为循环队列。</strong></p>
<p>当队首指针Q-&gt;front = MAXSIZE-1后，再前进一个位置就自动到0，这可以利用除法取余运算（%）来实现。</p>
<p>初始时：Q-&gt;front = Q-&gt;rear=0。<br>队首指针进1：Q-&gt;front = (Q-&gt;front + 1) % MAXSIZE。<br>队尾指针进1：Q-&gt;rear = (Q-&gt;rear + 1) % MAXSIZE。<br>队列长度：(Q-&gt;rear - Q-&gt;front + MAXSIZE) % MAXSIZE。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 50	<span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	QElemType data[MAXSIZE];	<span class="comment">//存放队列元素</span></span><br><span class="line">	<span class="type">int</span> front, rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span>&#123;OK,ERROR&#125;;</span><br><span class="line"><span class="function">Status <span class="title">visit</span><span class="params">(QElemType c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; c&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 初始化一个空队列Q */</span></span><br><span class="line"><span class="function">Status <span class="title">InitQueue</span><span class="params">(SqQueue* Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 将Q清为空队列 */</span></span><br><span class="line"><span class="function">Status <span class="title">ClearQueue</span><span class="params">(SqQueue* Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;front = Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若队列Q为空队列,则返回TRUE,否则返回FALSE */</span></span><br><span class="line"><span class="function">Status <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="comment">/* 队列空的标志 */</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 返回Q的元素个数，也就是队列的当前长度 */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">QueueLength</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span>  (Q.rear - Q.front + MAXSIZE) % MAXSIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若队列不空,则用e返回Q的队头元素,并返回OK,否则返回ERROR */</span></span><br><span class="line"><span class="function">Status <span class="title">GetHead</span><span class="params">(SqQueue Q, QElemType* e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Q.front == Q.rear) <span class="comment">/* 队列空 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    *e = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 若队列未满，则插入元素e为Q新的队尾元素 */</span></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(SqQueue* Q, QElemType e)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Q-&gt;rear + <span class="number">1</span>) % MAXSIZE == Q-&gt;front)    <span class="comment">/* 队列满的判断 */</span></span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    Q-&gt;data[Q-&gt;rear] = e;            <span class="comment">/* 将元素e赋值给队尾 */</span></span><br><span class="line">    Q-&gt;rear = (Q-&gt;rear + <span class="number">1</span>) % MAXSIZE;<span class="comment">/* rear指针向后移一位置， */</span></span><br><span class="line">    <span class="comment">/* 若到最后则转到数组头部 */</span></span><br><span class="line">    <span class="keyword">return</span>  OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 从队头到队尾依次对队列Q中每个元素输出 */</span></span><br><span class="line"><span class="function">Status <span class="title">QueueTraverse</span><span class="params">(SqQueue Q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    i = Q.front;</span><br><span class="line">    <span class="keyword">for</span> (i = Q.front; i != Q.rear; i = (i + <span class="number">1</span>) % MAXSIZE) &#123;</span><br><span class="line">        <span class="built_in">visit</span>(Q.data[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="ACM队列相关"><a href="#ACM队列相关" class="headerlink" title="ACM队列相关"></a>ACM队列相关</h2><blockquote>
<p>队列（queue）是一种具有「先进入队列的元素一定先出队列」性质的表。由于该性质，队列通常也被称为先进先出（first in first out）表，简称 FIFO 表。</p>
<h2 id="数组模拟队列"><a href="#数组模拟队列" class="headerlink" title="数组模拟队列"></a>数组模拟队列</h2><p>通常用一个数组模拟一个队列，用两个变量标记队列的首尾。</p>
<p>队列操作对应的代码如下：</p>
<ul>
<li>插入元素：<code>q[++qr] = x;</code></li>
<li>删除元素：<code>ql++;</code></li>
<li>访问队首：<code>q[ql]</code></li>
<li>访问队尾：<code>q[qr]</code></li>
<li>清空队列：<code>ql = 1; qr = 0;</code></li>
</ul>
<p>STL 中的 <code>queue</code> 容器提供了一众成员函数以供调用。其中较为常用的有：</p>
<ul>
<li>元素访问<ul>
<li><code>q.front()</code> 返回队首元素</li>
<li><code>q.back()</code> 返回队尾元素</li>
</ul>
</li>
<li>修改<ul>
<li><code>q.push()</code> 在队尾插入元素</li>
<li><code>q.pop()</code> 弹出队首元素</li>
</ul>
</li>
<li>容量<ul>
<li><code>q.empty()</code> 队列是否为空</li>
<li><code>q.size()</code> 返回队列中元素的数量</li>
</ul>
</li>
</ul>
<p>STL 中的 <code>deque</code> 容器提供了一众成员函数以供调用。其中较为常用的有：</p>
<ul>
<li>元素访问<ul>
<li><code>q.front()</code> 返回队首元素</li>
<li><code>q.back()</code> 返回队尾元素</li>
</ul>
</li>
<li>修改<ul>
<li><code>q.push_back()</code> 在队尾插入元素</li>
<li><code>q.pop_back()</code> 弹出队尾元素</li>
<li><code>q.push_front()</code> 在队首插入元素</li>
<li><code>q.pop_front()</code> 弹出队首元素</li>
<li><code>q.insert()</code> 在指定位置前插入元素（传入迭代器和元素）</li>
<li><code>q.erase()</code> 删除指定位置的元素（传入迭代器）</li>
</ul>
</li>
<li>容量<ul>
<li><code>q.empty()</code> 队列是否为空</li>
<li><code>q.size()</code> 返回队列中元素的数量</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="三、队列的链式存储结构"><a href="#三、队列的链式存储结构" class="headerlink" title="三、队列的链式存储结构"></a>三、队列的链式存储结构</h3><blockquote>
<h4 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h4><p><strong>队列的链式存储结构表示为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表，只不过它只能尾进头出而已</strong>。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 50	<span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="comment">/*链式队列结点*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span> &#123;</span><br><span class="line">	ElemType data;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">LinkNode</span>* next;</span><br><span class="line">&#125;LinkNode;</span><br><span class="line"><span class="comment">/*链式队列*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	LinkNode* front, * rear;	<span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Status</span>&#123;OK,ERROR&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队列初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue* Q)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Q-&gt;front = Q-&gt;rear = <span class="keyword">new</span> LinkNode;	<span class="comment">//建立头结点</span></span><br><span class="line">	Q-&gt;front-&gt;next = <span class="literal">NULL</span>;	<span class="comment">//初始为空</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//链队列入队</span></span><br><span class="line"></span><br><span class="line"><span class="function">Status <span class="title">EnQueue</span><span class="params">(LinkQueue* Q, ElemType e)</span> </span>&#123;</span><br><span class="line">	LinkNode *s = <span class="keyword">new</span> LinkNode;</span><br><span class="line">	s-&gt;data = e;</span><br><span class="line">	s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	Q-&gt;rear-&gt;next = s;	<span class="comment">//把拥有元素e新结点s赋值给原队尾结点的后继</span></span><br><span class="line">	Q-&gt;rear = s;	<span class="comment">//把当前的s设置为新的队尾结点</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*若队列不空，删除Q的队头元素，用e返回其值，并返回OK，否则返回ERROR*/</span></span><br><span class="line"><span class="function">Status <span class="title">DeQueue</span><span class="params">(LinkQueue* Q, ElemType* e)</span> </span>&#123;</span><br><span class="line">	LinkNode *p;</span><br><span class="line">	<span class="keyword">if</span> (Q-&gt;front == Q-&gt;rear) &#123;</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	&#125;</span><br><span class="line">	p = Q-&gt;front-&gt;next;	<span class="comment">//将欲删除的队头结点暂存给p</span></span><br><span class="line">	*e = p-&gt;data;	<span class="comment">//将欲删除的队头结点的值赋值给e</span></span><br><span class="line">	Q-&gt;front-&gt;next = p-&gt;next;	<span class="comment">//将原队头结点的后继赋值给头结点后继</span></span><br><span class="line">	<span class="comment">//若删除的队头是队尾，则删除后将rear指向头结点</span></span><br><span class="line">	<span class="keyword">if</span> (Q-&gt;rear == p) </span><br><span class="line">	&#123;</span><br><span class="line">		Q-&gt;rear = Q-&gt;front;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span> p;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><p>双端队列（deque）是队列的一种变形，一般队列只能在队尾添加元素（push），在队首删除元素（pop），双端队列则同时在队首或者队尾执行添加和删除工作。C++中，使用双端队列需要包含头文件<deque>。C++中队列的基本操作如下：</deque></p>
<blockquote>
<p>push_back()：在队列尾部添加元素，无返回值。这个操作跟普通队列（queue）的push()方法类似，在队列的尾部添加一个元素；<br>push_front()：在队列头部添加元素，无返回值；<br>pop_back()：删除队列尾部的元素，无返回值；<br>pop_front()：删除队列头部的元素，无返回值；<br>front() ：获得队列头部元素。此函数返回值为队列的头部元素，常与pop_front()函数一起，先通过front()获得队列头部元素，然后用pop_front()将其从队列中删除；<br>back()： 获得队列尾部元素。此函数返回值为队列的尾部元素，常与pop_back()函数一起，先通过back()获得队列头部元素，然后用pop_back()将其从队列中删除；<br>size()：获得队列大小。此函数返回队列的大小，返回值是“size_t”类型的数据，“size_t”是“unsigned int”的别名；<br>empty() ：判断队列是否为空。此函数返回队列是否为空，返回值是bool类型。队列空：返回true；不空：返回false。</p>
<p>堆是一棵树，其每个节点都有一个键值，且每个节点的键值都大于等于/小于等于其父亲的键值。</p>
<p>每个节点的键值都大于等于其父亲键值的堆叫做小根堆，否则叫做大根堆。STL 中的 <code>priority_queue</code> 其实就是一个大根堆。</p>
<p>（小根）堆主要支持的操作有：插入一个数、查询最小值、删除最小值、合并两个堆、减小一个元素的值。</p>
</blockquote>
<h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>顾名思义，单调队列的重点分为「单调」和「队列」。</p>
<p>「单调」指的是元素的「规律」——递增（或递减）。</p>
<blockquote>
<p>例如我们构造一个单调递增的队列会如下：</p>
<p>原序列为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>1</code></th>
<th><code>1 3 -1 -3 5 3 6 7</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
</tr>
</tbody>
</table>
</div>
<p>因为我们始终要维护队列保证其 <strong>递增</strong> 的特点，所以会有如下的事情发生：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">操作</th>
<th style="text-align:left">队列状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1 入队</td>
<td style="text-align:left"><code>&#123;1&#125;</code></td>
</tr>
<tr>
<td style="text-align:left">3 比 1 大，3 入队</td>
<td style="text-align:left"><code>&#123;1 3&#125;</code></td>
</tr>
<tr>
<td style="text-align:left">-1 比队列中所有元素小，所以清空队列 -1 入队</td>
<td style="text-align:left"><code>&#123;-1&#125;</code></td>
</tr>
<tr>
<td style="text-align:left">-3 比队列中所有元素小，所以清空队列 -3 入队</td>
<td style="text-align:left"><code>&#123;-3&#125;</code></td>
</tr>
<tr>
<td style="text-align:left">5 比 -3 大，直接入队</td>
<td style="text-align:left"><code>&#123;-3 5&#125;</code></td>
</tr>
<tr>
<td style="text-align:left">3 比 5 小，5 出队，3 入队</td>
<td style="text-align:left"><code>&#123;-3 3&#125;</code></td>
</tr>
<tr>
<td style="text-align:left">-3 已经在窗体外，所以 -3 出队；6 比 3 大，6 入队</td>
<td style="text-align:left"><code>&#123;3 6&#125;</code></td>
</tr>
<tr>
<td style="text-align:left">7 比 6 大，7 入队</td>
<td style="text-align:left"><code>&#123;3 6 7&#125;</code></td>
</tr>
</tbody>
</table>
</div>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i, a, n) for (int i = a; i &lt;= n; i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> frep(i, a, n) for (int i = a; i &gt;= n; i--)</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="type">long</span> <span class="type">long</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e7</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="type">int</span> q2[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> h=<span class="number">1</span>,t=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; q[h] + m &lt;= i)</span><br><span class="line">&#123;</span><br><span class="line">    h++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (h &lt;= t &amp;&amp; a[i]&lt;a[q[t]])</span><br><span class="line">&#123;</span><br><span class="line">    t--;</span><br><span class="line">&#125;</span><br><span class="line">q[++t] = i;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=m)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;a[q[h]]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line"> h = <span class="number">1</span>, t = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">rep</span>(i, <span class="number">1</span>, n)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (h &lt;= t &amp;&amp; q2[h] + m &lt;= i)</span><br><span class="line">    &#123;</span><br><span class="line">        h++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (h &lt;= t &amp;&amp; a[i] &gt; a[q2[t]])</span><br><span class="line">    &#123;</span><br><span class="line">        t--;</span><br><span class="line">    &#125;</span><br><span class="line">    q2[++t] = i;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= m)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; a[q2[h]] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="串"><a href="#串" class="headerlink" title="串"></a>串</h1><blockquote>
<p>串的逻辑结构和线性表极为相似，区别仅在于串的数据对象限定为字符集</p>
<p>串的存储结构：定长顺序存储表示、堆分配存储表示、块链存储表示</p>
<p>子串的定位操作通常称为串的模式匹配，它求的是子串在主串中的位置。</p>
</blockquote>
<p>1、<strong>串的概念</strong><br>字符串简称串，是一种特殊的<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=线性表&amp;spm=1001.2101.3001.7020">线性表</a>，它的数据元素仅由一个字符组成。</p>
<p>2、<strong>串的定义</strong><br>串(String)是由零个或多个字符组成的有限序列，又称字符串。</p>
<blockquote>
<p>其中s是串名,用双引号括起来的字符序列为串值，但引号本身并不属于串的内容。ai(1&lt;=i&lt;=n)是一个任意字符,它称为串的元素,是构成串的基本单位，i是它在整个串中的序号；n为串的长度,表示串中所包含的字符个数。</p>
</blockquote>
<ul>
<li><p><strong>串的长度</strong>：串中字符的个数</p>
</li>
<li><p><strong>空串</strong>：长度为0的串</p>
</li>
<li><p><strong>空格串</strong>：0个或多个空格字符组成的串</p>
</li>
<li><p><strong>子串</strong>：串中任意连续字符组成的子序列</p>
</li>
<li><p><strong>主串</strong>：包含子串的串</p>
</li>
<li><p><strong>位置</strong>：字符在串中的序号。子串在主串中的位置是其第一个字符在主串中的位置。</p>
</li>
<li><p><strong>串的相等</strong>：长度和对应位置字符都相等</p>
</li>
<li><p><strong>连接 concatenation</strong>：连接是一个重要的二进制操作。对于任意两个主串中的子串s和t，它们的连接根据放置s和t 的前后顺序来定符号序列。例如，子串s = love，t = hug，那么st 就是lovehug，ts 就是huglove。</p>
</li>
<li><p><strong>前缀和后缀 prefixes and suffixes</strong>：字符串s 可以说是t 的前缀，如果存在一个字符串u 满足条件t =su。如果u 是非空的，那么可以说s 是t 的一个合适的前缀；相应地，串s 可以说t 的后缀如果存在一个串u 满足条件t=us。如果u 是非空的，s 可以说是t 的一个合适的后缀。前缀和后缀可以说是t 的子串。</p>
</li>
<li><p><strong>旋转</strong>：串s = uv 可以被说成t 的旋转如果t = vu. 举个例子，当u = 00110, v = 01的时候，串0011001 是0100110 的旋转。</p>
</li>
<li><p><strong>逆转</strong>:串的逆转就是具有相同符号单顺序相反的字符串。例如，如果s=abc（a、b和c是字母表中符号），那么s 的逆转就是cba。一个与自身相反的字符串（例如，s=madam，逆转还是madam）被称为回文 palindrome，它还包括空字符串和所有长度为1的字符串。</p>
<p>设A和B分别为 A=‘This is a string’ B=‘is’ 则B是A的子串，A为主串。B在A中出现了两次，其中首次出现所对应的主串位置是3。因此，称B在A中的位置为3。 特别地，空串是任意串的子串，任意串是其自身的子串。</p>
</li>
</ul>
<h3 id="二、串的存储结构"><a href="#二、串的存储结构" class="headerlink" title="二、串的存储结构"></a>二、串的存储结构</h3><h4 id="1、定长顺序存储表示"><a href="#1、定长顺序存储表示" class="headerlink" title="1、定长顺序存储表示"></a>1、定长顺序存储表示</h4><p>类似于线性表的顺序存储结构，用一组地址连续的存储单元存储串值的字符序列。在串的定长顺序存储结构中，为每个串变量分配一个固定长度的存储区，即定长数组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSTRLEN 255   <span class="comment">//串的最大存储容量定义为255</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> SString[MAXSTRLEN + <span class="number">1</span>];   <span class="comment">//定义串的类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> status;</span><br><span class="line"><span class="comment">//创建一个串</span></span><br><span class="line"><span class="function">status <span class="title">STrAssign</span><span class="params">(SString&amp; T, <span class="type">char</span>* chars)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//创建一个值等于chars的串</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(chars) &gt; MAXSTRLEN)  <span class="keyword">return</span> ERROR;</span><br><span class="line">	T[<span class="number">0</span>] = <span class="built_in">strlen</span>(chars);</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= T[<span class="number">0</span>]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		T[i] = *(chars + i - <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断串是否为空串</span></span><br><span class="line"><span class="function">status <span class="title">StrEmpty</span><span class="params">(SString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//判断S是否为空串</span></span><br><span class="line">	<span class="keyword">if</span> (S[<span class="number">0</span>] == <span class="number">0</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出串</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">StrPrint</span><span class="params">(SString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//输出字符串T</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= T[<span class="number">0</span>]; i++)</span><br><span class="line">		cout &lt;&lt; T[i];</span><br><span class="line">	cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回串的元素个数</span></span><br><span class="line"><span class="function">status <span class="title">Strlength</span><span class="params">(SString S)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//返回串的元素个数</span></span><br><span class="line">	<span class="keyword">return</span> S[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将串清空</span></span><br><span class="line"><span class="function">status <span class="title">ClearString</span><span class="params">(SString S)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">//将S清为空串 </span></span><br><span class="line">	S[<span class="number">0</span>] = <span class="number">0</span>;              <span class="comment">/* 直接令串长为零 */</span></span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将串S复制到串T中</span></span><br><span class="line"><span class="function">status <span class="title">StrCopy</span><span class="params">(SString&amp; T, SString&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//由串S复制得串T</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= S[<span class="number">0</span>]; i++)</span><br><span class="line">		T[i] = S[i];</span><br><span class="line">	T[<span class="number">0</span>] = S[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//比较串S和串T</span></span><br><span class="line"><span class="comment">//若S &gt; T, 则返回值 &gt; 0; 若S = T, 则返回值 = 0; 若S &lt; T, 则返回值 &lt; 0</span></span><br><span class="line"><span class="function">status <span class="title">StrCompare</span><span class="params">(SString S, SString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">StrEmpty</span>(S) || <span class="built_in">StrEmpty</span>(T)) <span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= S[<span class="number">0</span>] &amp;&amp; i &lt;= T[<span class="number">0</span>]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (S[i] != T[i]) <span class="keyword">return</span> S[i] - T[i];    <span class="comment">//如果不相等，直接返回不相等的值的相减</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> S[<span class="number">0</span>] - T[<span class="number">0</span>];                          <span class="comment">//如果字符全部相等，返回他们字符长度的差值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除串中第pos个字符起长度为len的子串</span></span><br><span class="line"><span class="function">status <span class="title">StrDelete</span><span class="params">(SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 从串S中删除第pos个字符起长度为len的子串 </span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">0</span> || pos&gt;S[<span class="number">0</span>] - len + <span class="number">1</span> || len &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">for</span> (i = pos + len; i &lt;= S[<span class="number">0</span>]; i++)</span><br><span class="line">		S[i - len] = S[i];</span><br><span class="line">	S[<span class="number">0</span>] -= len;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在串的第pos个字符之后插入串T</span></span><br><span class="line"><span class="function">status <span class="title">StrInsert</span><span class="params">(SString&amp; S, <span class="type">int</span> pos, SString T)</span></span></span><br><span class="line"><span class="function"></span>&#123;  <span class="comment">//在串S的第pos个字符之后插入串T。完全插入返回TRUE, 部分插入返回FALSE</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (pos&lt;<span class="number">1</span> || pos&gt;MAXSTRLEN) <span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">if</span> (S[<span class="number">0</span>] + T[<span class="number">0</span>] &lt;= MAXSTRLEN)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = S[<span class="number">0</span>]; i &gt;= pos; i--)</span><br><span class="line">			S[i + T[<span class="number">0</span>]] = S[i];</span><br><span class="line">		<span class="keyword">for</span> (i = pos; i &lt; pos + T[<span class="number">0</span>]; i++)</span><br><span class="line">			S[i] = T[i - pos + <span class="number">1</span>];</span><br><span class="line">		S[<span class="number">0</span>] = S[<span class="number">0</span>] + T[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;  <span class="comment">//部分插入</span></span><br><span class="line">		<span class="keyword">for</span> (i = MAXSTRLEN; i &gt;= pos + T[<span class="number">0</span>]; i--)</span><br><span class="line">			S[i] = S[i - T[<span class="number">0</span>]];</span><br><span class="line">		<span class="keyword">for</span> (i = pos; i &lt; pos + T[<span class="number">0</span>]; i++)</span><br><span class="line">			S[i] = T[i - pos + <span class="number">1</span>];</span><br><span class="line">		S[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回串中第pos个字符起，长度为len的子串</span></span><br><span class="line"><span class="function">status <span class="title">SubString</span><span class="params">(SString&amp; Sub, SString S, <span class="type">int</span> pos, <span class="type">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//求串S中第pos个字符起，长度为len的子串</span></span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (pos &lt; <span class="number">1</span> || pos &gt; S[<span class="number">0</span>] || len &lt; <span class="number">0</span> || pos + len - <span class="number">1</span> &gt; S[<span class="number">0</span>])</span><br><span class="line">		<span class="keyword">return</span> ERROR;</span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		Sub[i] = S[pos+i<span class="number">-1</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	Sub[<span class="number">0</span>] = len;</span><br><span class="line">	<span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//联接两个串组成新串</span></span><br><span class="line"><span class="function">status <span class="title">Concat</span><span class="params">(SString&amp; T, SString s1, SString s2)</span></span></span><br><span class="line"><span class="function"><span class="comment">//两串用T返回S1和S2联接而成的新串。若未截断，则返回TRUE，否则FALSE</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">	<span class="keyword">if</span> (s1[<span class="number">0</span>] + s2[<span class="number">0</span>] &lt;= MAXSTRLEN)  <span class="comment">//串一和串二长度的总和小于主串的最大容量,未截断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= s1[<span class="number">0</span>]; i++)     T[i] = s1[i];</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= s2[<span class="number">0</span>]; i++)     T[s1[<span class="number">0</span>] + i] = s2[i];</span><br><span class="line">		T[<span class="number">0</span>] = s1[<span class="number">0</span>] + s2[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">return</span> TRUE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (s1[<span class="number">0</span>] &lt; MAXSTRLEN)    <span class="comment">//两串的长度的总和超过最大容量，串一未超过,串二被截断</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= s1[<span class="number">0</span>]; i++)   T[i] = s1[i];</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; MAXSTRLEN - s1[<span class="number">0</span>]; i++)  T[s1[<span class="number">0</span>] + i] = s2[i];</span><br><span class="line">		T[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span>                         <span class="comment">//两串均超过最大容量，均被截断，取串一中的元素</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= MAXSTRLEN; i++)   T[i] = s1[i];</span><br><span class="line">		T[<span class="number">0</span>] = MAXSTRLEN;</span><br><span class="line">		<span class="keyword">return</span> FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//串的定长顺序存储表示，SString[0]用来存储串的元素个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">串的实际长度只能小于等于MAXLEN，超过预定义长度的串值会被舍去，称为截断。</span></span><br><span class="line"><span class="comment">顺序存储，例如串S=”sjjg”，其中从S.ch[0]开始存放串，最后以字符’/0’来表示串值的结束，如下图：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="2、堆分配存储表示"><a href="#2、堆分配存储表示" class="headerlink" title="2、堆分配存储表示"></a>2、堆分配存储表示</h4><p>堆分配存储表示仍然以一组地址连续的存储单元存放串值的字符序列，但它们的存储空间是在程序执行过程中动态分配得到的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">char</span> *ch;	<span class="comment">//按串长分配存储区，ch指向串的基地址</span></span><br><span class="line">	<span class="type">int</span> length;	<span class="comment">//串的长度</span></span><br><span class="line">&#125;HString;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="3、块链存储表示"><a href="#3、块链存储表示" class="headerlink" title="3、块链存储表示"></a>3、块链存储表示</h4><p>类似于线性表的链式存储结构，也可采用链表方式存储串值。由于串的特殊性(每个元素只有一个字符)，在具体实现时，每个结点既可以存放一个字符， 也可以存放多个字符。每个结点称为块，整个链表称为块链结构。</p>
<h3 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h3><p>子串的定位操作是找子串在主串中从第pos个字符后首次出现的位置，又被称为串的模式匹配</p>
<h4 id="一、BF模式匹配算法"><a href="#一、BF模式匹配算法" class="headerlink" title="一、BF模式匹配算法"></a>一、BF模式匹配算法</h4><p>BF算法思想:Brute-Force算法又称蛮力匹配算法(简称BF算法),从主串S的第pos个字符开始，和模式串T的第一个字符进行比较，若相等，则继续比较后续字符；否则回溯到主串S的第pos+1个字符开始重新和模式串T进行比较。以此类推，直至模式串T中的每一个字符依次和主串S中的一个连续的字符序列相等，则称模式匹配成功，此时返回模式串T的第一个字符在主串S中的位置；否则主串中没有和模式串相等的字符序列，称模式匹配不成功。</p>
<ul>
<li>算法分析:</li>
<li><ul>
<li>BF算法的思想比较简单，但当在最坏情况下，算法的时间复杂度为O(n*m),其中n和m分别是主串和模式串的长度。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">第一轮：子串中的第一个字符与主串中的第一个字符进行比较</span></span><br><span class="line"><span class="comment">若相等，则继续比较主串与子串的第二个字符</span></span><br><span class="line"><span class="comment">若不相等，进行第二轮比较</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">第二轮：子串中的第一个字符与主串中第二个字符进行比较......</span></span><br><span class="line"><span class="comment">第N轮：依次比较下去，直到全部匹配</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ViolentMatch</span><span class="params">(<span class="type">char</span>* s, <span class="type">char</span>* p)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> sLen = <span class="built_in">strlen</span>(s);  </span><br><span class="line">    <span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);  </span><br><span class="line">  </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;  </span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (i &lt; sLen &amp;&amp; j &lt; pLen)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s[i] == p[j])  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//①如果当前字符匹配成功（即S[i] == P[j]），则i++，j++      </span></span><br><span class="line">            i++;  </span><br><span class="line">            j++;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//②如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0      </span></span><br><span class="line">            i = i - j + <span class="number">1</span>;  </span><br><span class="line">            j = <span class="number">0</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//匹配成功，返回模式串p在文本串s中的位置，否则返回-1  </span></span><br><span class="line">    <span class="keyword">if</span> (j == pLen)  </span><br><span class="line">        <span class="keyword">return</span> i - j;  </span><br><span class="line">    <span class="keyword">else</span>  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>这种算法简单易懂，却存在着一个很大的缺点，那就是需要多次回溯，效率低下，若主串为 000000000001 子串为00001，这就意味着每一轮都要比较到子串的最后一个字符才会匹配失败，有没有更好的办法呢？下面的KMP模式匹配算法就很好的解决了这一问题</p>
</blockquote>
<h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><p>Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP算法”，常用于在一个文本串S内查找一个模式串P 的出现位置，这个算法由Donald Knuth、Vaughan Pratt、James H. Morris三人于1977年联合发表，故取这3人的姓氏命名此算法。</p>
<p>朴素模式匹配算法，主串的 i 值会不断的进行回溯，但是 KMP模式匹配算法：</p>
<ul>
<li><blockquote>
<p>KMP 方法算法就利用之前判断过的信息，通过一个 next 数组，保存模式串中前后最长公共子序列的长度，每次回溯时，通过 next 数组找到，前面匹配过的位置，省去了大量的计算时间。</p>
</blockquote>
</li>
</ul>
<p>将这种没必要的回溯省略掉了，所以减少了执行次数</p>
<blockquote>
<p>什么是最长公共前后缀<br>字符串的前缀是指不包含最后一个字符的所有以第一个字符（索引为0）开头的连续子串</p>
<p>比如字符串 “ABABA” 的前缀有：A，AB，ABA，ABAB</p>
<p>字符串的后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串</p>
<p>比如字符串 “ABABA” 的后缀有：BABA，ABA，BA，A</p>
<p>公共前后缀：一个字符串的 所有前缀连续子串 和 所有后缀连续子串 中相等的子串</p>
<p>比如字符串 “ABABA”</p>
<p>前缀有：A，AB，ABA，ABAB<br>后缀有：BABA，ABA，BA，A<br>因此公共前后缀有：A ，ABA</p>
<p>最长公共前后缀：所有公共前后缀 的 长度最长的 那个子串</p>
<p>比如字符串 “ABABA” ，公共前后缀有：A ，ABA</p>
<p>由于 ABA 是 三个字符长度，A 是一个字符长度，那么最长公共前后缀就是 ABA</p>
<p>再比如说一个字符串 str = “ABCABD”</p>
<p>对于str从 索引为0 开始的子串 “A” 而言：</p>
<p>前缀：不包含最后一个字符A的 所有以第一个字符A开头 的 连续子串 不存在<br>后缀：不包含第一个字符A 的 所有以最后一个字符A结尾 的 连续子串 不存在<br>因此该子串的最长公共前后缀 为 0</p>
<p>对于str从 索引为0 开始的子串 “AB” 而言：</p>
<p>前缀：不包含 最后一个字符B 的 所有以第一个字符A开头 的 连续子串 有 —— “A”<br>后缀：不包含 第一个字符A 的 所有以最后一个字符B结尾 的 连续子串 有 —— “B”<br>因此该子串的最长公共前后缀 为 0</p>
<p>对于str从 索引为0 开始的子串 “ABC” 而言：</p>
<p>前缀：不包含 最后一个字符C 的 所有以第一个字符A开头 的 连续子串 有 —— “A”，“AB”<br>后缀：不包含 第一个字符A 的 所有以最后一个字符C 结尾 的 连续子串有 —— “BC”，“C”<br>前缀与后缀的连续子串不存在相同的，因此该子串的最长公共前后缀 为 0</p>
<p>对于str从 索引为0 开始的子串 “ABCA” 而言：</p>
<p>前缀：不包含 最后一个字符A 的 所有以第一个字符A开头 的 连续子串 有 —— “A”，“AB”，“ABC”<br>后缀：不包含 第一个字符A 的 所有以最后一个字符A 结尾 的 连续子串有 —— “BCA”，“CA”，“A”<br>前缀与后缀的连续子串中存在相同且最长的子串 A，因此该子串的最长公共前后缀 为 1</p>
<p>对于str从 索引为0 开始的子串 “ABCAB” 而言：</p>
<p>前缀：不包含 最后一个字符B 的 所有以第一个字符A开头 的 连续子串 有 —— “A”，“AB”，“ABC”，“ABCA”<br>后缀：不包含 第一个字符A 的 所有以最后一个字符B 结尾 的 连续子串有 —— “BCAB”，“CAB”，“AB”，“B”<br>前缀与后缀的连续子串中存在相同且最长的子串 AB，因此该子串的最长公共前后缀 为 2</p>
<p>对于str从 索引为0 开始的子串 “ABCABD” 而言：</p>
<p>前缀：不包含 最后一个字符D 的 所有以第一个字符A开头 的 连续子串 有 —— “A”，“AB”，“ABC”，“ABCA”，“ABCAB”<br>后缀：不包含 第一个字符A 的 所有以最后一个字符D 结尾 的 连续子串有 —— “BCABD”，“CABD”，“ABD”，“BD”，“D”<br>前缀与后缀的连续子串不存在相同的，因此该子串的最长公共前后缀 为 0<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_62982856/article/details/128003067">https://blog.csdn.net/qq_62982856/article/details/128003067</a></p>
<p>因此kmp算法本质是求解两次最长公共前后缀的过程。</p>
<p>正常的算法是暴力，然后i，j开始匹配，不相同回溯，i回溯到1，j回溯到0，简单粗暴，时间复杂度高，算法时间复杂度很高。</p>
<p>优化就是大名鼎鼎的kmp算法。</p>
<p>利用匹配失败后的信息，尽量减少模式串与主串的匹配次数。</p>
<p>前置知识：</p>
<p>前缀集合</p>
<p>后缀集合。</p>
<p>kmp算法中不回溯i，只回溯j。</p>
<p>a子串的后缀与b子串的前缀集合相等时候就可以</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 1000010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> kmp[N];</span><br><span class="line"><span class="type">int</span> la,lb,j; </span><br><span class="line">string a;</span><br><span class="line">string b;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    cin&gt;&gt;b;</span><br><span class="line">    a=<span class="string">&quot; &quot;</span>+a;</span><br><span class="line">    b=<span class="string">&quot; &quot;</span>+b;</span><br><span class="line">    la=a.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    lb=b.<span class="built_in">length</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>;i&lt;=lb;i++)</span><br><span class="line">	   &#123;     </span><br><span class="line">	   <span class="keyword">while</span>(j&amp;&amp;b[i]!=b[j+<span class="number">1</span>])</span><br><span class="line">        j=kmp[j];     </span><br><span class="line">       <span class="keyword">if</span>(b[j+<span class="number">1</span>]==b[i])j++;    </span><br><span class="line">        kmp[i]=j;</span><br><span class="line">       &#125;</span><br><span class="line">    j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=la;i++)</span><br><span class="line">	   &#123;</span><br><span class="line">          <span class="keyword">while</span>(j&gt;<span class="number">0</span>&amp;&amp;b[j+<span class="number">1</span>]!=a[i])</span><br><span class="line">           j=kmp[j];</span><br><span class="line">          <span class="keyword">if</span> (b[j+<span class="number">1</span>]==a[i]) </span><br><span class="line">           j++;</span><br><span class="line">          <span class="keyword">if</span> (j==lb) </span><br><span class="line">		  &#123;</span><br><span class="line">		  cout&lt;&lt;i-lb+<span class="number">1</span>&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">		  j=kmp[j];</span><br><span class="line">		  &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=lb;i++)</span><br><span class="line">    cout&lt;&lt;kmp[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/Real_Fool_/article/details/113930623">数据结构：树(Tree)【详解】_数据结构 树-CSDN博客</a></p>
<p>存储的是具有“一对多”关系的数据元素的集合。</p>
<h4 id="1、树的定义"><a href="#1、树的定义" class="headerlink" title="1、树的定义"></a>1、树的定义</h4><blockquote>
<p>树是n（n&gt;=0）个结点的有限集。当n = 0时，称为空树。在任意一棵非空树中应满足：</p>
<ol>
<li>有且仅有一个特定的称为根的结点。</li>
<li>当n&gt;1时，其余节点可分为m（m&gt;0）个互不相交的有限集T1,T2,…,Tm，其中每个集合本身又是一棵树，并且称为根的子树。</li>
</ol>
</blockquote>
<p>树天生适合递归。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20240211011754677.png" alt="image-20240211011754677"></p>
<blockquote>
<ol>
<li>树的根结点没有前驱，除根结点外的所有结点有且只有一个前驱。</li>
<li>树中所有结点可以有零个或多个后继。</li>
<li>结点：使用树结构存储的每一个数据元素都被称为“结点”。</li>
<li>父结点（双亲结点）、子结点和兄弟结点</li>
<li>孩子结点：结点的直接后继</li>
<li>双亲结点：结点的直接前驱</li>
<li>兄弟结点：同一双亲结点的孩子结点互称兄弟结点</li>
<li>树根结点（简称“根结点”）：每一个非空树都有且只有一个被称为根的结点。树根的判断依据为：如果一个结点没有父结点，那么这个结点就是整棵树的根结点。</li>
<li>叶子结点：如果结点没有任何子结点，那么此结点称为叶子结点（叶结点）</li>
<li>空树：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。</li>
<li>树是由根结点和若干棵子树构成的。</li>
<li>对于一个结点，拥有的子树数（结点有多少分支）称为结点的度（Degree）。如图度最大值为3</li>
<li>结点的层次：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。一棵树的深度（高度）是树中结点所在的最大的层次。</li>
<li>如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树。</li>
<li>由 m（m &gt;= 0）个互不相交的树组成的集合被称为森林。</li>
<li><strong>结点的深度</strong>是从根结点开始自顶向下逐层累加的。<br><strong>结点的高度</strong>是从叶结点开始自底向上逐层累加的。</li>
<li>树的高度和深度是树中结点的最大层数。</li>
<li>路径和路径长度。树中两个结点之间的<strong>路径</strong>是由这两个结点之间所经过的结点序列构成的,而<strong>路径长度</strong>是路径上所经过的边的个数。</li>
<li>二叉树：有限的结点的集合，由根结点和不相交的二叉子树组成</li>
<li>二叉树是每个节点最多有两个子树的树结构。它有五种基本形态：二叉树可以是空集；根可以有空的左子树或右子树；或者左、右子树皆为空。</li>
<li><strong>n个结点的树中有n-1条边</strong></li>
</ol>
</blockquote>
<p>满足以下两个条件的树形结构叫做二叉树：</p>
<blockquote>
<ul>
<li>每个结点至多只有两棵子树</li>
<li>二叉树的子树有左右之分，其次序不能颠倒。树可以有序可以无序</li>
</ul>
<h3 id="树的性质"><a href="#树的性质" class="headerlink" title="树的性质"></a>树的性质</h3><p>树具有如下基本的性质：<br>1）树中的结点数 = 所有结点的度数 + 1<br>  这个很容易理解：每个结点的度数 = 孩子结点的个数，最后再加上根结点，就是树中的结点数了。</p>
<p>2）度为m的树中，第i层上至多有m（i-1）方个结点<br>  求最多的结点数，那么每个结点的度均为m。<br>  第 i 层上的结点数 = 第 i-1 层结点的度数，也就是m<em>(第 i-1 层的结点个数) = m</em>m<em>(第 i-2 层的结点个数) = … = mi-1</em>（第1层的结点数）= mi-1（共乘了i次）。</p>
<p>3）高度为h的m叉树至多有(mh-1)/(m-1)个结点<br>  由树的上个性质可知，m叉树第 i 层至多有mi-1个结点。那么高度为h的m叉树的结点数至多：<br>  S = mh-1 + mh-2 + mh-3 + … + m + 1 = (mh-1)/(m-1)<br>  该树现在是个满m叉树。</p>
<p>等比数列求和即可</p>
<p>4）具有n个结点的m叉树的最小高度为⌈logm(n(m-1)+1)⌉<br>  求最小高度也就是每层结点数最多时的高度，即该树是一棵完全m叉树，设其高度为h。<br>  由树的第4个性质，有 n ≤ (mh-1)/(m-1)，解得 h ≥ logm(n(m-1)+1) 。<br>  故h为⌈logm(n(m-1)+1)⌉。<br>  另外，实际上有 (mh-1-1)/(m-1) +1≤ n ≤ (mh-1)/(m-1)，故最小高度h也可以为 ⌊logm((n-1)(m-1)+1)⌋ + 1。</p>
<h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><p><strong>性质1：在二叉树的第i层上至多有2的(i-1)次方个结点（i&gt;=1）。</strong></p>
<p><strong>性质2：深度为k的二叉树至多有2（k）-1次方个结点（k&gt;=1）。</strong></p>
<h3 id="性质3：具有n个结点的完全二叉树的深度为-log2-n-1"><a href="#性质3：具有n个结点的完全二叉树的深度为-log2-n-1" class="headerlink" title="性质3：具有n个结点的完全二叉树的深度为|log2(n)| + 1"></a>性质3：具有n个结点的完全二叉树的深度为|log2(n)| + 1</h3><h3 id="性质4：包含n个结点的二叉树的高度至少为log2-n-1-。"><a href="#性质4：包含n个结点的二叉树的高度至少为log2-n-1-。" class="headerlink" title="性质4：包含n个结点的二叉树的高度至少为log2 (n+1)。"></a><strong>性质4</strong>：包含n个结点的二叉树的高度至少为<strong>log2 (n+1)</strong>。</h3><p><strong>性质5：在任意一棵二叉树中，若终端结点的个数为n0，度为2的结点数为n2，则n0=n2+1</strong></p>
<p>n=n0+n1+n2</p>
<p>n=n1+2n2+1</p>
<p>即可</p>
</blockquote>
<h3 id="满二叉树与完全二叉树"><a href="#满二叉树与完全二叉树" class="headerlink" title="满二叉树与完全二叉树"></a>满二叉树与完全二叉树</h3><blockquote>
<p>满二叉树：每层结点均满，每层均具有最大结点数，又称完美二叉树</p>
<p>除最后一层无任何子<a href="https://link.zhihu.com/?target=https%3A//baike.baidu.com/item/%E8%8A%82%E7%82%B9">节点</a>外，每一层上的所有结点都有两个子结点二叉树。</p>
<p>　　国内教程定义：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树。也就是说，如果一个二叉树的层数为K，且结点总数是(2^k) -1 ，则它就是满二叉树。</p>
<p>　　国外(国际)定义:a binary tree T is full if each node is either a leaf or possesses exactly two childnodes.大意为：如果一棵二叉树的结点要么是叶子结点，要么它有两个孩子结点，这样的树就是满二叉树。</p>
<p>1、第i+1层的节点数为2^i</p>
<p>2、如果完美二叉树高度为n，那么总的节点数为2^n - 1</p>
<p>3、如果完美二叉树中叶子节点为m，非终端节点为k，那么m=k+1</p>
<p>4、如果完美二叉树中某节点下标为n，那么它的左节点下标为2n，右节点下标为2n+1</p>
</blockquote>
<ul>
<li>完全二叉树：与满二叉树的编号对应，但不要求每层均具有最大结点数</li>
</ul>
<blockquote>
<p>完全二叉树是由满二叉树而引出来的，若设二叉树的<code>深度为h</code>，<code>除第 h 层外</code>，<code>其它各层 (1～h-1) 的结点数都达到最大个数(即1~h-1层为一个满二叉树)</code>，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。</p>
<ul>
<li>若一棵二叉树至多只有最下面两层的结点的度数可以小于2，并且最下层的结点都集中在该层最左边的若干位置上，则此二叉树为完全二叉树。</li>
<li>若i为奇数且i&gt;1，那么tree[i]的左兄弟为tree[i-1]； </li>
<li>若i为偶数且i&lt;n，那么tree[i]的右兄弟为tree[i+1]；</li>
<li>若i&gt;n/2，那么tree[i]为叶子结点</li>
<li>若i&lt;(n-1)/2，那么tree必有两个孩子</li>
<li>完全二叉树第i层至多有2^(i-1)个节点，共i层的完全二叉树最多有2^i-1个节点。</li>
</ul>
</blockquote>
<p>区别于联系：满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树</p>
<p><strong>二叉查找树</strong>，<strong>二叉搜索树、二叉排序树、BST</strong></p>
<p><strong>定义</strong>：二叉查找树(Binary Search Tree)，又被称为二叉搜索树。设x为二叉查找树中的一个结点，x节点包含关键字key，节点x的key值记为key[x]。如果y是x的左子树中的一个结点，则key[y] &lt;= key[x]；如果y是x的右子树的一个结点，则key[y] &gt;= key[x]。</p>
<blockquote>
<p>在二叉查找树中：<br>(01) 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>(02) 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>(03) 任意节点的左、右子树也分别为二叉查找树。<br>(04) 没有键值相等的节点（no duplicate nodes）。</p>
</blockquote>
<h3 id="斜树"><a href="#斜树" class="headerlink" title="斜树"></a>斜树</h3><p>所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p>
<h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>树上任一结点的左子树和右子树的深度之差不超过1。</p>
<p>平衡二叉树必定是二叉搜索树。</p>
<p><strong>霍夫曼树</strong></p>
<blockquote>
<p>带权路径最短的二叉树称为哈夫曼树或最优二叉树。</p>
</blockquote>
<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><p><strong>顺序存储结构</strong></p>
<p><strong>链式存储结构</strong></p>
<p>主要有：</p>
<p><1> 双亲表示法<br> <2> 孩子表示法<br> <3> 孩子兄弟表示法</3></2></1></p>
<p>双亲表示法</p>
<p>采用<strong>一组连续空间</strong>来存储每个结点。</p>
<p><strong>根节点没有双亲</strong>，所以其在数组中存储的值为<strong>-1</strong>。</p>
<p><strong>其余的节点</strong>，只需要存储其父节点<strong>对应的数组下标即可</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/20210222174500547.png" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 100  <span class="comment">//树中最多结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;  <span class="comment">//树的结点定义</span></span><br><span class="line">    <span class="type">char</span> data;  <span class="comment">//数据元素</span></span><br><span class="line">    <span class="type">int</span> parent;  <span class="comment">//双亲位置域</span></span><br><span class="line">&#125;PTNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;  <span class="comment">//树的类型定义</span></span><br><span class="line">    PTNode nodes[MaxSize];  <span class="comment">//双亲表示</span></span><br><span class="line">    <span class="type">int</span> n;  <span class="comment">//结点数</span></span><br><span class="line">&#125;PTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>孩子表示法</p>
<p>将每个节点的孩子节点都用单链表连接起来形成一个线性结构，n个节点具有n个孩子链表。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 孩子表示法</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_SIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CNode</span> *next;</span><br><span class="line">&#125;CNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">PNode</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">CNode</span> *child;</span><br><span class="line">&#125;PNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">CTree</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode nodes[MAX_SIZE];</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">&#125;CTree;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>孩子兄弟表示法</p>
<p><strong>任意一棵树， 它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。 因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/20210222181409121.png" alt="在这里插入图片描述"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *FirstChild;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> *NextBrother;</span><br><span class="line">    </span><br><span class="line">&#125;Node,TREE;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p>
<p>二叉树的定义是递归式的。因此后续基本操作中，我们基本都是按照该概念来实现的</p>
<blockquote>
<p>四种主要的遍历思想为：</p>
<p>前序遍历：根结点 —-&gt; 左子树 —-&gt; 右子树</p>
<p>中序遍历：左子树—-&gt; 根结点 —-&gt; 右子树</p>
<p>后序遍历：左子树 —-&gt; 右子树 —-&gt; 根结点</p>
<p>层次遍历：只需按层次遍历即可</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前置</span></span><br><span class="line"><span class="comment">//递归建树</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//结构体的封装</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">BiTree</span>&#123;</span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">BiTree</span> *leftchild,*rightchild;</span><br><span class="line">&#125;BiTree;</span><br><span class="line"><span class="comment">//先序建立二叉树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CreateTree</span><span class="params">(BiTree *&amp;T)</span></span>&#123;</span><br><span class="line">    <span class="type">char</span> x;</span><br><span class="line">cin&gt;&gt;x;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="string">&#x27;#&#x27;</span>) T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTree;</span><br><span class="line">        T-&gt;data=x;</span><br><span class="line">        <span class="built_in">CreateTree</span>(T-&gt;leftchild);</span><br><span class="line">        <span class="built_in">CreateTree</span>(T-&gt;rightchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">visit</span>(T);	<span class="comment">//访问根节点</span></span><br><span class="line">		<span class="built_in">PreOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">		<span class="built_in">PreOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">InOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">		<span class="built_in">visit</span>(T);	<span class="comment">//访问根结点</span></span><br><span class="line">		<span class="built_in">InOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//力扣版本</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorder</span><span class="params">(TreeNode* root, vector&lt;<span class="type">int</span>&gt;&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;left, res);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="built_in">inorder</span>(root-&gt;right, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">inorder</span>(root, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PostOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="built_in">PostOrder</span>(T-&gt;lchild);	<span class="comment">//递归遍历左子树</span></span><br><span class="line">		<span class="built_in">PostOrder</span>(T-&gt;rchild);	<span class="comment">//递归遍历右子树</span></span><br><span class="line">		<span class="built_in">visit</span>(T);	<span class="comment">//访问根结点</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">LevelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">	<span class="built_in">InitQueue</span>(Q);	<span class="comment">//初始化辅助队列</span></span><br><span class="line">	BiTree p;</span><br><span class="line">	<span class="built_in">EnQueue</span>(Q, T);	<span class="comment">//将根节点入队</span></span><br><span class="line">	<span class="keyword">while</span>(!<span class="built_in">IsEmpty</span>(Q))&#123;	<span class="comment">//队列不空则循环</span></span><br><span class="line">		<span class="built_in">DeQueue</span>(Q, p);	<span class="comment">//队头结点出队</span></span><br><span class="line">		<span class="built_in">visit</span>(p);	<span class="comment">//访问出队结点</span></span><br><span class="line">		<span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">EnQueue</span>(Q, p-&gt;lchild);	<span class="comment">//左子树不空，则左子树根节点入队</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">EnQueue</span>(Q, p-&gt;rchild);	<span class="comment">//右子树不空，则右子树根节点入队</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/134184036">#图解 数据结构：轻松搞定线索二叉树 - 知乎 (zhihu.com)</a></p>
<p>（几乎完全抄袭）</p>
<p>背景来源：</p>
<blockquote>
<ul>
<li><p>在n个结点的二叉树中，必定有n+1个空链域（叶子结点的左右子树空间浪费了）</p>
<p>解释：</p>
<p>在N个节点的二叉树中，每个节点有2个指针，所以一共有2N个指针，除了根节点以外，每一个节点都有一个指针从它的父节点指向它，所以一共使用了N-1个指针，所以剩下2N-(N-1)也就是N+1个空指针；</p>
</li>
<li><p>二叉树的遍历，无论是递归还是非递归算法，效率都不算高。</p>
</li>
</ul>
<p>而知道了“前驱”和“后继”信息，就可以把二叉树看作一个<strong>链表结构</strong>，从而可以像遍历链表那样来遍历二叉树，<strong>进而提高效率</strong>。<strong>线索化</strong> ——引出</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/v2-3323632a025312529a6394f2db1287c6_720w.png" alt="img"></p>
<p>核心：所有<strong>原本为空的右(孩子)指针</strong>改为<strong>指向该节点在中序序列中的后继</strong>，所有原本为空的左(孩子)指针改为指向该节点的中序序列的前驱。</p>
<p>定义以下规则：</p>
<ol>
<li><p>ltag=0<strong>，表示指向节点的</strong>左孩子。</p>
</li>
<li><p>ltag=1<strong>，则表示</strong>lchild为线索<strong>，指向节点的</strong>直接前驱**</p>
</li>
<li><p>rtag=0<strong>，表示指向节点的</strong>右孩子。</p>
</li>
<li><p>rtag=1<strong>，则表示</strong>rchild为线索<strong>，指向节点的</strong>直接后继**</p>
<blockquote>
<p>这种指向前驱和后继的<strong>指针</strong>称为<strong>线索</strong>，加上了线索的二叉树就是线索二叉树；</p>
</blockquote>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TBNode</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> data;</span><br><span class="line">	<span class="type">int</span> ltag,rtag;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TBNode</span> *lchild;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">TBNode</span> *rchild;</span><br><span class="line">	</span><br><span class="line">&#125;TBNode;</span><br></pre></td></tr></table></figure>
<p>实现思路：按某种次序遍历二叉树，在遍历过程中用线索取代空指针即可。</p>
<h2 id="中序线索二叉树"><a href="#中序线索二叉树" class="headerlink" title="中序线索二叉树"></a>中序线索二叉树</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20240212005342768.png" alt="image-20240212005342768"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">Thread</span>* left_node, *right_node;<span class="comment">//左右指针</span></span><br><span class="line">	<span class="type">int</span> data;<span class="comment">//需要存放的数据</span></span><br><span class="line">	<span class="comment">/*默认0代表左右孩子 1代表前驱或者后继*/</span></span><br><span class="line">	<span class="type">int</span> left_type;<span class="comment">//类型标志</span></span><br><span class="line">	<span class="type">int</span> right_type;<span class="comment">//类型标志</span></span><br><span class="line">&#125;Node;</span><br><span class="line"> </span><br><span class="line">Node* pre;<span class="comment">//前驱结点的变量</span></span><br><span class="line">Node* head;<span class="comment">//头指针 指向某种遍历的第一个结点</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderThreadTree</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//如果当前结点为NULL 直接返回</span></span><br><span class="line">	<span class="keyword">if</span> (node == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//先处理左子树</span></span><br><span class="line">	<span class="built_in">inOrderThreadTree</span>(node-&gt;left_node);</span><br><span class="line">	<span class="keyword">if</span> (node-&gt;left_node == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//设置前驱结点</span></span><br><span class="line">		node-&gt;left_type = <span class="number">1</span>;</span><br><span class="line">		node-&gt;left_node = pre;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//如果结点的右子节点为NULL 处理前驱的右指针</span></span><br><span class="line">	<span class="keyword">if</span> (pre !=<span class="literal">NULL</span> &amp;&amp; pre-&gt;right_node == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//设置后继</span></span><br><span class="line">		pre-&gt;right_node = node;</span><br><span class="line">		pre-&gt;right_type = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//每处理一个节点 当前结点是下一个节点的前驱</span></span><br><span class="line">	pre = node;</span><br><span class="line">	<span class="comment">//最后处理右子树</span></span><br><span class="line">	<span class="built_in">inOrderThreadTree</span>(node-&gt;right_node);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrderTraverse</span><span class="params">(Node* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//从根节点开始先找到最左边</span></span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	Node* temp = root;</span><br><span class="line">	<span class="comment">//先找到最左边结点 然后根据线索化直接向右遍历</span></span><br><span class="line">	<span class="keyword">while</span> (temp != <span class="literal">NULL</span> &amp;&amp; temp-&gt;left_type == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		temp = temp-&gt;left_node;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (temp != <span class="literal">NULL</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//输出</span></span><br><span class="line">		temp = temp-&gt;right_node;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="树二叉树的转化"><a href="#树二叉树的转化" class="headerlink" title="树二叉树的转化"></a>树二叉树的转化</h3><h4 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h4><blockquote>
<p>树转换为二义树的规则:每个结点左指针指向它的第一个孩子，右指针指向它在树中的相邻右兄弟，这个规则又称“左孩子右兄弟”。由于根结点没有兄弟，所以对应的二叉树没有右子树。</p>
</blockquote>
<p>森林实际同理，只是把每一颗树当成兄弟，除此无别</p>
<h3 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h3><p>树的遍历的定义：以某种方式访问树中的每一个结点，且仅访问一次。<br>树的遍历主要有先根遍历和后根遍历。</p>
<p>先根遍历：若树非空，则先访问根结点，再按照从左到右的顺序遍历根结点的每一棵子树。这个访问顺序与这棵树对应的二叉树的先序遍历顺序相同。</p>
<p>后根遍历：若树非空，则按照从左到右的顺序遍历根结点的每一棵子树，之后再访问根结点。其访问顺序与这棵树对应的二叉树的中序遍历顺序相同。</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>二叉搜索树（BST，Binary Search Tree），也称二叉排序树或二叉查找树。<br>二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质：</p>
<ol>
<li>非空左子树的所有键值小于其根结点的键值。</li>
<li>非空右子树的所有键值大于其根结点的键值。</li>
<li>左、右子树都是二叉搜索树。</li>
</ol>
<p>结构</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TNode</span> *Position;</span><br><span class="line"><span class="keyword">typedef</span> Position BinTree; <span class="comment">/* 二叉树类型 */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TNode</span>&#123; <span class="comment">/* 树结点定义 */</span></span><br><span class="line">    ElementType Data; <span class="comment">/* 结点数据 */</span></span><br><span class="line">    BinTree Left;     <span class="comment">/* 指向左子树 */</span></span><br><span class="line">    BinTree Right;    <span class="comment">/* 指向右子树 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查找</p>
<p>递归版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( ElementType X, BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>( !BST ) <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/*查找失败*/</span></span><br><span class="line">	<span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Find</span>( X, BST-&gt;Right ); <span class="comment">/*在右子树中继续查找*/</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Find</span>( X, BST-&gt;Left ); <span class="comment">/*在左子树中继续查找*/</span></span><br><span class="line">	<span class="keyword">else</span> <span class="comment">/* X == BST-&gt;Data */</span></span><br><span class="line">		<span class="keyword">return</span> BST; <span class="comment">/*查找成功，返回结点的找到结点的地址*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>非递归版本</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">IterFind</span><span class="params">( ElementType X, BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">while</span>( BST ) </span><br><span class="line">	 &#123;</span><br><span class="line">		 <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">		 	BST = BST-&gt;Right; <span class="comment">/*向右子树中移动，继续查找*/</span></span><br><span class="line">		 <span class="keyword">else</span> <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">		 	BST = BST-&gt;Left; <span class="comment">/*向左子树中移动，继续查找*/</span></span><br><span class="line">		 <span class="keyword">else</span> <span class="comment">/* X == BST-&gt;Data */</span></span><br><span class="line">		 	<span class="keyword">return</span> BST; <span class="comment">/*查找成功，返回结点的找到结点的地址*/</span></span><br><span class="line">	 &#125;</span><br><span class="line">	 <span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/*查找失败*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查找最小值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">if</span>( !BST ) </span><br><span class="line">	 	<span class="keyword">return</span> <span class="literal">NULL</span>; <span class="comment">/*空的二叉搜索树，返回NULL*/</span></span><br><span class="line">	 <span class="keyword">else</span> <span class="keyword">if</span>( !BST-&gt;Left )</span><br><span class="line">	 	<span class="keyword">return</span> BST; <span class="comment">/*找到最左叶结点并返回*/</span></span><br><span class="line">	 <span class="keyword">else</span></span><br><span class="line">	 	<span class="keyword">return</span> <span class="built_in">FindMin</span>( BST-&gt;Left ); <span class="comment">/*沿左分支继续查找*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查找最大值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	 <span class="keyword">if</span>(BST )</span><br><span class="line">	 	<span class="keyword">while</span>( BST-&gt;Right )  <span class="comment">/*沿右分支继续查找，直到最右叶结点*/</span></span><br><span class="line">	 		BST = BST-&gt;Right;</span><br><span class="line">	 <span class="keyword">return</span> BST;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>插入：二叉搜索树在插入前，肯定要找到插入的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( !BST )&#123; <span class="comment">/* 若原树为空，生成并返回一个结点的二叉搜索树 */</span></span><br><span class="line">        BST =<span class="keyword">new</span> TNode;</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">/* 开始找要插入元素的位置 */</span></span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Left = <span class="built_in">Insert</span>( BST-&gt;Left, X );   <span class="comment">/*递归插入左子树*/</span></span><br><span class="line">        <span class="keyword">else</span>  <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Right = <span class="built_in">Insert</span>( BST-&gt;Right, X ); <span class="comment">/*递归插入右子树*/</span></span><br><span class="line">        <span class="comment">/* else X已经存在，什么都不做 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>删除：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    Position Tmp; </span><br><span class="line">    <span class="keyword">if</span>( !BST ) </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;要删除的元素未找到&quot;</span>); </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Left = <span class="built_in">Delete</span>( BST-&gt;Left, X );   <span class="comment">/* 从左子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &gt; BST-&gt;Data ) </span><br><span class="line">            BST-&gt;Right = <span class="built_in">Delete</span>( BST-&gt;Right, X ); <span class="comment">/* 从右子树递归删除 */</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; <span class="comment">/* BST就是要删除的结点 */</span></span><br><span class="line">            <span class="comment">/* 如果被删除结点有左右两个子结点 */</span> </span><br><span class="line">            <span class="keyword">if</span>( BST-&gt;Left &amp;&amp; BST-&gt;Right ) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/* 从右子树中找最小的元素填充删除结点 */</span></span><br><span class="line">                Tmp = <span class="built_in">FindMin</span>( BST-&gt;Right );</span><br><span class="line">                BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">                <span class="comment">/* 从右子树中删除最小元素 */</span></span><br><span class="line">                BST-&gt;Right = <span class="built_in">Delete</span>( BST-&gt;Right, BST-&gt;Data );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123; <span class="comment">/* 被删除结点有一个或无子结点 */</span></span><br><span class="line">                <span class="comment">//想象一下，如果删除的结点原来相对于父结点是左子树，而且它只有一个孩子结点，那这个孩子结点是不是一定会比当前结点的父亲结点小</span></span><br><span class="line">                <span class="comment">//同理，如果删除的结点原来相对于父结点是右子树，那么则大，因此直接指向子结点就是对的</span></span><br><span class="line">                Tmp = BST; </span><br><span class="line">                <span class="keyword">if</span>( !BST-&gt;Left )       <span class="comment">/* 只有右孩子或无子结点 */</span></span><br><span class="line">                    BST = BST-&gt;Right; </span><br><span class="line">                <span class="keyword">else</span>                   <span class="comment">/* 只有左孩子 */</span></span><br><span class="line">                    BST = BST-&gt;Left;</span><br><span class="line">                <span class="keyword">delete</span> Tmp ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>总结为：对于二叉排序树的查找，走的就是从根结点到要查找的结点的路径，其比较次数等于给定值的结点在二叉排序树的层数。因此取决于二叉搜索树的形状，不能太极端，不然无法近似为二分，因此我们希望构建出一颗平衡二叉树。</p>
<h2 id="平衡二叉树-1"><a href="#平衡二叉树-1" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>二叉搜索树一定程度上可以提高搜索效率，但是当原序列有序时，很容易使得二叉树退化成单链表，搜索效率降低为 O(n)。</p>
<p>毫无疑问</p>
<p>保持树的左右两端保持平衡，树的查找效率最高。</p>
<p>调平衡</p>
<p>平衡因子</p>
<p><strong>**定义：</strong>某节点的左子树与右子树的高度(深度)差即为该节点的平衡因子（BF,Balance Factor），平衡二叉树中不存在平衡因子大于 1 的节点。在一棵平衡二叉树中，节点的平衡因子只能取 0 、1 或者 -1 ，分别对应着左右子树等高，左子树比较高，右子树比较高。**</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20240212015251378.png" alt="image-20240212015251378"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20240212015327333.png" alt="image-20240212015327333"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20240212015403240.png" alt="image-20240212015403240"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20240212015508291.png" alt="image-20240212015508291"></p>
<p>实际上只有LL和RR</p>
<h4 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVLNode</span> *Tree;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">AVLNode</span>&#123;</span><br><span class="line">    <span class="type">int</span> depth; <span class="comment">//深度，这里计算每个结点的深度，通过深度的比较可得出是否平衡</span></span><br><span class="line">    Tree parent; <span class="comment">//该结点的父节点</span></span><br><span class="line">    ElementType val; <span class="comment">//结点值</span></span><br><span class="line">    Tree lchild;</span><br><span class="line">    Tree rchild;</span><br><span class="line">    <span class="built_in">AVLNode</span>(<span class="type">int</span> val=<span class="number">0</span>) &#123;</span><br><span class="line">        parent = <span class="literal">NULL</span>;</span><br><span class="line">        depth = <span class="number">0</span>;</span><br><span class="line">        lchild = rchild = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;val=val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>最小失衡子树</strong>：在<code>新插入的结点</code>向上查找，以第一个平衡因子的绝对值超过 1 的结点为根的子树称为最小不平衡子树。也就是说，<code>一棵失衡的树，是有可能有多棵子树同时失衡的</code>。而这个时候，<code>我们只要调整最小的不平衡子树，就能够将不平衡的树调整为平衡的树。</code></p>
<p>根据旋转的方向有两种处理方式，<code>左旋</code> 与 <code>右旋</code> 。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>LL</th>
<th>在 A 的左子树根节点的左子树上插入节点而破坏平衡</th>
<th>右旋转</th>
</tr>
</thead>
<tbody>
<tr>
<td>RR</td>
<td>在 A 的右子树根节点的右子树上插入节点而破坏平衡</td>
<td>左旋转</td>
</tr>
<tr>
<td>LR</td>
<td>在A的左子树根节点的右子树上插入节点而破坏平衡</td>
<td>先左旋后右旋</td>
</tr>
<tr>
<td>RL</td>
<td>在 A 的右子树根节点的左子树上插入节点而破坏平衡</td>
<td>先右旋后左旋</td>
</tr>
</tbody>
</table>
</div>
<p>右旋</p>
<p>（1）将失衡结点变为其左孩子的右孩子（2）将其原本的左孩子的右孩子变为的左孩子</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/20180722222413303.gif" alt="img"></p>
<p>左旋</p>
<p>（1）将失衡结点变为其右孩子的左孩子（2）将其原本的右孩子的左孩子变为的右孩子</p>
<p>总结：</p>
<blockquote>
<p> 1.RR型和LL型，以被破坏节点为基础进行其反向的旋转即可，即RR型进行左旋，LL型进行右旋。</p>
<p>   2.RL型和LR型，先以被破坏节点的LR或RL首字母的节点进行LR或RL首字母旋转，再以被破坏节点为基础进行LR或RL尾字母旋转，即RL型先以被破坏节点的R（右）节点为基础进行一次R（右）选，再以被破坏节点为基础进行一次L（左）旋；LR旋先以被破坏节点的L（左）节点为基础进行一次L（左）选，再以被破坏节点为基础进行一次R（右）旋。</p>
</blockquote>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElenmentType; </span><br><span class="line"><span class="comment">//平衡二叉树的结构 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">AVLNode</span>&#123;</span><br><span class="line">	<span class="type">int</span> depth;<span class="comment">//深度</span></span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">AVLNode</span> *left;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">AVLNode</span> *right;</span><br><span class="line">	<span class="keyword">struct</span> <span class="title class_">AVLNode</span> *parent;</span><br><span class="line">	ElenmentType value; </span><br><span class="line">	<span class="comment">//构造器 </span></span><br><span class="line">	<span class="built_in">AVLNode</span>(ElenmentType value=<span class="number">0</span>)&#123;</span><br><span class="line">		parent = <span class="literal">NULL</span>;</span><br><span class="line">        depth = <span class="number">0</span>;</span><br><span class="line">        left = right = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">this</span>-&gt;value=value;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;AVLtree,Tree;</span><br><span class="line"><span class="comment">//LL型调整函数</span></span><br><span class="line"><span class="comment">//返回根结点</span></span><br><span class="line"><span class="function">Tree* <span class="title">LL_rotate</span><span class="params">(Tree *root)</span></span>&#123;<span class="comment">//LL执行右旋 </span></span><br><span class="line">	<span class="comment">//root是原来的平衡二叉树的根结点</span></span><br><span class="line">	Tree *temp;<span class="comment">//临时变量</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//获取根结点的左孩子</span></span><br><span class="line">	temp = root-&gt;left;</span><br><span class="line">	<span class="comment">//根结点的左孩子变更为其原来左孩子的右孩子</span></span><br><span class="line">	root-&gt;left = temp-&gt;right;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//原来的根结点的左孩子变为了根结点</span></span><br><span class="line">	temp-&gt;right = root;</span><br><span class="line">	<span class="keyword">return</span> temp; </span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//RR型调整函数</span></span><br><span class="line"><span class="comment">//返回根结点 </span></span><br><span class="line"><span class="function">Tree* <span class="title">RR_rotate</span><span class="params">(Tree * root)</span></span>&#123;<span class="comment">//RR执行左旋 </span></span><br><span class="line">    Tree* temp;</span><br><span class="line">    temp = root-&gt;right;<span class="comment">//获取根结点的右孩子 </span></span><br><span class="line">    root-&gt;right = temp-&gt;left;<span class="comment">//根结点的右孩子变为其原来右孩子的左孩子 </span></span><br><span class="line">    temp-&gt;left = root;<span class="comment">//原来的根结点的右孩子变为了新的根结点 </span></span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1、LR型，先左旋转，再右旋转</span></span><br><span class="line"><span class="comment">//返回：新父节点</span></span><br><span class="line"><span class="function">Tree* <span class="title">LR_rotate</span><span class="params">(Tree* root)</span></span>&#123;</span><br><span class="line">	 Tree* temp;</span><br><span class="line">	 temp = root-&gt;left;</span><br><span class="line">    root-&gt;left =<span class="built_in">RR_rotate</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">LL_rotate</span>(root);</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//2RL型，先右旋转，再左旋转</span></span><br><span class="line"><span class="comment">//返回:新父节点</span></span><br><span class="line"><span class="function">Tree* <span class="title">RL_rotate</span><span class="params">(Tree* root)</span></span>&#123;</span><br><span class="line">	 Tree* temp;</span><br><span class="line">	 temp = root-&gt;right;</span><br><span class="line">    root-&gt;right=<span class="built_in">LL_rotate</span>(temp);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">RR_rotate</span>(root);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//树高</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">height</span><span class="params">(<span class="type">const</span> Tree* root)</span><span class="comment">//求树高，递归 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">max</span>(<span class="built_in">height</span>(root-&gt;left) , </span><br><span class="line">	</span><br><span class="line">	<span class="built_in">height</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//平衡因子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">diff</span><span class="params">(<span class="type">const</span> Tree* root)</span><span class="comment">//求平衡因子，即当前节点左右子树的差</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">height</span>(root-&gt;left) - <span class="built_in">height</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//平衡操作</span></span><br><span class="line"><span class="function">Tree* <span class="title">Balance</span><span class="params">(Tree* root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//	printf(&quot;平衡函数&quot;);</span></span><br><span class="line">    <span class="type">int</span> balanceFactor = <span class="built_in">diff</span>(root);<span class="comment">//diff用来计算平衡因子（左右子树高度差）</span></span><br><span class="line">    <span class="keyword">if</span> (balanceFactor &gt; <span class="number">1</span>)<span class="comment">//左子树高于右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">diff</span>(root-&gt;left) &gt; <span class="number">0</span>)<span class="comment">//LL的情况 </span></span><br><span class="line">            root=<span class="built_in">LL_rotate</span>(root);</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//LR的情况 </span></span><br><span class="line">            root=<span class="built_in">LR_rotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (balanceFactor &lt; <span class="number">-1</span>)<span class="comment">//右子树高于左子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">diff</span>(root-&gt;right) &gt; <span class="number">0</span>)<span class="comment">//RL的情况 </span></span><br><span class="line">            root=<span class="built_in">RL_rotate</span>(root);</span><br><span class="line">        <span class="keyword">else</span><span class="comment">//RR的情况 </span></span><br><span class="line">            root=<span class="built_in">RR_rotate</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//插入结点</span></span><br><span class="line"><span class="function">Tree* <span class="title">Insert</span><span class="params">(Tree* root,ElenmentType k )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == root)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">AVLNode</span>(k);<span class="comment">//如果根结点为null，则直接将值为根结点 </span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)</span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">&quot;创建失败&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;<span class="comment">//递归返回条件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k &lt; root-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">Insert</span>(root-&gt;left, k);<span class="comment">//递归左子树</span></span><br><span class="line">        <span class="comment">//balance operation</span></span><br><span class="line">        root = <span class="built_in">Balance</span>(root);<span class="comment">//平衡操作包含了四种旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k&gt;root-&gt;value)</span><br><span class="line">    &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">Insert</span>(root-&gt;right, k);<span class="comment">//递归右子树</span></span><br><span class="line">        <span class="comment">//balance operation</span></span><br><span class="line">        root = <span class="built_in">Balance</span>(root);<span class="comment">//平衡操作包含了四种旋转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//中序遍历,获取的数列是有序的 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">displayTree</span><span class="params">(Tree* node)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">displayTree</span>(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,node-&gt;value);</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span>(node-&gt;right != <span class="literal">NULL</span>)&#123;</span><br><span class="line">                <span class="built_in">displayTree</span>(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找value，成功则返回该结点 </span></span><br><span class="line"><span class="function">Tree* <span class="title">binaryTreeSearch</span><span class="params">(Tree *node,<span class="type">int</span> value)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(node-&gt;value==value)</span><br><span class="line">		<span class="keyword">return</span> node;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;value&gt;value)&#123;</span><br><span class="line">		<span class="keyword">if</span>(node-&gt;left!=<span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">binaryTreeSearch</span>(node-&gt;left,value);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(node-&gt;right!=<span class="literal">NULL</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">binaryTreeSearch</span>(node-&gt;right,value);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p>给定N个权值作为N个叶子结点，构造一棵二叉树，若该树的带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。</p>
<h3 id="路径和路径长度"><a href="#路径和路径长度" class="headerlink" title="路径和路径长度"></a>路径和路径长度</h3><p>在一棵树中，从一个结点往下可以达到的孩子或孙子结点之间的通路，称为路径。</p>
<p>通路中分支的数目称为路径长度。若规定根结点的层数为1，则从根结点到第L层结点的路径长度为L-1。</p>
<h3 id="节点的权和带权路径长度"><a href="#节点的权和带权路径长度" class="headerlink" title="节点的权和带权路径长度"></a>节点的权和带权路径长度</h3><p>若将树中结点赋给一个有着某种含义的数值，则这个数值称为该结点的权。结点的带权路径长度为：从根结点到该结点之间的路径长度与该结点的权的乘积。</p>
<p><em>*树的路径长度：</em>从树根到每一个结点的路径长度之和．记作：ＴＬ</p>
<p>树的的带权路径长度/**：树中所有叶子结点的带权路径长度之和．记作:WPL(Weighted Path Length)</p>
<p><strong>WPL 最小的二叉树</strong> 称为 <strong>霍夫曼树（Huffman Tree）</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/huffman-tree-1.png" alt="img"></p>
<p>哈夫曼算法</p>
<p>（１）根据n个给定的权值构成n棵二叉树的森林，森林中每一棵树只有一个带权的根结点（构造森林全是根）</p>
<p>（２）在森林中，选取两棵根结点的权值最小的树作为左右子树，构造一棵新的二叉树，且设置新的二叉树的根结点的权值为其左右子树上根结点的权值之和．（选用两小造新树）</p>
<p>（３）在森林中删除这两棵树，同时将新得到的二叉树加入到森林中．（删除两小添新人）</p>
<p>（４）重复（２）和（３），直到森林中只有一棵树为止，这棵树即为哈夫曼树．（重复２，３剩单根）<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/huffman-tree-2.png" alt="img"></p>
<h3 id="为哈夫曼树进行编码"><a href="#为哈夫曼树进行编码" class="headerlink" title="为哈夫曼树进行编码"></a>为哈夫曼树进行编码</h3><p>将二叉树分支中的左分支编为 0，右分支编为 1：</p>
<p>可以发现每个字符都在树的叶子节点上，因此要获取每个字符的哈夫曼编码，就通过根节点遍历到对应的子节点所经历的路径就是这个字符的编码：</p>
<h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><blockquote>
<p><strong>对于未建好的霍夫曼树，直接求其 WPL</strong></p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getWPL</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;  <span class="comment">// 对于未建好的霍夫曼树，直接求其 WPL</span></span><br><span class="line">  priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; huffman;  <span class="comment">// 小根堆</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) huffman.<span class="built_in">push</span>(arr[i]);</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) </span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> x = huffman.<span class="built_in">top</span>();</span><br><span class="line">    huffman.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> y = huffman.<span class="built_in">top</span>();</span><br><span class="line">    huffman.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="type">int</span> temp = x + y;</span><br><span class="line">    res += temp;</span><br><span class="line">    huffman.<span class="built_in">push</span>(temp);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="构建哈夫曼树"><a href="#构建哈夫曼树" class="headerlink" title="构建哈夫曼树"></a>构建哈夫曼树</h3><blockquote>
<p>排序</p>
</blockquote>
<p>哈夫曼树是一个带权的二叉树，而在哈夫曼编码中，字符的出现频率就是字符的权重。因此要根据字符的频率放入优先队列中进行排序。然后根据这些字符构建一棵哈夫曼树。</p>
<p>将队列中的每一个元素都看成一棵树。</p>
<blockquote>
<p>合并</p>
</blockquote>
<p>进行迭代，每次都去除队列中的前面两个元素，也就是权值最小的两棵子树进行合并成一棵子树。直到最终所有的元素合并成一棵树。这棵树就是哈夫曼树。</p>
<h3 id="为哈夫曼树进行编码-1"><a href="#为哈夫曼树进行编码-1" class="headerlink" title="为哈夫曼树进行编码"></a>为哈夫曼树进行编码</h3><p>将二叉树分支中的左分支编为 0，右分支编为 1：</p>
<p><a target="_blank" rel="noopener" href="https://oi-wiki.org/ds/huffman-tree/">霍夫曼树 - OI Wiki (oi-wiki.org)</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HNode</span> &#123;</span><br><span class="line">  <span class="type">int</span> weight;</span><br><span class="line">  HNode *lchild, *rchild;</span><br><span class="line">&#125; * Htree;</span><br><span class="line"></span><br><span class="line"><span class="function">Htree <span class="title">createHuffmanTree</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  Htree forest[N];</span><br><span class="line">  Htree root = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;  <span class="comment">// 将所有点存入森林</span></span><br><span class="line">    Htree temp;</span><br><span class="line">    temp = <span class="keyword">new</span> HNode;</span><br><span class="line">    temp-&gt;weight = arr[i];</span><br><span class="line">    temp-&gt;lchild = temp-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    forest[i] = temp;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">在每次循环中，动态分配了一个 HNode 类型的结构体，并将其权重初始化为数组 arr[] 的第 i 个元素，左右子节点指针初始化为 NULL。然后将该结构体的指针赋值给 forest[i]。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;  <span class="comment">// n-1 次循环建哈夫曼树</span></span><br><span class="line">    <span class="type">int</span> minn = <span class="number">-1</span>, minnSub;  <span class="comment">// minn 为最小值树根下标，minnsub 为次小值树根下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (forest[j] != <span class="literal">NULL</span> &amp;&amp; minn == <span class="number">-1</span>) &#123;</span><br><span class="line">        minn = j;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (forest[j] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        minnSub = j;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      这段代码的目的是初始化两个变量 minn 和 minnSub，以便后续在森林中找到权重最小和次小的两颗树。</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = minnSub; j &lt; n; j++) &#123;  <span class="comment">// 根据 minn 与 minnSub 赋值</span></span><br><span class="line">      <span class="keyword">if</span> (forest[j] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (forest[j]-&gt;weight &lt; forest[minn]-&gt;weight) &#123;</span><br><span class="line">          minnSub = minn;</span><br><span class="line">          minn = j;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (forest[j]-&gt;weight &lt; forest[minnSub]-&gt;weight) &#123;</span><br><span class="line">          minnSub = j;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      for (int j = minnSub; j &lt; n; j++) &#123;  // 根据 minn 与 minnSub 赋值</span></span><br><span class="line"><span class="comment">开始一个循环，从 minnSub 开始遍历 forest 数组中的剩余元素。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (forest[j] != NULL) &#123;</span></span><br><span class="line"><span class="comment">在每次循环中，首先检查当前位置的 forest[j] 是否不为 NULL。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if (forest[j]-&gt;weight &lt; forest[minn]-&gt;weight) &#123;</span></span><br><span class="line"><span class="comment">  minnSub = minn;</span></span><br><span class="line"><span class="comment">  minn = j;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">如果当前位置的树的权重小于 minn 所指示的树的权重，那么将 minnSub 更新为 minn，表示原来的 minn 变成了次小的树，然后将 minn 更新为 j，表示当前的树是最小的树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">else if (forest[j]-&gt;weight &lt; forest[minnSub]-&gt;weight) &#123;</span></span><br><span class="line"><span class="comment">  minnSub = j;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">否则，如果当前位置的树的权重小于 minnSub 所指示的树的权重，那么将 minnSub 更新为 j，表示找到了比当前 minnSub 指示的树更小的树。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这段代码的目的是在剩余的非空树中找到权重最小和次小的两颗树，并将它们的下标分别存储在 minn 和 minnSub 中。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建新树</span></span><br><span class="line">    root = <span class="keyword">new</span> HNode;</span><br><span class="line">    root-&gt;weight = forest[minn]-&gt;weight + forest[minnSub]-&gt;weight;</span><br><span class="line">    root-&gt;lchild = forest[minn];</span><br><span class="line">    root-&gt;rchild = forest[minnSub];</span><br><span class="line"></span><br><span class="line">    forest[minn] = root;     <span class="comment">// 指向新树的指针赋给 minn 位置</span></span><br><span class="line">    forest[minnSub] = <span class="literal">NULL</span>;  <span class="comment">// minnSub 位置为空</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>计算构成霍夫曼树的 WPL</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HNode</span> &#123;</span><br><span class="line">  <span class="type">int</span> weight;</span><br><span class="line">  HNode *lchild, *rchild;</span><br><span class="line">&#125; * Htree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getWPL</span><span class="params">(Htree root, <span class="type">int</span> len)</span> </span>&#123;  <span class="comment">// 递归实现，对于已经建好的霍夫曼树，求 WPL</span></span><br><span class="line">  <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>)  <span class="comment">// 叶节点</span></span><br><span class="line">      <span class="keyword">return</span> root-&gt;weight * len;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">int</span> left = <span class="built_in">getWPL</span>(root-&gt;lchild, len + <span class="number">1</span>);</span><br><span class="line">      <span class="type">int</span> right = <span class="built_in">getWPL</span>(root-&gt;rchild, len + <span class="number">1</span>);</span><br><span class="line">      <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对于给定序列，计算霍夫曼编码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">HNode</span> &#123;</span><br><span class="line">  <span class="type">int</span> weight;</span><br><span class="line">  HNode *lchild, *rchild;</span><br><span class="line">&#125; * Htree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">huffmanCoding</span><span class="params">(Htree root, <span class="type">int</span> len, <span class="type">int</span> arr[])</span> </span>&#123;  <span class="comment">// 计算霍夫曼编码</span></span><br><span class="line">  <span class="keyword">if</span> (root != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;lchild == <span class="literal">NULL</span> &amp;&amp; root-&gt;rchild == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     cout&lt;&lt;<span class="string">&quot;结点为&quot;</span>&lt;&lt;root-&gt;weight&lt;&lt;<span class="string">&quot;的字符的编码为: &quot;</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">    cout&lt;&lt;<span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      arr[len] = <span class="number">0</span>;</span><br><span class="line">      <span class="built_in">huffmanCoding</span>(root-&gt;lchild, len + <span class="number">1</span>, arr);</span><br><span class="line">      arr[len] = <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">huffmanCoding</span>(root-&gt;rchild, len + <span class="number">1</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><blockquote>
<p>图论（Graph Theory）是数学的一个分支。它以图为研究对象。图论中的图是由若干给定的点及连接两点的线所构成的图形，这种图形通常用来描述某些实体之间的某种特定关系，用点代表实体，用连接两点的线表示两个实体间具有的某种关系。<br>图是一种较线性表和树更加复杂的数据结构。在图形结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。</p>
</blockquote>
<p><strong>图的定义</strong>：</p>
<ul>
<li>一个图（Graph）G是一个有序对(G,V)，其中V是一些顶点的集合，G是一个连接这些顶点的边的集合。边可以是有向的（连接两个顶点的有序对）或者是无向的（连接两个顶点的无序对）。</li>
</ul>
<p><strong>顶点和边</strong>：</p>
<ul>
<li>图中的每个元素称为顶点（Vertex），通常用字母表示，如V、W、X等。</li>
<li>顶点之间的连接称为边（Edge），它可以是有向的或者是无向的。</li>
</ul>
<p>图可以被表示为 G={V, E}，其中 V={v1, … , vN}，E= {e1, … , eM}。</p>
<p>V表示图G中顶点的个数，也称图G的阶</p>
<p>E代表图G边的条数</p>
<p>图中不能一个顶点也没有，图的顶点集V一定非空，但边集E可以为空</p>
<p>图可能是无向的，这意味着图中的边在连接顶点时无需区分方向。否则，称图是有向的</p>
<blockquote>
<p><strong>有向图和无向图</strong>：</p>
<ul>
<li>如果图中的边具有方向，则称该图为有向图（Directed Graph）。</li>
<li>如果图中的边没有方向，则称该图为无向图（Undirected Graph）。</li>
</ul>
</blockquote>
<p><strong>路径和环</strong>：</p>
<ul>
<li><p>路径（Path）是图中连接顶点的一个序列，其中顶点之间通过边相连。</p>
</li>
<li><p>环（Cycle）是指图中的一个路径，起始顶点和结束顶点相同。</p>
</li>
<li><p>若一个图有n个顶点，并且有大于n − 1条边，则此图一定有环。</p>
</li>
<li><p>简单路径是指图中不包含重复顶点的路径</p>
</li>
<li><p>简单路径满足以下条件：</p>
<ol>
<li>顶点不重复：路径中的所有顶点各不相同。</li>
<li>边不重复：路径中的所有边各不相同。</li>
</ol>
</li>
<li><p><strong>简单回路（简单环）：除路径起点和终点相同外，其余顶点均不相同的路径。</strong></p>
</li>
</ul>
<p><strong>树</strong>：</p>
<ul>
<li>如果一个无向图是一个连通图且没有环，则称该图为树（Tree）。</li>
<li>树是一种特殊的图结构，它没有回路，并且任意两个顶点之间只有一条简单路径。</li>
</ul>
<p><strong>子图</strong>：</p>
<ul>
<li>子图（Subgraph）是原始图的一个子集，它包含原始图中的一些顶点和边，这些顶点和边之间的连接关系和方向（如果是有向图）保持不变。</li>
<li>例如，如果原始图有5个顶点和7条边，而子图中只选择了其中的3个顶点和5条边，那么这个子图就是原始图的一个子图。</li>
</ul>
<p><strong>生成子图</strong>：</p>
<ul>
<li>如果一个子图包含了原始图中的所有顶点，那么这个子图被称为原始图的生成子图（Spanning Subgraph）。</li>
<li>生成子图通常是指包含了原始图中所有顶点的最小连通子图，如果是无向图，通常是最小生成树。</li>
</ul>
<p><strong>图的连通性：</strong>在图论中，连通图基于连通的概念。在一个无向图 G 中，若从顶点 i 到顶点 j 有路径相连（当然从j到i也一定有路径），则称 i 和 j 是连通的。如果 G 是有向图，那么连接i和j的路径中所有的边都必须同向。如果图中任意两点都是连通的，那么图被称作连通图。如果此图是有向图，则称为强连通图（注意：需要双向都有路径）。图的连通性是图的基本性质。</p>
<ol>
<li><p><strong>连通</strong>：</p>
<p>在一个图中，如果任意两个顶点之间都存在路径，那么该图被称为是连通的。换句话说，对于图中的任意两个顶点u和v，都存在一条从顶点u到顶点v的路径。如果一个图不是连通的，则被称为是非连通的。</p>
<p>在上图中，图是连通的，因为任意两个顶点之间都存在路径。例如，顶点A和顶点E之间存在路径A -&gt; B -&gt; C -&gt; E。</p>
</li>
<li><p><strong>连通图</strong>：</p>
<p>如果一个图是连通的，即图中的任意两个顶点之间都存在路径，那么该图被称为是连通图。换句话说，一个图是连通图，当且仅当该图是一个连通的子图，即该图包含原始图中的所有顶点，并且顶点之间的连接关系和方向（如果是有向图）保持不变。</p>
<p>上图中的图是一个非连通图，因为它包含了两个不连通的子图：左侧的子图包含了顶点A、B、C，右侧的子图包含了顶点D、E、F。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>-<span class="attr">--B</span>    D-<span class="attr">--E</span></span><br><span class="line">  |  /       /</span><br><span class="line">  | /         /</span><br><span class="line">  C            F</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>连通分量</strong>：</p>
<p>在一个非连通图中，如果将该图分解为多个连通子图，且每个子图都是连通的，那么这些连通的子图被称为是该图的连通分量。换句话说，连通分量是将一个非连通图分割为连通子图的过程，其中每个连通子图都是极大连通子图（即无法再添加顶点或边使得其保持连通性）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">A</span>-<span class="attr">--B</span>    D-<span class="attr">--E</span></span><br><span class="line">|           /</span><br><span class="line">|            /</span><br><span class="line">C             F</span><br><span class="line">   </span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   上图中的非连通图被分解为了两个连通分量：左侧的连通分量包含了顶点A、B、C，右侧的连通分量包含了顶点D、E、F。</p>
<h3 id="无权图和有权图"><a href="#无权图和有权图" class="headerlink" title="无权图和有权图"></a>无权图和有权图</h3><p>   连接节点与节点的边是否有数值与之对应，有的话就是有权图，否则就是无权图。</p>
<ol>
<li><p><strong>无权图（Unweighted Graph）</strong>：</p>
<ul>
<li>无权图是指图中的边没有赋予任何权重或者成本的图。</li>
<li>在无权图中，边只表示顶点之间的连接关系，而不包含额外的信息。</li>
<li>通常用于表示简单的关系或者连接情况，例如社交网络中的好友关系图。</li>
</ul>
</li>
<li><p><strong>有权图（Weighted Graph）</strong>：</p>
<ul>
<li>有权图是指图中的边具有特定的权重或者成本的图。</li>
<li>在有权图中，每条边都被赋予了一个权重值，表示连接两个顶点之间的成本、距离或者其他衡量标准。</li>
<li>有权图可以用于模拟现实世界中的各种情况，例如道路网络中的距离、通信网络中的传输延迟等。</li>
</ul>
</li>
</ol>
<pre><code>  **生成树（Spanning Tree）**：

  - 一个连通图的生成树是指一个包含图中所有顶点且无环的子图。
  - 换句话说，生成树是一个树形结构，它包含了图中所有的顶点，并且用最少的边来连接所有的顶点，从而保持图的连通性。
  - 如果一个图是连通的，则一定存在至少一棵生成树。而对于非连通图，可以通过计算每个连通分量的生成树来得到整个图的生成树。



  ### 度

  1. **顶点的度（Degree）**：

     顶点的度是指与该顶点相邻的边的数量。对于无向图来说，顶点的度等于与该顶点相邻的边的数量；对于有向图来说，顶点的度等于该顶点的出度和入度之和。

  2. **出度（Out-degree）**：

     对于有向图中的一个顶点，其出度是指从该顶点出发的边的数量。换句话说，出度表示了从该顶点指向其他顶点的边的数量。

  3. **入度（In-degree）**：

     对于有向图中的一个顶点，其入度是指指向该顶点的边的数量。换句话说，入度表示了指向该顶点的边的数量。

  在有向图中，顶点的度可以进一步分为出度和入度，这是因为有向图中的边具有方向性，从而导致了边的起点和终点的区别。而在无向图中，顶点的度只有一个值，即与该顶点相邻的边的数量。
</code></pre><blockquote>
<ul>
<li>对于无向图中的一个顶点，其度等于与该顶点相邻的边的数量。</li>
<li>对于有向图中的一个顶点，其出度等于从该顶点出发的边的数量，入度等于指向该顶点的边的数量。</li>
</ul>
</blockquote>
<h3 id="稠密图、稀疏图"><a href="#稠密图、稀疏图" class="headerlink" title="稠密图、稀疏图"></a>稠密图、稀疏图</h3><p>边数很少的图称为稀疏图，反之称为稠密图。稀疏和稠密本身是模糊的概念，稀疏图和稠密图常常是相对而言的。一般当图G满足∣ E ∣ &lt; ∣ V ∣ l o g ∣ V ∣时，可以将G视为稀疏图。<br>其他一些知识</p>
<blockquote>
<p><strong>完全图：</strong>完全是一个简单的无向图，其中每对不同的顶点之间都恰连有一条边相连。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2NTE4NDYx,size_16,color_FFFFFF,t_70#pic_center.png" alt="在这里插入图片描述"></p>
<p><strong>自环边：</strong>一条边的起点终点是一个点。</p>
<p><strong>平行边：</strong>两个顶点之间存在多条边相连接。</p>
<h4 id="简单图：一个图G若满足-①不存在重复边-②不存在顶点到自身的边，则称图G为简单图。"><a href="#简单图：一个图G若满足-①不存在重复边-②不存在顶点到自身的边，则称图G为简单图。" class="headerlink" title="简单图：一个图G若满足:①不存在重复边;②不存在顶点到自身的边，则称图G为简单图。"></a>简单图：一个图G若满足:①不存在重复边;②不存在顶点到自身的边，则称图G为简单图。</h4><h4 id="多重图"><a href="#多重图" class="headerlink" title="多重图"></a>多重图</h4><p>若图G中某两个结点之间的边数多于一条，又允许顶点通过同一条边和自己关联，则G为多重图。</p>
</blockquote>
<h2 id="图的存储结构"><a href="#图的存储结构" class="headerlink" title="图的存储结构"></a>图的存储结构</h2><h2 id="直接存边"><a href="#直接存边" class="headerlink" title="直接存边"></a>直接存边</h2><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>使用一个数组来存边，数组中的每个元素都包含一条边的起点与终点（带边权的图还包含边权）。（或者使用多个数组分别存起点，终点和边权。）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">  <span class="type">int</span> u, v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;Edge&gt; e;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) cin &gt;&gt; e[i].u &gt;&gt; e[i].v;</span><br></pre></td></tr></table></figure>
<h2 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/20130429131721379.jpeg" alt="img"></p>
<h3 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h3><p>使用一个二维数组 <code>adj</code> 来存边，其中 <code>adj[u][v]</code> 为 1 表示存在 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="u"> 到 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="v"> 的边，为 0 表示不存在。如果是带边权的图，可以在 <code>adj[u][v]</code> 中存储 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="u"> 到 <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="v"> 的边的边权。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; adj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123; <span class="keyword">return</span> adj[u][v]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vis[u]) <span class="keyword">return</span>;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> v = <span class="number">1</span>; v &lt;= n; ++v) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj[u][v]) &#123;</span><br><span class="line">      <span class="built_in">dfs</span>(v);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  vis.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">  adj.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    adj[u][v] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//双向有权</span></span><br><span class="line"> <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mat[u][v] = w;</span><br><span class="line">    mat[v][u] = w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>邻接矩阵只适用于没有重边（或重边可以忽略）的情况。</p>
<p>其最显著的优点是可以 O(1)查询一条边是否存在。</p>
<p>由于邻接矩阵在稀疏图上效率很低（尤其是在点数较多的图上，空间无法承受），所以一般只会在稠密图上使用邻接矩阵。</p>
<blockquote>
<p>如果有权值没有边的就不能设置为0，而是应该设置为无穷参数</p>
</blockquote>
<h2 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h2><h3 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h3><p>使用一个支持动态增加元素的数据结构构成的数组，如 <code>vector&lt;int&gt; adj[n + 1]</code> 来存边，其中 <code>adj[u]</code> 存储的是点 u的所有出边的相关信息（终点、边权等)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">vector&lt;<span class="type">bool</span>&gt; vis;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; adj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">find_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; adj[u].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (adj[u][i] == v) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (vis[u]) <span class="keyword">return</span>;</span><br><span class="line">  vis[u] = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; adj[u].<span class="built_in">size</span>(); ++i) <span class="built_in">dfs</span>(adj[u][i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">  vis.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">  adj.<span class="built_in">resize</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> u, v;</span><br><span class="line">    cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">    adj[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有权值，即是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, w;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Edge&gt; edges[MAXN];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Edge e = &#123;to, w&#125;;</span><br><span class="line">    edges[from].<span class="built_in">push_back</span>(e);  <span class="comment">//向vector的最后添加一条边</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无向图</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add2</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">add</span>(u, v, w);</span><br><span class="line">    <span class="built_in">add</span>(v, u, w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="链式前向星"><a href="#链式前向星" class="headerlink" title="链式前向星"></a>链式前向星</h2><p>逃避了很久这个东西，终究还是逃不过了（）</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/sugarbliss/article/details/86495945">链式前向星—最通俗易懂的讲解-CSDN博客</a></p>
<p>讲的很好，一看就很清晰了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_edge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span><span class="comment">//加边，u起点，v终点，w边权</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    edge[cnt].to = v; <span class="comment">//终点</span></span><br><span class="line">    edge[cnt].w = w; <span class="comment">//权值</span></span><br><span class="line">    edge[cnt].next = head[u];<span class="comment">//以u为起点上一条边的编号，也就是与这个边起点相同的上一条边的编号</span></span><br><span class="line">    head[u] = cnt++;<span class="comment">//更新以u为起点上一条边的编号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如说我们</p>
<p>1 2 1</p>
<p>1 3 5</p>
<p>1 5 6</p>
<p>这三条边，他们出现的顺序依次是0，3，5</p>
<p>那么我们head[1]就从一开始的-1—-0—-3——5</p>
<p>最后我们得到的就是从5，开始的</p>
<p>而5的next就是3</p>
<p>3的next就是0</p>
<p>0的next就是-1，也就是我们的遍历的终止条件。</p>
<p>感觉链式前向星就是邻接表的静态版本，也就是为什么快的原因</p>
<p>遍历方式——————</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//n个起点</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = head[i]; j != <span class="number">-1</span>; j = edge[j].next)<span class="comment">//遍历以i为起点的边</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].to &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; edge[j].w &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>感谢那位大佬，讲的真的好。</p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><h1 id="【深基18-例3】查找文献"><a href="#【深基18-例3】查找文献" class="headerlink" title="【深基18.例3】查找文献"></a>【深基18.例3】查找文献</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>小 K 喜欢翻看洛谷博客获取知识。每篇文章可能会有若干个（也有可能没有）参考文献的链接指向别的博客文章。小 K 求知欲旺盛，如果他看了某篇文章，那么他一定会去看这篇文章的参考文献（如果他之前已经看过这篇参考文献的话就不用再看它了）。</p>
<p>假设洛谷博客里面一共有 n篇文章（编号为 1 到 n）以及 m 条参考文献引用关系。目前小 K 已经打开了编号为 1 的一篇文章，请帮助小 K 设计一种方法，使小 K 可以不重复、不遗漏的看完所有他能看到的文章。</p>
<p>这边是已经整理好的参考文献关系图，其中，文献 X → Y 表示文章 X 有参考文献 Y。不保证编号为 1 的文章没有被其他文章引用。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/f4n4tlhi.png" alt></p>
<p>请对这个图分别进行 DFS 和 BFS，并输出遍历结果。如果有很多篇文章可以参阅，请先看编号较小的那篇(因此你可能需要先排序)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">8 9</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">2 6</span><br><span class="line">3 7</span><br><span class="line">4 7</span><br><span class="line">4 8</span><br><span class="line">7 8</span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 2 5 6 3 7 8 4 </span><br><span class="line">1 2 3 4 5 6 7 8</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt; <span class="type">int</span> &gt;g[<span class="number">1000000</span>];</span><br><span class="line"><span class="type">bool</span> visit[<span class="number">10000000</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> u, v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	visit[x] = <span class="number">1</span>;</span><br><span class="line">	cout &lt;&lt; x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	<span class="keyword">if</span> (cur==n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[x].<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!visit[g[x][i]])</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs</span>(g[x][i], cur + <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="built_in">sizeof</span>(visit));</span><br><span class="line">	visit[x] = <span class="number">1</span>;</span><br><span class="line">	q.<span class="built_in">push</span>(x);</span><br><span class="line">	<span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">		q.<span class="built_in">pop</span>();</span><br><span class="line">		cout &lt;&lt; v &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; g[v].<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!visit[g[v][i]])</span><br><span class="line">			&#123;</span><br><span class="line">				visit[g[v][i]] = <span class="number">1</span>;</span><br><span class="line">				q.<span class="built_in">push</span>(g[v][i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=m ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; u &gt;&gt; v;</span><br><span class="line">		g[u].<span class="built_in">push_back</span>(v);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;=n ; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">sort</span>(g[i].<span class="built_in">begin</span>(), g[i].<span class="built_in">end</span>());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&#x27;/n&#x27;</span>;</span><br><span class="line">	<span class="built_in">bfs</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p><strong>如果一个无向连通图不包含回路(连通图中不存在环),那么就是一个树。</strong></p>
<p>注意：只有连通图才有生成树，而对于非连通图，只存在生成森林。</p>
<h4 id="prim-普里姆算法"><a href="#prim-普里姆算法" class="headerlink" title="prim(普里姆算法)"></a>prim(普里姆算法)</h4><blockquote>
<p>Prim算法是采用从点方面考虑来构建MST的一种算法，Prim 算法在稠密图中比Kruskal优，通常步骤如下</p>
<p>1.从源点出发，将所有与源点连接的点加入一个待处理的集合中<br>2.从集合中找出与源点的边中权重最小的点，从待处理的集合中移除标记为确定的点<br>3.将找到的点按照步骤1的方式处理<br>4.重复2，3步直到所有的点都被标记</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INF 0x3f3f3f3f</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">505</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> vis[maxn],dist[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">	dist[pos] = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 一共有 n 个点,就需要 遍历 n 次,每次寻找一个权值最小的点,记录其下标</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> cur = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++) &#123;</span><br><span class="line">			<span class="keyword">if</span>(!vis[j] &amp;&amp; (cur == <span class="number">-1</span> || dist[j] &lt; dist[cur])) &#123;</span><br><span class="line">				cur = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 这里需要提前终止</span></span><br><span class="line">		<span class="keyword">if</span>(dist[cur] &gt;= INF) <span class="keyword">return</span> INF;</span><br><span class="line">		sum += dist[cur];</span><br><span class="line">		vis[cur] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k ++) &#123;</span><br><span class="line">		    <span class="comment">// 只更新还没有找到的最小权值</span></span><br><span class="line">			<span class="keyword">if</span>(!vis[k]) dist[k] = <span class="built_in">min</span>(dist[k],a[cur][k]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="built_in">memset</span>(a,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(a));</span><br><span class="line">	<span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">		cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">		a[u][v] = <span class="built_in">min</span>(a[u][v],w);</span><br><span class="line">		a[v][u] = <span class="built_in">min</span>(a[v][u],w);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> value = <span class="built_in">prim</span>(<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">if</span>(value &gt;= INF) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;sum;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="kruskal-克鲁斯卡尔算法"><a href="#kruskal-克鲁斯卡尔算法" class="headerlink" title="kruskal (克鲁斯卡尔算法)"></a>kruskal (克鲁斯卡尔算法)</h4><p><strong>一种巧妙利用并查集来求最小生成树的算法。</strong></p>
<blockquote>
<p>对于图G(V,E)，以下是算法描述：</p>
<p>输入： 图G<br>输出： 图G的最小生成树<br>具体流程：<br>(1)将图G看做一个森林，每个顶点为一棵独立的树<br>(2)将所有的边加入集合S，即一开始S = E<br>(3)从S中拿出一条最短的边(u,v)，如果(u,v)不在同一棵树内，则连接u,v合并这两棵树，同时将(u,v)加入生成树的边集E’<br>(4)重复(3)直到所有点属于同一棵树，边集E’就是一棵最小生成树</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt; bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">2e5</span> + <span class="number">10</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span> &#123;</span><br><span class="line">	<span class="type">int</span> x,y,z;</span><br><span class="line">&#125;edge[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> a.z &lt; b.z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fa[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> u,v,w; </span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sum;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">get</span>(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">		cin&gt;&gt;edge[i].x&gt;&gt;edge[i].y&gt;&gt;edge[i].z);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		fa[i] = i;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">sort</span>(edge + <span class="number">1</span>,edge + <span class="number">1</span> + m,cmp);</span><br><span class="line">	<span class="comment">// 每次加入一条最短的边</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i ++) &#123;</span><br><span class="line">		<span class="type">int</span> x = <span class="built_in">get</span>(edge[i].x);</span><br><span class="line">		<span class="type">int</span> y = <span class="built_in">get</span>(edge[i].y);</span><br><span class="line">		<span class="keyword">if</span>(x == y) <span class="keyword">continue</span>;</span><br><span class="line">		fa[y] = x;</span><br><span class="line">		sum += edge[i].z;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">		<span class="keyword">if</span>(i == fa[i]) ans ++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(ans &gt; <span class="number">1</span>) <span class="built_in">puts</span>(<span class="string">&quot;impossible&quot;</span>);</span><br><span class="line">	<span class="keyword">else</span> cout&lt;&lt;sum;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h2><h3 id="Dijkstra算法"><a href="#Dijkstra算法" class="headerlink" title="Dijkstra算法"></a><strong>Dijkstra算法</strong></h3><p>Dijkstra 算法是一个基于「贪心」、「广度优先搜索」、「动态规划」求一个图中一个点到其他所有点的最短路径的算法，时间复杂度 O(n2)</p>
<h4 id="什么是dijkstra"><a href="#什么是dijkstra" class="headerlink" title="什么是dijkstra?"></a>什么是d<strong>i</strong>j<strong>k</strong>s<strong>t</strong>ra?</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/image-20240213183713595.png" alt="image-20240213183713595"></p>
<p><strong>1.算法介绍</strong></p>
<p>Dijkstra算法通常是求解单源最短路中最快的算法，但它无法处理存在负权边的情况。Dijkstra本质上是一种贪心算法，通过不断调整每个点的“当前距离”最终得到最优结果，</p>
<p><code>dijkstra的算法思想</code>是从以上最短距离数组中每次选择一个最近的点，将其作为下一个点，然后重新计算从起始点经过该点到其他所有点的距离，更新最短距离数据。已经选取过的点就是确定了最短路径的点，不再参与下一次计算。</p>
<p>堆优化找最短路径的过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PII pair<span class="string">&lt;int ,int&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF=<span class="number">1e10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n,m,s;</span><br><span class="line"><span class="type">int</span> dis[N];</span><br><span class="line"><span class="type">int</span> vis[N];</span><br><span class="line">vector&lt;PII&gt;E[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dj</span><span class="params">(<span class="type">int</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		dis[i]=INF;</span><br><span class="line">		vis[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	dis[s]=<span class="number">0</span>;</span><br><span class="line">	priority_queue&lt;PII,vector&lt;PII&gt;,greater&lt;PII&gt; &gt;q;</span><br><span class="line">	q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);</span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t=q.<span class="built_in">top</span>().second;</span><br><span class="line">	q.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">if</span>(vis[t])&#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		vis[t]=<span class="number">1</span>;		</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>,l=E[t].<span class="built_in">size</span>();i&lt;l;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> v=E[t][i].first;</span><br><span class="line">		<span class="type">int</span> w=E[t][i].second;</span><br><span class="line">	</span><br><span class="line">		<span class="keyword">if</span>(dis[v]&gt;dis[t]+w)</span><br><span class="line">		&#123;		</span><br><span class="line">			dis[v]=dis[t]+w;</span><br><span class="line">			q.<span class="built_in">push</span>(&#123;dis[v],v&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;</span><br><span class="line"><span class="type">int</span> u,v,w;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line">	cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">	E[u].<span class="built_in">push_back</span>(&#123;v,w&#125;);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="built_in">dj</span>(s);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;dis[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="Floyd算法"><a href="#Floyd算法" class="headerlink" title="Floyd算法"></a>Floyd算法</h3><p>Floyd算法是基于动态规划的，从结点 i 到结点 j 的最短路径只有两种：<br>1、直接 i 到 j<br>2、i 经过若干个结点到 k 再到 j<br>对于每一个k，我们都判断 d[i][j] 是否大于 d[i][k] + d[k][j]，如果大于，就可以更新d[i][j]了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;=n; k++)</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++)</span><br><span class="line">      d[i][j] = <span class="built_in">min</span>(d[i][j], d[i][k] + d[k][j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="拓补排序"><a href="#拓补排序" class="headerlink" title="拓补排序"></a>拓补排序</h2><p>在图论中，<strong>拓扑排序（Topological Sorting）</strong>是一个<strong>有向无环图（DAG, Directed Acyclic Graph）</strong>的所有顶点的线性序列。</p>
<blockquote>
<p>有向无环图（DAG）才有拓扑排序</p>
</blockquote>
<p>步骤：</p>
<blockquote>
<ol>
<li><p>从 DAG 图中选择一个 没有前驱（即入度为0）的顶点并输出。</p>
</li>
<li><p>从图中删除该顶点和所有以它为起点的有向边。</p>
</li>
<li><p>重复 1 和 2 直到当前的 DAG 图为空或<strong>当前图中不存在无前驱的顶点为止</strong>。后一种情况说明有向图中必然存在环。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/20150507001759702.png" alt="img"></p>
<p>一个有向无环图可以有<strong>一个或多个</strong>拓扑排序序列</p>
</li>
</ol>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//by dpcc</span></span><br><span class="line"><span class="comment">//世间温柔</span></span><br><span class="line"><span class="comment">//不过是芳春柳摇染花香</span></span><br><span class="line"><span class="comment">//槐序蝉鸣入深巷</span></span><br><span class="line"><span class="comment">//白茂叶落醉故乡</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll=<span class="type">long</span> <span class="type">long</span> ;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> in inline</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n)  for(re int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> frep(i,a,n) for(re int i=a;i&gt;=n;i--)</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;a[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> du[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> b[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> n2;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	queue&lt;<span class="type">int</span>&gt;q;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!du[i])</span><br><span class="line">&#123;</span><br><span class="line">	q.<span class="built_in">push</span>(i);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">		&#125;			</span><br><span class="line"><span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> x=q.<span class="built_in">front</span>();</span><br><span class="line">	b[++n2]=x;</span><br><span class="line">	q.<span class="built_in">pop</span>();</span><br><span class="line">	<span class="type">int</span> t=a[x].<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">	<span class="built_in">rep</span>(i,<span class="number">0</span>,t)</span><br><span class="line">	&#123;</span><br><span class="line">	du[a[x][i]]--;</span><br><span class="line">	<span class="keyword">if</span>(!du[a[x][i]])</span><br><span class="line">	&#123;</span><br><span class="line">		q.<span class="built_in">push</span>(a[x][i]);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;	</span><br><span class="line"><span class="built_in">frep</span>(i,n2,<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">	cout&lt;&lt;b[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	cin&gt;&gt;t;</span><br><span class="line">	<span class="keyword">while</span>(t!=<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">	a[t].<span class="built_in">push_back</span>(i);</span><br><span class="line">		du[i]++;</span><br><span class="line">		cin&gt;&gt;t;</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;		</span><br><span class="line"><span class="built_in">bfs</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><p>一、查找的基本概念<br><strong>查找定义：</strong>根据给定的某个值，在查找表中确定一个其关键字等于给定值的数据元素（或记录）。</p>
<p>查找表(Search Table)：是由同一类型的数据元素(或记录)构成的集合。</p>
<p>关键字(Key)：数据元素中唯一标识该元素的某个数据项的值，使用基于关键字的查找，查找结果应该是唯一的。</p>
<p>静态查找表(Static Search Table)：只作查找操作的查找表。<br><strong>动态查找表(Dynamic Search Table)</strong>： 在查找过程中同时插入查找表中不存在的数据元素，或者从查找表中删除已经存在的某个数据元素。</p>
<p><strong>平均查找长度（Average Search Length，ASL）：</strong>需和指定key进行比较的关键字的个数的期望值，称为查找算法在查找成功时的平均查找长度。</p>
<p>　　对于含有n个数据元素的查找表，查找成功的平均查找长度为：ASL = Pi*Ci的和。<br>　　Pi：查找表中第i个数据元素的概率。<br>　　Ci：找到第i个数据元素时已经比较过的次数。</p>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顺序查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">SequenceSearch</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">        <span class="keyword">if</span>(a[i]==value)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>O（N）</p>
<h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><blockquote>
<p><strong>元素必须是有序的，如果是无序的则要先进行排序操作。</strong></p>
<p><strong>折半查找的前提条件是需要有序表顺序存储，对于静态查找表，一次排序后不再变化，折半查找能得到不错的效率。但对于需要**</strong>频繁执行插入或删除操作的数据集来说，维护有序的排序会带来不小的工作量，那就不建议使用。**</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BinarySearch1</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> low, high, mid;</span><br><span class="line">    low = <span class="number">0</span>;</span><br><span class="line">    high = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid = (low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">            high = mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">            low = mid+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> ret = <span class="number">-1</span>;  <span class="comment">// 未搜索到数据返回-1下标</span></span><br><span class="line">  <span class="type">int</span> mid;</span><br><span class="line">  <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">    mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);  <span class="comment">// 直接平均可能会溢出，所以用这个算法</span></span><br><span class="line">    <span class="keyword">if</span> (arr[mid] &lt; key)</span><br><span class="line">      start = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; key)</span><br><span class="line">      end = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> &#123;  <span class="comment">// 最后检测相等是因为多数搜索情况不是大于就是小于</span></span><br><span class="line">      ret = mid;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;  <span class="comment">// 单一出口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>背景：</p>
<blockquote>
<p>当我们从字典中查找 “apple” 这个单词的时候，我们肯定不会傻傻地像二分查找一样首先从中间开始。相反，**我们会从首字母为 a 的地方开始查找。</p>
</blockquote>
<p>插值查找是一种在<strong>有序数组</strong>（前提条件）中查找某一特定元素的查找算法。插值查找基于二分查找，不同的是插值查找每次从自适应mid处开始查找，提高查找效率。</p>
<p>归根到底只是Mid不同罢了</p>
<p>插值查找的平均复杂度为 Θ(log⁡log⁡n) ，</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//插值查找</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">InsertionSearch</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> value, <span class="type">int</span> low, <span class="type">int</span> high)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> mid = low+(value-a[low])/(a[high]-a[low])*(high-low);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]==value)</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&gt;value)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">InsertionSearch</span>(a, value, low, mid<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(a[mid]&lt;value)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">InsertionSearch</span>(a, value, mid+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）对于<strong>数据量较大，关键字分布比较均匀</strong>的查找表来说，采用插值查找时速度较快。<br>（2）<strong>在关键字分布不均匀的情况下，插值查找不一定比折半查找好</strong>。</p>
<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><p><strong>斐波那契</strong>查找原理与<strong>二分查找</strong>相似，仅仅改变了中间结点（mid）的位置，mid不再是中间或插值得到，而是位于<strong>黄金分割点</strong>附近。</p>
<p> 前置<strong>n = Fu - 1</strong></p>
<ul>
<li>若相等，则查找成功</li>
<li>若key &lt; a[Fu-1] ，则继续在 a[1] 至 a[Fu-1 - 1] 的子表中进行查找</li>
<li>若key &gt; a[Fu-1] ，则继续在 a[Fu-1 + 1] 至 a[Fu - 1] 的子表中进行查找。该子表的长度为 Fu-2 -1</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契查找.cpp </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdafx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span>  <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_size=<span class="number">20</span>;<span class="comment">//斐波那契数组的长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造一个斐波那契数组*/</span> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Fibonacci</span><span class="params">(<span class="type">int</span> * F)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    F[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;max_size;++i)</span><br><span class="line">        F[i]=F[i<span class="number">-1</span>]+F[i<span class="number">-2</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定义斐波那契查找法*/</span>  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">FibonacciSearch</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> n, <span class="type">int</span> key)</span>  <span class="comment">//a为要查找的数组,n为要查找的数组长度,key为要查找的关键字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> low=<span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> high=n<span class="number">-1</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> F[max_size];</span><br><span class="line">  <span class="built_in">Fibonacci</span>(F);<span class="comment">//构造一个斐波那契数组F </span></span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(n&gt;F[k]<span class="number">-1</span>)<span class="comment">//计算n位于斐波那契数列的位置</span></span><br><span class="line">      ++k;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span>  * temp;<span class="comment">//将数组a扩展到F[k]-1的长度</span></span><br><span class="line">  temp=<span class="keyword">new</span> <span class="type">int</span> [F[k]<span class="number">-1</span>];</span><br><span class="line">  <span class="built_in">memcpy</span>(temp,a,n*<span class="built_in">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=n;i&lt;F[k]<span class="number">-1</span>;++i)</span><br><span class="line">     temp[i]=a[n<span class="number">-1</span>];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(key&lt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">      high=mid<span class="number">-1</span>;</span><br><span class="line">      k-=<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;temp[mid])</span><br><span class="line">    &#123;</span><br><span class="line">     low=mid+<span class="number">1</span>;</span><br><span class="line">     k-=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">if</span>(mid&lt;n)</span><br><span class="line">           <span class="keyword">return</span> mid; <span class="comment">//若相等则说明mid即为查找到的位置</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> n<span class="number">-1</span>; <span class="comment">//若mid&gt;=n则说明是扩展的数值,返回n-1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">delete</span> [] temp;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">16</span>,<span class="number">24</span>,<span class="number">35</span>,<span class="number">47</span>,<span class="number">59</span>,<span class="number">62</span>,<span class="number">73</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;</span><br><span class="line">    <span class="type">int</span> key=<span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> index=<span class="built_in">FibonacciSearch</span>(a,<span class="built_in">sizeof</span>(a)/<span class="built_in">sizeof</span>(<span class="type">int</span>),key);</span><br><span class="line">    cout&lt;&lt;key&lt;&lt;<span class="string">&quot; is located at:&quot;</span>&lt;&lt;index;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><p>索引查找又称为分块查找，是一种介于顺序查找和二分查找之间的一种查找方法，索引查找的基本思想是：首先查找索引表，可用二分查找或顺序查找，然后在确定的块中进行顺序查找。</p>
<p>在实现索引查找算法前需要弄清楚以下三个术语。</p>
<p>（1）主表：即要查找的序列。</p>
<p>（2）查找表：一般我们会将主表分成几个块，每个块中的元素被称为是查找表。</p>
<p>（3）索引表：即索引项的集合。</p>
<p>在利用索引查找时，需要先对数据进行分块。</p>
<p>就是分块然后进行查找</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> a[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">　　<span class="type">int</span> i, startValue;</span><br><span class="line">　　i = <span class="number">0</span>;</span><br><span class="line">　　<span class="keyword">while</span> (i&lt;<span class="number">3</span> &amp;&amp; key&gt;newIndex[i].key) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　<span class="comment">// 确定在哪个块中，遍历每个块，确定key在哪个块中</span></span><br><span class="line">　　　　i++;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">if</span> (i&gt;=<span class="number">3</span>) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　<span class="comment">//大于分得的块数，则返回0</span></span><br><span class="line">　　　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">　　&#125;</span><br><span class="line">　　startValue = newIndex[i].start; <span class="comment">//startValue等于块范围的起始值</span></span><br><span class="line">　　<span class="keyword">while</span> (startValue &lt;= startValue+<span class="number">5</span> &amp;&amp; a[startValue]!=key)</span><br><span class="line">　　&#123;</span><br><span class="line">　　　　startValue++;</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">if</span> (startValue&gt;startValue+<span class="number">5</span>) </span><br><span class="line">　　&#123; </span><br><span class="line">　　　　<span class="comment">//如果大于块范围的结束值，则说明没有要查找的数</span></span><br><span class="line">　　　　<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">　　&#125;</span><br><span class="line"></span><br><span class="line">　　<span class="keyword">return</span> startValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h2><p>哈希表又称散列表，一种以「key-value」形式存储数据的数据结构。所谓以「key-value」形式存储数据，是指任意的键值 key 都唯一对应到内存中的某个位置。只需要输入查找的键值，就可以快速地找到其对应的 value。可以把哈希表理解为一种高级的数组，这种数组的下标可以是很大的整数，浮点数，字符串甚至结构体。</p>
<p>冲突：<code>key1≠key2; Hash（key1）==Hash（key2）</code>，即两个不同关键字，具有相同地址时，就叫发生冲突。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/20210517094111543.png" alt="关键字和存储地址之间的对应关系"></p>
<h3 id="1、直接定址法"><a href="#1、直接定址法" class="headerlink" title="1、直接定址法"></a>1、直接定址法</h3><p>哈希地址：f(key) = a*key+b (a,b为常数)</p>
<p>这种方法的优点是：简单，均匀，不会产生冲突。但是需要事先知道 key 的分布情况，适合查找表较小并且连续的情况。</p>
<h3 id="2、数字分析法"><a href="#2、数字分析法" class="headerlink" title="2、数字分析法"></a>2、数字分析法</h3><p>若我们现在要存储某家公司员工登记表，如果用手机号码作为 key，那么极有可能前7位都是相同的，所以我们选择最后四位作为 f(key) 就是不错的选择。</p>
<h3 id="3、平方取中法"><a href="#3、平方取中法" class="headerlink" title="3、平方取中法"></a>3、平方取中法</h3><p>故名思义，比如 key 是1234，那么它的平方就是1522756，再抽取中间的3位就是227作为 f(key) 。</p>
<h3 id="4、折叠法"><a href="#4、折叠法" class="headerlink" title="4、折叠法"></a>4、折叠法</h3><p>折叠法是将 key 从左到右分割成位数相等的几个部分(最后一部分位数不够可以短些)，然后将这几部分叠加求和，并按哈希表的表长，取后几位作为 f(key) 。</p>
<p>比如我们的 key 是 9876543210，哈希表的表长为3位，我们将 key 分为4组，987|654|321|0 ，然后将它们叠加求和 987+654+321+0=1962，再取后3位即得到 f(key) = 962 。</p>
<h3 id="5、除留余数法"><a href="#5、除留余数法" class="headerlink" title="5、除留余数法"></a>5、除留余数法</h3><p>哈希地址：f(key) = key mod p (p&lt;=m) m为哈希表表长。</p>
<p><strong>这种方法是最常用的哈希函数构造方法。</strong></p>
<h3 id="处理冲突"><a href="#处理冲突" class="headerlink" title="处理冲突"></a>处理冲突</h3><blockquote>
<h3 id="1-开放地址法（闭散列法）："><a href="#1-开放地址法（闭散列法）：" class="headerlink" title="1.开放地址法（闭散列法）："></a>1.开放地址法（闭散列法）：</h3><p>核心思想是，把发生冲突的元素放到哈希表中的另外一个位置。<br>线性探测法：发生冲突时，逐位往后挪动，寻找合适位置，只要哈希表没满，就一定能找到一个不发生冲突的位置。<br>addressi=( Hash(key) + di )，其中 di = 1，2，3··</p>
<p>二次探测法：发生冲突时，每次向后挪动k2个单位（k为挪动次数）。<br>addressi=( Hash(key) + di )，其中 di = 12，22，32···</p>
<p>伪随机探测法：发生冲突时，每次向后挪动k个单位（k为伪随机生成数）。</p>
<p>线性探测法的优点是：只要散列表未填满，总能找到一个不发生冲突的地址。缺点是：会产生 ”二次聚集“ 现象。而二次探测法和伪随机探测法的优点是：可以避免 “二次聚集“ 现象。缺点也很显然：不能保证一定找到不发生冲突的地址。</p>
<h3 id="2-链地址法（开散列法）："><a href="#2-链地址法（开散列法）：" class="headerlink" title="2.链地址法（开散列法）："></a>2.链地址法（开散列法）：</h3><ul>
<li>链地址法的基本思想是：把具有相同散列地址的记录放在同一个单链表中，称为同义词链表。有 m个散列地址就有 m个单链表，同时用数组 HT[0…m-1]存放各个链表的头指针，凡是散列地址为 i 的记录都以结点方式插入到以HT[i]为头结点的单链表中。</li>
</ul>
</blockquote>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢”浮”到数列的顶端。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/bubbleSort.gif" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Swap</span><span class="params">(<span class="type">int</span>* pa, <span class="type">int</span>* pb)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> tmp = *pa;</span><br><span class="line">	*pa = *pb;</span><br><span class="line">	*pb = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">		<span class="comment">//单趟</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - j; ++i) &#123;</span><br><span class="line">			<span class="comment">//前一个数大于后一个数，就交换</span></span><br><span class="line">			<span class="keyword">if</span> (a[i - <span class="number">1</span>] &gt; a[i]) &#123;</span><br><span class="line">				<span class="built_in">Swap</span>(&amp;a[i - <span class="number">1</span>], &amp;a[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p><strong>选择排序（ Selection sort）是一种简单直观的排序算法。它的工作原理是每一趟从待排序的数据元素中选出最小（或最大）的一个元素，顺序放在已排好序的数列的最后，直到全部待排序的数据元素排完。</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/selectionSort.gif" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select_Sort</span><span class="params">(<span class="type">int</span>* arr, <span class="type">int</span> n)</span>   <span class="comment">//arr为数据数组，n为数组长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">		<span class="type">int</span> min = i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[min] &gt; arr[j]) &#123;</span><br><span class="line">				min = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (min != i) &#123;</span><br><span class="line">			<span class="built_in">swap</span>(arr[i], arr[min]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>排序：即将一组混乱的数据按从小到大或者从大到小的顺序进行有序的排列出来。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/insertionSort.gif" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InsertSort</span><span class="params">(<span class="type">int</span> *beauties, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> index;	<span class="comment">// 存储待比较的的索引</span></span><br><span class="line">	<span class="type">int</span> ret;	<span class="comment">// 保存待插入数据</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">		index = i - <span class="number">1</span>;		<span class="comment">// 保存待插入数据的前一个数据的索引</span></span><br><span class="line">		ret = beauties[i];	<span class="comment">// 保存待插入数据</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当索引大于等于零，且所有对应的数值大于待插入数据</span></span><br><span class="line">		<span class="keyword">while</span> (index &gt;= <span class="number">0</span> &amp;&amp; beauties[index] &gt; ret) &#123;</span><br><span class="line">			beauties[index + <span class="number">1</span>] = beauties[index];	<span class="comment">// 将当前索引的数值往后移动一个位置</span></span><br><span class="line">			index--;	<span class="comment">// 索引减一</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 当索引为-1或者索引对应的值要比ret小时，就可以退出循环，ret就可以插入到索引加一的位置了</span></span><br><span class="line">		beauties[index + <span class="number">1</span>] = ret;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入排序是一个稳定的排序方法。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/20200708163800850.gif" alt="在这里插入图片描述"></p>
<p>希尔排序(Shell Sort)是插入排序的一种。也称缩小增量排序，是直接插入排序算法的一种更高效的改进版本。希尔排序是非稳定排序算法。该方法因DL．Shell于1959年提出而得名。希尔排序是记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<p><strong>1. 时间复杂度：</strong>最坏情况下，每两个数都要比较并交换一次，则<strong>最坏情况下的时间复杂度为O（n2）</strong>, 最好情况下，数组是有序的，不需要交换，只需要比较，则<strong>最好情况下的时间复杂度为O（n）。</strong></p>
<p>经大量人研究，希尔排序的<strong>平均时间复杂度为O（n1.3）</strong></p>
<p><strong>2. 空间复杂度：</strong>希尔排序，只需要一个变量用于两数交换，与n的大小无关，所以<strong>空间复杂度为：O（1）。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ShellSort</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">	<span class="type">int</span> grp = len / <span class="number">2</span>;		<span class="comment">// 计算增量</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (; grp &gt; <span class="number">0</span>; grp = grp / <span class="number">2</span>) &#123;	<span class="comment">// 每次计算完一轮，增量再除以二</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 选择排序</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = grp; i &lt; len; i++) &#123;	</span><br><span class="line">			<span class="type">int</span> cur = arr[i];	<span class="comment">// 先空出第二个数的位置</span></span><br><span class="line">			<span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 根据增量往前比较，小的在前，大的在后</span></span><br><span class="line">			<span class="keyword">for</span> (j = i - grp; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; cur; j = j - grp) &#123;</span><br><span class="line">				arr[j + grp] = arr[j];	<span class="comment">// 符合条件将前面的数据移动到空出的位置</span></span><br><span class="line">			&#125;</span><br><span class="line">			arr[j + grp] = cur;	<span class="comment">// 最后将待插入数据cur插入到前面空出的位置</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序算法有两个基本的操作，一个是分，也就是把原数组划分成两个子数组的过程。另一个是治，它将两个有序数组合并成一个更大的有序数组。</p>
<p>将待排序的线性表不断地切分成若干个子表，直到每个子表只包含一个元素，这时，可以认为只包含一个元素的子表是有序表。<br>将子表两两合并，每合并一次，就会产生一个新的且更长的有序表，重复这一步骤，直到最后只剩下一个子表，这个子表就是排好序的线性表。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/20200209185525881.gif" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line"><span class="built_in">merge_sort</span>(a,l,mid),<span class="built_in">merge_sort</span>(a,mid+<span class="number">1</span>,r);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=l,j=l,k=mid+<span class="number">1</span>;i&lt;=r;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(j==mid+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]=a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(k==r+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]=a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a[j]&lt;=a[k])</span><br><span class="line">    &#123;</span><br><span class="line">        t[i]=a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        t[i]=a[k++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">&#123;</span><br><span class="line">    a[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法性能"><a href="#算法性能" class="headerlink" title="算法性能"></a>算法性能</h2><p>速度仅次于快速排序。</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p><strong>O(nlogn)</strong>。</p>
<h3 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h3><p><strong>O(N)</strong>，归并排序需要一个与原数组相同长度的数组做辅助来排序。</p>
<h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><p><strong>稳定</strong>。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/quickSort.gif" alt="img"></p>
<p>采用“分治”的思想，对于一组数据，选择一个基准元素（base），通常选择第一个或最后一个元素，通过第一轮扫描，比base小的元素都在base左边，比base大的元素都在base右边，再有同样的方法递归排序这两部分，直到序列中所有数据均有序为止。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">qSortArray</span><span class="params">(<span class="type">int</span> array[], <span class="type">int</span> start, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> low = start;</span><br><span class="line">	<span class="type">int</span> high = last;</span><br><span class="line">	<span class="keyword">if</span> (low &lt; high)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span> (low &lt; high)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">while</span> (array[low] &lt;= array[start] &amp;&amp; low &lt; last)</span><br><span class="line">			&#123;</span><br><span class="line">				low++;<span class="comment">//满足小于基准的条件，指针右移</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">while</span> (array[high] &gt;= array[start] &amp;&amp; high &gt; start)</span><br><span class="line">			&#123;</span><br><span class="line">				high--;<span class="comment">//满足大于基准的条件，指针左移</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (low &lt; high)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">swap</span>(array[low], array[high]);<span class="comment">//交换两个不满足条件的元素</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(array[start], array[high]);<span class="comment">//插入基准元素</span></span><br><span class="line">		<span class="built_in">qSortArray</span>(array, start, high - <span class="number">1</span>);</span><br><span class="line">		<span class="built_in">qSortArray</span>(array, high + <span class="number">1</span>, last);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆结构</p>
<p>解释在代码里</p>
<p>这是大根堆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">1e7</span>;</span><br><span class="line"><span class="type">int</span> w[N];</span><br><span class="line"><span class="type">int</span> tot;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> rep(i,a,n) for(int i=a;i&lt;=n;i++)</span></span><br><span class="line"><span class="comment">//一个是数组，一个是最后一个节点所在位置</span></span><br><span class="line"><span class="comment">//1.top操作</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> w[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//返回堆顶也就是最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">1</span>||w[x]&lt;w[x/<span class="number">2</span>])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//就是你已经到达根顶了，或者你已经小于你的父节点了</span></span><br><span class="line">    <span class="comment">//这样就行了实际上</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">swap</span>(w[x],w[x/<span class="number">2</span>]);</span><br><span class="line"><span class="comment">//这也正是没有达到上述情况，那么你就要交换</span></span><br><span class="line"><span class="built_in">modify</span>(x/<span class="number">2</span>);</span><br><span class="line"><span class="comment">//交换完继续处理上一个节点</span></span><br><span class="line"><span class="comment">//递归处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w[++tot]=x;<span class="comment">//加入元素直接在尾部进行加入</span></span><br><span class="line">    <span class="built_in">modify</span>(tot);<span class="comment">//自底向上修复</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">repair</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x*<span class="number">2</span>&gt;tot)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">    <span class="comment">//已经到达叶子节点，和上个modify操作一样</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> tar=<span class="number">2</span>*x;</span><br><span class="line"><span class="keyword">if</span>(x*<span class="number">2</span>+<span class="number">1</span>&lt;=tot)</span><br><span class="line">&#123;</span><br><span class="line">    tar=w[x*<span class="number">2</span>]&gt;w[x*<span class="number">2</span>+<span class="number">1</span>]?x*<span class="number">2</span>:x*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(w[x]&lt;w[tar])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">swap</span>(w[x],w[tar]);</span><br><span class="line">    <span class="built_in">repair</span>(tar);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(w[<span class="number">1</span>],w[tot--]);</span><br><span class="line">    <span class="comment">//这一步有两个操作，第一个是交换头尾，第二个是删除尾部</span></span><br><span class="line">   <span class="comment">//接下来我们要修复头部</span></span><br><span class="line">   <span class="built_in">repair</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    cin&gt;&gt;x;</span><br><span class="line">    <span class="built_in">push</span>(-x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">rep</span>(i,<span class="number">1</span>,n)</span><br><span class="line">&#123;</span><br><span class="line">    cout&lt;&lt;-<span class="built_in">top</span>()&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/images/countingSort.gif" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CountingSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;a)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">count</span><span class="params">(MAX, <span class="number">0</span>)</span></span>;           <span class="comment">//统计每个数字出现的次数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : a)</span><br><span class="line">	count[x]++;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num = <span class="number">0</span>; num &lt; MAX; num++)&#123;</span><br><span class="line">    	<span class="keyword">while</span>(count[num])&#123;</span><br><span class="line">    	    a[k++] = num;</span><br><span class="line">    	    count[num]--;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;().<span class="built_in">swap</span>(count);           <span class="comment">//相当于用一个空直接换掉</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x : v)</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">int</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">        a.<span class="built_in">push_back</span>(<span class="built_in">rand</span>() % <span class="number">100</span> + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">show</span>(a);</span><br><span class="line">    <span class="built_in">CountingSort</span>(a);</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">show</span>(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li>在额外空间充足的情况下，尽量增大桶的数量</li>
<li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li>
</ol>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>桶排序按下列步骤进行：</p>
<ol>
<li>设置一个定量的数组当作空桶；</li>
<li>遍历序列，并将元素一个个放到对应的桶中；</li>
<li>对每个不是空的桶进行排序；</li>
<li>从不是空的桶里把元素再放回原来的序列中。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, w, a[N];</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; bucket[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; A.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    <span class="type">int</span> key = A[i];</span><br><span class="line">    <span class="type">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; A[j] &gt; key) &#123;</span><br><span class="line">      A[j + <span class="number">1</span>] = A[j];</span><br><span class="line">      --j;</span><br><span class="line">    &#125;</span><br><span class="line">    A[j + <span class="number">1</span>] = key;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bucket_sort</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> bucket_size = w / n + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    bucket[i].<span class="built_in">clear</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    bucket[a[i] / bucket_size].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="built_in">insertion_sort</span>(bucket[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; bucket[i].<span class="built_in">size</span>(); ++j) &#123;</span><br><span class="line">      a[++p] = bucket[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="STLsort"><a href="#STLsort" class="headerlink" title="STLsort"></a>STLsort</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a[0] .. a[n - 1] 为需要排序的数列</span></span><br><span class="line"><span class="comment">// 对 a 原地排序，将其按从小到大的顺序排列</span></span><br><span class="line">std::<span class="built_in">sort</span>(a, a + n);</span><br><span class="line"></span><br><span class="line"><span class="comment">// cmp 为自定义的比较函数</span></span><br><span class="line">std::<span class="built_in">sort</span>(a, a + n, cmp);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">data</span> &#123;</span><br><span class="line">  <span class="type">int</span> a, b;</span><br><span class="line"></span><br><span class="line">  <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> data rhs) <span class="type">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a == rhs.a) ? (b &lt; rhs.b) : (a &lt; rhs.a);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; da[<span class="number">1009</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(<span class="type">const</span> data u1, <span class="type">const</span> data u2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (u1.a == u2.a) ? (u1.b &gt; u2.b) : (u1.a &gt; u2.a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">std::<span class="built_in">sort</span>(da + <span class="number">1</span>, da + <span class="number">1</span> + <span class="number">10</span>);  <span class="comment">// 使用结构体中定义的 &lt; 运算符，从小到大排序</span></span><br><span class="line">std::<span class="built_in">sort</span>(da + <span class="number">1</span>, da + <span class="number">1</span> + <span class="number">10</span>, cmp);  <span class="comment">// 使用 cmp 函数进行比较，从大到小排序</span></span><br></pre></td></tr></table></figure>
<h2 id="本文的主要参考（抄袭对象）"><a href="#本文的主要参考（抄袭对象）" class="headerlink" title="本文的主要参考（抄袭对象）"></a>本文的主要参考（抄袭对象）</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/real_fool_/category_10818355.html">数据结构_UniqueUnit的博客-CSDN博客</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://totorocatcat.top">Totoro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://totorocatcat.top/2024/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-1/">http://totorocatcat.top/2024/02/13/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://totorocatcat.top" target="_blank">Totoroの旅</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8F%90%E9%AB%98/">提高</a></div><div class="post_share"><div class="social-share" data-image="https://npm.elemecdn.com/ushio-api-img-moe@5.0.64/img_649_702x1000_300_null_normal.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/02/14/%E8%85%BE%E8%AE%AF%E5%90%8E%E7%AB%AF%E5%BC%80%E5%8F%91C/" title="腾讯后端开发C++"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_157.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">腾讯后端开发C++</div></div></a></div><div class="next-post pull-right"><a href="/2024/02/09/%E3%80%8A%E9%9D%92%E6%98%A5%E7%AE%80%E7%AB%A0%E3%80%8B%E7%AC%AC%E4%BA%8C%E5%8D%81%E5%9B%9B%E7%AB%A0/" title="《青春简章》第二十四章"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_81.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《青春简章》第二十四章</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2024/03/16/163/" title="cf163"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.71/img_712_516x728_72_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-16</div><div class="title">cf163</div></div></a></div><div><a href="/2024/03/06/222/" title="AtCoder Beginner Contest 222"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.9/img_93_597x800_349.986572265625_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-06</div><div class="title">AtCoder Beginner Contest 222</div></div></a></div><div><a href="/2024/01/30/2023%E7%BE%8E%E8%B5%9Be%E9%A2%98%E5%88%86%E6%9E%90/" title="2023美赛e题分析"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_175.webp" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-01-30</div><div class="title">2023美赛e题分析</div></div></a></div><div><a href="/2024/03/06/225/" title="AtCoder Beginner Contest 225"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.56/img_561_849x1200_96_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-06</div><div class="title">AtCoder Beginner Contest 225</div></div></a></div><div><a href="/2024/03/07/336/" title="AtCoder Beginner Contest 336"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.66/img_665_800x747_96_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-07</div><div class="title">AtCoder Beginner Contest 336</div></div></a></div><div><a href="/2024/03/07/339/" title="Atcoder Beginner Contest 339"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.54/img_544_1200x1680_96_null_normal.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-03-07</div><div class="title">Atcoder Beginner Contest 339</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/px3.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Totoro</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">328</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">14</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/4512abc"><i class="fab fa-github"></i><span>🛴前往小窝......</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/4512abc" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:4512abc@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到龙猫の小窝</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">引言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E4%B8%8E%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">2.</span> <span class="toc-text">背景与前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E4%B8%BB%E8%A6%81%E6%9C%89%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E3%80%81%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E3%80%81%E7%B4%A2%E5%BC%95%E5%AD%98%E5%82%A8%E5%92%8C%E6%95%A3%E5%88%97%E5%AD%98%E5%82%A8"><span class="toc-number">2.1.</span> <span class="toc-text">数据的存储结构主要有顺序存储、链式存储、索引存储和散列存储</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.</span> <span class="toc-text">时间复杂度与空间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87"><span class="toc-number">3.1.</span> <span class="toc-text">算法效率</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7O%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%B3%95%E8%A7%84%E5%88%99"><span class="toc-number">3.2.</span> <span class="toc-text">大O的表示法规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">3.3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%90%8E%E7%BB%9F%E8%AE%A1%E6%B3%95"><span class="toc-number">3.3.0.1.</span> <span class="toc-text">事后统计法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACM%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.4.</span> <span class="toc-text">ACM时间复杂度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">4.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.1.</span> <span class="toc-text">一、线性表的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E9%99%90%EF%BC%9A"><span class="toc-number">4.1.1.</span> <span class="toc-text">有限：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97"><span class="toc-number">4.1.2.</span> <span class="toc-text">序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">4.1.3.</span> <span class="toc-text">基本操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">二、线性表的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">线性表的顺序表示和实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%AD%A5%E9%AA%A4"><span class="toc-number">4.3.</span> <span class="toc-text">代码实现步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.</span> <span class="toc-text">线性表的链式存储和实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%BC%94%E7%A4%BA"><span class="toc-number">4.5.</span> <span class="toc-text">代码演示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D%E4%B8%A4%E7%A7%8D%E6%8F%92%E6%B3%95%EF%BC%8C%E5%A4%B4%E6%8F%92%E6%B3%95%E5%92%8C%E5%B0%BE%E6%8F%92%E6%B3%95"><span class="toc-number">4.6.</span> <span class="toc-text">介绍两种插法，头插法和尾插法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9%E5%88%86%E6%9E%90"><span class="toc-number">4.7.</span> <span class="toc-text">优缺点分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">4.8.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">4.9.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%93%BE%E8%A1%A8"><span class="toc-number">4.10.</span> <span class="toc-text">其他链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="toc-number">4.11.</span> <span class="toc-text">双向链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%BC%E8%BF%B0"><span class="toc-number">4.11.1.</span> <span class="toc-text">代码综述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-number">4.11.2.</span> <span class="toc-text">循环链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%BB%BC%E8%BF%B0-1"><span class="toc-number">4.11.3.</span> <span class="toc-text">代码综述</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.12.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">5.</span> <span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">5.1.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.1.</span> <span class="toc-text">一、栈的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">1、栈的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.2.</span> <span class="toc-text">二、栈的顺序存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E4%BA%8EACM%E7%9A%84%E6%A0%88%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.3.</span> <span class="toc-text">偏向于ACM的栈实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%88%EF%BC%88%E4%B8%A4%E6%A0%88%E5%85%B1%E4%BA%AB%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">共享栈（两栈共享空间）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%EF%BC%881%EF%BC%89%E5%85%B1%E4%BA%AB%E6%A0%88%E6%A6%82%E5%BF%B5"><span class="toc-number">5.1.3.1.1.</span> <span class="toc-text">（1）共享栈概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">5.1.3.1.2.</span> <span class="toc-text">顺序存储</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.1.4.</span> <span class="toc-text">三、栈的顺序存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">5.2.</span> <span class="toc-text">单调栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%9B%E8%B0%B7%E5%8D%95%E8%B0%83%E6%A0%88"><span class="toc-number">5.2.1.</span> <span class="toc-text">洛谷单调栈</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">6.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.0.1.</span> <span class="toc-text">一、队列的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">6.0.1.1.</span> <span class="toc-text">1、队列的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.0.2.</span> <span class="toc-text">二、队列的顺序存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ACM%E9%98%9F%E5%88%97%E7%9B%B8%E5%85%B3"><span class="toc-number">6.1.</span> <span class="toc-text">ACM队列相关</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%A8%A1%E6%8B%9F%E9%98%9F%E5%88%97"><span class="toc-number">6.2.</span> <span class="toc-text">数组模拟队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.2.1.</span> <span class="toc-text">三、队列的链式存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E9%98%9F%E5%88%97"><span class="toc-number">6.2.1.1.</span> <span class="toc-text">链队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">6.2.2.</span> <span class="toc-text">双端队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97"><span class="toc-number">6.3.</span> <span class="toc-text">单调队列</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-number">7.</span> <span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">7.0.1.</span> <span class="toc-text">二、串的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E5%AE%9A%E9%95%BF%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">1、定长顺序存储表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81%E5%A0%86%E5%88%86%E9%85%8D%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">2、堆分配存储表示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81%E5%9D%97%E9%93%BE%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="toc-number">7.0.1.3.</span> <span class="toc-text">3、块链存储表示</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">7.0.2.</span> <span class="toc-text">串的模式匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E3%80%81BF%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">一、BF模式匹配算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#KMP%E7%AE%97%E6%B3%95"><span class="toc-number">7.0.2.2.</span> <span class="toc-text">KMP算法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A0%91"><span class="toc-number">8.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%E3%80%81%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">8.0.0.1.</span> <span class="toc-text">1、树的定义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">8.0.1.</span> <span class="toc-text">树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">8.0.2.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A83%EF%BC%9A%E5%85%B7%E6%9C%89n%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E4%B8%BA-log2-n-1"><span class="toc-number">8.0.3.</span> <span class="toc-text">性质3：具有n个结点的完全二叉树的深度为|log2(n)| + 1</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%B4%A84%EF%BC%9A%E5%8C%85%E5%90%ABn%E4%B8%AA%E7%BB%93%E7%82%B9%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%AB%98%E5%BA%A6%E8%87%B3%E5%B0%91%E4%B8%BAlog2-n-1-%E3%80%82"><span class="toc-number">8.0.4.</span> <span class="toc-text">性质4：包含n个结点的二叉树的高度至少为log2 (n+1)。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%8E%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.0.5.</span> <span class="toc-text">满二叉树与完全二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%9C%E6%A0%91"><span class="toc-number">8.0.6.</span> <span class="toc-text">斜树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.0.7.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">8.0.8.</span> <span class="toc-text">树的存储结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">8.1.</span> <span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.1.0.1.</span> <span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.1.0.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">8.1.0.3.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86"><span class="toc-number">8.1.0.4.</span> <span class="toc-text">层次遍历</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.2.</span> <span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.3.</span> <span class="toc-text">中序线索二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E5%8C%96"><span class="toc-number">8.3.1.</span> <span class="toc-text">树二叉树的转化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">树转换为二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">8.3.2.</span> <span class="toc-text">树的遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">8.4.</span> <span class="toc-text">二叉搜索树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91-1"><span class="toc-number">8.5.</span> <span class="toc-text">平衡二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E7%82%B9%E7%BB%93%E6%9E%84"><span class="toc-number">8.5.0.1.</span> <span class="toc-text">结点结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-number">8.5.1.</span> <span class="toc-text">代码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">8.6.</span> <span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84%E5%92%8C%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-number">8.6.1.</span> <span class="toc-text">路径和路径长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%9A%84%E6%9D%83%E5%92%8C%E5%B8%A6%E6%9D%83%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6"><span class="toc-number">8.6.2.</span> <span class="toc-text">节点的权和带权路径长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81"><span class="toc-number">8.6.3.</span> <span class="toc-text">为哈夫曼树进行编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81-1"><span class="toc-number">8.6.4.</span> <span class="toc-text">代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-number">8.6.5.</span> <span class="toc-text">构建哈夫曼树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81-1"><span class="toc-number">8.6.6.</span> <span class="toc-text">为哈夫曼树进行编码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">9.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%9D%83%E5%9B%BE%E5%92%8C%E6%9C%89%E6%9D%83%E5%9B%BE"><span class="toc-number">9.0.1.</span> <span class="toc-text">无权图和有权图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%A0%E5%AF%86%E5%9B%BE%E3%80%81%E7%A8%80%E7%96%8F%E5%9B%BE"><span class="toc-number">9.0.2.</span> <span class="toc-text">稠密图、稀疏图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E5%9B%BE%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%9B%BEG%E8%8B%A5%E6%BB%A1%E8%B6%B3-%E2%91%A0%E4%B8%8D%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E8%BE%B9-%E2%91%A1%E4%B8%8D%E5%AD%98%E5%9C%A8%E9%A1%B6%E7%82%B9%E5%88%B0%E8%87%AA%E8%BA%AB%E7%9A%84%E8%BE%B9%EF%BC%8C%E5%88%99%E7%A7%B0%E5%9B%BEG%E4%B8%BA%E7%AE%80%E5%8D%95%E5%9B%BE%E3%80%82"><span class="toc-number">9.0.2.1.</span> <span class="toc-text">简单图：一个图G若满足:①不存在重复边;②不存在顶点到自身的边，则称图G为简单图。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E5%9B%BE"><span class="toc-number">9.0.2.2.</span> <span class="toc-text">多重图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">9.1.</span> <span class="toc-text">图的存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%AD%98%E8%BE%B9"><span class="toc-number">9.2.</span> <span class="toc-text">直接存边</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-1"><span class="toc-number">9.2.1.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">9.3.</span> <span class="toc-text">邻接矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-2"><span class="toc-number">9.3.1.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8"><span class="toc-number">9.4.</span> <span class="toc-text">邻接表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95-3"><span class="toc-number">9.4.1.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%89%8D%E5%90%91%E6%98%9F"><span class="toc-number">9.5.</span> <span class="toc-text">链式前向星</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">9.6.</span> <span class="toc-text">图的遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%90%E6%B7%B1%E5%9F%BA18-%E4%BE%8B3%E3%80%91%E6%9F%A5%E6%89%BE%E6%96%87%E7%8C%AE"><span class="toc-number">10.</span> <span class="toc-text">【深基18.例3】查找文献</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%8F%8F%E8%BF%B0"><span class="toc-number">10.1.</span> <span class="toc-text">题目描述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B%E8%BE%93%E5%87%BA-1"><span class="toc-number">10.1.1.</span> <span class="toc-text">样例输出 #1</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">10.2.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#prim-%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95"><span class="toc-number">10.2.0.1.</span> <span class="toc-text">prim(普里姆算法)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kruskal-%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95"><span class="toc-number">10.2.0.2.</span> <span class="toc-text">kruskal (克鲁斯卡尔算法)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">10.3.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dijkstra%E7%AE%97%E6%B3%95"><span class="toc-number">10.3.1.</span> <span class="toc-text">Dijkstra算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFdijkstra"><span class="toc-number">10.3.1.1.</span> <span class="toc-text">什么是dijkstra?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Floyd%E7%AE%97%E6%B3%95"><span class="toc-number">10.3.2.</span> <span class="toc-text">Floyd算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E8%A1%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">10.4.</span> <span class="toc-text">拓补排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">11.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">11.1.</span> <span class="toc-text">顺序查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="toc-number">11.2.</span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-number">11.3.</span> <span class="toc-text">插值查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE"><span class="toc-number">11.4.</span> <span class="toc-text">斐波那契查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="toc-number">11.5.</span> <span class="toc-text">分块查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%9F%A5%E6%89%BE"><span class="toc-number">11.6.</span> <span class="toc-text">哈希查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E6%B3%95"><span class="toc-number">11.6.1.</span> <span class="toc-text">1、直接定址法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E6%95%B0%E5%AD%97%E5%88%86%E6%9E%90%E6%B3%95"><span class="toc-number">11.6.2.</span> <span class="toc-text">2、数字分析法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%B9%B3%E6%96%B9%E5%8F%96%E4%B8%AD%E6%B3%95"><span class="toc-number">11.6.3.</span> <span class="toc-text">3、平方取中法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E3%80%81%E6%8A%98%E5%8F%A0%E6%B3%95"><span class="toc-number">11.6.4.</span> <span class="toc-text">4、折叠法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E3%80%81%E9%99%A4%E7%95%99%E4%BD%99%E6%95%B0%E6%B3%95"><span class="toc-number">11.6.5.</span> <span class="toc-text">5、除留余数法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81"><span class="toc-number">11.6.6.</span> <span class="toc-text">处理冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%80%E6%94%BE%E5%9C%B0%E5%9D%80%E6%B3%95%EF%BC%88%E9%97%AD%E6%95%A3%E5%88%97%E6%B3%95%EF%BC%89%EF%BC%9A"><span class="toc-number">11.6.7.</span> <span class="toc-text">1.开放地址法（闭散列法）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%93%BE%E5%9C%B0%E5%9D%80%E6%B3%95%EF%BC%88%E5%BC%80%E6%95%A3%E5%88%97%E6%B3%95%EF%BC%89%EF%BC%9A"><span class="toc-number">11.6.8.</span> <span class="toc-text">2.链地址法（开散列法）：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">12.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">12.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">12.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">12.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">12.4.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">12.5.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%80%A7%E8%83%BD"><span class="toc-number">12.6.</span> <span class="toc-text">算法性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">12.6.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">12.6.2.</span> <span class="toc-text">空间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="toc-number">12.6.3.</span> <span class="toc-text">稳定性</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">12.7.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">12.8.</span> <span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">12.9.</span> <span class="toc-text">计数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">12.10.</span> <span class="toc-text">桶排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B"><span class="toc-number">12.10.1.</span> <span class="toc-text">过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#STLsort"><span class="toc-number">12.11.</span> <span class="toc-text">STLsort</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8F%82%E8%80%83%EF%BC%88%E6%8A%84%E8%A2%AD%E5%AF%B9%E8%B1%A1%EF%BC%89"><span class="toc-number">12.12.</span> <span class="toc-text">本文的主要参考（抄袭对象）</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 By Totoro</div><div class="footer_custom_text">I wish you to become your own sun, no need to rely on who's light.<p><a target="_blank" href="https://hexo.io/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat&logo=hexo" title="博客框架为Hexo"></a>&nbsp;<a target="_blank" href="https://butterfly.js.org/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat&logo=bitdefender" title="主题采用butterfly"></a>&nbsp;<a target="_blank" href="https://www.jsdelivr.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/CDN-jsDelivr-orange?style=flat&logo=jsDelivr" title="本站使用JsDelivr为静态资源提供CDN加速"></a> &nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Vervel-brightgreen?style=flat&logo=Vercel" title="本站采用双线部署，默认线路托管于Vercel"></a>&nbsp;<a target="_blank" href="https://vercel.com/ "><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Hosted-Coding-0cedbe?style=flat&logo=Codio" title="本站采用双线部署，联通线路托管于Coding"></a>&nbsp;<a target="_blank" href="https://github.com/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat&logo=GitHub" title="本站项目由Gtihub托管"></a>&nbsp;<a target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://img.shields.io/badge/Copyright-BY--NC--SA%204.0-d42328?style=flat&logo=Claris" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"></a></p></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="/js/tw_cn.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5.2.0/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu@4.0.7/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><script>(() => {
  const initValine = () => {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'HT1PalaKkPaG1UqAXBhJXIu8-gzGzoHsz',
      appKey: 'iT0TnVVAwf9zuZ7NqwclQItY',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  const loadValine = async () => {
    if (typeof Valine === 'function') initValine()
    else {
      await getScript('https://cdn.jsdelivr.net/npm/valine@1.5.1/dist/Valine.min.js')
      initValine()
    }
  }

  if ('Valine' === 'Valine' || !false) {
    if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
    else setTimeout(loadValine, 0)
  } else {
    window.loadOtherComment = loadValine
  }
})()</script></div><script defer src="/js/light.js"></script><canvas id="universe"></canvas><script defer src="/js/universe.js"></script><script async src="/js/title.js"></script><script defer src="https://npm.elemecdn.com/jquery@latest/dist/jquery.min.js"></script><script defer data-pjax src="/js/cat.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-fluttering-ribbon.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="30" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/canvas-nest.min.js"></script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/dist/click-show-text.min.js" data-mobile="true" data-text="只此无为身，且前行,忘记过去的人注定重蹈覆辙,我是我，我靠自己站立，我会做好自身,如果我睡大觉，谁给我摘月亮呢,假期和朋友，是人生中顶好的两样东西啊。,去爱，去失去，要不负相遇,没什么想不想通的，只是固执而已,我们深爱星辰，乃至不惧夜的黑,吃，喝，享受幸福，接受奇迹,浊水若长流，自清澄,雅俗共赏,总会有什么也不想的幸福时刻吧,时间顺流而下，生活逆流而上,悟已往之不谏，知来者之可追,希望你的小世界里,山花烂漫,茶酒俱全,安宁清淡,明朗欢愉" data-fontsize="18px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=4.12.0"></script></div></div><!-- hexo injector body_end start --><script data-pjax>
    function butterfly_categories_card_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<style>li.categoryBar-list-item{width:32.3%;}.categoryBar-list{max-height: 380px;overflow:auto;}.categoryBar-list::-webkit-scrollbar{width:0!important}@media screen and (max-width: 650px){.categoryBar-list{max-height: 320px;}}</style><div class="recent-post-item" style="height:auto;width:100%;padding:0px;"><div id="categoryBar"><ul class="categoryBar-list"><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_12.webp);"> <a class="categoryBar-list-link" href="categories/刷题计划/">刷题计划</a><span class="categoryBar-list-count">72</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_13.webp);"> <a class="categoryBar-list-link" href="categories/ACMの旅/">ACMの旅</a><span class="categoryBar-list-count">75</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_14.webp);"> <a class="categoryBar-list-link" href="categories/编程基础/">编程基础</a><span class="categoryBar-list-count">34</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_17.webp);"> <a class="categoryBar-list-link" href="categories/数学建模/">数学建模</a><span class="categoryBar-list-count">31</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_18.webp);"> <a class="categoryBar-list-link" href="categories/前端の旅/">前端の旅</a><span class="categoryBar-list-count">15</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_19.webp);"> <a class="categoryBar-list-link" href="categories/CS知识/">CS知识</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_20.webp);"> <a class="categoryBar-list-link" href="categories/个人安排/">个人安排</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_21.webp);"> <a class="categoryBar-list-link" href="categories/文学/">文学</a><span class="categoryBar-list-count">29</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" href="categories/杂项/">杂项</a><span class="categoryBar-list-count">6</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_22.webp);"> <a class="categoryBar-list-link" href="categories/少年游/">少年游</a><span class="categoryBar-list-count">2</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_23.webp);"> <a class="categoryBar-list-link" href="categories/数据结构/">数据结构</a><span class="categoryBar-list-count">1</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_24.webp);"> <a class="categoryBar-list-link" href="categories/C-实训/">C++实训</a><span class="categoryBar-list-count">8</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_25.webp);"> <a class="categoryBar-list-link" href="categories/期末の旅/">期末の旅</a><span class="categoryBar-list-count">9</span><span class="categoryBar-list-descr"></span></li><li class="categoryBar-list-item" style="background:url(https://source.fomal.cc/img/default_cover_26.webp);"> <a class="categoryBar-list-link" href="categories/牛客の旅/">牛客の旅</a><span class="categoryBar-list-count">43</span><span class="categoryBar-list-descr"></span></li></ul></div></div>';
      console.log('已挂载butterfly_categories_card')
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      }
    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    butterfly_categories_card_injector_config()
    }
  </script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/01/29/诗兴大发/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_69.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-01-29</span><a class="blog-slider__title" href="2024/01/29/诗兴大发/" alt="">诗兴大发</a><div class="blog-slider__text">未觉，却是中二少年的诗仙梦</div><a class="blog-slider__button" href="2024/01/29/诗兴大发/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/02/13/数据结构与算法-1/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://npm.elemecdn.com/ushio-api-img-moe@5.0.64/img_649_702x1000_300_null_normal.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-02-13</span><a class="blog-slider__title" href="2024/02/13/数据结构与算法-1/" alt="">数据结构与算法(总)</a><div class="blog-slider__text">方便大二看（）</div><a class="blog-slider__button" href="2024/02/13/数据结构与算法-1/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="2024/02/24/常见优化技巧/" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.fomal.cc/img/default_cover_238.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-02-24</span><a class="blog-slider__title" href="2024/02/24/常见优化技巧/" alt="">常见优化技巧</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" href="2024/02/24/常见优化技巧/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>